# 内存分区


### 1、内存分区

#### 1.1 运行之前

1）预处理：宏定义展开、头文件展开、条件编译，这里并不会检查语法

2）编译：检查语法，将预处理后文件编译生成汇编文件

3）汇编：将汇编文件生成目标文件(二进制文件)

4）链接：将目标文件链接为可执行程序

当我们编译完成生成可执行文件之后，我们通过在linux下`size`命令可以查看一个可执行二进制文件基本情况：

![img](https://alphaguo-1322521250.cos.ap-beijing.myqcloud.com/202312312338781.jpeg)

通过上图可以得知，在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（`text`）、数据区（`data`）和未初始化数据区（`bss`）3 个部分（有些人直接把`data`和`bss`合起来叫做静态区或全局区）。

l 代码区存放 CPU 执行的机器指令。通常代码区是可**共享**的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是**只读**的，使其只读的原因是防止程序意外地修改了它的指t令。另外，代码区还规划了局部变量的相关信息。

 l 全局初始化数据区/静态数据区（data段）该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和t）和常量数据（如字符串常量）。 

l 未初始化数据区（又叫 bss 区）存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。

 

***\*总体来讲说，程序源代码被编译之后主要分成两种段：程序指令(代码区)和程序数据（数据区）。代码段属于程序指令，而数据域段和.bss段属于程序数据。\****

 

那为什么把程序的指令和程序数据分开呢？

程序被load到内存中之后，可以将数据和代码分别映射到两个内存区域。由于数据区域对进程来说是可读可写的，而指令区域对程序来讲说是只读的，所以分区之后呢，可以将程序指令区域和数据区域分别设置成可读可写或只读。这样可以防止程序的指令有意或者无意被修改；

当系统中运行着多个同样的程序的时候，这些程序执行的指令都是一样的，所以只需要内存中保存一份程序的指令就可以了，只是每一个程序运行中数据不一样而已，这样可以节省大量的内存。比如说之前的Windows Internet Explorer 7.0运行起来之后， 它需要占用112 844KB的内存，它的私有部分数据有大概15 944KB，也就是说有96 900KB空间是共享的，如果程序中运行了几百个这样的进程，可以想象共享的方法可以节省大量的内存。 

#### 1.2运行之后

  程序在加载到内存前，代码区和全局区(`data`和`bss`)的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序`load`(加载)到内存，除了根据可执行程序的信息分出代码区（`text`）、数据区（`data`）和未初始化数据区（`bss`）之外，还额外增加了栈区、堆区。

l 代码区（text segment）

加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。

 

l 未初始化数据区（BSS）

加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。

l 全局初始化数据区/静态数据区（data segment）

加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。

 

l 栈区（stack）

栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。

 

l 堆区（heap）

堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

| **类型**       | **作用域** | **生命周期**   | **存储位置**                    |
| -------------- | ---------- | -------------- | ------------------------------- |
| auto变量       | 一对{}内   | 当前函数       | 栈区                            |
| static局部变量 | 一对{}内   | 整个程序运行期 | 初始化在data段，未初始化在BSS段 |
| extern变量     | 整个程序   | 整个程序运行期 | 初始化在data段，未初始化在BSS段 |
| static全局变量 | 当前文件   | 整个程序运行期 | 初始化在data段，未初始化在BSS段 |
| extern函数     | 整个程序   | 整个程序运行期 | 代码区                          |
| static函数     | 当前文件   | 整个程序运行期 | 代码区                          |
| register变量   | 一对{}内   | 当前函数       | 运行时存储在CPU寄存器           |
| 字符串常量     | 当前文件   | 整个程序运行期 | data段                          |

### 2、分区模型

#### 2.1栈区

由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。

```c
#char* func(){
	char p[] = "hello world!"; //在栈区存储 乱码
	printf("%s\n", p);
	return p;
}
void test(){
	char* p = NULL;
	p = func();  
	printf("%s\n",p); 
}
```

#### 2.2堆区

由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用`malloc`或者`new`进行堆的申请。

```c
char* func(){
	char* str = malloc(100);
	strcpy(str, "hello world!");
	printf("%s\n",str);
	return str;
}

void test01(){
	char* p = NULL;
	p = func();
	printf("%s\n",p);
}

void allocateSpace(char* p){
	p = malloc(100);
	strcpy(p, "hello world!");
	printf("%s\n", p);
}

void test02(){
	
	char* p = NULL;
	allocateSpace(p);

	printf("%s\n", p);
}
```

![img](https://alphaguo-1322521250.cos.ap-beijing.myqcloud.com/202312312338731.jpeg)

堆分配内存API：

```c
#include <stdlib.h>
void *calloc(size_t nmemb, size_t size);
功能：
在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存	置0。
参数：
nmemb：所需内存单元数量
size：每个内存单元的大小（单位：字节）
返回值：
	成功：分配空间的起始地址
失败：NULL
```

```c
#include <stdlib.h>
void *realloc(void *ptr, size_t size);
功能：
重新分配用malloc或者calloc函数在堆中分配内存空间的大小。
realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。
参数：
ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致
size：为重新分配内存的大小, 单位：字节
返回值：
成功：新分配的堆内存地址
失败：NULL
```

```c
void test01(){
	
	int* p1 = calloc(10,sizeof(int));
	if (p1 == NULL){
		return;
	}
	for (int i = 0; i < 10; i ++){
		p1[i] = i + 1;
	}
	for (int i = 0; i < 10; i++){
		printf("%d ",p1[i]);
	}
	printf("\n");
	free(p1);
}

void test02(){
	int* p1 = calloc(10, sizeof(int));
	if (p1 == NULL){
		return;
	}
	for (int i = 0; i < 10; i++){
		p1[i] = i + 1;
	}

	int* p2 = realloc(p1, 15 * sizeof(int));
	if (p2 == NULL){
		return;
	}

	printf("%d\n", p1);
	printf("%d\n", p2);

	//打印
	for (int i = 0; i < 15; i++){
		printf("%d ", p2[i]);
	}
	printf("\n");

	//重新赋值
	for (int i = 0; i < 15; i++){
		p2[i] = i + 1;
	}
	
	//再次打印
	for (int i = 0; i < 15; i++){
		printf("%d ", p2[i]);
	}
	printf("\n");

	free(p2);
}
```

### 3、全局/静态区

​		全局静态区内的变量在编译阶段已经分配好内存空间并初始化。这块内存在程序运行期间一直存在,它主要存储**全局变量**、**静态变量**和**常量**。

（1）这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。

（2）全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。

（3）字符串常量存储在全局/静态存储区的常量区。 

```c
int v1 = 10;//全局/静态区
const int v2 = 20; //常量，一旦初始化，不可修改
static int v3 = 20; //全局/静态区
char *p1; //全局/静态区，编译器默认初始化为NULL

//那么全局static int 和 全局int变量有什么区别？

void test(){
	static int v4 = 20; //全局/静态区
}
```

```c
char* func(){
	static char arr[] = "hello world!"; //在静态区存储 可读可写
	arr[2] = 'c';
	char* p = "hello world!"; //全局/静态区-字符串常量区 
	//p[2] = 'c'; //只读，不可修改 
	printf("%d\n",arr);
	printf("%d\n",p);
	printf("%s\n", arr);
	return arr;
}
void test(){
	char* p = func();
	printf("%s\n",p);
}
```

ANSI C中规定：修改字符串常量，结果是未定义的。

ANSI C并没有规定编译器的实现者对字符串的处理，例如：

1.有些编译器可修改字符串常量，有些编译器则不可修改字符串常量。

2.有些编译器把多个相同的字符串常量看成一个（这种优化可能出现在字符串常量中，节省空间），有些则不进行此优化。如果进行优化，则可能导致修改一个字符串常量导致另外的字符串常量也发生变化，结果不可知。

**所以尽量不要去修改字符串常量**！

在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等，初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。

***\*数据区包括\****：堆，栈，全局/静态存储区。
　　***\*全局/静态存储区包括\****：常量区，全局区、静态区。
　　***\*常量区包括\****：字符串常量区、常变量区。
　　***\*代码区\****：存放程序编译后的二进制代码，不可寻址区。

***\*可以说，C/C++内存分区其实只有两个，即代码区和数据区。\****

### 4、函数调用模型

#### 4.1函数调用流程

栈(stack)是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。在解释为什么栈如此重要之前，我们先了解一下传统的栈的定义：

在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：**先入栈的数据最后出栈**(First In Last Out,FILO).

在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。

栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：

-  函数的返回地址；
-  函数的参数；
-  局部变量；
-  保存的上下文：包括在函数调用前后需要保持不变的寄存器。

我们从下面的代码，分析以下函数的调用过程：

```c
int func(int a,int b){
	int t_a = a;
	int t_b = b;
	return t_a + t_b;
}

int main(){
	int ret = 0;
	ret = func(10, 20);
	return EXIT_SUCCESS;
}
```

#### 4.2调用惯例

 现在，我们大致了解了函数调用的过程，这期间有一个现象，那就是函数的调用者和被调用者对函数调用有着一致的理解，例如，它们双方都一致的认为函数的参数是按照某个固定的方式压入栈中。如果不这样的话，函数将无法正确运行。

   如果函数调用方在传递参数的时候先压入a参数，再压入b参数，而被调用函数则认为先压入的是b,后压入的是a,那么被调用函数在使用a,b值时候，就会颠倒。

因此，**函数的调用方和被调用方对于函数是如何调用的必须有一个明确的约定，只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为****”****调用惯例(**Calling Convention)”.一个调用惯例一般包含以下几个方面：

***\*函数参数的传递顺序和方式\****

函数的传递有很多种方式，最常见的是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：从左向右，还是从右向左。有些调用惯例还允许使用寄存器传递参数，以提高性能。

***\*栈的维护方式\****

在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。

为了在链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。

事实上，在c语言里，存在着多个调用惯例，而默认的是cdecl.任何一个没有显示指定调用惯例的函数都是默认是cdecl惯例。比如我们上面对于func函数的声明，它的完整写法应该是：

 int _cdecl func(int a,int b);

***\*注意: _cdecl不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在_cdecl这样的关键字，而是使用__attribute__((cdecl)).\****

| 调用惯例 | 出栈方     | 参数传递                                       | 名字修饰                   |
| -------- | ---------- | ---------------------------------------------- | -------------------------- |
| cdecl    | 函数调用方 | 从右至左参数入栈                               | 下划线+函数名              |
| stdcall  | 函数本身   | 从右至左参数入栈                               | 下划线+函数名+@+参数字节数 |
| fastcall | 函数本身   | 前两个参数由寄存器传递，其余参数通过堆栈传递。 | @+函数名+@+参数的字节数    |
| pascal   | 函数本身   | 从左至右参数入栈                               | 较为复杂，参见相关文档     |

####  4.3函数变量传递分析

![img](https://alphaguo-1322521250.cos.ap-beijing.myqcloud.com/202312312338873.png)

![img](https://alphaguo-1322521250.cos.ap-beijing.myqcloud.com/202312312338097.png)

![img](https://alphaguo-1322521250.cos.ap-beijing.myqcloud.com/202312312338960.png)

![img](https://alphaguo-1322521250.cos.ap-beijing.myqcloud.com/202312312338789.png)

![img](https://alphaguo-1322521250.cos.ap-beijing.myqcloud.com/202312312338412.png)

#### 4.4栈的生长方向和内存存放方向

![img](https://alphaguo-1322521250.cos.ap-beijing.myqcloud.com/202312312338760.png)

```c
//1. 栈的生长方向
void test01(){

	int a = 10;
	int b = 20;
	int c = 30;
	int d = 40;

	printf("a = %d\n", &a);
	printf("b = %d\n", &b);
	printf("c = %d\n", &c);
	printf("d = %d\n", &d);

	//a的地址大于b的地址，故而生长方向向下
}

//2. 内存生长方向(小端模式)
void test02(){
	
	//高位字节 -> 地位字节
	int num = 0xaabbccdd;
	unsigned char* p = &num;

	//从首地址开始的第一个字节
	printf("%x\n",*p);
	printf("%x\n", *(p + 1));
	printf("%x\n", *(p + 2));
	printf("%x\n", *(p + 3));
}
```


