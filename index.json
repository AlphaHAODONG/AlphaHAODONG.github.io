[{"categories":["中间件"],"content":" Docker实用篇","date":"2024-04-20","objectID":"/docker/:0:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#docker实用篇"},{"categories":["中间件"],"content":" 1.初识Docker","date":"2024-04-20","objectID":"/docker/:0:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#1初识docker"},{"categories":["中间件"],"content":" 1.1.什么是Docker前面学习的linux系统虽然可以部署应用，但是操作给部署带来了很大的麻烦。 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题 ","date":"2024-04-20","objectID":"/docker/:1:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#11什么是docker"},{"categories":["中间件"],"content":" 1.1.1.应用部署的环境问题大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题： 依赖关系复杂，容易出现兼容性问题 开发、测试、生产环境有差异 例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。 ","date":"2024-04-20","objectID":"/docker/:1:1","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#111应用部署的环境问题"},{"categories":["中间件"],"content":" 1.1.2.Docker解决依赖兼容问题而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？ Docker为了解决依赖的兼容问题的，采用了两个手段： 将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包 将每个应用放到一个隔离容器去运行，避免互相干扰 这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。 虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？ ","date":"2024-04-20","objectID":"/docker/:1:2","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#112docker解决依赖兼容问题"},{"categories":["中间件"],"content":" 1.1.3.Docker解决操作系统环境差异要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下： 结构包括： 计算机硬件：例如CPU、内存、磁盘等 系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。 系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。 应用于计算机交互的流程如下： 1）应用调用操作系统应用（函数库），实现各种功能 2）系统函数库是对内核指令集的封装，会调用内核指令 3）内核指令操作计算机硬件 Ubuntu和CentOS都是基于Linux内核，无非是系统应用不同，提供的函数库有差异： 此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了： Docker如何解决不同系统环境的问题？ Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包 Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行 如图： ","date":"2024-04-20","objectID":"/docker/:1:3","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#113docker解决操作系统环境差异"},{"categories":["中间件"],"content":" 1.1.4.小结Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？ Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像 Docker应用运行在容器中，使用沙箱机制，相互隔离 Docker如何解决开发、测试、生产环境有差异的问题？ Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行 Docker是一个快速交付应用、运行应用的技术，具备下列优势： 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统 运行时利用沙箱机制形成隔离容器，各个应用互不干扰 启动、移除都可以通过一行命令完成，方便快捷 ","date":"2024-04-20","objectID":"/docker/:1:4","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#114小结"},{"categories":["中间件"],"content":" 1.2.Docker和虚拟机的区别Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。 两者有什么差异呢？ 虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。 传统的虚拟机需要模拟整台机器包括硬件，每台虚拟机都需要有⾃⼰的操作系统，虚拟机⼀旦被开启，预分配给他的资源将全部被占⽤。每⼀个虚拟机包括应⽤，必要的⼆进制和库，以及⼀个完整的⽤户操作系统。像平常用的VMware就属于虚拟机操作软件。 Docker仅仅是封装函数库，并没有模拟完整的操作系统，如图： Docker是一种容器技术。 容器技术是和我们的宿主机共享硬件资源及操作系统可以实现资源的动态分配。容器包含应⽤和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在⽤户空间以分离的进程运⾏。 所有主流的Linux发行版都可以运行Docker ps: 对比来看： 小结： Docker和虚拟机的差异： docker是一个系统进程；虚拟机是在操作系统中的操作系统 docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般 ","date":"2024-04-20","objectID":"/docker/:2:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#12docker和虚拟机的区别"},{"categories":["中间件"],"content":" 1.3.Docker架构","date":"2024-04-20","objectID":"/docker/:3:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#13docker架构"},{"categories":["中间件"],"content":" 1.3.1.镜像和容器Docker中有几个重要的概念： 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。 容器（Container）：镜像中的应用程序运行后形成的进程就是容器，只是Docker会给容器进程做隔离，对外不可见。 一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的文件。只有运行时，才会加载到内存，形成进程。 而镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。 容器呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。 例如你下载了一个QQ，如果我们将QQ在磁盘上的运行文件及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。 ","date":"2024-04-20","objectID":"/docker/:3:1","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#131镜像和容器"},{"categories":["中间件"],"content":" 1.3.2.DockerHub开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。 DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。 国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。 我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像： ","date":"2024-04-20","objectID":"/docker/:3:2","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#132dockerhub"},{"categories":["中间件"],"content":" 1.3.3.Docker架构我们要使用Docker来操作镜像、容器，就必须要安装Docker。 Docker是一个CS架构的程序，由两部分组成： 服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等 客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。 如图： ","date":"2024-04-20","objectID":"/docker/:3:3","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#133docker架构"},{"categories":["中间件"],"content":" 1.3.4.小结镜像： 将应用程序及其依赖、环境、配置打包在一起 容器： 镜像运行起来就是容器，一个镜像可以运行多个容器 Docker结构： 服务端：接收命令或远程请求，操作镜像或容器 客户端：发送命令或者请求到Docker服务端 DockerHub： 一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry ","date":"2024-04-20","objectID":"/docker/:3:4","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#134小结"},{"categories":["中间件"],"content":" 1.4.安装Docker企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考课前资料中的文档： ","date":"2024-04-20","objectID":"/docker/:4:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#14安装docker"},{"categories":["中间件"],"content":" 2.Docker的基本操作","date":"2024-04-20","objectID":"/docker/:0:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#2docker的基本操作"},{"categories":["中间件"],"content":" 2.1.镜像操作","date":"2024-04-20","objectID":"/docker/:1:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#21镜像操作"},{"categories":["中间件"],"content":" 2.1.1.镜像名称首先来看下镜像的名称组成： 镜名称一般分两部分组成：[repository]:[tag]。 在没有指定tag时，默认是latest，代表最新版本的镜像 如图： 这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。 ","date":"2024-04-20","objectID":"/docker/:1:1","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#211镜像名称"},{"categories":["中间件"],"content":" 2.1.2.镜像命令常见的镜像操作命令如图： ","date":"2024-04-20","objectID":"/docker/:1:2","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#212镜像命令"},{"categories":["中间件"],"content":" 2.1.3.案例1-拉取、查看镜像需求：从DockerHub中拉取一个nginx镜像并查看 1）首先去镜像仓库搜索nginx镜像，比如DockerHub: 2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx 3）通过命令：docker images 查看拉取到的镜像 ","date":"2024-04-20","objectID":"/docker/:1:3","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#213案例1-拉取查看镜像"},{"categories":["中间件"],"content":" 2.1.4.案例2-保存、导入镜像需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来 1）利用docker xx –help命令查看docker save和docker load的语法 例如，查看save命令用法，可以输入命令： docker save --help 结果： 命令格式： docker save -o [保存的目标文件名称] [镜像名称] 2）使用docker save导出镜像到磁盘 运行命令： docker save -o nginx.tar nginx:latest 结果如图： 3）使用docker load加载镜像 先删除本地的nginx镜像： docker rmi nginx:latest 然后运行命令，加载本地文件： docker load -i nginx.tar 结果： ","date":"2024-04-20","objectID":"/docker/:1:4","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#214案例2-保存导入镜像"},{"categories":["中间件"],"content":" 2.1.5.练习需求：去DockerHub搜索并拉取一个Redis镜像 目标： 1）去DockerHub搜索Redis镜像 2）查看Redis镜像的名称和版本 3）利用docker pull命令拉取镜像 说明：拉取指定版本的redis镜像 docker pull redis:latest 4）利用docker save命令将 redis:latest打包为一个redis.tar包 docker save -o redis.tar redis:latest 5）利用docker rmi 删除本地的redis:latest docker rmi redis:latest 6）利用docker load 重新加载 redis.tar文件 docker load -i redis.tar ","date":"2024-04-20","objectID":"/docker/:1:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#215练习"},{"categories":["中间件"],"content":" 2.2.容器操作","date":"2024-04-20","objectID":"/docker/:2:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#22容器操作"},{"categories":["中间件"],"content":" 2.2.1.容器相关命令容器操作的命令如图： 容器保护三个状态： 运行：进程正常运行 暂停：进程暂停，CPU不再运行，并不释放内存 停止：进程终止，回收进程占用的内存、CPU等资源 其中： docker run：创建并运行一个容器，处于运行状态 docker pause：让一个运行的容器暂停 docker unpause：让一个容器从暂停状态恢复运行 docker stop：停止一个运行的容器 docker start：让一个停止的容器再次运行 docker rm：删除一个容器 docker ps -a 查看所有容器 ","date":"2024-04-20","objectID":"/docker/:2:1","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#221容器相关命令"},{"categories":["中间件"],"content":" 2.2.2.案例-创建并运行一个容器创建并运行nginx容器的命令： docker run --name containerName -p 80:80 -d nginx 命令解读： docker run ：创建并运行一个容器 –name : 给容器起一个名字，比如叫做mn -p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 -d：后台运行容器 nginx：镜像名称，例如nginx 这里的-p参数，是将容器端口映射到宿主机端口。 默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。 现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了： 浏览器直接访问： ","date":"2024-04-20","objectID":"/docker/:2:2","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#222案例-创建并运行一个容器"},{"categories":["中间件"],"content":" 2.2.3.案例-进入容器，修改文件需求：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您” 提示：进入容器要用到docker exec命令。 步骤： 1）进入容器。进入我们刚刚创建的nginx容器的命令为： docker exec -it mn bash 命令解读： docker exec ：进入容器内部，执行一个命令 -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 mn ：要进入的容器的名称 bash：进入容器后执行的命令，bash是一个linux终端交互命令 bash命令是shell脚本命令的超集，大多数shell脚本都可以在bash下运行，bash主要有如下这些功能： cd rm mkdir…. 2）进入nginx的HTML所在目录 /usr/share/nginx/html 容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样： nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。 查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在/usr/share/nginx/html 我们执行命令，进入该目录： cd /usr/share/nginx/html 查看目录下文件： 3）修改index.html的内容 容器内没有vim命令，无法直接修改，我们用下面的命令来修改： sed -i -e 's#Welcome to nginx#传智教育欢迎您#g' -e 's#\u003chead\u003e#\u003chead\u003e\u003cmeta charset=\"utf-8\"\u003e#g' index.html 说明： 1)-e : 可以在同一行里执行多条命令 2)-i 就是直接对文本文件进行操作的 在浏览器访问自己的虚拟机地址，例如我的是：http://192.168.150.101，即可看到结果： ","date":"2024-04-20","objectID":"/docker/:2:3","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#223案例-进入容器修改文件"},{"categories":["中间件"],"content":" 2.2.4.小结【1】暂停容器? docker pause 容器名 浏览器访问： 【2】从暂停回到运行容器? docker unpause 容器名 浏览器可以访问了： 【3】停止容器? docker stop 容器名 浏览器访问效果: 【4】从停止到启动容器? docker start 容器名 浏览器访问效果: 【5】查看所有运行的容器状态? 如果将容器关闭： 再次查看所有运行的容器状态? 可以通过-a参数查看所有状态的容器，包括已经停止的 【6】查看容器日志? docker logs 容器名 添加 -f 参数可以持续查看日志。浏览器访问，不用执行命令，直接在终端输出日志信息。 【7】删除容器 docker rm 容器名 不能删除运行中的容器，除非添加 -f 参数 docker rm -f 容器名 【8】docker run命令的常见参数有哪些？ –name：指定容器名称 -p：指定端口映射 -d：让容器后台运行 docker run --name containerName -p 80:80 -d nginx ","date":"2024-04-20","objectID":"/docker/:2:4","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#224小结"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#225-案例创建并运行一个redis容器并且支持数据持久化"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#1实现步骤"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#2具体实现"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#步骤一到dockerhub搜索redis镜像"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#步骤二查看redis镜像文档中的帮助信息"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#步骤三利用docker-run-命令运行一个redis容器"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#步骤四进入redis容器"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#步骤五执行redis-cli客户端命令"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#步骤六设置数据num666"},{"categories":["中间件"],"content":" 2.2.5 案例：创建并运行一个redis容器，并且支持数据持久化 1.实现步骤 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes 2.具体实现 步骤一：到DockerHub搜索Redis镜像 步骤二：查看Redis镜像文档中的帮助信息 步骤三：利用docker run 命令运行一个Redis容器 docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --name：指定容器名称,redis表示容器名 -p：指定端口映射。6379:6379 冒号左侧是宿主机端口，右侧是容器端口 -d：让容器后台运行 redis：表示镜像名 redis-server：表示redis服务 --appendonly yes ：开启aof持久化 步骤四：进入redis容器 docker exec -it redis bash 步骤五：执行redis-cli客户端命令 redis-cli 步骤六：设置数据num=666 set num 666 步骤七:在window系统中使用redis客户端连接 ps:大家可以回想我们前面讲解linux安装redis有多么麻烦。而使用docker是不是更加方便。 ","date":"2024-04-20","objectID":"/docker/:2:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#步骤七在window系统中使用redis客户端连接"},{"categories":["中间件"],"content":" 2.3.数据卷（容器数据管理）在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。 这就是因为容器与数据（容器内文件）耦合带来的后果。 要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。 ","date":"2024-04-20","objectID":"/docker/:3:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#23数据卷容器数据管理"},{"categories":["中间件"],"content":" 2.3.1.什么是数据卷**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。 一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。 这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了 ","date":"2024-04-20","objectID":"/docker/:3:1","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#231什么是数据卷"},{"categories":["中间件"],"content":" 2.3.2.数据集操作命令数据卷操作的基本语法如下： docker volume [COMMAND] docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作： create 创建一个volume inspect 显示一个或多个volume的信息 ls 列出所有的volume prune 删除未使用的volume rm 删除一个或多个指定的volume ","date":"2024-04-20","objectID":"/docker/:3:2","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#232数据集操作命令"},{"categories":["中间件"],"content":" 2.3.3.创建和查看数据卷需求：创建一个数据卷，并查看数据卷在宿主机的目录位置 ① 创建数据卷 docker volume create html ② 查看所有数据 docker volume ls 结果： 说明: 第一个数据卷是docker自己生成的。我们不需要关心。 ③ 查看数据卷详细信息卷 docker volume inspect html 结果： 可以看到，我们创建的html这个数据卷关联的宿主机目录为/var/lib/docker/volumes/html/_data目录。 小结： 数据卷的作用： 将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全 数据卷操作： docker volume create：创建数据卷 docker volume ls：查看所有数据卷 docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置 docker volume rm：删除指定数据卷 docker volume prune：删除所有未使用的数据卷 ","date":"2024-04-20","objectID":"/docker/:3:3","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#233创建和查看数据卷"},{"categories":["中间件"],"content":" 2.3.4.挂载数据卷我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下： docker run --name mn -v html:/root/html -p 8080:80 -d nginx:latest 这里的-v就是挂载数据卷的命令： -v html:/root/html ：把html数据卷挂载到容器内的/root/html这个目录中 ","date":"2024-04-20","objectID":"/docker/:3:4","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#234挂载数据卷"},{"categories":["中间件"],"content":" 2.3.5.案例-给nginx挂载数据卷需求：创建一个nginx容器，修改容器内的html目录内的index.html内容 分析：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。 提示：运行容器时使用 -v 参数挂载数据卷 步骤： ① 创建容器并挂载数据卷到容器内的HTML目录 docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx -d：后台运行容器 ② 进入html数据卷所在位置，并修改HTML内容 # 查看html数据卷的位置 docker volume inspect html # 进入该目录 cd /var/lib/docker/volumes/html/_data # 修改文件 vim index.html ③浏览器访问 ","date":"2024-04-20","objectID":"/docker/:3:5","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#235案例-给nginx挂载数据卷"},{"categories":["中间件"],"content":" 2.3.6.案例-给MySQL挂载本地目录容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下： 带数据卷模式：宿主机目录 –\u003e 数据卷 —\u003e 容器内目录 直接挂载模式：宿主机目录 —\u003e 容器内目录 如图： 语法： 目录挂载与数据卷挂载的语法是类似的： -v [宿主机目录]:[容器内目录] -v [宿主机文件]:[容器内文件] 需求：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器 实现思路如下： 1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像 docker load -i mysql.tar 查看镜像： docker images 2）创建目录/tmp/mysql/data mkdir -p /tmp/mysql/data 说明：-p表示创建多级目录 3）去 查阅资料，创建并运行MySQL容器，要求： ① 挂载/tmp/mysql/data到mysql容器内数据存储目录 说明：mysql的data目录是我们平常经常容易修改的目录，因此我们将容器中的data目录挂载到宿主机的本地目录 ② 设置MySQL密码 docker run --restart=always -p 3306:3306 --name mysql -v /tmp/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1234 -d mysql:5.7.25 说明： 1.--restart=always 表示当Docker重启时，当前mysql容器总是重启容器.如果不加，docker重启，mysql不会重启 2.-p 3306:3306 ：port ，冒号前面的表示宿主机的端口号，冒号右边的表示mysql容器端口号 3.--name mysql 表示当前的容器名 4.-v /tmp/mysql/data:/var/lib/mysql 1)-v [宿主机目录]:[容器内目录] 2)/tmp/mysql/data 表示宿主机目录 3)/var/lib/mysql 表示data在容器中的位置，这个目录是通过dockerhub官方查看的 5.-e：表示environment环境变量的意思 6.-d：表示后台运行 7.mysql:5.7.25 表示mysql镜像名 注意： ​ 1.如果启动报错，有可能是端口号冲突，此时可以执行命令 systemctl stop mysqld。停止之前开启的mysql服务。 ​ 2.删除之前创建的mysql容器：docker rm mysql 查看mysql容器是否启动： 使用mysql客户端datagrip访问下： 补充： 1.netstat -tnlp | grep :3306 属于linux系统命令查看3306端口号是否被占用 2.service mysqld stop 停止mysql服务 ","date":"2024-04-20","objectID":"/docker/:3:6","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#236案例-给mysql挂载本地目录"},{"categories":["中间件"],"content":" 2.3.7.小结docker run的命令中通过 -v 参数挂载文件或目录到容器中： -v volume名称:容器内目录 -v 宿主机文件:容器内文 -v 宿主机目录:容器内目录 数据卷挂载与目录直接挂载的 数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找 目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看 ","date":"2024-04-20","objectID":"/docker/:3:7","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#237小结"},{"categories":["中间件"],"content":" 3.Dockerfile自定义镜像(理解)之前学习的镜像都是DockerHub官方制作的镜像，我们在实际开发中自己写的代码是否可以让DockerHub官方帮助我们制作镜像呢? 显然是不能的，我们不能把公司代码交给DockerHub官方来制作镜像，主要是不安全。所以在实际开发中，我们自己写的代码一定要自己制作镜像。 而要自定义镜像，就必须先了解镜像的结构才行。 ","date":"2024-04-20","objectID":"/docker/:0:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#3dockerfile自定义镜像理解"},{"categories":["中间件"],"content":" 3.1.镜像结构镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。 我们以MySQL为例，来看看镜像的组成结构： 简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。 我们要构建镜像，其实就是实现上述打包的过程。 ","date":"2024-04-20","objectID":"/docker/:1:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#31镜像结构"},{"categories":["中间件"],"content":" 3.2.Dockerfile语法构建自定义的镜像时，并不需要一个个文件去拷贝，打包。 我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。 而描述上述信息的文件就是Dockerfile文件。 Dockerfile就是一个文本文件，其中包含一个个的指令(Instruction)，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。 更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder ","date":"2024-04-20","objectID":"/docker/:2:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#32dockerfile语法"},{"categories":["中间件"],"content":" 3.3.构建Java项目","date":"2024-04-20","objectID":"/docker/:3:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#33构建java项目"},{"categories":["中间件"],"content":" 3.3.1.基于Ubuntu构建Java项目需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目 步骤1：新建一个空文件夹docker-demo 步骤2：拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录 步骤3：拷贝课前资料中的jdk8.tar.gz文件到docker-demo这个目录 步骤4：拷贝课前资料提供的Dockerfile到docker-demo这个目录 其中的内容如下： # 指定基础镜像 FROM ubuntu:16.04 # 配置环境变量，JDK的安装目录 ENV JAVA_DIR=/usr/local # 拷贝jdk和java项目的包 COPY ./jdk8.tar.gz $JAVA_DIR/ COPY ./docker-demo.jar /tmp/app.jar # 安装JDK RUN cd $JAVA_DIR \\ \u0026\u0026 tar -xf ./jdk8.tar.gz \\ \u0026\u0026 mv ./jdk1.8.0_144 ./java8 # 配置环境变量 ENV JAVA_HOME=$JAVA_DIR/java8 ENV PATH=$PATH:$JAVA_HOME/bin # 暴露端口 EXPOSE 8090 # 入口，java项目的启动命令 ENTRYPOINT java -jar /tmp/app.jar 步骤5：切换到docker-demo 将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下 步骤6：运行命令： docker build -t javaweb:1.0 . 说明: 1.docker build 表示构建 2.-t:t的全称是tag表示版本 3.javaweb:1.0 ：镜像组成格式 repository:版本 javaweb表示repository，属于标识符，随便定义 4. 在版本即1.0后面一定加空格然后书写点，点表示在当前目录执行Dockerfile文件 查看镜像 构建容器： docker run --name myWeb1.0 -p 8090:8090 -d javaweb:1.0 查看启动的容器 最后访问 http://192.168.200.128:8090/hello/count，其中的ip改成你的虚拟机ip ","date":"2024-04-20","objectID":"/docker/:3:1","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#331基于ubuntu构建java项目"},{"categories":["中间件"],"content":" 3.3.2.基于java8构建Java项目虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。 例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。 **需求：**基于java:8-alpine镜像，将一个Java项目构建为镜像 实现思路如下： ① 在tmp目录下在新建一个空的目录docker-demo02 ② 拷贝课前资料提供的docker-demo.jar到这个目录中 ③ 然后在目录中新建一个文件，命名为Dockerfile，编写Dockerfile文件： a ）基于java:8-alpine作为基础镜像 b ）将docker-demo.jar拷贝到镜像中 c ）暴露端口 d ）编写入口ENTRYPOINT 内容如下： FROM java:8-alpine COPY ./docker-demo.jar /tmp/app.jar # 暴露端口 EXPOSE 8090 # 入口，java项目的启动命令 ENTRYPOINT java -jar /tmp/app.jar ④ 使用docker build命令构建镜像 docker build -t javaweb:2.0 . ⑤停止之前启动的容器myWeb1.0，否则端口号冲突 docker stop myWeb1.0 ⑥ 使用docker run创建容器并运行 docker run --name myWeb2.0 -p 8090:8090 -d javaweb:2.0 ⑦浏览器访问 ","date":"2024-04-20","objectID":"/docker/:3:2","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#332基于java8构建java项目"},{"categories":["中间件"],"content":" 3.4.小结小结： Dockerfile的本质是一个文件，通过指令描述镜像的构建过程 Dockerfile的第一行必须是FROM，从一个基础镜像来构建 基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine ","date":"2024-04-20","objectID":"/docker/:4:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#34小结"},{"categories":["中间件"],"content":" 4.Docker-Compose通过我们上述学习，对于每个应用都是手动创建和运行容器，那么实际开发中小一点的公司几十个应用，大一点公司几百个应用，而如果一个一个手动部署，效率会比较低也比较麻烦。因此我们可以学习下面的技术Docker-Compose来解决。 Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！ ","date":"2024-04-20","objectID":"/docker/:0:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#4docker-compose"},{"categories":["中间件"],"content":" 4.1.初识DockerComposeCompose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下： version: \"3.8\" services: mysql: image: mysql:5.7.25 environment: MYSQL_ROOT_PASSWORD: 123 volumes: - \"/tmp/mysql/data:/var/lib/mysql\" web: build: . ports: - \"8090:8090\" 上面的Compose文件就描述一个项目，其中包含两个容器： mysql：一个基于mysql:5.7.25镜像构建的容器，并且挂载了1个目录 web：一个基于docker build临时构建的镜像容器，映射端口时8090 DockerCompose的详细语法参考官网：https://docs.docker.com/compose/compose-file/ 其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。 补充:以前执行命令创建镜像和容器方式： docker run --restart=always -p 3306:3306 --name mysql -v /tmp/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=1234 -d mysql:5.7.25 docker build -t javaweb:1.0 . ","date":"2024-04-20","objectID":"/docker/:1:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#41初识dockercompose"},{"categories":["中间件"],"content":" 4.2.安装DockerCompose参考课前资料 ","date":"2024-04-20","objectID":"/docker/:2:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#42安装dockercompose"},{"categories":["中间件"],"content":" 4.3.部署应用(这里简单实现就好，后期学习微服务会多个微服务部署) 课下完成","date":"2024-04-20","objectID":"/docker/:3:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#43部署应用这里简单实现就好后期学习微服务会多个微服务部署-课下完成"},{"categories":["中间件"],"content":" 4.3.1.实现思路【1】 查看 资料\\原始代码\\docker-compose文件夹，里面是已经编写好了docker-compose文件和项目 【2】修改docker-compose的配置文件docker-compose.yml变为自己当前的环境配置参数 【3】将docker-compose目录上传到虚拟机中的/tmp目录下面 【4】切换到docker-compose目录下即docker-compose.yml文件所在位置 【5】查看之前启动的容器并全部删除 【6】停止mysql服务 【7】执行命令 docker-compose up -d 批量构建容器，并启动 【8】使用浏览器访问项目 【9】使用mysql客户端datagrip访问mysql服务 ","date":"2024-04-20","objectID":"/docker/:3:1","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#431实现思路"},{"categories":["中间件"],"content":" 4.3.2.具体实现【1】 查看 资料\\原始代码\\docker-compose文件夹，里面是已经编写好了docker-compose文件和项目 【2】修改docker-compose的配置文件docker-compose.yml变为自己当前的环境配置参数 # DockerCompose的版本是3.2 version: \"3.2\" # DockerCompose启动时启动的服务(应用)，一共启动2个服务 services: # 基于已有的镜像image: mysql:5.7.25去创建mysql容器 mysql: # 你的虚拟机镜像应该是mysql:5.7.25。这里基于你的mysql镜像创建容器 image: mysql:5.7.25 container_name: mysql_container environment: MYSQL_ROOT_PASSWORD: 1234 volumes: - \"/tmp/mysql/data:/var/lib/mysql\" - \"/tmp/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf\" ports: - \"3306:3306\" # 自己构建镜像然后创建容器 myweb: # 找到当前目录下myweb-service下面的Dockerfile然后构建镜像 build: ./myweb-service # 镜像名是 myweb:3.0 image: myweb:3.0 container_name: myweb_container ports: # 在浏览器访问项目的端口号是8082 - \"8082:8090\" 【3】将docker-compose目录上传到虚拟机中的/tmp目录下面 【4】切换到docker-compose目录下即docker-compose.yml文件所在位置 【5】查看之前启动的容器并全部删除 【6】停止mysql服务 service mysqld stop 【7】执行命令 docker-compose up -d 批量构建容器，并启动 # 利用DockerCompose部署,批量构建容器，并启动 # 说明:docker-compose up -d 以后台的方式运行容器. # up表示创建和启动容器 # -d 表示后台 docker-compose up -d 【8】使用浏览器访问项目 【9】使用mysql客户端datagrip访问mysql服务 ","date":"2024-04-20","objectID":"/docker/:3:2","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#432具体实现"},{"categories":["中间件"],"content":" 5.Docker镜像仓库 理解","date":"2024-04-20","objectID":"/docker/:0:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#5docker镜像仓库-理解"},{"categories":["中间件"],"content":" 5.1Docker镜像仓库介绍我们之前学习了一些镜像，例如第三方的镜像mysql reids等，也有我们自己创建的镜像。那么这些镜像都需要管理和保存，管理和保存镜像的地方就叫镜像仓库（ Docker Registry ）。有公共的和私有的两种形式： 公共仓库：例如Docker官方的 Docker Hub，国内也有一些云服务商提供类似于 Docker Hub 的公开服务，比如 网易云镜像服务、DaoCloud 镜像服务、阿里云镜像服务等。 私有仓库：除了使用公开仓库外，用户还可以在本地搭建私有 Docker Registry。企业自己的镜像最好是采用私有Docker Registry来实现。实际开发中我们一般都是自己搭建镜像仓库，因为将企业的项目的镜像上传到公共仓库不安全。 ","date":"2024-04-20","objectID":"/docker/:1:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#51docker镜像仓库介绍"},{"categories":["中间件"],"content":" 5.1.搭建私有镜像仓库参考课前资料《CentOS7安装Docker.md》 ","date":"2024-04-20","objectID":"/docker/:2:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#51搭建私有镜像仓库"},{"categories":["中间件"],"content":" 5.2.推送、拉取镜像推送镜像到私有镜像服务必须先tag(版本)，步骤如下： ① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.200.128:5000/ docker tag nginx:latest 192.168.200.128:5000/nginx:1.0 说明： 1.nginx:latest 表示原来的镜像名和版本 2.192.168.200.128:5000 私有仓库的地址 3.nginx:1.0 ：新的镜像和版本 ② 推送镜像 docker push 192.168.200.128:5000/nginx:1.0 ③ 拉取镜像 【1】先删除之前的镜像 docker rmi 192.168.200.128:5000/nginx:1.0 nginx:latest 【2】在拉取新的镜像 docker pull 192.168.200.128:5000/nginx:1.0 ","date":"2024-04-20","objectID":"/docker/:3:0","series":null,"tags":["Docker"],"title":"Docker","uri":"/docker/#52推送拉取镜像"},{"categories":["中间件"],"content":" Nacos注册中心国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。 ","date":"2024-03-31","objectID":"/nacos/:0:0","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#nacos注册中心"},{"categories":["中间件"],"content":" 1.认识和安装NacosNacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。 安装方式可以参考课前资料《Nacos安装指南.md》 ","date":"2024-03-31","objectID":"/nacos/:1:0","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#1认识和安装nacos"},{"categories":["中间件"],"content":" 2.服务注册到nacosNacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。 主要差异在于： 依赖不同 服务地址不同 ","date":"2024-03-31","objectID":"/nacos/:2:0","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#2服务注册到nacos"},{"categories":["中间件"],"content":" 1）引入依赖在cloud-demo父工程的pom文件中的\u003cdependencyManagement\u003e中引入SpringCloudAlibaba的依赖： \u003cdependencyManagement\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.2.6.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e 然后在user-service和order-service中的pom文件中引入nacos-discovery依赖： \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e 注意：不要忘了注释掉eureka的依赖。 ","date":"2024-03-31","objectID":"/nacos/:2:1","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#1引入依赖"},{"categories":["中间件"],"content":" 2）配置nacos地址在user-service和order-service的application.yml中添加nacos地址： spring: cloud: nacos: server-addr: localhost:8848 注意：不要忘了注释掉eureka的地址 ","date":"2024-03-31","objectID":"/nacos/:2:2","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#2配置nacos地址"},{"categories":["中间件"],"content":" 3）重启重启微服务后，登录nacos管理页面，可以看到微服务信息： ","date":"2024-03-31","objectID":"/nacos/:2:3","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#3重启"},{"categories":["中间件"],"content":" 3.服务分级存储模型一个服务可以有多个实例，例如我们的user-service，可以有: 127.0.0.1:8081 127.0.0.1:8082 127.0.0.1:8083 假如这些实例分布于全国各地的不同机房，例如： 127.0.0.1:8081，在上海机房 127.0.0.1:8082，在上海机房 127.0.0.1:8083，在杭州机房 Nacos就将同一机房内的实例 划分为一个集群。 也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图： 微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如： 杭州机房内的order-service应该优先访问同机房的user-service。 ","date":"2024-03-31","objectID":"/nacos/:3:0","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#3服务分级存储模型"},{"categories":["中间件"],"content":" 5.3.1.给user-service配置集群修改user-service的application.yml文件，添加集群配置： spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 重启两个user-service实例后，我们可以在nacos控制台看到下面结果： 我们再次复制一个user-service启动配置，添加属性： -Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH 配置如图所示： 启动UserApplication3后再次查看nacos控制台： ","date":"2024-03-31","objectID":"/nacos/:3:1","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#531给user-service配置集群"},{"categories":["中间件"],"content":" 5.3.2.同集群优先的负载均衡默认的ZoneAvoidanceRule并不能实现根据同集群优先来实现负载均衡。 因此Nacos中提供了一个NacosRule的实现，可以优先从同集群中挑选实例。 1）给order-service配置集群信息 修改order-service的application.yml文件，添加集群配置： spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ # 集群名称 2）修改负载均衡规则 修改order-service的application.yml文件，修改负载均衡规则： userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 ","date":"2024-03-31","objectID":"/nacos/:3:2","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#532同集群优先的负载均衡"},{"categories":["中间件"],"content":" 4.权重配置实际部署中会出现这样的场景： 服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。 但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。 因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。 在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重： 在弹出的编辑窗口，修改权重： 注意：如果权重修改为0，则该实例永远不会被访问 ","date":"2024-03-31","objectID":"/nacos/:4:0","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#4权重配置"},{"categories":["中间件"],"content":" 5.环境隔离Nacos提供了namespace来实现环境隔离功能。 nacos中可以有多个namespace namespace下可以有group、service等 不同namespace之间相互隔离，例如不同namespace的服务互相不可见 ","date":"2024-03-31","objectID":"/nacos/:5:0","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#5环境隔离"},{"categories":["中间件"],"content":" 5.1.创建namespace默认情况下，所有service、data、group都在同一个namespace，名为public： 我们可以点击页面新增按钮，添加一个namespace： 然后，填写表单： 就能在页面看到一个新的namespace： ","date":"2024-03-31","objectID":"/nacos/:5:1","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#51创建namespace"},{"categories":["中间件"],"content":" 5.2.给微服务配置namespace给微服务配置namespace只能通过修改配置来实现。 例如，修改order-service的application.yml文件： spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: HZ namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID 重启order-service后，访问控制台，可以看到下面的结果： 此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错： ","date":"2024-03-31","objectID":"/nacos/:5:2","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#52给微服务配置namespace"},{"categories":["中间件"],"content":" 6.Nacos与Eureka的区别Nacos的服务实例分为两种l类型： 临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。 非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。 配置一个服务实例为永久实例： spring: cloud: nacos: discovery: ephemeral: false # 设置为非临时实例 Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异： Nacos与eureka的共同点 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别 Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式 临时实例心跳不正常会被剔除，非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式，服务列表更新更及时 Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式 ","date":"2024-03-31","objectID":"/nacos/:6:0","series":null,"tags":["Nacos"],"title":"Nacos","uri":"/nacos/#6nacos与eureka的区别"},{"categories":["算法"],"content":" 1、[USACO09OCT] The Robot Plow G","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#1usaco09oct-the-robot-plow-g"},{"categories":["算法"],"content":" 题目描述Farmer John has purchased a new robotic plow in order to relieve him from the drudgery of plowing field after field after field. It achieves this goal but at a slight disadvantage: the robotic plow can only plow in a perfect rectangle with sides of integer length. Because FJ’s field has trees and other obstacles, FJ sets up the plow to plow many different rectangles, which might end up overlapping. He’s curious as to just how many squares in his field are actually plowed after he programs the plow with various plow instructions, each of which describes a rectangle by giving its lower left and upper right x,y coordinates. As usual, the field is partitioned into squares whose sides are parallel to the x and y axes. The field is X squares wide and Y squares high (1 \u003c= X \u003c= 240; 1 \u003c= Y \u003c= 240). Each of the I (1 \u003c= I \u003c= 200) plow instructions comprises four integers: Xll, Yll, Xur, and Yur (1 \u003c= Xll \u003c= Xur; Xll \u003c= Xur \u003c= X; 1 \u003c= Yll \u003c= Yur; Yll \u003c= Yur \u003c= Y) which are the lower left and upper right coordinates of the rectangle to be plowed. The plow will plow all the field’s squares in the range (Xll..Xur, Yll..Yur) which might be one more row and column than would initially be assumed (depending on how you go about your assumptions, of course). Consider a field that is 6 squares wide and 4 squares high. As FJ issues a pair of plowing instructions (shown), the field gets plowed as shown by ‘*’ and ‘#’ (normally plowed field all looks the same, but ‘#’ shows which were most recently plowed): ...... **.... #####. ...... (1,1)(2,4) **.... (1,3)(5,4) #####. ...... **.... **.... ...... **.... **.... A total of 14 squares are plowed. POINTS: 25 Farmer John为了让自己从无穷无尽的犁田工作中解放出来，于是买了个新机器人帮助他犁田。这个机器人可以完成犁田的任务，可惜有一个小小的缺点：这个犁田机器人一次只能犁一个边的长度是整数的长方形的田地。 因为FJ的田地有树和其它障碍物，所以FJ设定机器人去犁很多不同的长方形。这些长方形允许重叠。他给机器人下了P个指令，每个指令包含一个要犁长方形的地。这片田地由长方形的左下角和右上角坐标决定。他很好奇最后到底有多少个方格的地被犁过了。 一般来说，田地被分割为很多小方格。这些方格的边和x轴或y轴平行。田地的宽度为X个方格，高度为Y个方格 (1 \u003c= X \u003c= 240; 1 \u003c= Y \u003c= 240). FJ执行了I (1 \u003c= I \u003c= 200)个指令，每个指令包含4个整数：Xll, Yll, Xur, Yur (1 \u003c= Xll \u003c= Xur; Xll \u003c= Xur \u003c=X; 1 \u003c= Yll \u003c= Yur; Yll \u003c= Yur \u003c= Y), 分别是要犁的长方形的左下角坐标和右上角坐标。机器人会犁所有的横坐标在Xll..Xur并且纵坐标在Yll..Yur范围内的所有方格的地。可能这个长方形会比你想象的多一行一列（就是说从第Xll列到第Xur列一共有Xur - Xll + 1列而不是Xur - Xll列）。 考虑一个6方格宽4方格高的田地。FJ进行了2个操作（如下），田地就被犁成\"*“和”#“了。虽然一般被犁过的地看起来都是一样的。但是标成”#“可以更清晰地看出最近一次被犁的长方形。 一共14个方格的地被犁过了。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:1:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题目描述"},{"categories":["算法"],"content":" 输入格式* Line 1: Three space-separated integers: X, Y, and I * Lines 2..I+1: Line i+1 contains plowing instruction i which is described by four integers: Xll, Yll, Xur, and Yur ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:2:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输入格式"},{"categories":["算法"],"content":" 输出格式* Line 1: A single integer that is the total number of squares plowed ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:3:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输出格式"},{"categories":["算法"],"content":" 样例 #1","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例-1"},{"categories":["算法"],"content":" 样例输入 #1 6 4 2 1 1 2 4 1 3 5 4 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输入-1"},{"categories":["算法"],"content":" 样例输出 #1 14 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输出-1"},{"categories":["算法"],"content":" 提示As in the task’s example. 题目意思并不是一针见血的，分析如下： ​ 有一个6 x 4的方格，输入了2条指令，第一条指令是(1,1)和(2,4)围成的范围，一共是2 x 4 = 8个格子，第二条指令是(1,3)和(5,4)围成的范围，一共是5 x 2 = 10个格子。但是中间有（1,3）（1,4）（2,3）（2,4）是重复的格子，所以要减去，即最后答案为18 - 4 =14 个格子。 ​ 第一次做题的时候可能会想去求出重复格子的个数，这种做法是可行的，但是不可取，所以换个思路，定义一个bool类型的数组，当某个格子被访问时，把它的值变为1，最后统计值为1的格子个数就可以了。。。 #define _CRT_SECURE_NO_WARNINGS #include \u003ciostream\u003e using namespace std; #include \u003cstring\u003e #include\u003ccstring\u003e bool a[240 + 5][240 + 5]; //将访问到的每个格子状态变为1 void ex(int x, int y, int s, int t) { for (int i = x; i \u003c= s; i++) { for (int j = y;j \u003c= t; j++) { a[i][j] = 1; } } } int main() { int m, n, c; int x, y, s, t, count = 0; memset(a, 0, sizeof(a)); cin \u003e\u003e m \u003e\u003e n \u003e\u003e c; for (int i = 0; i \u003c c; i++) { cin \u003e\u003e x \u003e\u003e y \u003e\u003e s \u003e\u003e t; ex(x, y, s, t); } //统计在范围内有多少个格子变为1了 for (int i = 1; i \u003c= m; i++) { for (int j = 1; j \u003c= n; j++) { if (a[i][j]) count++; } } cout \u003c\u003c count; system(\"pause\"); return 0; } ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#提示"},{"categories":["算法"],"content":" 2、[COCI2006-2007#1] Modulo","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#2coci2006-20071-modulo"},{"categories":["算法"],"content":" 题面翻译给出 $10$ 个整数，问这些整数除以 $42$ 后得到的余数有多少种。 第一个样例的十个结果是 $1,2,3,4,5,6,7,8,9,10$，有 $10$ 个不同的结果； 第二个样例结果都是 $0$，只有一个不同的结果； 第三个样例余数是 $39,40,41,0,1,2,40,41,0,1$，有 $0,1,2,39,40,41$ 这六个不同的结果。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:1:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题面翻译"},{"categories":["算法"],"content":" 题目描述Given two integers A and B, A modulo B is the remainder when dividing A by B. For example, the numbers 7, 14, 27 and 38 become 1, 2, 0 and 2, modulo 3. Write a program that accepts 10 numbers as input and outputs the number of distinct numbers in the input, if the numbers are considered modulo 42. ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:2:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题目描述-1"},{"categories":["算法"],"content":" 输入格式The input will contain 10 non-negative integers, each smaller than 1000, one per line. ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:3:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输入格式-1"},{"categories":["算法"],"content":" 输出格式Output the number of distinct values when considered modulo 42 on a single line. ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输出格式-1"},{"categories":["算法"],"content":" 样例 #1","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例-1-1"},{"categories":["算法"],"content":" 样例输入 #1 1 2 3 4 5 6 7 8 9 10 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输入-1-1"},{"categories":["算法"],"content":" 样例输出 #1 10 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输出-1-1"},{"categories":["算法"],"content":" 样例 #2","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:6:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例-2"},{"categories":["算法"],"content":" 样例输入 #2 42 84 252 420 840 126 42 84 420 126 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:6:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输入-2"},{"categories":["算法"],"content":" 样例输出 #2 1 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:6:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输出-2"},{"categories":["算法"],"content":" 样例 #3","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:7:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例-3"},{"categories":["算法"],"content":" 样例输入 #3 39 40 41 42 43 44 82 83 84 85 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:7:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输入-3"},{"categories":["算法"],"content":" 样例输出 #3 6 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:7:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输出-3"},{"categories":["算法"],"content":" 提示In the first example, the numbers modulo 42 are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. In the second example all numbers modulo 42 are 0. In the third example, the numbers modulo 42 are 39, 40, 41, 0, 1, 2, 40, 41, 0 and 1. There are 6 distinct numbers. ​ 首先来分析：题目给出10个数，每个数除以42，要我们求出余数的种类个数，相同的余数算1个种类。 ​ 你可能会想到：先创建一个集合，把每一次得到的余数与集合中的元素比较，如果集合中没有此元素，则存入集合，那么有没有更简单的方法？ ​ 思路如下： 用上桶排序，定义一个大小为42的bool类型数组a[42]，初始值为0。 每一次求出的余数可以看做数组下标，把它的值变为1。a[余数]=1 最后求出a[i]=1的个数 #define _CRT_SECURE_NO_WARNINGS #include \u003ciostream\u003e using namespace std; #include \u003cstring\u003e #include \u003ccstring\u003e bool a[42]; int main() { int sum = 0, x; memset(a, 0, sizeof(a)); for (int i = 0; i \u003c 10; i++) { cin \u003e\u003e x; a[x % 42] = 1; } for (int i = 0; i \u003c 42; i++) { if (a[i]) { sum++; } } cout \u003c\u003c sum \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:8:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#提示-1"},{"categories":["算法"],"content":" 3、子数整数","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#3子数整数"},{"categories":["算法"],"content":" 题目描述对于一个五位数 $\\overline{a_1a_2a_3a_4a_5}$，可将其拆分为三个子数： $sub_1=\\overline{a_1a_2a_3}$ $sub_2=\\overline{a_2a_3a_4}$ $sub_3=\\overline{a_3a_4a_5}$ 例如，五位数 $20207$ 可以拆分成 $sub_1=202$ $sub_2=020\\ (=20)$ $sub_3=207$ 现在给定一个正整数 $K$，要求你编程求出 $10000$ 到 $30000$ 之间所有满足下述条件的五位数，条件是这些五位数的三个子数 $sub_1,sub_2,sub_3$ 都可被 $K$ 整除。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:1:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题目描述-2"},{"categories":["算法"],"content":" 输入格式一个正整数 $K$。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:2:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输入格式-2"},{"categories":["算法"],"content":" 输出格式每一行为一个满足条件的五位数，要求从小到大输出。不得重复输出或遗漏。如果无解，则输出 No。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:3:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输出格式-2"},{"categories":["算法"],"content":" 样例 #1","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例-1-2"},{"categories":["算法"],"content":" 样例输入 #1 15 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输入-1-2"},{"categories":["算法"],"content":" 样例输出 #1 22555 25555 28555 30000 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输出-1-2"},{"categories":["算法"],"content":" 提示$0\u003cK\u003c1000$ ​ 先来分析： ​ 这道题的重点在于如何取出三个子数，比较人性化的一点是题目限定了标准为五位数，所以只需要通过/和%的运用就可以取出三个子数。 #define _CRT_SECURE_NO_WARNINGS #include \u003cbits/stdc++.h\u003e using namespace std; int main() { int k, sub1, sub2, sub3; bool flag = 0; cin \u003e\u003e k; for (int i = 10000; i \u003c= 30000; i++) { sub1 = i / 100; sub2 = (i / 10) % 1000; sub3 = i % 1000; if (sub1 % k == 0 \u0026\u0026 sub2 % k == 0 \u0026\u0026 sub3 % k == 0) { flag = 1; cout \u003c\u003c i \u003c\u003c endl; } } if (!flag) { cout \u003c\u003c \"No\" \u003c\u003c endl; } system(\"pause\"); return 0; } ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#提示-2"},{"categories":["算法"],"content":" 4、The Blocks Problem","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#4the-blocks-problem"},{"categories":["算法"],"content":" 题面翻译初始时从左到右有 $n$ 个木块，编号为 $0 \\ldots n-1$,要求实现下列四种操作： move a onto b : 把 $a$ 和 $b$ 上方的木块归位，然后把 $a$ 放到 $b$ 上面。 move a over b : 把 $a$ 上方的木块归位，然后把 $a$ 放在 $b$ 所在木块堆的最上方。 pile a onto b : 把 $b$ 上方的木块归位，然后把 $a$ 及以上的木块坨到 $b$ 上面。 pile a over b : 把 $a$ 及以上的木块坨到 $b$ 的上面。 一组数据的结束标志为 quit，如果有非法指令（如 $a$ 与 $b$ 在同一堆），无需处理。 输出:所有操作输入完毕后，从左到右，从下到上输出每个位置的木块编号。 感谢 jxdql2001 提供的翻译。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:1:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题面翻译-1"},{"categories":["算法"],"content":" 题目描述PDF ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:2:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题目描述-3"},{"categories":["算法"],"content":" 输入格式 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:3:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输入格式-3"},{"categories":["算法"],"content":" 输出格式 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输出格式-3"},{"categories":["算法"],"content":" 样例 #1","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例-1-3"},{"categories":["算法"],"content":" 样例输入 #1 10 move 9 onto 1 move 8 over 1 move 7 over 1 move 6 over 1 pile 8 over 6 pile 8 over 5 move 2 over 1 move 4 over 9 quit ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输入-1-3"},{"categories":["算法"],"content":" 样例输出 #1 0: 0 1: 1 9 2 4 2: 3: 3 4: 5: 5 8 7 6 6: 7: 8: 9: ​ 先来分析： ​ 这个题意不是一针见血的，应该把样例输出横着看，:左边的1234567890表示的是9个位置，:右边的是每个位置上的木块。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输出-1-3"},{"categories":["算法"],"content":" 5、移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u003c len; i++) { print(nums[i]); } 示例 1： 输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,3,0,4] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 50 0 \u003c= val \u003c= 100 int removeElement(int* nums, int numsSize, int val) { int *p=nums;//p找等于val的元素 int *q=nums+numsSize-1;//q找不等于val的元素 while(p\u003c=q){ if(*q==val){ q--; continue; } if(*p==val){ *p=*q; q--; }else{ p++; } } return p-nums; } class Solution { public: int removeElement(vector\u003cint\u003e\u0026 nums, int val) { int j=nums.size()-1; for(int i=0; i\u003c=j; i++) { if(nums[i]==val) { swap(nums[i--],nums[j--]); } } return j+1; } }; ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#5移除元素"},{"categories":["算法"],"content":" 6、旋转链表给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 示例 1： 输入：head = [1,2,3,4,5], k = 2 输出：[4,5,1,2,3] 示例 2： 输入：head = [0,1,2], k = 4 输出：[2,0,1] 提示： 链表中节点的数目在范围 [0, 500] 内 -100 \u003c= Node.val \u003c= 100 0 \u003c= k \u003c= 2 * 109 #define _CRT_SECURE_NO_WARNINGS #include \u003ciostream\u003e using namespace std; #include \u003cstring\u003e struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; class Solution { public: ListNode* rotateRight(ListNode* head, int k) { ListNode *p=head; ListNode *q=head; if(head==nullptr || k==0){ return head; } int length=0; for(ListNode *i=head; i!=nullptr; i=i-\u003enext) { length++; } k=k%length; //把p移动k个节点 for(int i=0; i\u003ck; i++) { p=p-\u003enext; } while(p-\u003enext!=nullptr) { //把p移动到原链表的尾节点 //此时q指向的是新链表的尾节点 q=q-\u003enext; p=p-\u003enext; } //把原链表的尾节点的next指向原链表的头节点 p-\u003enext=head; //设置新链表的头节点 head=q-\u003enext; //q指向的是新链表的尾节点，next置空 q-\u003enext=nullptr; return head; } }; int main() { return 0; } ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#6旋转链表"},{"categories":["算法"],"content":" 7、 逆波兰表达式求值给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。 请你计算该表达式。返回一个表示表达式值的整数。 注意： 有效的算符为 '+'、'-'、'*' 和 '/' 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 示例 1： 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"] 输出：22 解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示： 1 \u003c= tokens.length \u003c= 104 tokens[i] 是一个算符（\"+\"、\"-\"、\"*\" 或 \"/\"），或是在范围 [-200, 200] 内的一个整数 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#7-逆波兰表达式求值httpsleetcodecnproblemsevaluate-reverse-polish-notation"},{"categories":["算法"],"content":" 8、矩阵链乘 Matrix Chain Multiplication","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#8矩阵链乘-matrix-chain-multiplication"},{"categories":["算法"],"content":" 题面翻译","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:1:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题面翻译-2"},{"categories":["算法"],"content":" 矩阵链乘","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:2:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#矩阵链乘"},{"categories":["算法"],"content":" 题目描述假设你必须评估一种表达形如 ABCDE，其中 A,B,C,D,E是矩阵。既然矩阵乘法是关联的，那么乘法的顺序是任意的。然而，链乘的元素数量必须由你选择的赋值顺序决定。 例如，A，B，C分别是 50 * 10 ，10 * 20 和 20 * 5 的矩阵。现在有两种方案计算 A * B * C ,即（A * B) * C 和 A*(B * C)。 第一个要进行15000次基本乘法，而第二个只进行3500次。 你的任务就是写出一个程序判定以给定的方式相乘需要多少次基本乘法计算。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:2:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题目描述-4"},{"categories":["算法"],"content":" 输入格式输入包含两个部分：矩阵和表达式。 输入文件的第一行包含了一个整数 n(1 $\\leq$ n $\\leq$ 26), 代表矩阵的个数。接下来的n行每一行都包含了一个大写字母，说明矩阵的名称，以及两个整数，说明行与列的个数。 第二个部分严格遵守以下的语法： SecondPart = Line { Line } Line = Expression Expression = Matrix | “(” Expression Expression “)” Matrix = “A” | “B” | “C” | … | “X” | “Y” | “Z” ###输出格式 对于每一个表达式，如果乘法无法进行就输出 \" error “。否则就输出一行包含计算所需的乘法次数。 感谢@onceagain 提供翻译 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:2:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输入格式-4"},{"categories":["算法"],"content":" 题目描述PDF ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:3:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题目描述-5"},{"categories":["算法"],"content":" 输入格式 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输入格式-5"},{"categories":["算法"],"content":" 输出格式 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输出格式-4"},{"categories":["算法"],"content":" 样例 #1","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:6:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例-1-4"},{"categories":["算法"],"content":" 样例输入 #1 9 A 50 10 B 10 20 C 20 5 D 30 35 E 35 15 F 15 5 G 5 10 H 10 20 I 20 25 A B C (AA) (AB) (AC) (A(BC)) ((AB)C) (((((DE)F)G)H)I) (D(E(F(G(HI))))) ((D(EF))((GH)I)) ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:6:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输入-1-4"},{"categories":["算法"],"content":" 样例输出 #1 0 0 0 error 10000 error 3500 15000 40500 47500 15125 #define _CRT_SECURE_NO_WARNINGS // 禁用安全警告 #include \u003cbits/stdc++.h\u003e // 包含通用的标准库头文件 using namespace std; const int maxSize = 26 + 5; // 定义最大尺寸为31 struct Matrix { // 定义矩阵结构体 int a, b; // 矩阵的行和列 Matrix(int a = 0, int b = 0) // 构造函数，初始化矩阵的行和列 : a(a), b(b) {} } m[maxSize]; // 创建Matrix类型的数组m stack\u003cMatrix\u003e s; // 声明一个存放Matrix类型的栈s int main01() { int n; // 声明整数变量n char c; // 声明字符变量c string str; // 声明字符串变量str cin \u003e\u003e n; // 从标准输入流读取一个整数n for (int i = 0; i \u003c n; i++) { // 循环读取n次 cin \u003e\u003e c; // 从标准输入流读取一个字符c int k = c - 'A'; // 如果输入的是字母，则转换为整数 cin \u003e\u003e m[k].a \u003e\u003e m[k].b; // 从标准输入流读取两个整数，分别赋值给m[k].a和m[k].b } while (cin \u003e\u003e str) { // 循环读取字符串str，直到读取失败 int len = str.length(); // 获取字符串str的长度 bool error = false; // 声明布尔变量error，并初始化为false int ans = 0; // 声明整数变量ans，并初始化为0 for (int i = 0; i \u003c len; i++) { // 循环遍历字符串str if (isalpha(str[i])) { // 如果str[i]是字母 s.push(m[str[i] - 'A']); // 将m[str[i]-'A']入栈 } else if (str[i] == ')') { // 如果str[i]是右括号 Matrix m2 = s.top(); // 栈顶元素出栈，并赋值给m2 s.pop(); // 弹出栈顶元素 Matrix m1 = s.top(); // 再次将栈顶元素出栈，并赋值给m1 s.pop(); // 弹出栈顶元素 if (m1.b != m2.a) { // 如果m1的列数不等于m2的行数 error = true; // 将error标记为true break; // 退出循环 } ans += m1.a * m1.b * m2.b; // 计算矩阵相乘的结果，并累加到ans上 s.push(Matrix(m1.a, m2.b)); // 将新的矩阵入栈，行数为m1的行数，列数为m2的列数 } } if (error) { // 如果error为true cout \u003c\u003c \"error\" \u003c\u003c endl; // 输出错误信息 } else { // 否则 cout \u003c\u003c ans \u003c\u003c endl; // 输出计算结果 } } system(\"pause\"); // 暂停系统，等待用户按任意键继续 return 0; // 返回0，表示程序正常结束 } ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:6:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输出-1-4"},{"categories":["算法"],"content":" 9、打印队列 Printer Queue","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#9打印队列-printer-queue"},{"categories":["算法"],"content":" 题面翻译学生会里只有一台打印机，但是有很多文件需要打印，因此打印任务不可避免地需要等待。有些打印任务比较急，有些不那么急，所以每个任务都有一个1～9间的优先级，优先级越高表示任务越急。 打印机的运作方式如下：首先从打印队列里取出一个任务J，如果队列里有比J更急的任务，则直接把J放到打印队列尾部，否则打印任务J（此时不会把它放回打印队列）。 输入打印队列中各个任务的优先级以及所关注的任务在队列中的位置（队首位置为0），输出该任务完成的时刻。所有任务都需要1分钟打印。例如，打印队列为{1,1,9,1,1,1}，目前处于队首的任务最终完成时刻为5。 输入T 接下来T组数据 每组数据输入N，TOP。接下来N个数，TOP代表队列首 Translated by @HuangBo ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:1:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题面翻译-3"},{"categories":["算法"],"content":" 题目描述PDF ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:2:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题目描述-6"},{"categories":["算法"],"content":" 输入格式 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:3:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输入格式-6"},{"categories":["算法"],"content":" 输出格式 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输出格式-5"},{"categories":["算法"],"content":" 样例 #1","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例-1-5"},{"categories":["算法"],"content":" 样例输入 #1 3 //3组数据 1 0 //共1个任务，你的任务下标为0 5 //你的任务是5 4 2 //共4个任务，你的任务下标为2 1 2 3 4 //你的任务是3 6 0 //共6个任务，你的任务下标为0 1 1 9 1 1 1 //你的任务是1 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输入-1-5"},{"categories":["算法"],"content":" 样例输出 #1 1 2 5 #define _CRT_SECURE_NO_WARNINGS #include \u003cbits/stdc++.h\u003e using namespace std; int main() { int T, n, m;//T:几组优先级，n:本组优先级个数，m:你的优先级下标 cin \u003e\u003e T; for (int i = 0; i \u003c T; i++) { queue\u003cint\u003e q;//记录每个优先级的下标 vector\u003cint\u003e a, b;//a:原优先级排序,b:降序后的优先级排序 int k = 0, x;//x:输入所有的优先级 cin \u003e\u003e n \u003e\u003e m; for (int j = 0; j \u003c n; j++) { cin \u003e\u003e x; a.push_back(x); b.push_back(x); q.push(j); } sort(b. begin(), b.end(), greater\u003cint\u003e());//降序 int w = 0; int max = 0; while (!q.empty()) { max = b[w]; int t = q.front(); if (a[t] \u003c max) { q.pop(); q.push(t); } else { if (t == m) { cout \u003c\u003c ++k \u003c\u003c endl; break; } else { q.pop(); k++; w++; } } } } system(\"pause\"); return 0; } ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输出-1-5"},{"categories":["算法"],"content":" 10、第 k 小整数","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:0:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#10第-k-小整数"},{"categories":["算法"],"content":" 题目描述现有 $n$ 个正整数，要求出这 $n$ 个正整数中的第 $k$ 个最小整数（相同大小的整数只计算一次）。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:1:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#题目描述-7"},{"categories":["算法"],"content":" 输入格式第一行为 $n$ 和 $k$; 第二行开始为 $n$ 个正整数的值，整数间用空格隔开。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:2:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输入格式-7"},{"categories":["算法"],"content":" 输出格式第$k$个最小整数的值；若无解，则输出 NO RESULT。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:3:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#输出格式-6"},{"categories":["算法"],"content":" 样例 #1","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例-1-6"},{"categories":["算法"],"content":" 样例输入 #1 10 3 1 3 3 7 2 5 1 2 4 6 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:1","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输入-1-6"},{"categories":["算法"],"content":" 样例输出 #1 3 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:4:2","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#样例输出-1-6"},{"categories":["算法"],"content":" 提示$n \\leq 10000$，$k \\leq 1000$，正整数均小于 $30000$。 ","date":"2024-01-31","objectID":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/:5:0","series":null,"tags":["算法基础"],"title":"内功一阶","uri":"/%E5%86%85%E5%8A%9F%E4%B8%80%E9%98%B6/#提示-3"},{"categories":["数据结构"],"content":" 1、线性表基本概念​ 线性结构是一种最简单且常用的数据结构。线性结构的基本特点是节点之间满足线性关系。本章讨论的动态数组、链表、栈、队列都属于线性结构。他们的共同之处，是节点中有且只有一个开始节点和终端节点。按这种关系，可以把它们的所有节点排列成一个线性序列。但是，他们分别属于几种不同的抽象数据类型实现，它们之间的区别，主要就是操作的不同. 线性表是零个或者多个数据元素的有限序列，数据元素之间是有顺序的，数据元素个数是有限的，数据元素的类型必须相同 线性表的性质： a0 为线性表的第一个元素，只有一个后继。 an 为线性表的最后一个元素，只有一个前驱。 除 a0 和 an 外的其它元素 ai，既有前驱，又有后继。 线性表能够逐项访问和顺序存取。 线性表的抽象数据类型定义： ADT线性表（List） Data 线性表的数据对象集合为{ a1, a2, ……, an }，每个元素的类型均为DataType。其中，除第一个元素a1外，每个元素有且只有一个直接前驱元素，除了最后一个元素an外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一一对应的。 Operation（操作） // 初始化，建立一个空的线性表L。 InitList(*L); // 若线性表为空，返回true，否则返回false ListEmpty(L); // 将线性表清空 ClearList(*L); // 将线性表L中的第i个位置的元素返回给e GetElem(L, i, *e); // 在线性表L中的第i个位置插入新元素e ListInsert(*L, i, e); // 删除线性表L中的第i个位置元素，并用e返回其值 ListDelete(*L, i, *e); // 返回线性表L的元素个数 ListLength(L); // 销毁线性表 DestroyList(*L); ","date":"2024-01-02","objectID":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/:0:1","series":null,"tags":["线性表"],"title":"线性表","uri":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/#1线性表基本概念"},{"categories":["数据结构"],"content":" 2、线性表的顺序存储​ 采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个的存储在一块连续的存储区域中，这种顺序表示的线性表也成为顺序表。 2.1 线性表顺序存储(动态数组)的设计与实现操作要点: 插入元素算法 判断线性表是否合法 判断插入位置是否合法 判断空间是否满足 把最后一个元素到插入位置的元素后移一个位置 将新元素插入 线性表长度加1 获取元素操作 判断线性表是否合法 判断位置是否合法 直接通过数组下标的方式获取元素 删除元素算法 判断线性表是否合法 判断删除位置是否合法 将元素取出 将删除位置后的元素分别向前移动一个位置 线性表长度减1 元素的插入 元素的删除 注意: 链表的容量和链表的长度是两个不同的概念 #define _CRT_SECURE_NO_WARNINGS #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e struct Person { char name[64]; int age; }; //动态数组结构体 struct dynamiArray { //真实在堆区开辟数组的指针 void** p1; //数组容量 int m_Capacity; //数组长度 int m_Size; }; //初始化数组 struct dynamiArray * init_dynamicArray(int capacity) { if (capacity \u003c= 0) { return NULL; } //给数组分配内存 struct dynamiArray* arr = malloc(sizeof(struct dynamiArray)); if (arr == NULL) { return NULL; } //给数组初始化 arr-\u003ep1 = malloc(sizeof(void*) * capacity); arr-\u003em_Capacity = capacity; arr-\u003em_Size = 0; return arr; }; //插入数据 void insert_dynamiArray(struct dynamiArray* arr, void* data, int pos) { if (arr == NULL) { return; } if (data == NULL) { return; } if (pos\u003c0 || pos\u003earr-\u003em_Size) { //尾插 pos = arr-\u003em_Size; } //判断数组是否满了 if (arr-\u003em_Size == arr-\u003em_Capacity) { //计算新内存空间大小 int newCapacity = arr-\u003em_Capacity * 2; //开辟新的空间 void** newsPace = malloc(sizeof(void*) * newCapacity); //将原空间的数据拷贝到新空间下 memcpy(newsPace, arr-\u003ep1, sizeof(void*)* arr-\u003em_Capacity); //释放原空间 free(arr-\u003ep1); //更改指针指向 arr-\u003ep1 = newsPace; //更新新的容量 arr-\u003em_Capacity = newCapacity; } for (int i = arr-\u003em_Size; i \u003epos; i--) { arr-\u003ep1[i] = arr-\u003ep1[i-1]; } arr-\u003ep1[pos] = data; arr-\u003em_Size++; } //按照位置删除数据 void removeByPos_dynamiArray(struct dynamiArray* arr, int pos) { if(arr==NULL) { return; } //无效的删除位置 if(pos\u003c0||pos\u003earr-\u003em_Size-1) { return; } for (int i = pos; i \u003c arr-\u003em_Size; i++) { arr-\u003ep1[i] = arr-\u003ep1[i + 1]; } arr-\u003em_Size--; } int comparePerson(void *data1,void*data2) { struct Person* p1 = data1; struct Person* p2 = data2; return strcmp(p1-\u003ename, p2-\u003ename) == 0 \u0026\u0026 p1-\u003eage == p2-\u003eage; } //按照值删除 void removeByValue_dynamiArray(struct dynamiArray* arr, void* data, int(*myCompare)(void*, void*)) { if(arr==NULL) { return; } if(data==NULL) { return; } for (int i = 0; i \u003c arr-\u003em_Size; i++) { if (myCompare(arr-\u003ep1[i], data)) { removeByPos_dynamiArray(arr, i); break; } } } //遍历 void foreach_dynamiArray(struct dynamiArray* arr,void(*myPrint)(void*)) { if(arr==NULL) { return; } for (int i = 0; i \u003c arr-\u003em_Size; i++) { myPrint(arr-\u003ep1[i]); } } void printPerson(void* data) { struct Person* person = data; printf(\"姓名: %s 年龄: %d \\n\", person-\u003ename, person-\u003eage); } void destory_dynamiArray(struct dynamiArray* arr) { if (arr == NULL) { return; } if (arr-\u003ep1 != NULL) { free(arr-\u003ep1); arr-\u003ep1 = NULL; } free(arr); arr = NULL; return; } void test01() { struct dynamiArray* arr = init_dynamicArray(3); struct Person p1 = { \"赵云\",18 }; struct Person p2 = { \"关羽\",19 }; struct Person p3 = { \"张飞\",20 }; struct Person p4 = { \"刘备\",21 }; printf(\"插入数据前，数组的容量为 %d\\n\", arr-\u003em_Capacity); printf(\"插入数据前，数组的大小为 %d\\n\", arr-\u003em_Size); insert_dynamiArray(arr, \u0026p1, 0); insert_dynamiArray(arr, \u0026p2, -1); insert_dynamiArray(arr, \u0026p3, 0); insert_dynamiArray(arr, \u0026p4, -1); foreach_dynamiArray(arr, printPerson); /* 姓名: 张飞 年龄 : 20 姓名 : 赵云 年龄 : 18 姓名 : 关羽 年龄 : 19 姓名 : 刘备 年龄 : 2*/ printf(\"插入数据后，数组的容量为 %d\\n\", arr-\u003em_Capacity); printf(\"插入数据后，数组的大小为 %d\\n\", arr-\u003em_Size); printf(\"删除关羽\\n\"); removeByPos_dynamiArray(arr, 2); foreach_dynamiArray(arr, printPerson); printf(\"删除刘备\\n\"); struct Person p = { \"刘备\",21 }; removeByValue_dynamiArray(arr, \u0026p, comparePerson); foreach_dynamiArray(arr, printPerson); } int main() { test01(); system(\"pause\"); return 0; } 2.2 优点和缺点优点： 无需为线性表中的逻辑关系增加额外的空间。 可以快速的获取表中合法位置的元素。 缺点： 插入和删除操作需要移动大量元素。 ","date":"2024-01-02","objectID":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/:0:2","series":null,"tags":["线性表"],"title":"线性表","uri":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/#2线性表的顺序存储"},{"categories":["数据结构"],"content":" 2、线性表的顺序存储​ 采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个的存储在一块连续的存储区域中，这种顺序表示的线性表也成为顺序表。 2.1 线性表顺序存储(动态数组)的设计与实现操作要点: 插入元素算法 判断线性表是否合法 判断插入位置是否合法 判断空间是否满足 把最后一个元素到插入位置的元素后移一个位置 将新元素插入 线性表长度加1 获取元素操作 判断线性表是否合法 判断位置是否合法 直接通过数组下标的方式获取元素 删除元素算法 判断线性表是否合法 判断删除位置是否合法 将元素取出 将删除位置后的元素分别向前移动一个位置 线性表长度减1 元素的插入 元素的删除 注意: 链表的容量和链表的长度是两个不同的概念 #define _CRT_SECURE_NO_WARNINGS #include #include #include struct Person { char name[64]; int age; }; //动态数组结构体 struct dynamiArray { //真实在堆区开辟数组的指针 void** p1; //数组容量 int m_Capacity; //数组长度 int m_Size; }; //初始化数组 struct dynamiArray * init_dynamicArray(int capacity) { if (capacity \u003c= 0) { return NULL; } //给数组分配内存 struct dynamiArray* arr = malloc(sizeof(struct dynamiArray)); if (arr == NULL) { return NULL; } //给数组初始化 arr-\u003ep1 = malloc(sizeof(void*) * capacity); arr-\u003em_Capacity = capacity; arr-\u003em_Size = 0; return arr; }; //插入数据 void insert_dynamiArray(struct dynamiArray* arr, void* data, int pos) { if (arr == NULL) { return; } if (data == NULL) { return; } if (pos\u003c0 || pos\u003earr-\u003em_Size) { //尾插 pos = arr-\u003em_Size; } //判断数组是否满了 if (arr-\u003em_Size == arr-\u003em_Capacity) { //计算新内存空间大小 int newCapacity = arr-\u003em_Capacity * 2; //开辟新的空间 void** newsPace = malloc(sizeof(void*) * newCapacity); //将原空间的数据拷贝到新空间下 memcpy(newsPace, arr-\u003ep1, sizeof(void*)* arr-\u003em_Capacity); //释放原空间 free(arr-\u003ep1); //更改指针指向 arr-\u003ep1 = newsPace; //更新新的容量 arr-\u003em_Capacity = newCapacity; } for (int i = arr-\u003em_Size; i \u003epos; i--) { arr-\u003ep1[i] = arr-\u003ep1[i-1]; } arr-\u003ep1[pos] = data; arr-\u003em_Size++; } //按照位置删除数据 void removeByPos_dynamiArray(struct dynamiArray* arr, int pos) { if(arr==NULL) { return; } //无效的删除位置 if(pos\u003c0||pos\u003earr-\u003em_Size-1) { return; } for (int i = pos; i \u003c arr-\u003em_Size; i++) { arr-\u003ep1[i] = arr-\u003ep1[i + 1]; } arr-\u003em_Size--; } int comparePerson(void *data1,void*data2) { struct Person* p1 = data1; struct Person* p2 = data2; return strcmp(p1-\u003ename, p2-\u003ename) == 0 \u0026\u0026 p1-\u003eage == p2-\u003eage; } //按照值删除 void removeByValue_dynamiArray(struct dynamiArray* arr, void* data, int(*myCompare)(void*, void*)) { if(arr==NULL) { return; } if(data==NULL) { return; } for (int i = 0; i \u003c arr-\u003em_Size; i++) { if (myCompare(arr-\u003ep1[i], data)) { removeByPos_dynamiArray(arr, i); break; } } } //遍历 void foreach_dynamiArray(struct dynamiArray* arr,void(*myPrint)(void*)) { if(arr==NULL) { return; } for (int i = 0; i \u003c arr-\u003em_Size; i++) { myPrint(arr-\u003ep1[i]); } } void printPerson(void* data) { struct Person* person = data; printf(\"姓名: %s 年龄: %d \\n\", person-\u003ename, person-\u003eage); } void destory_dynamiArray(struct dynamiArray* arr) { if (arr == NULL) { return; } if (arr-\u003ep1 != NULL) { free(arr-\u003ep1); arr-\u003ep1 = NULL; } free(arr); arr = NULL; return; } void test01() { struct dynamiArray* arr = init_dynamicArray(3); struct Person p1 = { \"赵云\",18 }; struct Person p2 = { \"关羽\",19 }; struct Person p3 = { \"张飞\",20 }; struct Person p4 = { \"刘备\",21 }; printf(\"插入数据前，数组的容量为 %d\\n\", arr-\u003em_Capacity); printf(\"插入数据前，数组的大小为 %d\\n\", arr-\u003em_Size); insert_dynamiArray(arr, \u0026p1, 0); insert_dynamiArray(arr, \u0026p2, -1); insert_dynamiArray(arr, \u0026p3, 0); insert_dynamiArray(arr, \u0026p4, -1); foreach_dynamiArray(arr, printPerson); /* 姓名: 张飞 年龄 : 20 姓名 : 赵云 年龄 : 18 姓名 : 关羽 年龄 : 19 姓名 : 刘备 年龄 : 2*/ printf(\"插入数据后，数组的容量为 %d\\n\", arr-\u003em_Capacity); printf(\"插入数据后，数组的大小为 %d\\n\", arr-\u003em_Size); printf(\"删除关羽\\n\"); removeByPos_dynamiArray(arr, 2); foreach_dynamiArray(arr, printPerson); printf(\"删除刘备\\n\"); struct Person p = { \"刘备\",21 }; removeByValue_dynamiArray(arr, \u0026p, comparePerson); foreach_dynamiArray(arr, printPerson); } int main() { test01(); system(\"pause\"); return 0; } 2.2 优点和缺点优点： 无需为线性表中的逻辑关系增加额外的空间。 可以快速的获取表中合法位置的元素。 缺点： 插入和删除操作需要移动大量元素。 ","date":"2024-01-02","objectID":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/:0:2","series":null,"tags":["线性表"],"title":"线性表","uri":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/#21-线性表顺序存储动态数组的设计与实现"},{"categories":["数据结构"],"content":" 2、线性表的顺序存储​ 采用顺序存储是表示线性表最简单的方法，具体做法是：将线性表中的元素一个接一个的存储在一块连续的存储区域中，这种顺序表示的线性表也成为顺序表。 2.1 线性表顺序存储(动态数组)的设计与实现操作要点: 插入元素算法 判断线性表是否合法 判断插入位置是否合法 判断空间是否满足 把最后一个元素到插入位置的元素后移一个位置 将新元素插入 线性表长度加1 获取元素操作 判断线性表是否合法 判断位置是否合法 直接通过数组下标的方式获取元素 删除元素算法 判断线性表是否合法 判断删除位置是否合法 将元素取出 将删除位置后的元素分别向前移动一个位置 线性表长度减1 元素的插入 元素的删除 注意: 链表的容量和链表的长度是两个不同的概念 #define _CRT_SECURE_NO_WARNINGS #include #include #include struct Person { char name[64]; int age; }; //动态数组结构体 struct dynamiArray { //真实在堆区开辟数组的指针 void** p1; //数组容量 int m_Capacity; //数组长度 int m_Size; }; //初始化数组 struct dynamiArray * init_dynamicArray(int capacity) { if (capacity \u003c= 0) { return NULL; } //给数组分配内存 struct dynamiArray* arr = malloc(sizeof(struct dynamiArray)); if (arr == NULL) { return NULL; } //给数组初始化 arr-\u003ep1 = malloc(sizeof(void*) * capacity); arr-\u003em_Capacity = capacity; arr-\u003em_Size = 0; return arr; }; //插入数据 void insert_dynamiArray(struct dynamiArray* arr, void* data, int pos) { if (arr == NULL) { return; } if (data == NULL) { return; } if (pos\u003c0 || pos\u003earr-\u003em_Size) { //尾插 pos = arr-\u003em_Size; } //判断数组是否满了 if (arr-\u003em_Size == arr-\u003em_Capacity) { //计算新内存空间大小 int newCapacity = arr-\u003em_Capacity * 2; //开辟新的空间 void** newsPace = malloc(sizeof(void*) * newCapacity); //将原空间的数据拷贝到新空间下 memcpy(newsPace, arr-\u003ep1, sizeof(void*)* arr-\u003em_Capacity); //释放原空间 free(arr-\u003ep1); //更改指针指向 arr-\u003ep1 = newsPace; //更新新的容量 arr-\u003em_Capacity = newCapacity; } for (int i = arr-\u003em_Size; i \u003epos; i--) { arr-\u003ep1[i] = arr-\u003ep1[i-1]; } arr-\u003ep1[pos] = data; arr-\u003em_Size++; } //按照位置删除数据 void removeByPos_dynamiArray(struct dynamiArray* arr, int pos) { if(arr==NULL) { return; } //无效的删除位置 if(pos\u003c0||pos\u003earr-\u003em_Size-1) { return; } for (int i = pos; i \u003c arr-\u003em_Size; i++) { arr-\u003ep1[i] = arr-\u003ep1[i + 1]; } arr-\u003em_Size--; } int comparePerson(void *data1,void*data2) { struct Person* p1 = data1; struct Person* p2 = data2; return strcmp(p1-\u003ename, p2-\u003ename) == 0 \u0026\u0026 p1-\u003eage == p2-\u003eage; } //按照值删除 void removeByValue_dynamiArray(struct dynamiArray* arr, void* data, int(*myCompare)(void*, void*)) { if(arr==NULL) { return; } if(data==NULL) { return; } for (int i = 0; i \u003c arr-\u003em_Size; i++) { if (myCompare(arr-\u003ep1[i], data)) { removeByPos_dynamiArray(arr, i); break; } } } //遍历 void foreach_dynamiArray(struct dynamiArray* arr,void(*myPrint)(void*)) { if(arr==NULL) { return; } for (int i = 0; i \u003c arr-\u003em_Size; i++) { myPrint(arr-\u003ep1[i]); } } void printPerson(void* data) { struct Person* person = data; printf(\"姓名: %s 年龄: %d \\n\", person-\u003ename, person-\u003eage); } void destory_dynamiArray(struct dynamiArray* arr) { if (arr == NULL) { return; } if (arr-\u003ep1 != NULL) { free(arr-\u003ep1); arr-\u003ep1 = NULL; } free(arr); arr = NULL; return; } void test01() { struct dynamiArray* arr = init_dynamicArray(3); struct Person p1 = { \"赵云\",18 }; struct Person p2 = { \"关羽\",19 }; struct Person p3 = { \"张飞\",20 }; struct Person p4 = { \"刘备\",21 }; printf(\"插入数据前，数组的容量为 %d\\n\", arr-\u003em_Capacity); printf(\"插入数据前，数组的大小为 %d\\n\", arr-\u003em_Size); insert_dynamiArray(arr, \u0026p1, 0); insert_dynamiArray(arr, \u0026p2, -1); insert_dynamiArray(arr, \u0026p3, 0); insert_dynamiArray(arr, \u0026p4, -1); foreach_dynamiArray(arr, printPerson); /* 姓名: 张飞 年龄 : 20 姓名 : 赵云 年龄 : 18 姓名 : 关羽 年龄 : 19 姓名 : 刘备 年龄 : 2*/ printf(\"插入数据后，数组的容量为 %d\\n\", arr-\u003em_Capacity); printf(\"插入数据后，数组的大小为 %d\\n\", arr-\u003em_Size); printf(\"删除关羽\\n\"); removeByPos_dynamiArray(arr, 2); foreach_dynamiArray(arr, printPerson); printf(\"删除刘备\\n\"); struct Person p = { \"刘备\",21 }; removeByValue_dynamiArray(arr, \u0026p, comparePerson); foreach_dynamiArray(arr, printPerson); } int main() { test01(); system(\"pause\"); return 0; } 2.2 优点和缺点优点： 无需为线性表中的逻辑关系增加额外的空间。 可以快速的获取表中合法位置的元素。 缺点： 插入和删除操作需要移动大量元素。 ","date":"2024-01-02","objectID":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/:0:2","series":null,"tags":["线性表"],"title":"线性表","uri":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/#22-优点和缺点"},{"categories":["数据结构"],"content":" 3、线性表的链式存储(单向链表)​ 前面我们写的线性表的顺序存储(动态数组)的案例，最大的缺点是插入和删除时需要移动大量元素，这显然需要耗费时间，能不能想办法解决呢？链表。 ​ 链表为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。 单链表 线性表的链式存储结构中，每个节点中只包含一个指针域，这样的链表叫单链表。 通过每个节点的指针域将线性表的数据元素按其逻辑次序链接在一起（如图）。 概念解释： 表头结点 链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息 数据节点 链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息 尾节点 链表中的最后一个数据结点，其下一元素指针为空，表示无后继。 3.1 线性表的链式存储(单项链表)的设计与实现 插入操作 node-\u003enext = current-\u003enext; current-\u003enext = node; 删除操作 current-\u003enext = ret-\u003enext; #define _CRT_SECURE_NO_WARNINGS #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e //节点 struct LinkNode { //数据域 void* data; //指针域 struct LinkNode* next; }; struct Node { char name[64]; int age; }; //链表 struct LList { //头结点 struct LinkNode pHeader; //链表长度 int m_Size; }; typedef void* LinkList; //初始化链表 LinkList init_LinkList() { struct LList* myList = malloc(sizeof(struct LList)); if(myList==NULL) { return NULL; } myList-\u003epHeader.data = NULL; myList-\u003epHeader.next = NULL; myList-\u003em_Size = 0; return myList; } //插入数据 void insert_LinkList(LinkList list, int pos, void* data) { struct LList* myList = list; if (list == NULL || data == NULL) { return; } if (pos\u003c0 || pos\u003emyList-\u003em_Size) { pos = myList-\u003em_Size; } //创建一个临时节点,用来寻找新节点的前驱结点 struct LinkNode* pCurrent = \u0026myList-\u003epHeader; for (int i = 0; i \u003c pos; i++) { pCurrent = pCurrent-\u003enext; }//此时pCurrent节点就是新节点的前驱节点 struct LinkNode* newNode = malloc(sizeof(struct LinkNode)); newNode-\u003edata = data; newNode-\u003enext = NULL; newNode-\u003enext = pCurrent-\u003enext; pCurrent-\u003enext = newNode; //更新链表长度 myList-\u003em_Size++; return; } void printNode(void* data) { struct Node* node = data; printf(\"姓名：%s 年龄：%d\\n\", node-\u003ename, node-\u003eage); } //遍历 void foreach_LinkList(LinkList list, void(*myPrint)(void*)) { if (list == NULL) { return; } struct LList* myList = list; struct LinkNode* pCurrent = myList-\u003epHeader.next; while (pCurrent != NULL) { myPrint(pCurrent-\u003edata); pCurrent = pCurrent-\u003enext; } } //删除链表节点 void removeBuPos_LinkList(LinkList list, int pos) { if (list == NULL) { return; } struct LList* mylist = list; if (pos\u003c0 || pos\u003emylist-\u003em_Size - 1) { return; } //找到待删除位置的前驱节点位置 struct LinkNode* pCurrent = \u0026mylist-\u003epHeader; for (int i = 0; i \u003c pos; i++) { pCurrent = pCurrent-\u003enext; } //此时pcurrent就是待删除节点的前驱节点位置 struct LinkNode* pDel = pCurrent-\u003enext;//pdel就是要删除的节点 pCurrent-\u003enext = pDel-\u003enext; free(pDel); pDel = NULL; //更新链表长度 mylist-\u003em_Size--; } //回调函数，删除对比 int CompareNode(void* data1, void* data2) { struct Node* n1 = data1; struct Node* n2 = data2; return strcmp(n1-\u003ename, n2-\u003ename) == 0 \u0026\u0026 n1-\u003eage == n2-\u003eage; } //按值删除链表节点 void removeByValue_LinkList(LinkList list, void* data, int (*myCompare)(void*, void*)) { if (list == NULL) { return; } if (data == NULL) { return; } //将list还原成真实的链表结构体 struct LList* mylist = list; //创建两个辅助指针变量 struct LinkNode* pPrey = \u0026mylist-\u003epHeader; struct LinkNode* pCurrent = mylist-\u003epHeader.next; //遍历链表，找用户要删除的数据 for (int i = 0; i \u003c mylist-\u003em_Size; i++) { if (myCompare(data, pCurrent-\u003edata)) { //找到要修改的数据了，更改指针指向 pPrey-\u003enext = pCurrent-\u003enext; free(pCurrent); pCurrent = NULL; mylist-\u003em_Size++; break; } pPrey = pCurrent; pCurrent = pCurrent-\u003enext; } } //清除链表 void clear_LinkList(LinkList list) { if (list == NULL) { return; } struct LList* myList = list; struct LinkNode* pCurrent = myList-\u003epHeader.next; struct LinkNode* pNext = NULL; while (pCurrent != NULL) { pNext = pCurrent-\u003enext; free(pCurrent); pCurrent = pNext; } myList-\u003epHeader.next = NULL; myList-\u003em_Size = 0; } //销毁链表 void destory_LinkList(LinkList list) { if (list == NULL) { return; } clear_LinkList(list); free(list); list = NULL; } void test02() { LinkList myList = init_LinkList(); struct Node p1 = { \"赵云\",18 }; struct Node p2 = { \"关羽\",19 }; struct Node p3 = { \"张飞\",20 }; struct Node p4 = { \"刘备\",21 }; struct Node p5 = { \"黄忠\",22 }; struct Node p6 = { \"曹操\",23 }; insert_LinkList(myList, 0, \u0026p1); insert_LinkList(myList, -1, \u0026p2); insert_LinkList(myList, 0, \u0026p3); insert_LinkList(myList, -1, \u0026p4); insert_LinkList(myList, 0, \u0026p5); insert_LinkList(myList, -1, \u0026p6); foreach_LinkList(myList, ","date":"2024-01-02","objectID":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/:0:3","series":null,"tags":["线性表"],"title":"线性表","uri":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/#3线性表的链式存储单向链表"},{"categories":["数据结构"],"content":" 3、线性表的链式存储(单向链表)​ 前面我们写的线性表的顺序存储(动态数组)的案例，最大的缺点是插入和删除时需要移动大量元素，这显然需要耗费时间，能不能想办法解决呢？链表。 ​ 链表为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。 单链表 线性表的链式存储结构中，每个节点中只包含一个指针域，这样的链表叫单链表。 通过每个节点的指针域将线性表的数据元素按其逻辑次序链接在一起（如图）。 概念解释： 表头结点 链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息 数据节点 链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息 尾节点 链表中的最后一个数据结点，其下一元素指针为空，表示无后继。 3.1 线性表的链式存储(单项链表)的设计与实现 插入操作 node-\u003enext = current-\u003enext; current-\u003enext = node; 删除操作 current-\u003enext = ret-\u003enext; #define _CRT_SECURE_NO_WARNINGS #include #include #include //节点 struct LinkNode { //数据域 void* data; //指针域 struct LinkNode* next; }; struct Node { char name[64]; int age; }; //链表 struct LList { //头结点 struct LinkNode pHeader; //链表长度 int m_Size; }; typedef void* LinkList; //初始化链表 LinkList init_LinkList() { struct LList* myList = malloc(sizeof(struct LList)); if(myList==NULL) { return NULL; } myList-\u003epHeader.data = NULL; myList-\u003epHeader.next = NULL; myList-\u003em_Size = 0; return myList; } //插入数据 void insert_LinkList(LinkList list, int pos, void* data) { struct LList* myList = list; if (list == NULL || data == NULL) { return; } if (pos\u003c0 || pos\u003emyList-\u003em_Size) { pos = myList-\u003em_Size; } //创建一个临时节点,用来寻找新节点的前驱结点 struct LinkNode* pCurrent = \u0026myList-\u003epHeader; for (int i = 0; i \u003c pos; i++) { pCurrent = pCurrent-\u003enext; }//此时pCurrent节点就是新节点的前驱节点 struct LinkNode* newNode = malloc(sizeof(struct LinkNode)); newNode-\u003edata = data; newNode-\u003enext = NULL; newNode-\u003enext = pCurrent-\u003enext; pCurrent-\u003enext = newNode; //更新链表长度 myList-\u003em_Size++; return; } void printNode(void* data) { struct Node* node = data; printf(\"姓名：%s 年龄：%d\\n\", node-\u003ename, node-\u003eage); } //遍历 void foreach_LinkList(LinkList list, void(*myPrint)(void*)) { if (list == NULL) { return; } struct LList* myList = list; struct LinkNode* pCurrent = myList-\u003epHeader.next; while (pCurrent != NULL) { myPrint(pCurrent-\u003edata); pCurrent = pCurrent-\u003enext; } } //删除链表节点 void removeBuPos_LinkList(LinkList list, int pos) { if (list == NULL) { return; } struct LList* mylist = list; if (pos\u003c0 || pos\u003emylist-\u003em_Size - 1) { return; } //找到待删除位置的前驱节点位置 struct LinkNode* pCurrent = \u0026mylist-\u003epHeader; for (int i = 0; i \u003c pos; i++) { pCurrent = pCurrent-\u003enext; } //此时pcurrent就是待删除节点的前驱节点位置 struct LinkNode* pDel = pCurrent-\u003enext;//pdel就是要删除的节点 pCurrent-\u003enext = pDel-\u003enext; free(pDel); pDel = NULL; //更新链表长度 mylist-\u003em_Size--; } //回调函数，删除对比 int CompareNode(void* data1, void* data2) { struct Node* n1 = data1; struct Node* n2 = data2; return strcmp(n1-\u003ename, n2-\u003ename) == 0 \u0026\u0026 n1-\u003eage == n2-\u003eage; } //按值删除链表节点 void removeByValue_LinkList(LinkList list, void* data, int (*myCompare)(void*, void*)) { if (list == NULL) { return; } if (data == NULL) { return; } //将list还原成真实的链表结构体 struct LList* mylist = list; //创建两个辅助指针变量 struct LinkNode* pPrey = \u0026mylist-\u003epHeader; struct LinkNode* pCurrent = mylist-\u003epHeader.next; //遍历链表，找用户要删除的数据 for (int i = 0; i \u003c mylist-\u003em_Size; i++) { if (myCompare(data, pCurrent-\u003edata)) { //找到要修改的数据了，更改指针指向 pPrey-\u003enext = pCurrent-\u003enext; free(pCurrent); pCurrent = NULL; mylist-\u003em_Size++; break; } pPrey = pCurrent; pCurrent = pCurrent-\u003enext; } } //清除链表 void clear_LinkList(LinkList list) { if (list == NULL) { return; } struct LList* myList = list; struct LinkNode* pCurrent = myList-\u003epHeader.next; struct LinkNode* pNext = NULL; while (pCurrent != NULL) { pNext = pCurrent-\u003enext; free(pCurrent); pCurrent = pNext; } myList-\u003epHeader.next = NULL; myList-\u003em_Size = 0; } //销毁链表 void destory_LinkList(LinkList list) { if (list == NULL) { return; } clear_LinkList(list); free(list); list = NULL; } void test02() { LinkList myList = init_LinkList(); struct Node p1 = { \"赵云\",18 }; struct Node p2 = { \"关羽\",19 }; struct Node p3 = { \"张飞\",20 }; struct Node p4 = { \"刘备\",21 }; struct Node p5 = { \"黄忠\",22 }; struct Node p6 = { \"曹操\",23 }; insert_LinkList(myList, 0, \u0026p1); insert_LinkList(myList, -1, \u0026p2); insert_LinkList(myList, 0, \u0026p3); insert_LinkList(myList, -1, \u0026p4); insert_LinkList(myList, 0, \u0026p5); insert_LinkList(myList, -1, \u0026p6); foreach_LinkList(myList, ","date":"2024-01-02","objectID":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/:0:3","series":null,"tags":["线性表"],"title":"线性表","uri":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/#31-线性表的链式存储单项链表的设计与实现"},{"categories":["数据结构"],"content":" 3、线性表的链式存储(单向链表)​ 前面我们写的线性表的顺序存储(动态数组)的案例，最大的缺点是插入和删除时需要移动大量元素，这显然需要耗费时间，能不能想办法解决呢？链表。 ​ 链表为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。 单链表 线性表的链式存储结构中，每个节点中只包含一个指针域，这样的链表叫单链表。 通过每个节点的指针域将线性表的数据元素按其逻辑次序链接在一起（如图）。 概念解释： 表头结点 链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息 数据节点 链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息 尾节点 链表中的最后一个数据结点，其下一元素指针为空，表示无后继。 3.1 线性表的链式存储(单项链表)的设计与实现 插入操作 node-\u003enext = current-\u003enext; current-\u003enext = node; 删除操作 current-\u003enext = ret-\u003enext; #define _CRT_SECURE_NO_WARNINGS #include #include #include //节点 struct LinkNode { //数据域 void* data; //指针域 struct LinkNode* next; }; struct Node { char name[64]; int age; }; //链表 struct LList { //头结点 struct LinkNode pHeader; //链表长度 int m_Size; }; typedef void* LinkList; //初始化链表 LinkList init_LinkList() { struct LList* myList = malloc(sizeof(struct LList)); if(myList==NULL) { return NULL; } myList-\u003epHeader.data = NULL; myList-\u003epHeader.next = NULL; myList-\u003em_Size = 0; return myList; } //插入数据 void insert_LinkList(LinkList list, int pos, void* data) { struct LList* myList = list; if (list == NULL || data == NULL) { return; } if (pos\u003c0 || pos\u003emyList-\u003em_Size) { pos = myList-\u003em_Size; } //创建一个临时节点,用来寻找新节点的前驱结点 struct LinkNode* pCurrent = \u0026myList-\u003epHeader; for (int i = 0; i \u003c pos; i++) { pCurrent = pCurrent-\u003enext; }//此时pCurrent节点就是新节点的前驱节点 struct LinkNode* newNode = malloc(sizeof(struct LinkNode)); newNode-\u003edata = data; newNode-\u003enext = NULL; newNode-\u003enext = pCurrent-\u003enext; pCurrent-\u003enext = newNode; //更新链表长度 myList-\u003em_Size++; return; } void printNode(void* data) { struct Node* node = data; printf(\"姓名：%s 年龄：%d\\n\", node-\u003ename, node-\u003eage); } //遍历 void foreach_LinkList(LinkList list, void(*myPrint)(void*)) { if (list == NULL) { return; } struct LList* myList = list; struct LinkNode* pCurrent = myList-\u003epHeader.next; while (pCurrent != NULL) { myPrint(pCurrent-\u003edata); pCurrent = pCurrent-\u003enext; } } //删除链表节点 void removeBuPos_LinkList(LinkList list, int pos) { if (list == NULL) { return; } struct LList* mylist = list; if (pos\u003c0 || pos\u003emylist-\u003em_Size - 1) { return; } //找到待删除位置的前驱节点位置 struct LinkNode* pCurrent = \u0026mylist-\u003epHeader; for (int i = 0; i \u003c pos; i++) { pCurrent = pCurrent-\u003enext; } //此时pcurrent就是待删除节点的前驱节点位置 struct LinkNode* pDel = pCurrent-\u003enext;//pdel就是要删除的节点 pCurrent-\u003enext = pDel-\u003enext; free(pDel); pDel = NULL; //更新链表长度 mylist-\u003em_Size--; } //回调函数，删除对比 int CompareNode(void* data1, void* data2) { struct Node* n1 = data1; struct Node* n2 = data2; return strcmp(n1-\u003ename, n2-\u003ename) == 0 \u0026\u0026 n1-\u003eage == n2-\u003eage; } //按值删除链表节点 void removeByValue_LinkList(LinkList list, void* data, int (*myCompare)(void*, void*)) { if (list == NULL) { return; } if (data == NULL) { return; } //将list还原成真实的链表结构体 struct LList* mylist = list; //创建两个辅助指针变量 struct LinkNode* pPrey = \u0026mylist-\u003epHeader; struct LinkNode* pCurrent = mylist-\u003epHeader.next; //遍历链表，找用户要删除的数据 for (int i = 0; i \u003c mylist-\u003em_Size; i++) { if (myCompare(data, pCurrent-\u003edata)) { //找到要修改的数据了，更改指针指向 pPrey-\u003enext = pCurrent-\u003enext; free(pCurrent); pCurrent = NULL; mylist-\u003em_Size++; break; } pPrey = pCurrent; pCurrent = pCurrent-\u003enext; } } //清除链表 void clear_LinkList(LinkList list) { if (list == NULL) { return; } struct LList* myList = list; struct LinkNode* pCurrent = myList-\u003epHeader.next; struct LinkNode* pNext = NULL; while (pCurrent != NULL) { pNext = pCurrent-\u003enext; free(pCurrent); pCurrent = pNext; } myList-\u003epHeader.next = NULL; myList-\u003em_Size = 0; } //销毁链表 void destory_LinkList(LinkList list) { if (list == NULL) { return; } clear_LinkList(list); free(list); list = NULL; } void test02() { LinkList myList = init_LinkList(); struct Node p1 = { \"赵云\",18 }; struct Node p2 = { \"关羽\",19 }; struct Node p3 = { \"张飞\",20 }; struct Node p4 = { \"刘备\",21 }; struct Node p5 = { \"黄忠\",22 }; struct Node p6 = { \"曹操\",23 }; insert_LinkList(myList, 0, \u0026p1); insert_LinkList(myList, -1, \u0026p2); insert_LinkList(myList, 0, \u0026p3); insert_LinkList(myList, -1, \u0026p4); insert_LinkList(myList, 0, \u0026p5); insert_LinkList(myList, -1, \u0026p6); foreach_LinkList(myList, ","date":"2024-01-02","objectID":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/:0:3","series":null,"tags":["线性表"],"title":"线性表","uri":"/%E7%BA%BF%E6%80%A7%E8%A1%A8/#32-优点和缺点"},{"categories":["Linux"],"content":" Linux","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:0:0","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#linux"},{"categories":["Linux"],"content":" 1. 前言","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:1:0","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#1-前言"},{"categories":["Linux"],"content":" 1.1 什么是Linux Linux是一套免费使用和自由传播的操作系统。说到操作系统，大家比较熟知的应该就是Windows和MacOS操作系统，我们今天所学习的Linux也是一款操作系统。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:1:1","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#11-什么是linux"},{"categories":["Linux"],"content":" 1.2 为什么要学Linux那么我们为什么要学习Linux呢，主要出于两个方面的原因。 1). 企业用人要求 以下，是从知名招聘网站上搜索的java开发工程师的岗位要求，在很多的岗位要求中都提到了Linux操作系统的经验。 为什么作为javaEE开发工程师，企业还要求我们会Linux操作系统的相关知识呢? 这是因为Linux操作系统提供了很多稳定的发行版本，广泛的应用在我们的各种服务器操作系统领域，我们将来开发出来的项目，最终要上线运行，就需要将项目部署在Linux服务器中。 2). 个人发展需要 我们作为javaEE开发工程师，将来在企业中开发时会涉及到很多的数据库、中间件等技术，比如MySQL、Redis、MQ等技术，而这些应用软件大多都是需要安装在Linux系统中使用的。我们做为开发人员，是需要通过远程工具连接Linux操作系统，然后来操作这些软件的。而且一些小公司，可能还需要我们自己在服务器上安装这些软件。 所以，不管从企业的用人需求层面，还是个人发展需要层面来讲，我们作为服务端开发工程师，Linux的基本使用是我们必不可少的技能。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:1:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#12-为什么要学linux"},{"categories":["Linux"],"content":" 1.3 学完Linux能干什么学习完Linux操作系统课程之后，我们可以做以下几个方面的事情： 1). 环境搭建 系统安装 : 一般我们不会直接将Linux系统安装在本机电脑上，而会安装在公司的一台专门的服务器上。 远程连接 : 那么我们要想使用服务器，一般都是通过远程连接工具连接Linux系统进行操作。 2). 常用命令 连接上服务器之后，我们可以通过所学习的相关指令， 来操作Linux服务器，在Linux服务器中可以执行如下操作： A. 文件、目录的基本操作(查看,删除,创建等) B. 文件及文件夹的拷贝、移动、重命名 C. 文件的打包、压缩、解压缩操作 D. 文本的编辑 3). 安装软件 基本的常用指令学会操作之后，我们可以在Linux服务器中安装我们开发常用的软件，比如： JDK、Tomcat、MySQL的安装及配置。 4). 项目部署 把基础的软件及环境安装配置好之后，我们就可以将我们开发的项目部署在服务器中进行运行并测试。 对于我们学习Linux操作系统时，Linux命令是基础，也是学习Linux系统的重点内容，虽然Linux的指令有很多，但是我们常用的指令并不多，大家在学习的时候，主要掌握这部分常用的指令就可以了，对于其他的指令，以后我们用到的时候，知道怎么查询即可。 对于Linux的常用指令的学习，最好的学习方法就是：多敲 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:1:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#13-学完linux能干什么"},{"categories":["Linux"],"content":" 2. Linux简介","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:2:0","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#2-linux简介"},{"categories":["Linux"],"content":" 2.1 主流操作系统不同领域的主流操作系统，主要分为以下这么几类： 桌面操作系统、服务器操作系统、移动设备操作系统、嵌入式操作系统。接下来，这几个领域中，代表性的操作系统是那些? 1). 桌面操作系统 操作系统 特点 Windows 用户数量最多 MacOS 操作体验好，办公人士首选 Linux 用户数量少(桌面操作系统,Linux使用较少) 2). 服务器操作系统 操作系统 特点 Unix 安全、稳定、付费 Linux 安全、稳定、免费、占有率高 Windows Server 付费、占有率低 3). 移动设备操作系统 操作系统 特点 Android 基于 Linux 、开源，主要用于智能手机、平板电脑和智能电视 IOS 苹果公司开发、不开源，用于苹果公司的产品，例如：iPhone、 iPad 4). 嵌入式操作系统 操作系统 特点 Linux 机顶盒、路由器、交换机 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:2:1","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#21-主流操作系统"},{"categories":["Linux"],"content":" 2.2 Linux发展历史 时间：1991年 地点：芬兰赫尔辛基大学 人物：Linus Torvalds（21岁） 语言：C语言、汇编语言 logo：企鹅 特点：免费、开源(源代码开放)、多用户(同时允许多个用户操作同一个Linux系统)、多任务(同时允许多个任务执行) ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:2:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#22-linux发展历史"},{"categories":["Linux"],"content":" 2.3 Linux系统版本Linux系统的版本分为两种，分别是： 内核版 和 发行版。 1). 内核版 由Linus Torvalds及其团队开发、维护 免费、开源 负责控制硬件 2). 发行版 基于Linux内核版进行扩展 由各个Linux厂商开发、维护 有收费版本和免费版本 我们使用Linux操作系统，实际上选择的是Linux的发行版本。在linux系统中，有各种各样的发行版本，具体如下： 发行版本 Logo 特点 Ubuntu 以桌面应用为主 RedHat 应用最广泛、收费 CentOS RedHat的社区版、免费 openSUSE 对个人完全免费、图形界面华丽 Fedora 功能完备、快速更新、免费 红旗Linux 北京中科红旗软件技术有限公司开发 除了上述罗列出来的发行版，还有很多Linux发行版 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:2:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#23-linux系统版本"},{"categories":["Linux"],"content":" 3. Linux安装","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:0","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#3-linux安装"},{"categories":["Linux"],"content":" 3.1 安装方式介绍Linux系统的安装方式，主要包含以下两种： 方式 概述 场景 物理机安装 直接将操作系统安装到服务器硬件上 企业开发中，我们使用的服务器基本都是采用这种方式 虚拟机安装 通过虚拟机软件安装 我们在学习阶段，没有自己服务器，而我们又需要学Linux，就可以安装在虚拟机上 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能、运行在完全隔离环境中的完整计算机系统。常用虚拟机软件： VMWare VirtualBox VMLite WorkStation Qemu HopeddotVOS ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:1","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#31-安装方式介绍"},{"categories":["Linux"],"content":" 3.2 安装VMware 直接双击运行VMware安装程序，根据提示完成安装即可。 以上就是VMware在安装时的每一步操作，基本上就是点击 “下一步” 一直进行安装。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#32-安装vmware"},{"categories":["Linux"],"content":" 3.3 安装LinuxVMware虚拟机安装完毕之后，我们就可以打开VMware，并在上面来安装Linux操作系统。具体步骤如下： 1). 选择创建新的虚拟机 2). 选择\"典型\"配置 3). 选择\"稍后安装操作系统(S)\" 4). 选择\"Linux\"操作系统,“CentOS7 64位\"版本 5). 设置虚拟机的名称及系统文件存放路径 6). 设置磁盘容量 7). 自定义硬件信息 8). 启动上述创建的新虚拟机 9). 选择\"Install CentOS7” 进入到Linux系统里面, 我们发现光标无法移动到windows操作系统中了, 这个时候, 我们可以通过快捷键 “Ctrl+Alt” 切换光标到windows系统中。 10). 选择语言为 “简体中文” 11). 选择\"自动配置分区\" 12). 选择\"最小安装\" 13). 设置\"root\"用户密码 安装完毕后，点击窗口中的蓝色的 “重启” 按钮，重启Linux系统。 14). 登录系统 注意 : 在Linux系统中，在命令行中输入密码信息，为了保证安全性，密码是不显示的(看似没有输入，实际已经输入了)； ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#33-安装linux"},{"categories":["Linux"],"content":" 3.4 网卡设置服务器重启完成之后，我们可以通过linux的指令 ip addr 来查询Linux系统的IP地址，具体信息如下: 从图中我们可以看到，并没有获取到linux系统的IP地址，这是为什么呢？这是由于启动服务器时未加载网卡，导致IP地址初始化失败而造成的。那么接下来我们就需要来修改网络初始化配置，设定网卡在系统启动时初始化。 具体操作步骤如下： 1). 修改网卡的配置项 cd / 进入根目录 cd etc 进入etc目录 cd sysconfig 进入sysconfig目录 cd network-scripts 进入network-scripts vi ifcfg-ens33 编辑ifcfg-ens33文件 进入文件后执行如下操作: ①. 按 i 键 进入编辑状态 ②. 按↑↓键来移动光标, 删除no,输入yes ③. 按 ESC 键 ④. 输入 :wq ⑤. 按 ENTER 保存退出 备注: 在上述的操作中用到了Linux中的相关指令, 目前大家不用深究, 后面会详细讲解, 目前大家只需要把这个文件的配置项ONBOOT的值有no改为yes即可。 2). 重新启动虚拟机 重启之后, 再次输入root的用户名密码，登录到Linux系统之后，可以通过指令 ip addr 来查看IP地址。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:4","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#34-网卡设置"},{"categories":["Linux"],"content":" 3.5 安装SSH连接工具 3.5.1 SSH连接工具介绍Linux已经安装并且配置好了，接下来我们要来学习Linux的基本操作指令。而在学习之前，我们还需要做一件事情，由于我们企业开发时，Linux服务器一般都是在远程的机房部署的，我们要操作服务器，不会每次都跑到远程的机房里面操作，而是会直接通过SSH连接工具进行连接操作。 SSH（Secure Shell），建立在应用层基础上的安全协议。常用的SSH连接工具: SSH工具 Logo 说明 putty 免费, 界面简单, 功能单一 secureCRT 收费, 功能强大 xshell 收费版/免费版 finalshell 免费, 功能强大, 界面效果好 (课程中采用) 3.5.2 FinalShell安装 双击.exe文件，然后进行正常的安装即可。 3.5.3 连接Linux1). 打开finalShell 2). 建立连接 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:5","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#35-安装ssh连接工具"},{"categories":["Linux"],"content":" 3.5 安装SSH连接工具 3.5.1 SSH连接工具介绍Linux已经安装并且配置好了，接下来我们要来学习Linux的基本操作指令。而在学习之前，我们还需要做一件事情，由于我们企业开发时，Linux服务器一般都是在远程的机房部署的，我们要操作服务器，不会每次都跑到远程的机房里面操作，而是会直接通过SSH连接工具进行连接操作。 SSH（Secure Shell），建立在应用层基础上的安全协议。常用的SSH连接工具: SSH工具 Logo 说明 putty 免费, 界面简单, 功能单一 secureCRT 收费, 功能强大 xshell 收费版/免费版 finalshell 免费, 功能强大, 界面效果好 (课程中采用) 3.5.2 FinalShell安装 双击.exe文件，然后进行正常的安装即可。 3.5.3 连接Linux1). 打开finalShell 2). 建立连接 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:5","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#351-ssh连接工具介绍"},{"categories":["Linux"],"content":" 3.5 安装SSH连接工具 3.5.1 SSH连接工具介绍Linux已经安装并且配置好了，接下来我们要来学习Linux的基本操作指令。而在学习之前，我们还需要做一件事情，由于我们企业开发时，Linux服务器一般都是在远程的机房部署的，我们要操作服务器，不会每次都跑到远程的机房里面操作，而是会直接通过SSH连接工具进行连接操作。 SSH（Secure Shell），建立在应用层基础上的安全协议。常用的SSH连接工具: SSH工具 Logo 说明 putty 免费, 界面简单, 功能单一 secureCRT 收费, 功能强大 xshell 收费版/免费版 finalshell 免费, 功能强大, 界面效果好 (课程中采用) 3.5.2 FinalShell安装 双击.exe文件，然后进行正常的安装即可。 3.5.3 连接Linux1). 打开finalShell 2). 建立连接 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:5","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#352-finalshell安装"},{"categories":["Linux"],"content":" 3.5 安装SSH连接工具 3.5.1 SSH连接工具介绍Linux已经安装并且配置好了，接下来我们要来学习Linux的基本操作指令。而在学习之前，我们还需要做一件事情，由于我们企业开发时，Linux服务器一般都是在远程的机房部署的，我们要操作服务器，不会每次都跑到远程的机房里面操作，而是会直接通过SSH连接工具进行连接操作。 SSH（Secure Shell），建立在应用层基础上的安全协议。常用的SSH连接工具: SSH工具 Logo 说明 putty 免费, 界面简单, 功能单一 secureCRT 收费, 功能强大 xshell 收费版/免费版 finalshell 免费, 功能强大, 界面效果好 (课程中采用) 3.5.2 FinalShell安装 双击.exe文件，然后进行正常的安装即可。 3.5.3 连接Linux1). 打开finalShell 2). 建立连接 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:5","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#353-连接linux"},{"categories":["Linux"],"content":" 3.6 Linux目录结构登录到Linux系统之后，我们需要先来熟悉一下Linux的目录结构。在Linux系统中，也是存在目录的概念的，但是Linux的目录结构和Windows的目录结构是存在比较多的差异的 在Windows目录下，是一个一个的盘符(C盘、D盘、E盘)，目录是归属于某一个盘符的。Linux系统中的目录有以下特点： A. / 是所有目录的顶点 B. 目录结构像一颗倒挂的树 Linux 和 Windows的目录结构对比: Linux的目录结构，如下： 根目录/ 下各个目录的作用及含义说明: 编号 目录 含义 1 /bin 存放二进制可执行文件 2 /boot 存放系统引导时使用的各种文件 3 /dev 存放设备文件 4 /etc 存放系统配置文件 5 /home 存放系统用户的文件 6 /lib 存放程序运行所需的共享库和内核模块 7 /opt 额外安装的可选应用程序包所放置的位置 8 /root 超级用户目录 9 /sbin 存放二进制可执行文件，只有root用户才能访问 10 /tmp 存放临时文件 11 /usr 存放系统应用程序 12 /var 存放运行时需要改变数据的文件，例如日志文件 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:6","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#36-linux目录结构"},{"categories":["Linux"],"content":" 4. Linux常用命令","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:0","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#4-linux常用命令"},{"categories":["Linux"],"content":" 4.1 Linux命令初体验 4.1.1 常用命令演示在这一部分中，我们主要介绍几个常用的命令，让大家快速感受以下Linux指令的操作方式。主要包含以下几个指令： 序号 命令 对应英文 作用 1 ls [目录名] list 查看当前目录下的内容 2 pwd print work directory 查看当前所在目录 3 cd [目录名] change directory 切换目录 4 touch [文件名] touch 如果文件不存在,创建文件 5 mkdir [目录名] make directory 创建目录 6 rm [文件名] remove 删除指定文件 接下来，我们快速的来演示一下这些常用的指令。 1). ls 指令解读: ​ ls 查看当前目录下的内容(文件及目录) ​ ls / 查看指定目录(/)下的内容 2). pwd 指令解读: ​ pwd 查看当前所在目录 3). cd 指令解读: ​ cd / 切换到根目录 ​ cd /root 切换到/root目录 4). touch 指令解读: ​ touch 1.txt 创建文件1.txt ​ touch 2.txt 3.txt 4.txt 一次性创建文件2.txt,3.txt,3.txt 5). mkdir 指令解读: ​ mkdir 01 创建文件夹01 6). rm 指令解读: ​ rm 4.txt 删除文件 (删除文件时,需要确认,输入y, 代表确定) ==注意:== ​ ​ ==在执行Linux命令时，提示信息如果显示为乱码，如上图所示。这是由于编码问题导致，只需要修改Linux的编码即可，命令如下：== ​ echo ‘LANG=“en_US.UTF-8”’ » /etc/profile ​ source /etc/profile 4.1.2 Linux命令使用技巧在我们使用Linux系统命令时，可以使用以下几个技巧： 1). Tab键自动补全 2). 连续两次Tab键，给出操作提示 3). 使用上下箭头快速调出曾经使用过的命令 4). 使用clear命令或者Ctrl+l快捷键实现清屏 操作示例: A. 执行指令的时候，对于操作的文件/目录，按一下Tab会自动补全: B. 如果上述以 “1.” 开头的文件有多个，可以按两下Tab键，给出操作提示: C. 使用clear命令或者Ctrl+l快捷键实现清屏: 清屏之后，界面就变得干净了: 4.1.3 Linux命令格式 command [-options] [parameter] 说明: command: 命令名 [-options]: 选项，可用来对命令进行控制，也可以省略 [parameter]: 传给命令的参数，可以是零个、一个或者多个 注意: [] 代表可选 命令名、选项、参数之间有空格进行分隔 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:1","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#41-linux命令初体验"},{"categories":["Linux"],"content":" 4.1 Linux命令初体验 4.1.1 常用命令演示在这一部分中，我们主要介绍几个常用的命令，让大家快速感受以下Linux指令的操作方式。主要包含以下几个指令： 序号 命令 对应英文 作用 1 ls [目录名] list 查看当前目录下的内容 2 pwd print work directory 查看当前所在目录 3 cd [目录名] change directory 切换目录 4 touch [文件名] touch 如果文件不存在,创建文件 5 mkdir [目录名] make directory 创建目录 6 rm [文件名] remove 删除指定文件 接下来，我们快速的来演示一下这些常用的指令。 1). ls 指令解读: ​ ls 查看当前目录下的内容(文件及目录) ​ ls / 查看指定目录(/)下的内容 2). pwd 指令解读: ​ pwd 查看当前所在目录 3). cd 指令解读: ​ cd / 切换到根目录 ​ cd /root 切换到/root目录 4). touch 指令解读: ​ touch 1.txt 创建文件1.txt ​ touch 2.txt 3.txt 4.txt 一次性创建文件2.txt,3.txt,3.txt 5). mkdir 指令解读: ​ mkdir 01 创建文件夹01 6). rm 指令解读: ​ rm 4.txt 删除文件 (删除文件时,需要确认,输入y, 代表确定) ==注意:== ​ ​ ==在执行Linux命令时，提示信息如果显示为乱码，如上图所示。这是由于编码问题导致，只需要修改Linux的编码即可，命令如下：== ​ echo ‘LANG=“en_US.UTF-8”’ » /etc/profile ​ source /etc/profile 4.1.2 Linux命令使用技巧在我们使用Linux系统命令时，可以使用以下几个技巧： 1). Tab键自动补全 2). 连续两次Tab键，给出操作提示 3). 使用上下箭头快速调出曾经使用过的命令 4). 使用clear命令或者Ctrl+l快捷键实现清屏 操作示例: A. 执行指令的时候，对于操作的文件/目录，按一下Tab会自动补全: B. 如果上述以 “1.” 开头的文件有多个，可以按两下Tab键，给出操作提示: C. 使用clear命令或者Ctrl+l快捷键实现清屏: 清屏之后，界面就变得干净了: 4.1.3 Linux命令格式 command [-options] [parameter] 说明: command: 命令名 [-options]: 选项，可用来对命令进行控制，也可以省略 [parameter]: 传给命令的参数，可以是零个、一个或者多个 注意: [] 代表可选 命令名、选项、参数之间有空格进行分隔 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:1","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#411-常用命令演示"},{"categories":["Linux"],"content":" 4.1 Linux命令初体验 4.1.1 常用命令演示在这一部分中，我们主要介绍几个常用的命令，让大家快速感受以下Linux指令的操作方式。主要包含以下几个指令： 序号 命令 对应英文 作用 1 ls [目录名] list 查看当前目录下的内容 2 pwd print work directory 查看当前所在目录 3 cd [目录名] change directory 切换目录 4 touch [文件名] touch 如果文件不存在,创建文件 5 mkdir [目录名] make directory 创建目录 6 rm [文件名] remove 删除指定文件 接下来，我们快速的来演示一下这些常用的指令。 1). ls 指令解读: ​ ls 查看当前目录下的内容(文件及目录) ​ ls / 查看指定目录(/)下的内容 2). pwd 指令解读: ​ pwd 查看当前所在目录 3). cd 指令解读: ​ cd / 切换到根目录 ​ cd /root 切换到/root目录 4). touch 指令解读: ​ touch 1.txt 创建文件1.txt ​ touch 2.txt 3.txt 4.txt 一次性创建文件2.txt,3.txt,3.txt 5). mkdir 指令解读: ​ mkdir 01 创建文件夹01 6). rm 指令解读: ​ rm 4.txt 删除文件 (删除文件时,需要确认,输入y, 代表确定) ==注意:== ​ ​ ==在执行Linux命令时，提示信息如果显示为乱码，如上图所示。这是由于编码问题导致，只需要修改Linux的编码即可，命令如下：== ​ echo ‘LANG=“en_US.UTF-8”’ » /etc/profile ​ source /etc/profile 4.1.2 Linux命令使用技巧在我们使用Linux系统命令时，可以使用以下几个技巧： 1). Tab键自动补全 2). 连续两次Tab键，给出操作提示 3). 使用上下箭头快速调出曾经使用过的命令 4). 使用clear命令或者Ctrl+l快捷键实现清屏 操作示例: A. 执行指令的时候，对于操作的文件/目录，按一下Tab会自动补全: B. 如果上述以 “1.” 开头的文件有多个，可以按两下Tab键，给出操作提示: C. 使用clear命令或者Ctrl+l快捷键实现清屏: 清屏之后，界面就变得干净了: 4.1.3 Linux命令格式 command [-options] [parameter] 说明: command: 命令名 [-options]: 选项，可用来对命令进行控制，也可以省略 [parameter]: 传给命令的参数，可以是零个、一个或者多个 注意: [] 代表可选 命令名、选项、参数之间有空格进行分隔 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:1","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#412-linux命令使用技巧"},{"categories":["Linux"],"content":" 4.1 Linux命令初体验 4.1.1 常用命令演示在这一部分中，我们主要介绍几个常用的命令，让大家快速感受以下Linux指令的操作方式。主要包含以下几个指令： 序号 命令 对应英文 作用 1 ls [目录名] list 查看当前目录下的内容 2 pwd print work directory 查看当前所在目录 3 cd [目录名] change directory 切换目录 4 touch [文件名] touch 如果文件不存在,创建文件 5 mkdir [目录名] make directory 创建目录 6 rm [文件名] remove 删除指定文件 接下来，我们快速的来演示一下这些常用的指令。 1). ls 指令解读: ​ ls 查看当前目录下的内容(文件及目录) ​ ls / 查看指定目录(/)下的内容 2). pwd 指令解读: ​ pwd 查看当前所在目录 3). cd 指令解读: ​ cd / 切换到根目录 ​ cd /root 切换到/root目录 4). touch 指令解读: ​ touch 1.txt 创建文件1.txt ​ touch 2.txt 3.txt 4.txt 一次性创建文件2.txt,3.txt,3.txt 5). mkdir 指令解读: ​ mkdir 01 创建文件夹01 6). rm 指令解读: ​ rm 4.txt 删除文件 (删除文件时,需要确认,输入y, 代表确定) ==注意:== ​ ​ ==在执行Linux命令时，提示信息如果显示为乱码，如上图所示。这是由于编码问题导致，只需要修改Linux的编码即可，命令如下：== ​ echo ‘LANG=“en_US.UTF-8”’ » /etc/profile ​ source /etc/profile 4.1.2 Linux命令使用技巧在我们使用Linux系统命令时，可以使用以下几个技巧： 1). Tab键自动补全 2). 连续两次Tab键，给出操作提示 3). 使用上下箭头快速调出曾经使用过的命令 4). 使用clear命令或者Ctrl+l快捷键实现清屏 操作示例: A. 执行指令的时候，对于操作的文件/目录，按一下Tab会自动补全: B. 如果上述以 “1.” 开头的文件有多个，可以按两下Tab键，给出操作提示: C. 使用clear命令或者Ctrl+l快捷键实现清屏: 清屏之后，界面就变得干净了: 4.1.3 Linux命令格式 command [-options] [parameter] 说明: command: 命令名 [-options]: 选项，可用来对命令进行控制，也可以省略 [parameter]: 传给命令的参数，可以是零个、一个或者多个 注意: [] 代表可选 命令名、选项、参数之间有空格进行分隔 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:1","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#413-linux命令格式"},{"categories":["Linux"],"content":" 4.2 文件目录操作命令 4.2.1 ls 作用: 显示指定目录下的内容 语法: ls [-al] [dir] 说明: -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出 注意: 由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll 常见用法: ls -al 查看当前目录的所有文件及目录详细信息 ls -al /etc 查看/etc目录下所有文件及目录详细信息 ll 查看当前目录文件及目录的详细信息 操作示例: 4.2.2 cd 作用: 用于切换当前工作目录，即进入指定目录 语法: cd [dirName] 特殊说明: ~ 表示用户的home目录 . 表示目前所在的目录 .. 表示目前目录位置的上级目录 举例: cd .. 切换到当前目录的上级目录 cd ~ 切换到用户的home目录 cd /usr/local 切换到/usr/local目录 备注: ​ 用户的home目录 ​ root用户 /root ​ 其他用户 /home/xxx 操作示例: cd .. 切换到当前目录位置的上级目录; 可以通过 cd ../.. 来切换到上级目录的上级目录。 4.2.3 cat 作用: 用于显示文件内容 语法: cat [-n] fileName 说明: -n: 由1开始对所有输出的行数编号 举例: cat /etc/profile 查看/etc目录下的profile文件内容 操作演示: cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。 4.2.4 more 作用: 以分页的形式显示文件内容 语法: more fileName 操作说明: 回车键 向下滚动一行 空格键 向下滚动一屏 b 返回上一屏 q或者Ctrl+C 退出more 举例： more /etc/profile 以分页方式显示/etc目录下的profile文件内容 操作示例： 当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。 4.2.5 tail 作用: 查看文件末尾的内容 语法: tail [-f] fileName 说明: -f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出 举例: tail /etc/profile 显示/etc目录下的profile文件末尾10行的内容 tail -20 /etc/profile 显示/etc目录下的profile文件末尾20行的内容 tail -f /itcast/my.log 动态读取/itcast目录下的my.log文件末尾内容并显示 操作示例： A. 默认查询文件尾部10行记录 B. 可以通过指定参数设置查询尾部指定行数的数据 C. 动态读取文件尾部的数据 在窗口1中执行指令 tail -f 1.txt 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 echo 1 \u003e\u003e 1.txt , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。 如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。 4.2.6 mkdir 作用: 创建目录 语法: mkdir [-p] dirName 说明: -p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建 举例: mkdir itcast 在当前目录下，建立一个名为itcast的子目录 mkdir -p itcast/test 在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个 操作演示: 4.2.7 rmdir 作用: 删除空目录 语法: rmdir [-p] dirName 说明: -p: 当子目录被删除后使父目录为空目录的话，则一并删除 举例: rmdir itcast 删除名为itcast的空目录 rmdir -p itcast/test 删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除 rmdir itcast* 删除名称以itcast开始的空目录 操作演示: A. 删除空目录 B. 删除非空目录 C. 使用*通配符删除目录 *: 是一个通配符，代表任意字符； rmdir itcast* : 删除以itcast开头的目录 rmdir *itcast : 删除以itcast结尾的目录 4.2.8 rm 作用: 删除文件或者目录 语法: rm [-rf] name 说明: -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除 -f: 无需确认，直接删除 举例: rm -r itcast/ 删除名为itcast的目录和目录中所有文件，删除前需确认 rm -rf itcast/ 无需确认，直接删除名为itcast的目录和目录中所有文件 rm -f hello.txt 无需确认，直接删除hello.txt文件 操作示例: ==注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。== ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#42-文件目录操作命令"},{"categories":["Linux"],"content":" 4.2 文件目录操作命令 4.2.1 ls 作用: 显示指定目录下的内容 语法: ls [-al] [dir] 说明: -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出 注意: 由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll 常见用法: ls -al 查看当前目录的所有文件及目录详细信息 ls -al /etc 查看/etc目录下所有文件及目录详细信息 ll 查看当前目录文件及目录的详细信息 操作示例: 4.2.2 cd 作用: 用于切换当前工作目录，即进入指定目录 语法: cd [dirName] 特殊说明: ~ 表示用户的home目录 . 表示目前所在的目录 .. 表示目前目录位置的上级目录 举例: cd .. 切换到当前目录的上级目录 cd ~ 切换到用户的home目录 cd /usr/local 切换到/usr/local目录 备注: ​ 用户的home目录 ​ root用户 /root ​ 其他用户 /home/xxx 操作示例: cd .. 切换到当前目录位置的上级目录; 可以通过 cd ../.. 来切换到上级目录的上级目录。 4.2.3 cat 作用: 用于显示文件内容 语法: cat [-n] fileName 说明: -n: 由1开始对所有输出的行数编号 举例: cat /etc/profile 查看/etc目录下的profile文件内容 操作演示: cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。 4.2.4 more 作用: 以分页的形式显示文件内容 语法: more fileName 操作说明: 回车键 向下滚动一行 空格键 向下滚动一屏 b 返回上一屏 q或者Ctrl+C 退出more 举例： more /etc/profile 以分页方式显示/etc目录下的profile文件内容 操作示例： 当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。 4.2.5 tail 作用: 查看文件末尾的内容 语法: tail [-f] fileName 说明: -f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出 举例: tail /etc/profile 显示/etc目录下的profile文件末尾10行的内容 tail -20 /etc/profile 显示/etc目录下的profile文件末尾20行的内容 tail -f /itcast/my.log 动态读取/itcast目录下的my.log文件末尾内容并显示 操作示例： A. 默认查询文件尾部10行记录 B. 可以通过指定参数设置查询尾部指定行数的数据 C. 动态读取文件尾部的数据 在窗口1中执行指令 tail -f 1.txt 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 echo 1 \u003e\u003e 1.txt , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。 如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。 4.2.6 mkdir 作用: 创建目录 语法: mkdir [-p] dirName 说明: -p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建 举例: mkdir itcast 在当前目录下，建立一个名为itcast的子目录 mkdir -p itcast/test 在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个 操作演示: 4.2.7 rmdir 作用: 删除空目录 语法: rmdir [-p] dirName 说明: -p: 当子目录被删除后使父目录为空目录的话，则一并删除 举例: rmdir itcast 删除名为itcast的空目录 rmdir -p itcast/test 删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除 rmdir itcast* 删除名称以itcast开始的空目录 操作演示: A. 删除空目录 B. 删除非空目录 C. 使用*通配符删除目录 *: 是一个通配符，代表任意字符； rmdir itcast* : 删除以itcast开头的目录 rmdir *itcast : 删除以itcast结尾的目录 4.2.8 rm 作用: 删除文件或者目录 语法: rm [-rf] name 说明: -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除 -f: 无需确认，直接删除 举例: rm -r itcast/ 删除名为itcast的目录和目录中所有文件，删除前需确认 rm -rf itcast/ 无需确认，直接删除名为itcast的目录和目录中所有文件 rm -f hello.txt 无需确认，直接删除hello.txt文件 操作示例: ==注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。== ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#421-ls"},{"categories":["Linux"],"content":" 4.2 文件目录操作命令 4.2.1 ls 作用: 显示指定目录下的内容 语法: ls [-al] [dir] 说明: -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出 注意: 由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll 常见用法: ls -al 查看当前目录的所有文件及目录详细信息 ls -al /etc 查看/etc目录下所有文件及目录详细信息 ll 查看当前目录文件及目录的详细信息 操作示例: 4.2.2 cd 作用: 用于切换当前工作目录，即进入指定目录 语法: cd [dirName] 特殊说明: ~ 表示用户的home目录 . 表示目前所在的目录 .. 表示目前目录位置的上级目录 举例: cd .. 切换到当前目录的上级目录 cd ~ 切换到用户的home目录 cd /usr/local 切换到/usr/local目录 备注: ​ 用户的home目录 ​ root用户 /root ​ 其他用户 /home/xxx 操作示例: cd .. 切换到当前目录位置的上级目录; 可以通过 cd ../.. 来切换到上级目录的上级目录。 4.2.3 cat 作用: 用于显示文件内容 语法: cat [-n] fileName 说明: -n: 由1开始对所有输出的行数编号 举例: cat /etc/profile 查看/etc目录下的profile文件内容 操作演示: cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。 4.2.4 more 作用: 以分页的形式显示文件内容 语法: more fileName 操作说明: 回车键 向下滚动一行 空格键 向下滚动一屏 b 返回上一屏 q或者Ctrl+C 退出more 举例： more /etc/profile 以分页方式显示/etc目录下的profile文件内容 操作示例： 当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。 4.2.5 tail 作用: 查看文件末尾的内容 语法: tail [-f] fileName 说明: -f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出 举例: tail /etc/profile 显示/etc目录下的profile文件末尾10行的内容 tail -20 /etc/profile 显示/etc目录下的profile文件末尾20行的内容 tail -f /itcast/my.log 动态读取/itcast目录下的my.log文件末尾内容并显示 操作示例： A. 默认查询文件尾部10行记录 B. 可以通过指定参数设置查询尾部指定行数的数据 C. 动态读取文件尾部的数据 在窗口1中执行指令 tail -f 1.txt 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 echo 1 \u003e\u003e 1.txt , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。 如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。 4.2.6 mkdir 作用: 创建目录 语法: mkdir [-p] dirName 说明: -p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建 举例: mkdir itcast 在当前目录下，建立一个名为itcast的子目录 mkdir -p itcast/test 在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个 操作演示: 4.2.7 rmdir 作用: 删除空目录 语法: rmdir [-p] dirName 说明: -p: 当子目录被删除后使父目录为空目录的话，则一并删除 举例: rmdir itcast 删除名为itcast的空目录 rmdir -p itcast/test 删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除 rmdir itcast* 删除名称以itcast开始的空目录 操作演示: A. 删除空目录 B. 删除非空目录 C. 使用*通配符删除目录 *: 是一个通配符，代表任意字符； rmdir itcast* : 删除以itcast开头的目录 rmdir *itcast : 删除以itcast结尾的目录 4.2.8 rm 作用: 删除文件或者目录 语法: rm [-rf] name 说明: -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除 -f: 无需确认，直接删除 举例: rm -r itcast/ 删除名为itcast的目录和目录中所有文件，删除前需确认 rm -rf itcast/ 无需确认，直接删除名为itcast的目录和目录中所有文件 rm -f hello.txt 无需确认，直接删除hello.txt文件 操作示例: ==注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。== ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#422-cd"},{"categories":["Linux"],"content":" 4.2 文件目录操作命令 4.2.1 ls 作用: 显示指定目录下的内容 语法: ls [-al] [dir] 说明: -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出 注意: 由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll 常见用法: ls -al 查看当前目录的所有文件及目录详细信息 ls -al /etc 查看/etc目录下所有文件及目录详细信息 ll 查看当前目录文件及目录的详细信息 操作示例: 4.2.2 cd 作用: 用于切换当前工作目录，即进入指定目录 语法: cd [dirName] 特殊说明: ~ 表示用户的home目录 . 表示目前所在的目录 .. 表示目前目录位置的上级目录 举例: cd .. 切换到当前目录的上级目录 cd ~ 切换到用户的home目录 cd /usr/local 切换到/usr/local目录 备注: ​ 用户的home目录 ​ root用户 /root ​ 其他用户 /home/xxx 操作示例: cd .. 切换到当前目录位置的上级目录; 可以通过 cd ../.. 来切换到上级目录的上级目录。 4.2.3 cat 作用: 用于显示文件内容 语法: cat [-n] fileName 说明: -n: 由1开始对所有输出的行数编号 举例: cat /etc/profile 查看/etc目录下的profile文件内容 操作演示: cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。 4.2.4 more 作用: 以分页的形式显示文件内容 语法: more fileName 操作说明: 回车键 向下滚动一行 空格键 向下滚动一屏 b 返回上一屏 q或者Ctrl+C 退出more 举例： more /etc/profile 以分页方式显示/etc目录下的profile文件内容 操作示例： 当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。 4.2.5 tail 作用: 查看文件末尾的内容 语法: tail [-f] fileName 说明: -f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出 举例: tail /etc/profile 显示/etc目录下的profile文件末尾10行的内容 tail -20 /etc/profile 显示/etc目录下的profile文件末尾20行的内容 tail -f /itcast/my.log 动态读取/itcast目录下的my.log文件末尾内容并显示 操作示例： A. 默认查询文件尾部10行记录 B. 可以通过指定参数设置查询尾部指定行数的数据 C. 动态读取文件尾部的数据 在窗口1中执行指令 tail -f 1.txt 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 echo 1 \u003e\u003e 1.txt , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。 如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。 4.2.6 mkdir 作用: 创建目录 语法: mkdir [-p] dirName 说明: -p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建 举例: mkdir itcast 在当前目录下，建立一个名为itcast的子目录 mkdir -p itcast/test 在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个 操作演示: 4.2.7 rmdir 作用: 删除空目录 语法: rmdir [-p] dirName 说明: -p: 当子目录被删除后使父目录为空目录的话，则一并删除 举例: rmdir itcast 删除名为itcast的空目录 rmdir -p itcast/test 删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除 rmdir itcast* 删除名称以itcast开始的空目录 操作演示: A. 删除空目录 B. 删除非空目录 C. 使用*通配符删除目录 *: 是一个通配符，代表任意字符； rmdir itcast* : 删除以itcast开头的目录 rmdir *itcast : 删除以itcast结尾的目录 4.2.8 rm 作用: 删除文件或者目录 语法: rm [-rf] name 说明: -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除 -f: 无需确认，直接删除 举例: rm -r itcast/ 删除名为itcast的目录和目录中所有文件，删除前需确认 rm -rf itcast/ 无需确认，直接删除名为itcast的目录和目录中所有文件 rm -f hello.txt 无需确认，直接删除hello.txt文件 操作示例: ==注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。== ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#423-cat"},{"categories":["Linux"],"content":" 4.2 文件目录操作命令 4.2.1 ls 作用: 显示指定目录下的内容 语法: ls [-al] [dir] 说明: -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出 注意: 由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll 常见用法: ls -al 查看当前目录的所有文件及目录详细信息 ls -al /etc 查看/etc目录下所有文件及目录详细信息 ll 查看当前目录文件及目录的详细信息 操作示例: 4.2.2 cd 作用: 用于切换当前工作目录，即进入指定目录 语法: cd [dirName] 特殊说明: ~ 表示用户的home目录 . 表示目前所在的目录 .. 表示目前目录位置的上级目录 举例: cd .. 切换到当前目录的上级目录 cd ~ 切换到用户的home目录 cd /usr/local 切换到/usr/local目录 备注: ​ 用户的home目录 ​ root用户 /root ​ 其他用户 /home/xxx 操作示例: cd .. 切换到当前目录位置的上级目录; 可以通过 cd ../.. 来切换到上级目录的上级目录。 4.2.3 cat 作用: 用于显示文件内容 语法: cat [-n] fileName 说明: -n: 由1开始对所有输出的行数编号 举例: cat /etc/profile 查看/etc目录下的profile文件内容 操作演示: cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。 4.2.4 more 作用: 以分页的形式显示文件内容 语法: more fileName 操作说明: 回车键 向下滚动一行 空格键 向下滚动一屏 b 返回上一屏 q或者Ctrl+C 退出more 举例： more /etc/profile 以分页方式显示/etc目录下的profile文件内容 操作示例： 当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。 4.2.5 tail 作用: 查看文件末尾的内容 语法: tail [-f] fileName 说明: -f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出 举例: tail /etc/profile 显示/etc目录下的profile文件末尾10行的内容 tail -20 /etc/profile 显示/etc目录下的profile文件末尾20行的内容 tail -f /itcast/my.log 动态读取/itcast目录下的my.log文件末尾内容并显示 操作示例： A. 默认查询文件尾部10行记录 B. 可以通过指定参数设置查询尾部指定行数的数据 C. 动态读取文件尾部的数据 在窗口1中执行指令 tail -f 1.txt 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 echo 1 \u003e\u003e 1.txt , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。 如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。 4.2.6 mkdir 作用: 创建目录 语法: mkdir [-p] dirName 说明: -p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建 举例: mkdir itcast 在当前目录下，建立一个名为itcast的子目录 mkdir -p itcast/test 在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个 操作演示: 4.2.7 rmdir 作用: 删除空目录 语法: rmdir [-p] dirName 说明: -p: 当子目录被删除后使父目录为空目录的话，则一并删除 举例: rmdir itcast 删除名为itcast的空目录 rmdir -p itcast/test 删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除 rmdir itcast* 删除名称以itcast开始的空目录 操作演示: A. 删除空目录 B. 删除非空目录 C. 使用*通配符删除目录 *: 是一个通配符，代表任意字符； rmdir itcast* : 删除以itcast开头的目录 rmdir *itcast : 删除以itcast结尾的目录 4.2.8 rm 作用: 删除文件或者目录 语法: rm [-rf] name 说明: -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除 -f: 无需确认，直接删除 举例: rm -r itcast/ 删除名为itcast的目录和目录中所有文件，删除前需确认 rm -rf itcast/ 无需确认，直接删除名为itcast的目录和目录中所有文件 rm -f hello.txt 无需确认，直接删除hello.txt文件 操作示例: ==注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。== ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#424-more"},{"categories":["Linux"],"content":" 4.2 文件目录操作命令 4.2.1 ls 作用: 显示指定目录下的内容 语法: ls [-al] [dir] 说明: -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出 注意: 由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll 常见用法: ls -al 查看当前目录的所有文件及目录详细信息 ls -al /etc 查看/etc目录下所有文件及目录详细信息 ll 查看当前目录文件及目录的详细信息 操作示例: 4.2.2 cd 作用: 用于切换当前工作目录，即进入指定目录 语法: cd [dirName] 特殊说明: ~ 表示用户的home目录 . 表示目前所在的目录 .. 表示目前目录位置的上级目录 举例: cd .. 切换到当前目录的上级目录 cd ~ 切换到用户的home目录 cd /usr/local 切换到/usr/local目录 备注: ​ 用户的home目录 ​ root用户 /root ​ 其他用户 /home/xxx 操作示例: cd .. 切换到当前目录位置的上级目录; 可以通过 cd ../.. 来切换到上级目录的上级目录。 4.2.3 cat 作用: 用于显示文件内容 语法: cat [-n] fileName 说明: -n: 由1开始对所有输出的行数编号 举例: cat /etc/profile 查看/etc目录下的profile文件内容 操作演示: cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。 4.2.4 more 作用: 以分页的形式显示文件内容 语法: more fileName 操作说明: 回车键 向下滚动一行 空格键 向下滚动一屏 b 返回上一屏 q或者Ctrl+C 退出more 举例： more /etc/profile 以分页方式显示/etc目录下的profile文件内容 操作示例： 当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。 4.2.5 tail 作用: 查看文件末尾的内容 语法: tail [-f] fileName 说明: -f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出 举例: tail /etc/profile 显示/etc目录下的profile文件末尾10行的内容 tail -20 /etc/profile 显示/etc目录下的profile文件末尾20行的内容 tail -f /itcast/my.log 动态读取/itcast目录下的my.log文件末尾内容并显示 操作示例： A. 默认查询文件尾部10行记录 B. 可以通过指定参数设置查询尾部指定行数的数据 C. 动态读取文件尾部的数据 在窗口1中执行指令 tail -f 1.txt 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 echo 1 \u003e\u003e 1.txt , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。 如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。 4.2.6 mkdir 作用: 创建目录 语法: mkdir [-p] dirName 说明: -p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建 举例: mkdir itcast 在当前目录下，建立一个名为itcast的子目录 mkdir -p itcast/test 在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个 操作演示: 4.2.7 rmdir 作用: 删除空目录 语法: rmdir [-p] dirName 说明: -p: 当子目录被删除后使父目录为空目录的话，则一并删除 举例: rmdir itcast 删除名为itcast的空目录 rmdir -p itcast/test 删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除 rmdir itcast* 删除名称以itcast开始的空目录 操作演示: A. 删除空目录 B. 删除非空目录 C. 使用*通配符删除目录 *: 是一个通配符，代表任意字符； rmdir itcast* : 删除以itcast开头的目录 rmdir *itcast : 删除以itcast结尾的目录 4.2.8 rm 作用: 删除文件或者目录 语法: rm [-rf] name 说明: -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除 -f: 无需确认，直接删除 举例: rm -r itcast/ 删除名为itcast的目录和目录中所有文件，删除前需确认 rm -rf itcast/ 无需确认，直接删除名为itcast的目录和目录中所有文件 rm -f hello.txt 无需确认，直接删除hello.txt文件 操作示例: ==注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。== ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#425-tail"},{"categories":["Linux"],"content":" 4.2 文件目录操作命令 4.2.1 ls 作用: 显示指定目录下的内容 语法: ls [-al] [dir] 说明: -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出 注意: 由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll 常见用法: ls -al 查看当前目录的所有文件及目录详细信息 ls -al /etc 查看/etc目录下所有文件及目录详细信息 ll 查看当前目录文件及目录的详细信息 操作示例: 4.2.2 cd 作用: 用于切换当前工作目录，即进入指定目录 语法: cd [dirName] 特殊说明: ~ 表示用户的home目录 . 表示目前所在的目录 .. 表示目前目录位置的上级目录 举例: cd .. 切换到当前目录的上级目录 cd ~ 切换到用户的home目录 cd /usr/local 切换到/usr/local目录 备注: ​ 用户的home目录 ​ root用户 /root ​ 其他用户 /home/xxx 操作示例: cd .. 切换到当前目录位置的上级目录; 可以通过 cd ../.. 来切换到上级目录的上级目录。 4.2.3 cat 作用: 用于显示文件内容 语法: cat [-n] fileName 说明: -n: 由1开始对所有输出的行数编号 举例: cat /etc/profile 查看/etc目录下的profile文件内容 操作演示: cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。 4.2.4 more 作用: 以分页的形式显示文件内容 语法: more fileName 操作说明: 回车键 向下滚动一行 空格键 向下滚动一屏 b 返回上一屏 q或者Ctrl+C 退出more 举例： more /etc/profile 以分页方式显示/etc目录下的profile文件内容 操作示例： 当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。 4.2.5 tail 作用: 查看文件末尾的内容 语法: tail [-f] fileName 说明: -f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出 举例: tail /etc/profile 显示/etc目录下的profile文件末尾10行的内容 tail -20 /etc/profile 显示/etc目录下的profile文件末尾20行的内容 tail -f /itcast/my.log 动态读取/itcast目录下的my.log文件末尾内容并显示 操作示例： A. 默认查询文件尾部10行记录 B. 可以通过指定参数设置查询尾部指定行数的数据 C. 动态读取文件尾部的数据 在窗口1中执行指令 tail -f 1.txt 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 echo 1 \u003e\u003e 1.txt , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。 如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。 4.2.6 mkdir 作用: 创建目录 语法: mkdir [-p] dirName 说明: -p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建 举例: mkdir itcast 在当前目录下，建立一个名为itcast的子目录 mkdir -p itcast/test 在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个 操作演示: 4.2.7 rmdir 作用: 删除空目录 语法: rmdir [-p] dirName 说明: -p: 当子目录被删除后使父目录为空目录的话，则一并删除 举例: rmdir itcast 删除名为itcast的空目录 rmdir -p itcast/test 删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除 rmdir itcast* 删除名称以itcast开始的空目录 操作演示: A. 删除空目录 B. 删除非空目录 C. 使用*通配符删除目录 *: 是一个通配符，代表任意字符； rmdir itcast* : 删除以itcast开头的目录 rmdir *itcast : 删除以itcast结尾的目录 4.2.8 rm 作用: 删除文件或者目录 语法: rm [-rf] name 说明: -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除 -f: 无需确认，直接删除 举例: rm -r itcast/ 删除名为itcast的目录和目录中所有文件，删除前需确认 rm -rf itcast/ 无需确认，直接删除名为itcast的目录和目录中所有文件 rm -f hello.txt 无需确认，直接删除hello.txt文件 操作示例: ==注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。== ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#426-mkdir"},{"categories":["Linux"],"content":" 4.2 文件目录操作命令 4.2.1 ls 作用: 显示指定目录下的内容 语法: ls [-al] [dir] 说明: -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出 注意: 由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll 常见用法: ls -al 查看当前目录的所有文件及目录详细信息 ls -al /etc 查看/etc目录下所有文件及目录详细信息 ll 查看当前目录文件及目录的详细信息 操作示例: 4.2.2 cd 作用: 用于切换当前工作目录，即进入指定目录 语法: cd [dirName] 特殊说明: ~ 表示用户的home目录 . 表示目前所在的目录 .. 表示目前目录位置的上级目录 举例: cd .. 切换到当前目录的上级目录 cd ~ 切换到用户的home目录 cd /usr/local 切换到/usr/local目录 备注: ​ 用户的home目录 ​ root用户 /root ​ 其他用户 /home/xxx 操作示例: cd .. 切换到当前目录位置的上级目录; 可以通过 cd ../.. 来切换到上级目录的上级目录。 4.2.3 cat 作用: 用于显示文件内容 语法: cat [-n] fileName 说明: -n: 由1开始对所有输出的行数编号 举例: cat /etc/profile 查看/etc目录下的profile文件内容 操作演示: cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。 4.2.4 more 作用: 以分页的形式显示文件内容 语法: more fileName 操作说明: 回车键 向下滚动一行 空格键 向下滚动一屏 b 返回上一屏 q或者Ctrl+C 退出more 举例： more /etc/profile 以分页方式显示/etc目录下的profile文件内容 操作示例： 当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。 4.2.5 tail 作用: 查看文件末尾的内容 语法: tail [-f] fileName 说明: -f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出 举例: tail /etc/profile 显示/etc目录下的profile文件末尾10行的内容 tail -20 /etc/profile 显示/etc目录下的profile文件末尾20行的内容 tail -f /itcast/my.log 动态读取/itcast目录下的my.log文件末尾内容并显示 操作示例： A. 默认查询文件尾部10行记录 B. 可以通过指定参数设置查询尾部指定行数的数据 C. 动态读取文件尾部的数据 在窗口1中执行指令 tail -f 1.txt 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 echo 1 \u003e\u003e 1.txt , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。 如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。 4.2.6 mkdir 作用: 创建目录 语法: mkdir [-p] dirName 说明: -p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建 举例: mkdir itcast 在当前目录下，建立一个名为itcast的子目录 mkdir -p itcast/test 在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个 操作演示: 4.2.7 rmdir 作用: 删除空目录 语法: rmdir [-p] dirName 说明: -p: 当子目录被删除后使父目录为空目录的话，则一并删除 举例: rmdir itcast 删除名为itcast的空目录 rmdir -p itcast/test 删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除 rmdir itcast* 删除名称以itcast开始的空目录 操作演示: A. 删除空目录 B. 删除非空目录 C. 使用*通配符删除目录 *: 是一个通配符，代表任意字符； rmdir itcast* : 删除以itcast开头的目录 rmdir *itcast : 删除以itcast结尾的目录 4.2.8 rm 作用: 删除文件或者目录 语法: rm [-rf] name 说明: -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除 -f: 无需确认，直接删除 举例: rm -r itcast/ 删除名为itcast的目录和目录中所有文件，删除前需确认 rm -rf itcast/ 无需确认，直接删除名为itcast的目录和目录中所有文件 rm -f hello.txt 无需确认，直接删除hello.txt文件 操作示例: ==注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。== ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#427-rmdir"},{"categories":["Linux"],"content":" 4.2 文件目录操作命令 4.2.1 ls 作用: 显示指定目录下的内容 语法: ls [-al] [dir] 说明: -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，同时将文件型态(d表示目录，-表示文件)、权限、拥有者、文件大小等信息详细列出 注意: 由于我们使用ls命令时经常需要加入-l选项，所以Linux为ls -l命令提供了一种简写方式，即ll 常见用法: ls -al 查看当前目录的所有文件及目录详细信息 ls -al /etc 查看/etc目录下所有文件及目录详细信息 ll 查看当前目录文件及目录的详细信息 操作示例: 4.2.2 cd 作用: 用于切换当前工作目录，即进入指定目录 语法: cd [dirName] 特殊说明: ~ 表示用户的home目录 . 表示目前所在的目录 .. 表示目前目录位置的上级目录 举例: cd .. 切换到当前目录的上级目录 cd ~ 切换到用户的home目录 cd /usr/local 切换到/usr/local目录 备注: ​ 用户的home目录 ​ root用户 /root ​ 其他用户 /home/xxx 操作示例: cd .. 切换到当前目录位置的上级目录; 可以通过 cd ../.. 来切换到上级目录的上级目录。 4.2.3 cat 作用: 用于显示文件内容 语法: cat [-n] fileName 说明: -n: 由1开始对所有输出的行数编号 举例: cat /etc/profile 查看/etc目录下的profile文件内容 操作演示: cat 指令会一次性查看文件的所有内容，如果文件内容比较多，这个时候查看起来就不是很方便了，这个时候我们可以通过一个新的指令more。 4.2.4 more 作用: 以分页的形式显示文件内容 语法: more fileName 操作说明: 回车键 向下滚动一行 空格键 向下滚动一屏 b 返回上一屏 q或者Ctrl+C 退出more 举例： more /etc/profile 以分页方式显示/etc目录下的profile文件内容 操作示例： 当我们在查看一些比较大的文件时，我们可能需要经常查询文件尾部的数据信息，那这个时候如果文件很大，我们要一直向下翻页，直到最后一页，去看最新添加的数据，这种方式就比较繁琐了，此时，我们可以借助于tail指令。 4.2.5 tail 作用: 查看文件末尾的内容 语法: tail [-f] fileName 说明: -f : 动态读取文件末尾内容并显示，通常用于日志文件的内容输出 举例: tail /etc/profile 显示/etc目录下的profile文件末尾10行的内容 tail -20 /etc/profile 显示/etc目录下的profile文件末尾20行的内容 tail -f /itcast/my.log 动态读取/itcast目录下的my.log文件末尾内容并显示 操作示例： A. 默认查询文件尾部10行记录 B. 可以通过指定参数设置查询尾部指定行数的数据 C. 动态读取文件尾部的数据 在窗口1中执行指令 tail -f 1.txt 动态查看文件尾部的数据。然后在顶部的标签中右键选择 “复制标签”，打开新的窗口2 , 此时再新打开的窗口2中执行指令 echo 1 \u003e\u003e 1.txt , 往1.txt文件尾部追加内容，然后我们就可以在窗口1中看到最新的文件尾部的数据。 如果我们不想查看文件尾部的数据了，可以直接使用快捷键 Ctrl+C ， 结束当前进程。 4.2.6 mkdir 作用: 创建目录 语法: mkdir [-p] dirName 说明: -p: 确保目录名称存在，不存在的就创建一个。通过此选项，可以实现多层目录同时创建 举例: mkdir itcast 在当前目录下，建立一个名为itcast的子目录 mkdir -p itcast/test 在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个 操作演示: 4.2.7 rmdir 作用: 删除空目录 语法: rmdir [-p] dirName 说明: -p: 当子目录被删除后使父目录为空目录的话，则一并删除 举例: rmdir itcast 删除名为itcast的空目录 rmdir -p itcast/test 删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除 rmdir itcast* 删除名称以itcast开始的空目录 操作演示: A. 删除空目录 B. 删除非空目录 C. 使用*通配符删除目录 *: 是一个通配符，代表任意字符； rmdir itcast* : 删除以itcast开头的目录 rmdir *itcast : 删除以itcast结尾的目录 4.2.8 rm 作用: 删除文件或者目录 语法: rm [-rf] name 说明: -r: 将目录及目录中所有文件（目录）逐一删除，即递归删除 -f: 无需确认，直接删除 举例: rm -r itcast/ 删除名为itcast的目录和目录中所有文件，删除前需确认 rm -rf itcast/ 无需确认，直接删除名为itcast的目录和目录中所有文件 rm -f hello.txt 无需确认，直接删除hello.txt文件 操作示例: ==注意: 对于 rm -rf xxx 这样的指令，在执行的时候，一定要慎重，确认无误后再进行删除，避免误删。== ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#428-rm"},{"categories":["Linux"],"content":" 4.3 拷贝移动命令 4.3.1 cp 作用: 用于复制文件或目录 语法: cp [-r] source dest 说明: -r: 如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件 举例: cp hello.txt itcast/ 将hello.txt复制到itcast目录中 cp hello.txt ./hi.txt 将hello.txt复制到当前目录，并改名为hi.txt cp -r itcast/ ./itheima/ 将itcast目录和目录下所有文件复制到itheima目录下 cp -r itcast/* ./itheima/ 将itcast目录下所有文件复制到itheima目录下 操作示例: 如果拷贝的内容是目录，需要加上参数 -r 4.3.2 mv 作用: 为文件或目录改名、或将文件或目录移动到其它位置 语法: mv source dest 举例: mv hello.txt hi.txt 将hello.txt改名为hi.txt mv hi.txt itheima/ 将文件hi.txt移动到itheima目录中 mv hi.txt itheima/hello.txt 将hi.txt移动到itheima目录中，并改名为hello.txt mv itcast/ itheima/ 如果itheima目录不存在，将itcast目录改名为itheima mv itcast/ itheima/ 如果itheima目录存在，将itcast目录移动到itheima目录中 操作示例: mv 命令既能够改名，又可以移动，具体是改名还是移动,系统会根据我们输入的参数进行判定(如果第二个参数dest是一个已存在的目录,将执行移动操作,其他情况都是改名) ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#43-拷贝移动命令"},{"categories":["Linux"],"content":" 4.3 拷贝移动命令 4.3.1 cp 作用: 用于复制文件或目录 语法: cp [-r] source dest 说明: -r: 如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件 举例: cp hello.txt itcast/ 将hello.txt复制到itcast目录中 cp hello.txt ./hi.txt 将hello.txt复制到当前目录，并改名为hi.txt cp -r itcast/ ./itheima/ 将itcast目录和目录下所有文件复制到itheima目录下 cp -r itcast/* ./itheima/ 将itcast目录下所有文件复制到itheima目录下 操作示例: 如果拷贝的内容是目录，需要加上参数 -r 4.3.2 mv 作用: 为文件或目录改名、或将文件或目录移动到其它位置 语法: mv source dest 举例: mv hello.txt hi.txt 将hello.txt改名为hi.txt mv hi.txt itheima/ 将文件hi.txt移动到itheima目录中 mv hi.txt itheima/hello.txt 将hi.txt移动到itheima目录中，并改名为hello.txt mv itcast/ itheima/ 如果itheima目录不存在，将itcast目录改名为itheima mv itcast/ itheima/ 如果itheima目录存在，将itcast目录移动到itheima目录中 操作示例: mv 命令既能够改名，又可以移动，具体是改名还是移动,系统会根据我们输入的参数进行判定(如果第二个参数dest是一个已存在的目录,将执行移动操作,其他情况都是改名) ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#431-cp"},{"categories":["Linux"],"content":" 4.3 拷贝移动命令 4.3.1 cp 作用: 用于复制文件或目录 语法: cp [-r] source dest 说明: -r: 如果复制的是目录需要使用此选项，此时将复制该目录下所有的子目录和文件 举例: cp hello.txt itcast/ 将hello.txt复制到itcast目录中 cp hello.txt ./hi.txt 将hello.txt复制到当前目录，并改名为hi.txt cp -r itcast/ ./itheima/ 将itcast目录和目录下所有文件复制到itheima目录下 cp -r itcast/* ./itheima/ 将itcast目录下所有文件复制到itheima目录下 操作示例: 如果拷贝的内容是目录，需要加上参数 -r 4.3.2 mv 作用: 为文件或目录改名、或将文件或目录移动到其它位置 语法: mv source dest 举例: mv hello.txt hi.txt 将hello.txt改名为hi.txt mv hi.txt itheima/ 将文件hi.txt移动到itheima目录中 mv hi.txt itheima/hello.txt 将hi.txt移动到itheima目录中，并改名为hello.txt mv itcast/ itheima/ 如果itheima目录不存在，将itcast目录改名为itheima mv itcast/ itheima/ 如果itheima目录存在，将itcast目录移动到itheima目录中 操作示例: mv 命令既能够改名，又可以移动，具体是改名还是移动,系统会根据我们输入的参数进行判定(如果第二个参数dest是一个已存在的目录,将执行移动操作,其他情况都是改名) ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#432-mv"},{"categories":["Linux"],"content":" 4.4 打包压缩命令 作用: 对文件进行打包、解包、压缩、解压 语法: tar [-zcxvf] fileName [files] 包文件后缀为.tar表示只是完成了打包，并没有压缩 包文件后缀为.tar.gz表示打包的同时还进行了压缩 说明: -z: z代表的是gzip，通过gzip命令处理文件，gzip可以对文件压缩或者解压 -c: c代表的是create，即创建新的包文件 -x: x代表的是extract，实现从包文件中还原文件 -v: v代表的是verbose，显示命令的执行过程 -f: f代表的是file，用于指定包文件的名称 举例： 打包 tar -cvf hello.tar ./* 将当前目录下所有文件打包，打包后的文件名为hello.tar tar -zcvf hello.tar.gz ./* 将当前目录下所有文件打包并压缩，打包后的文件名为hello.tar.gz 解包 tar -xvf hello.tar 将hello.tar文件进行解包，并将解包后的文件放在当前目录 tar -zxvf hello.tar.gz 将hello.tar.gz文件进行解压，并将解压后的文件放在当前目录 tar -zxvf hello.tar.gz -C /usr/local 将hello.tar.gz文件进行解压，并将解压后的文件放在/usr/local目录 操作示例: A. 打包 B. 打包并压缩 C. 解包 D. 解压 解压到指定目录,需要加上参数 -C ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:4","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#44-打包压缩命令"},{"categories":["Linux"],"content":" 4.5 文本编辑命令文本编辑的命令，主要包含两个: vi 和 vim，两个命令的用法类似，我们课程中主要讲解vim的使用。 4.5.1 vi\u0026vim介绍作用: vi命令是Linux系统提供的一个文本编辑工具，可以对文件内容进行编辑，类似于Windows中的记事本 语法: vi fileName 说明: 1). vim是从vi发展来的一个功能更加强大的文本编辑工具，编辑文件时可以对文本内容进行着色，方便我们对文件进行编辑处理，所以实际工作中vim更加常用。 2). 要使用vim命令，需要我们自己完成安装。可以使用下面的命令来完成安装：yum install vim 4.5.2 vim安装命令： yum install vim 安装过程中，会有确认提示，此时输入 y，然后回车，继续安装： 4.5.3 vim使用作用: 对文件内容进行编辑，vim其实就是一个文本编辑器 语法: vim fileName 说明: 1). 在使用vim命令编辑文件时，如果指定的文件存在则直接打开此文件。如果指定的文件不存在则新建文件。 2). vim在进行文本编辑时共分为三种模式，分别是 命令模式（Command mode），插入模式（Insert mode）和底行模式（Last line mode）。这三种模式之间可以相互切换。我们在使用vim时一定要注意我们当前所处的是哪种模式。 三种模式: - 命令模式 A. 命令模式下可以查看文件内容、移动光标（上下左右箭头、gg、G） B. 通过vim命令打开文件后，默认进入命令模式 C. 另外两种模式需要首先进入命令模式，才能进入彼此 | 命令模式指令 | 含义 | | ------------ | --------------------------------- | | gg | 定位到文本内容的第一行 | | G | 定位到文本内容的最后一行 | | dd | 删除光标所在行的数据 | | ndd | 删除当前光标所在行及之后的n行数据 | | u | 撤销操作 | | shift+zz | 保存并退出 | | i 或 a 或 o | 进入插入模式 | ​ 插入模式 A. 插入模式下可以对文件内容进行编辑 B. 在命令模式下按下[i,a,o]任意一个，可以进入插入模式。进入插入模式后，下方会出现【insert】字样 C. 在插入模式下按下ESC键，回到命令模式 底行模式 A. 底行模式下可以通过命令对文件内容进行查找、显示行号、退出等操作 B. 在命令模式下按下[:,/]任意一个，可以进入底行模式 C. 通过/方式进入底行模式后，可以对文件内容进行查找 D. 通过:方式进入底行模式后，可以输入wq（保存并退出）、q!（不保存退出）、set nu（显示行号） 底行模式命令 含义 :wq 保存并退出 :q! 不保存退出 :set nu 显示行号 :set nonu 取消行号显示 :n 定位到第n行, 如 :10 就是定位到第10行 ​ ​ 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:5","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#45-文本编辑命令"},{"categories":["Linux"],"content":" 4.5 文本编辑命令文本编辑的命令，主要包含两个: vi 和 vim，两个命令的用法类似，我们课程中主要讲解vim的使用。 4.5.1 vi\u0026vim介绍作用: vi命令是Linux系统提供的一个文本编辑工具，可以对文件内容进行编辑，类似于Windows中的记事本 语法: vi fileName 说明: 1). vim是从vi发展来的一个功能更加强大的文本编辑工具，编辑文件时可以对文本内容进行着色，方便我们对文件进行编辑处理，所以实际工作中vim更加常用。 2). 要使用vim命令，需要我们自己完成安装。可以使用下面的命令来完成安装：yum install vim 4.5.2 vim安装命令： yum install vim 安装过程中，会有确认提示，此时输入 y，然后回车，继续安装： 4.5.3 vim使用作用: 对文件内容进行编辑，vim其实就是一个文本编辑器 语法: vim fileName 说明: 1). 在使用vim命令编辑文件时，如果指定的文件存在则直接打开此文件。如果指定的文件不存在则新建文件。 2). vim在进行文本编辑时共分为三种模式，分别是 命令模式（Command mode），插入模式（Insert mode）和底行模式（Last line mode）。这三种模式之间可以相互切换。我们在使用vim时一定要注意我们当前所处的是哪种模式。 三种模式: - 命令模式 A. 命令模式下可以查看文件内容、移动光标（上下左右箭头、gg、G） B. 通过vim命令打开文件后，默认进入命令模式 C. 另外两种模式需要首先进入命令模式，才能进入彼此 | 命令模式指令 | 含义 | | ------------ | --------------------------------- | | gg | 定位到文本内容的第一行 | | G | 定位到文本内容的最后一行 | | dd | 删除光标所在行的数据 | | ndd | 删除当前光标所在行及之后的n行数据 | | u | 撤销操作 | | shift+zz | 保存并退出 | | i 或 a 或 o | 进入插入模式 | ​ 插入模式 A. 插入模式下可以对文件内容进行编辑 B. 在命令模式下按下[i,a,o]任意一个，可以进入插入模式。进入插入模式后，下方会出现【insert】字样 C. 在插入模式下按下ESC键，回到命令模式 底行模式 A. 底行模式下可以通过命令对文件内容进行查找、显示行号、退出等操作 B. 在命令模式下按下[:,/]任意一个，可以进入底行模式 C. 通过/方式进入底行模式后，可以对文件内容进行查找 D. 通过:方式进入底行模式后，可以输入wq（保存并退出）、q!（不保存退出）、set nu（显示行号） 底行模式命令 含义 :wq 保存并退出 :q! 不保存退出 :set nu 显示行号 :set nonu 取消行号显示 :n 定位到第n行, 如 :10 就是定位到第10行 ​ ​ 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:5","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#451-vivim介绍"},{"categories":["Linux"],"content":" 4.5 文本编辑命令文本编辑的命令，主要包含两个: vi 和 vim，两个命令的用法类似，我们课程中主要讲解vim的使用。 4.5.1 vi\u0026vim介绍作用: vi命令是Linux系统提供的一个文本编辑工具，可以对文件内容进行编辑，类似于Windows中的记事本 语法: vi fileName 说明: 1). vim是从vi发展来的一个功能更加强大的文本编辑工具，编辑文件时可以对文本内容进行着色，方便我们对文件进行编辑处理，所以实际工作中vim更加常用。 2). 要使用vim命令，需要我们自己完成安装。可以使用下面的命令来完成安装：yum install vim 4.5.2 vim安装命令： yum install vim 安装过程中，会有确认提示，此时输入 y，然后回车，继续安装： 4.5.3 vim使用作用: 对文件内容进行编辑，vim其实就是一个文本编辑器 语法: vim fileName 说明: 1). 在使用vim命令编辑文件时，如果指定的文件存在则直接打开此文件。如果指定的文件不存在则新建文件。 2). vim在进行文本编辑时共分为三种模式，分别是 命令模式（Command mode），插入模式（Insert mode）和底行模式（Last line mode）。这三种模式之间可以相互切换。我们在使用vim时一定要注意我们当前所处的是哪种模式。 三种模式: - 命令模式 A. 命令模式下可以查看文件内容、移动光标（上下左右箭头、gg、G） B. 通过vim命令打开文件后，默认进入命令模式 C. 另外两种模式需要首先进入命令模式，才能进入彼此 | 命令模式指令 | 含义 | | ------------ | --------------------------------- | | gg | 定位到文本内容的第一行 | | G | 定位到文本内容的最后一行 | | dd | 删除光标所在行的数据 | | ndd | 删除当前光标所在行及之后的n行数据 | | u | 撤销操作 | | shift+zz | 保存并退出 | | i 或 a 或 o | 进入插入模式 | ​ 插入模式 A. 插入模式下可以对文件内容进行编辑 B. 在命令模式下按下[i,a,o]任意一个，可以进入插入模式。进入插入模式后，下方会出现【insert】字样 C. 在插入模式下按下ESC键，回到命令模式 底行模式 A. 底行模式下可以通过命令对文件内容进行查找、显示行号、退出等操作 B. 在命令模式下按下[:,/]任意一个，可以进入底行模式 C. 通过/方式进入底行模式后，可以对文件内容进行查找 D. 通过:方式进入底行模式后，可以输入wq（保存并退出）、q!（不保存退出）、set nu（显示行号） 底行模式命令 含义 :wq 保存并退出 :q! 不保存退出 :set nu 显示行号 :set nonu 取消行号显示 :n 定位到第n行, 如 :10 就是定位到第10行 ​ ​ 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:5","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#452-vim安装"},{"categories":["Linux"],"content":" 4.5 文本编辑命令文本编辑的命令，主要包含两个: vi 和 vim，两个命令的用法类似，我们课程中主要讲解vim的使用。 4.5.1 vi\u0026vim介绍作用: vi命令是Linux系统提供的一个文本编辑工具，可以对文件内容进行编辑，类似于Windows中的记事本 语法: vi fileName 说明: 1). vim是从vi发展来的一个功能更加强大的文本编辑工具，编辑文件时可以对文本内容进行着色，方便我们对文件进行编辑处理，所以实际工作中vim更加常用。 2). 要使用vim命令，需要我们自己完成安装。可以使用下面的命令来完成安装：yum install vim 4.5.2 vim安装命令： yum install vim 安装过程中，会有确认提示，此时输入 y，然后回车，继续安装： 4.5.3 vim使用作用: 对文件内容进行编辑，vim其实就是一个文本编辑器 语法: vim fileName 说明: 1). 在使用vim命令编辑文件时，如果指定的文件存在则直接打开此文件。如果指定的文件不存在则新建文件。 2). vim在进行文本编辑时共分为三种模式，分别是 命令模式（Command mode），插入模式（Insert mode）和底行模式（Last line mode）。这三种模式之间可以相互切换。我们在使用vim时一定要注意我们当前所处的是哪种模式。 三种模式: - 命令模式 A. 命令模式下可以查看文件内容、移动光标（上下左右箭头、gg、G） B. 通过vim命令打开文件后，默认进入命令模式 C. 另外两种模式需要首先进入命令模式，才能进入彼此 | 命令模式指令 | 含义 | | ------------ | --------------------------------- | | gg | 定位到文本内容的第一行 | | G | 定位到文本内容的最后一行 | | dd | 删除光标所在行的数据 | | ndd | 删除当前光标所在行及之后的n行数据 | | u | 撤销操作 | | shift+zz | 保存并退出 | | i 或 a 或 o | 进入插入模式 | ​ 插入模式 A. 插入模式下可以对文件内容进行编辑 B. 在命令模式下按下[i,a,o]任意一个，可以进入插入模式。进入插入模式后，下方会出现【insert】字样 C. 在插入模式下按下ESC键，回到命令模式 底行模式 A. 底行模式下可以通过命令对文件内容进行查找、显示行号、退出等操作 B. 在命令模式下按下[:,/]任意一个，可以进入底行模式 C. 通过/方式进入底行模式后，可以对文件内容进行查找 D. 通过:方式进入底行模式后，可以输入wq（保存并退出）、q!（不保存退出）、set nu（显示行号） 底行模式命令 含义 :wq 保存并退出 :q! 不保存退出 :set nu 显示行号 :set nonu 取消行号显示 :n 定位到第n行, 如 :10 就是定位到第10行 ​ ​ 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:5","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#453-vim使用"},{"categories":["Linux"],"content":" 4.6 查找命令 4.6.1 find 作用: 在指定目录下查找文件 语法: find dirName -option fileName 举例: find . –name \"*.java\" 在当前目录及其子目录下查找.java结尾文件 find /itcast -name \"*.java\" 在/itcast目录及其子目录下查找.java结尾的文件 操作示例: 4.6.2 grep 作用: 从指定文件中查找指定的文本内容 语法: grep word fileName 举例: grep Hello HelloWorld.java 查找HelloWorld.java文件中出现的Hello字符串的位置 grep hello *.java 查找当前目录中所有.java结尾的文件中包含hello字符串的位置 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:6","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#46-查找命令"},{"categories":["Linux"],"content":" 4.6 查找命令 4.6.1 find 作用: 在指定目录下查找文件 语法: find dirName -option fileName 举例: find . –name \"*.java\" 在当前目录及其子目录下查找.java结尾文件 find /itcast -name \"*.java\" 在/itcast目录及其子目录下查找.java结尾的文件 操作示例: 4.6.2 grep 作用: 从指定文件中查找指定的文本内容 语法: grep word fileName 举例: grep Hello HelloWorld.java 查找HelloWorld.java文件中出现的Hello字符串的位置 grep hello *.java 查找当前目录中所有.java结尾的文件中包含hello字符串的位置 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:6","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#461-find"},{"categories":["Linux"],"content":" 4.6 查找命令 4.6.1 find 作用: 在指定目录下查找文件 语法: find dirName -option fileName 举例: find . –name \"*.java\" 在当前目录及其子目录下查找.java结尾文件 find /itcast -name \"*.java\" 在/itcast目录及其子目录下查找.java结尾的文件 操作示例: 4.6.2 grep 作用: 从指定文件中查找指定的文本内容 语法: grep word fileName 举例: grep Hello HelloWorld.java 查找HelloWorld.java文件中出现的Hello字符串的位置 grep hello *.java 查找当前目录中所有.java结尾的文件中包含hello字符串的位置 操作示例: ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:4:6","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#462-grep"},{"categories":["Linux"],"content":" 5. 软件安装","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:0","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#5-软件安装"},{"categories":["Linux"],"content":" 5.1 软件安装方式在Linux系统中，安装软件的方式主要有四种，这四种安装方式的特点如下： 安装方式 特点 二进制发布包安装 软件已经针对具体平台编译打包发布，只要解压，修改配置即可 rpm安装 软件已经按照redhat的包管理规范进行打包，使用rpm命令进行安装，==不能自行解决库依赖问题== yum安装 一种在线软件安装方式，本质上还是rpm安装，自动下载安装包并安装，安装过程中自动解决库依赖问题(安装过程需要联网) 源码编译安装 软件以源码工程的形式发布，需要自己编译打包 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:1","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#51-软件安装方式"},{"categories":["Linux"],"content":" 5.2 安装JDK上述我们介绍了Linux系统软件安装的四种形式，接下来我们就通过第一种(二进制发布包)形式来安装JDK。 JDK对应的二进制发布包，如下： JDK具体安装步骤如下： 1). 上传安装包 使用FinalShell自带的上传工具将jdk的二进制发布包上传到Linux 由于上述在进行文件上传时，选择的上传目录为根目录 /，上传完毕后，我们执行指令 cd / 切换到根目录下，查看上传的安装包。 2). 解压安装包 执行如下指令，将上传上来的压缩包进行解压，并通过-C参数指定解压文件存放目录为 /usr/local。 tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local 3). 配置环境变量 使用vim命令修改/etc/profile文件，在文件末尾加入如下配置 JAVA_HOME=/usr/local/jdk1.8.0_171 PATH=$JAVA_HOME/bin:$PATH 具体操作指令如下: 1). 编辑/etc/profile文件，进入命令模式 vim /etc/profile 2). 在命令模式中，输入指令 G ， 切换到文件最后 G 3). 在命令模式中输入 i/a/o 进入插入模式，然后切换到文件最后一行 i 4). 将上述的配置拷贝到文件中 JAVA_HOME=/usr/local/jdk1.8.0_171 PATH=$JAVA_HOME/bin:$PATH 5). 从插入模式，切换到指令模式 ESC 6). 按:进入底行模式，然后输入wq，回车保存 :wq 4). 重新加载profile文件 为了使更改的配置立即生效，需要重新加载profile文件，执行命令: source /etc/profile 5). 检查安装是否成功 java -version ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#52-安装jdk"},{"categories":["Linux"],"content":" 5.3 安装Tomcat 5.3.1 Tomcat安装Tomcat的安装和上述JDK的安装采用相同的方式，都是使用二进制发布包的形式进行安装 具体安装步骤如下： 1). 上传安装包 使用FinalShell自带的上传工具将Tomcat的二进制发布包上传到Linux(与前面上传JDK安装包步骤一致)。 2). 解压安装包 将上传上来的安装包解压到指定目录/usr/local下，执行命令为 tar -zxvf apache-tomcat-7.0.57.tar.gz -C /usr/local 3). 启动Tomcat 进入Tomcat的bin目录启动服务。执行命令为: cd /usr/local/apache-tomcat-7.0.57/ cd bin sh startup.sh或者./startup.sh 5.3.2 Tomcat进程查看上述我们将Tomcat启动完成之后，并不能知道Tomcat是否正常运行，那么我们验证Tomcat启动是否成功，有多种方式，我们这里主要介绍常见的两种方式： 1). 查看启动日志 Tomcat的启动日志输出在Tomcat的安装目录下的logs目录中，Tomcat的启动及运行日志文件名为 catalina.out，所以我们查看Tomcat启动日志，主要可以通过两条指令，如下： 1). 分页查询Tomcat的日志信息 more /usr/local/apache-tomcat-7.0.57/logs/catalina.out 2). 查询日志文件尾部的50行记录 tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out 只要Tomcat在启动的过程中，日志输出没有报错，基本可以判定Tomcat启动成功了。 2). 查询系统进程 我们也可以通过Linux系统的查看系统进程的指令，来判定Tomcat进程是否存在，从而判定Tomcat是否启动。执行如下指令： ps -ef|grep tomcat 说明: ==ps==命令是linux下非常强大的进程查看命令，通过ps -ef可以查看当前运行的所有进程的详细信息 ==\"|\"== 在Linux中称为管道符，可以将前一个命令的结果输出给后一个命令作为输入 使用ps命令查看进程时，经常配合管道符和查找命令 grep 一起使用，来查看特定进程 5.3.3 防火墙操作前面我们已经通过日志的方式及查看系统进程的方式，验证了Tomcat服务已经正常启动，接下来我们就可以尝试访问一下。访问地址：http://192.168.138.130:8080，我们发现是访问不到的。 那为什么tomcat启动成功了，但就是访问不到呢？原因就在于Linux系统的防火墙，系统安装完毕后，系统启动时，防火墙自动启动，防火墙拦截了所有端口的访问。接下来我们就需要学习一下，如何操作防火墙，具体指令如下： 操作 指令 备注 查看防火墙状态 systemctl status firewalld / firewall-cmd –state 暂时关闭防火墙 systemctl stop firewalld 永久关闭防火墙(禁用开机自启) systemctl disable firewalld ==下次启动,才生效== 暂时开启防火墙 systemctl start firewalld 永久开启防火墙(启用开机自启) systemctl enable firewalld ==下次启动,才生效== 开放指定端口 firewall-cmd –zone=public –add-port=8080/tcp –permanent ==需要重新加载生效== 关闭指定端口 firewall-cmd –zone=public –remove-port=8080/tcp –permanent ==需要重新加载生效== 立即生效(重新加载) firewall-cmd –reload 查看开放端口 firewall-cmd –zone=public –list-ports 注意： ​ A. systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作 ​ B. firewall-cmd是Linux中专门用于控制防火墙的命令 ​ C. 为了保证系统安全，服务器的防火墙不建议关闭 那么我们要想访问到Tomcat，就可以采取两种类型的操作： A. 关闭防火墙 执行指令 : systemctl stop firewalld 关闭之后，再次访问Tomcat，就可以访问到了。 注意: 上面我们也提到了，直接关闭系统的防火墙，是不建议的，因为这样会造成系统不安全。 B. 开放Tomcat的端口号8080 执行指令: ①. 先开启系统防火墙 systemctl start firewalld ②. 再开放8080端口号 firewall-cmd --zone=public --add-port=8080/tcp --permanent ③. 重新加载防火墙 firewall-cmd --reload 执行上述的操作之后，就开放了当前系统中的8080端口号，再次访问Tomcat。 5.3.4 停止Tomcat在Linux系统中，停止Tomcat服务的方式主要有两种： 1). 运行Tomcat提供的脚本文件 在Tomcat安装目录下有一个bin目录，这个目录中存放的是tomcat的运行脚本文件，其中有一个脚本就是用于停止tomcat服务的。 我们可以切换到bin目录，并执行如下指令，来停止Tomcat服务： sh shutdown.sh ./shutdown.sh 2). 结束Tomcat进程 我们可以先通过 ps -ef|grep tomcat 指令查看tomcat进程的信息，从进程信息中获取tomcat服务的进程号。然后通过kill -9 的形式，来杀死系统进程。 通过上述的指令，我们可以获取到tomcat的进程号为 79947。接下来，我们就可以通过指令 ，来杀死tomcat的进程 ： kill -9 79947 执行完上述指令之后，我们再访问Linux系统中的Tomcat，就访问不到了。 注意： ​ kill命令是Linux提供的用于结束进程的命令，-9表示强制结束 注意 ： ​ 虽然上述讲解的两种方式，都可以停止Tomcat服务，但是推荐使用第一种方式(./shutdown.sh)执行脚本来关闭tomcat服务，如果通过第一种方式停止不了tomcat了，这个时候，我们可以考虑使用第二种方式，强制杀死进程。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#53-安装tomcat"},{"categories":["Linux"],"content":" 5.3 安装Tomcat 5.3.1 Tomcat安装Tomcat的安装和上述JDK的安装采用相同的方式，都是使用二进制发布包的形式进行安装 具体安装步骤如下： 1). 上传安装包 使用FinalShell自带的上传工具将Tomcat的二进制发布包上传到Linux(与前面上传JDK安装包步骤一致)。 2). 解压安装包 将上传上来的安装包解压到指定目录/usr/local下，执行命令为 tar -zxvf apache-tomcat-7.0.57.tar.gz -C /usr/local 3). 启动Tomcat 进入Tomcat的bin目录启动服务。执行命令为: cd /usr/local/apache-tomcat-7.0.57/ cd bin sh startup.sh或者./startup.sh 5.3.2 Tomcat进程查看上述我们将Tomcat启动完成之后，并不能知道Tomcat是否正常运行，那么我们验证Tomcat启动是否成功，有多种方式，我们这里主要介绍常见的两种方式： 1). 查看启动日志 Tomcat的启动日志输出在Tomcat的安装目录下的logs目录中，Tomcat的启动及运行日志文件名为 catalina.out，所以我们查看Tomcat启动日志，主要可以通过两条指令，如下： 1). 分页查询Tomcat的日志信息 more /usr/local/apache-tomcat-7.0.57/logs/catalina.out 2). 查询日志文件尾部的50行记录 tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out 只要Tomcat在启动的过程中，日志输出没有报错，基本可以判定Tomcat启动成功了。 2). 查询系统进程 我们也可以通过Linux系统的查看系统进程的指令，来判定Tomcat进程是否存在，从而判定Tomcat是否启动。执行如下指令： ps -ef|grep tomcat 说明: ==ps==命令是linux下非常强大的进程查看命令，通过ps -ef可以查看当前运行的所有进程的详细信息 ==\"|\"== 在Linux中称为管道符，可以将前一个命令的结果输出给后一个命令作为输入 使用ps命令查看进程时，经常配合管道符和查找命令 grep 一起使用，来查看特定进程 5.3.3 防火墙操作前面我们已经通过日志的方式及查看系统进程的方式，验证了Tomcat服务已经正常启动，接下来我们就可以尝试访问一下。访问地址：http://192.168.138.130:8080，我们发现是访问不到的。 那为什么tomcat启动成功了，但就是访问不到呢？原因就在于Linux系统的防火墙，系统安装完毕后，系统启动时，防火墙自动启动，防火墙拦截了所有端口的访问。接下来我们就需要学习一下，如何操作防火墙，具体指令如下： 操作 指令 备注 查看防火墙状态 systemctl status firewalld / firewall-cmd –state 暂时关闭防火墙 systemctl stop firewalld 永久关闭防火墙(禁用开机自启) systemctl disable firewalld ==下次启动,才生效== 暂时开启防火墙 systemctl start firewalld 永久开启防火墙(启用开机自启) systemctl enable firewalld ==下次启动,才生效== 开放指定端口 firewall-cmd –zone=public –add-port=8080/tcp –permanent ==需要重新加载生效== 关闭指定端口 firewall-cmd –zone=public –remove-port=8080/tcp –permanent ==需要重新加载生效== 立即生效(重新加载) firewall-cmd –reload 查看开放端口 firewall-cmd –zone=public –list-ports 注意： ​ A. systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作 ​ B. firewall-cmd是Linux中专门用于控制防火墙的命令 ​ C. 为了保证系统安全，服务器的防火墙不建议关闭 那么我们要想访问到Tomcat，就可以采取两种类型的操作： A. 关闭防火墙 执行指令 : systemctl stop firewalld 关闭之后，再次访问Tomcat，就可以访问到了。 注意: 上面我们也提到了，直接关闭系统的防火墙，是不建议的，因为这样会造成系统不安全。 B. 开放Tomcat的端口号8080 执行指令: ①. 先开启系统防火墙 systemctl start firewalld ②. 再开放8080端口号 firewall-cmd --zone=public --add-port=8080/tcp --permanent ③. 重新加载防火墙 firewall-cmd --reload 执行上述的操作之后，就开放了当前系统中的8080端口号，再次访问Tomcat。 5.3.4 停止Tomcat在Linux系统中，停止Tomcat服务的方式主要有两种： 1). 运行Tomcat提供的脚本文件 在Tomcat安装目录下有一个bin目录，这个目录中存放的是tomcat的运行脚本文件，其中有一个脚本就是用于停止tomcat服务的。 我们可以切换到bin目录，并执行如下指令，来停止Tomcat服务： sh shutdown.sh ./shutdown.sh 2). 结束Tomcat进程 我们可以先通过 ps -ef|grep tomcat 指令查看tomcat进程的信息，从进程信息中获取tomcat服务的进程号。然后通过kill -9 的形式，来杀死系统进程。 通过上述的指令，我们可以获取到tomcat的进程号为 79947。接下来，我们就可以通过指令 ，来杀死tomcat的进程 ： kill -9 79947 执行完上述指令之后，我们再访问Linux系统中的Tomcat，就访问不到了。 注意： ​ kill命令是Linux提供的用于结束进程的命令，-9表示强制结束 注意 ： ​ 虽然上述讲解的两种方式，都可以停止Tomcat服务，但是推荐使用第一种方式(./shutdown.sh)执行脚本来关闭tomcat服务，如果通过第一种方式停止不了tomcat了，这个时候，我们可以考虑使用第二种方式，强制杀死进程。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#531-tomcat安装"},{"categories":["Linux"],"content":" 5.3 安装Tomcat 5.3.1 Tomcat安装Tomcat的安装和上述JDK的安装采用相同的方式，都是使用二进制发布包的形式进行安装 具体安装步骤如下： 1). 上传安装包 使用FinalShell自带的上传工具将Tomcat的二进制发布包上传到Linux(与前面上传JDK安装包步骤一致)。 2). 解压安装包 将上传上来的安装包解压到指定目录/usr/local下，执行命令为 tar -zxvf apache-tomcat-7.0.57.tar.gz -C /usr/local 3). 启动Tomcat 进入Tomcat的bin目录启动服务。执行命令为: cd /usr/local/apache-tomcat-7.0.57/ cd bin sh startup.sh或者./startup.sh 5.3.2 Tomcat进程查看上述我们将Tomcat启动完成之后，并不能知道Tomcat是否正常运行，那么我们验证Tomcat启动是否成功，有多种方式，我们这里主要介绍常见的两种方式： 1). 查看启动日志 Tomcat的启动日志输出在Tomcat的安装目录下的logs目录中，Tomcat的启动及运行日志文件名为 catalina.out，所以我们查看Tomcat启动日志，主要可以通过两条指令，如下： 1). 分页查询Tomcat的日志信息 more /usr/local/apache-tomcat-7.0.57/logs/catalina.out 2). 查询日志文件尾部的50行记录 tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out 只要Tomcat在启动的过程中，日志输出没有报错，基本可以判定Tomcat启动成功了。 2). 查询系统进程 我们也可以通过Linux系统的查看系统进程的指令，来判定Tomcat进程是否存在，从而判定Tomcat是否启动。执行如下指令： ps -ef|grep tomcat 说明: ==ps==命令是linux下非常强大的进程查看命令，通过ps -ef可以查看当前运行的所有进程的详细信息 ==\"|\"== 在Linux中称为管道符，可以将前一个命令的结果输出给后一个命令作为输入 使用ps命令查看进程时，经常配合管道符和查找命令 grep 一起使用，来查看特定进程 5.3.3 防火墙操作前面我们已经通过日志的方式及查看系统进程的方式，验证了Tomcat服务已经正常启动，接下来我们就可以尝试访问一下。访问地址：http://192.168.138.130:8080，我们发现是访问不到的。 那为什么tomcat启动成功了，但就是访问不到呢？原因就在于Linux系统的防火墙，系统安装完毕后，系统启动时，防火墙自动启动，防火墙拦截了所有端口的访问。接下来我们就需要学习一下，如何操作防火墙，具体指令如下： 操作 指令 备注 查看防火墙状态 systemctl status firewalld / firewall-cmd –state 暂时关闭防火墙 systemctl stop firewalld 永久关闭防火墙(禁用开机自启) systemctl disable firewalld ==下次启动,才生效== 暂时开启防火墙 systemctl start firewalld 永久开启防火墙(启用开机自启) systemctl enable firewalld ==下次启动,才生效== 开放指定端口 firewall-cmd –zone=public –add-port=8080/tcp –permanent ==需要重新加载生效== 关闭指定端口 firewall-cmd –zone=public –remove-port=8080/tcp –permanent ==需要重新加载生效== 立即生效(重新加载) firewall-cmd –reload 查看开放端口 firewall-cmd –zone=public –list-ports 注意： ​ A. systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作 ​ B. firewall-cmd是Linux中专门用于控制防火墙的命令 ​ C. 为了保证系统安全，服务器的防火墙不建议关闭 那么我们要想访问到Tomcat，就可以采取两种类型的操作： A. 关闭防火墙 执行指令 : systemctl stop firewalld 关闭之后，再次访问Tomcat，就可以访问到了。 注意: 上面我们也提到了，直接关闭系统的防火墙，是不建议的，因为这样会造成系统不安全。 B. 开放Tomcat的端口号8080 执行指令: ①. 先开启系统防火墙 systemctl start firewalld ②. 再开放8080端口号 firewall-cmd --zone=public --add-port=8080/tcp --permanent ③. 重新加载防火墙 firewall-cmd --reload 执行上述的操作之后，就开放了当前系统中的8080端口号，再次访问Tomcat。 5.3.4 停止Tomcat在Linux系统中，停止Tomcat服务的方式主要有两种： 1). 运行Tomcat提供的脚本文件 在Tomcat安装目录下有一个bin目录，这个目录中存放的是tomcat的运行脚本文件，其中有一个脚本就是用于停止tomcat服务的。 我们可以切换到bin目录，并执行如下指令，来停止Tomcat服务： sh shutdown.sh ./shutdown.sh 2). 结束Tomcat进程 我们可以先通过 ps -ef|grep tomcat 指令查看tomcat进程的信息，从进程信息中获取tomcat服务的进程号。然后通过kill -9 的形式，来杀死系统进程。 通过上述的指令，我们可以获取到tomcat的进程号为 79947。接下来，我们就可以通过指令 ，来杀死tomcat的进程 ： kill -9 79947 执行完上述指令之后，我们再访问Linux系统中的Tomcat，就访问不到了。 注意： ​ kill命令是Linux提供的用于结束进程的命令，-9表示强制结束 注意 ： ​ 虽然上述讲解的两种方式，都可以停止Tomcat服务，但是推荐使用第一种方式(./shutdown.sh)执行脚本来关闭tomcat服务，如果通过第一种方式停止不了tomcat了，这个时候，我们可以考虑使用第二种方式，强制杀死进程。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#532-tomcat进程查看"},{"categories":["Linux"],"content":" 5.3 安装Tomcat 5.3.1 Tomcat安装Tomcat的安装和上述JDK的安装采用相同的方式，都是使用二进制发布包的形式进行安装 具体安装步骤如下： 1). 上传安装包 使用FinalShell自带的上传工具将Tomcat的二进制发布包上传到Linux(与前面上传JDK安装包步骤一致)。 2). 解压安装包 将上传上来的安装包解压到指定目录/usr/local下，执行命令为 tar -zxvf apache-tomcat-7.0.57.tar.gz -C /usr/local 3). 启动Tomcat 进入Tomcat的bin目录启动服务。执行命令为: cd /usr/local/apache-tomcat-7.0.57/ cd bin sh startup.sh或者./startup.sh 5.3.2 Tomcat进程查看上述我们将Tomcat启动完成之后，并不能知道Tomcat是否正常运行，那么我们验证Tomcat启动是否成功，有多种方式，我们这里主要介绍常见的两种方式： 1). 查看启动日志 Tomcat的启动日志输出在Tomcat的安装目录下的logs目录中，Tomcat的启动及运行日志文件名为 catalina.out，所以我们查看Tomcat启动日志，主要可以通过两条指令，如下： 1). 分页查询Tomcat的日志信息 more /usr/local/apache-tomcat-7.0.57/logs/catalina.out 2). 查询日志文件尾部的50行记录 tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out 只要Tomcat在启动的过程中，日志输出没有报错，基本可以判定Tomcat启动成功了。 2). 查询系统进程 我们也可以通过Linux系统的查看系统进程的指令，来判定Tomcat进程是否存在，从而判定Tomcat是否启动。执行如下指令： ps -ef|grep tomcat 说明: ==ps==命令是linux下非常强大的进程查看命令，通过ps -ef可以查看当前运行的所有进程的详细信息 ==\"|\"== 在Linux中称为管道符，可以将前一个命令的结果输出给后一个命令作为输入 使用ps命令查看进程时，经常配合管道符和查找命令 grep 一起使用，来查看特定进程 5.3.3 防火墙操作前面我们已经通过日志的方式及查看系统进程的方式，验证了Tomcat服务已经正常启动，接下来我们就可以尝试访问一下。访问地址：http://192.168.138.130:8080，我们发现是访问不到的。 那为什么tomcat启动成功了，但就是访问不到呢？原因就在于Linux系统的防火墙，系统安装完毕后，系统启动时，防火墙自动启动，防火墙拦截了所有端口的访问。接下来我们就需要学习一下，如何操作防火墙，具体指令如下： 操作 指令 备注 查看防火墙状态 systemctl status firewalld / firewall-cmd –state 暂时关闭防火墙 systemctl stop firewalld 永久关闭防火墙(禁用开机自启) systemctl disable firewalld ==下次启动,才生效== 暂时开启防火墙 systemctl start firewalld 永久开启防火墙(启用开机自启) systemctl enable firewalld ==下次启动,才生效== 开放指定端口 firewall-cmd –zone=public –add-port=8080/tcp –permanent ==需要重新加载生效== 关闭指定端口 firewall-cmd –zone=public –remove-port=8080/tcp –permanent ==需要重新加载生效== 立即生效(重新加载) firewall-cmd –reload 查看开放端口 firewall-cmd –zone=public –list-ports 注意： ​ A. systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作 ​ B. firewall-cmd是Linux中专门用于控制防火墙的命令 ​ C. 为了保证系统安全，服务器的防火墙不建议关闭 那么我们要想访问到Tomcat，就可以采取两种类型的操作： A. 关闭防火墙 执行指令 : systemctl stop firewalld 关闭之后，再次访问Tomcat，就可以访问到了。 注意: 上面我们也提到了，直接关闭系统的防火墙，是不建议的，因为这样会造成系统不安全。 B. 开放Tomcat的端口号8080 执行指令: ①. 先开启系统防火墙 systemctl start firewalld ②. 再开放8080端口号 firewall-cmd --zone=public --add-port=8080/tcp --permanent ③. 重新加载防火墙 firewall-cmd --reload 执行上述的操作之后，就开放了当前系统中的8080端口号，再次访问Tomcat。 5.3.4 停止Tomcat在Linux系统中，停止Tomcat服务的方式主要有两种： 1). 运行Tomcat提供的脚本文件 在Tomcat安装目录下有一个bin目录，这个目录中存放的是tomcat的运行脚本文件，其中有一个脚本就是用于停止tomcat服务的。 我们可以切换到bin目录，并执行如下指令，来停止Tomcat服务： sh shutdown.sh ./shutdown.sh 2). 结束Tomcat进程 我们可以先通过 ps -ef|grep tomcat 指令查看tomcat进程的信息，从进程信息中获取tomcat服务的进程号。然后通过kill -9 的形式，来杀死系统进程。 通过上述的指令，我们可以获取到tomcat的进程号为 79947。接下来，我们就可以通过指令 ，来杀死tomcat的进程 ： kill -9 79947 执行完上述指令之后，我们再访问Linux系统中的Tomcat，就访问不到了。 注意： ​ kill命令是Linux提供的用于结束进程的命令，-9表示强制结束 注意 ： ​ 虽然上述讲解的两种方式，都可以停止Tomcat服务，但是推荐使用第一种方式(./shutdown.sh)执行脚本来关闭tomcat服务，如果通过第一种方式停止不了tomcat了，这个时候，我们可以考虑使用第二种方式，强制杀死进程。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#533-防火墙操作"},{"categories":["Linux"],"content":" 5.3 安装Tomcat 5.3.1 Tomcat安装Tomcat的安装和上述JDK的安装采用相同的方式，都是使用二进制发布包的形式进行安装 具体安装步骤如下： 1). 上传安装包 使用FinalShell自带的上传工具将Tomcat的二进制发布包上传到Linux(与前面上传JDK安装包步骤一致)。 2). 解压安装包 将上传上来的安装包解压到指定目录/usr/local下，执行命令为 tar -zxvf apache-tomcat-7.0.57.tar.gz -C /usr/local 3). 启动Tomcat 进入Tomcat的bin目录启动服务。执行命令为: cd /usr/local/apache-tomcat-7.0.57/ cd bin sh startup.sh或者./startup.sh 5.3.2 Tomcat进程查看上述我们将Tomcat启动完成之后，并不能知道Tomcat是否正常运行，那么我们验证Tomcat启动是否成功，有多种方式，我们这里主要介绍常见的两种方式： 1). 查看启动日志 Tomcat的启动日志输出在Tomcat的安装目录下的logs目录中，Tomcat的启动及运行日志文件名为 catalina.out，所以我们查看Tomcat启动日志，主要可以通过两条指令，如下： 1). 分页查询Tomcat的日志信息 more /usr/local/apache-tomcat-7.0.57/logs/catalina.out 2). 查询日志文件尾部的50行记录 tail -50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out 只要Tomcat在启动的过程中，日志输出没有报错，基本可以判定Tomcat启动成功了。 2). 查询系统进程 我们也可以通过Linux系统的查看系统进程的指令，来判定Tomcat进程是否存在，从而判定Tomcat是否启动。执行如下指令： ps -ef|grep tomcat 说明: ==ps==命令是linux下非常强大的进程查看命令，通过ps -ef可以查看当前运行的所有进程的详细信息 ==\"|\"== 在Linux中称为管道符，可以将前一个命令的结果输出给后一个命令作为输入 使用ps命令查看进程时，经常配合管道符和查找命令 grep 一起使用，来查看特定进程 5.3.3 防火墙操作前面我们已经通过日志的方式及查看系统进程的方式，验证了Tomcat服务已经正常启动，接下来我们就可以尝试访问一下。访问地址：http://192.168.138.130:8080，我们发现是访问不到的。 那为什么tomcat启动成功了，但就是访问不到呢？原因就在于Linux系统的防火墙，系统安装完毕后，系统启动时，防火墙自动启动，防火墙拦截了所有端口的访问。接下来我们就需要学习一下，如何操作防火墙，具体指令如下： 操作 指令 备注 查看防火墙状态 systemctl status firewalld / firewall-cmd –state 暂时关闭防火墙 systemctl stop firewalld 永久关闭防火墙(禁用开机自启) systemctl disable firewalld ==下次启动,才生效== 暂时开启防火墙 systemctl start firewalld 永久开启防火墙(启用开机自启) systemctl enable firewalld ==下次启动,才生效== 开放指定端口 firewall-cmd –zone=public –add-port=8080/tcp –permanent ==需要重新加载生效== 关闭指定端口 firewall-cmd –zone=public –remove-port=8080/tcp –permanent ==需要重新加载生效== 立即生效(重新加载) firewall-cmd –reload 查看开放端口 firewall-cmd –zone=public –list-ports 注意： ​ A. systemctl是管理Linux中服务的命令，可以对服务进行启动、停止、重启、查看状态等操作 ​ B. firewall-cmd是Linux中专门用于控制防火墙的命令 ​ C. 为了保证系统安全，服务器的防火墙不建议关闭 那么我们要想访问到Tomcat，就可以采取两种类型的操作： A. 关闭防火墙 执行指令 : systemctl stop firewalld 关闭之后，再次访问Tomcat，就可以访问到了。 注意: 上面我们也提到了，直接关闭系统的防火墙，是不建议的，因为这样会造成系统不安全。 B. 开放Tomcat的端口号8080 执行指令: ①. 先开启系统防火墙 systemctl start firewalld ②. 再开放8080端口号 firewall-cmd --zone=public --add-port=8080/tcp --permanent ③. 重新加载防火墙 firewall-cmd --reload 执行上述的操作之后，就开放了当前系统中的8080端口号，再次访问Tomcat。 5.3.4 停止Tomcat在Linux系统中，停止Tomcat服务的方式主要有两种： 1). 运行Tomcat提供的脚本文件 在Tomcat安装目录下有一个bin目录，这个目录中存放的是tomcat的运行脚本文件，其中有一个脚本就是用于停止tomcat服务的。 我们可以切换到bin目录，并执行如下指令，来停止Tomcat服务： sh shutdown.sh ./shutdown.sh 2). 结束Tomcat进程 我们可以先通过 ps -ef|grep tomcat 指令查看tomcat进程的信息，从进程信息中获取tomcat服务的进程号。然后通过kill -9 的形式，来杀死系统进程。 通过上述的指令，我们可以获取到tomcat的进程号为 79947。接下来，我们就可以通过指令 ，来杀死tomcat的进程 ： kill -9 79947 执行完上述指令之后，我们再访问Linux系统中的Tomcat，就访问不到了。 注意： ​ kill命令是Linux提供的用于结束进程的命令，-9表示强制结束 注意 ： ​ 虽然上述讲解的两种方式，都可以停止Tomcat服务，但是推荐使用第一种方式(./shutdown.sh)执行脚本来关闭tomcat服务，如果通过第一种方式停止不了tomcat了，这个时候，我们可以考虑使用第二种方式，强制杀死进程。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:3","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#534-停止tomcat"},{"categories":["Linux"],"content":" 5.4 安装MySQL 5.4.1 MySQL安装对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了解一下什么rpm？ **RPM：**全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安装软件的工具。 我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下： 1). 检测当前系统是否安装过MySQL相关数据库 需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下： rpm -qa 查询当前系统中安装的所有软件 rpm -qa | grep mysql 查询当前系统中安装的名称带mysql的软件 rpm -qa | grep mariadb 查询当前系统中安装的名称带mariadb的软件 通过rpm -qa 查询到系统通过rpm安装的所有软件，太多了，不方便查看，所以我们可以通过管道符 | 配合着grep进行过滤查询。 通过查询，我们发现在当前系统中存在mariadb数据库，是CentOS7中自带的，而这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。 2). 卸载现有的MySQL数据库 在rpm中，卸载软件的语法为： rpm -e --nodeps 软件名称 那么，我们就可以通过指令，卸载 mariadb，具体指令为： rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。 3). 将MySQL安装包上传到Linux并解压 A. 上传MySQL安装包 我们需要将该安装包上传到Linux系统的根目录 / 下面。 B. 解压到/usr/local/mysql 执行如下指令: mkdir /usr/local/mysql tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C /usr/local/mysql 4). 安装顺序安装rpm安装包 cd /usr/local/mysql/ rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm yum install net-tools rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm 说明: 因为rpm安装方式，是不会自动处理依赖关系的，需要我们自己处理，所以对于上面的rpm包的安装顺序不能随意修改。 安装过程中提示缺少net-tools依赖，使用yum安装(yum是一种在线安装方式，需要保证联网) 可以通过指令(yum update)升级现有软件及系统内核 5.4.2 MySQL启动MySQL安装完成之后，会自动注册为系统的服务，服务名为mysqld。那么，我们就可以通过systemctl指令来查看mysql的状态、启动mysql、停止mysql。 systemctl status mysqld 查看mysql服务状态 systemctl start mysqld 启动mysql服务 systemctl stop mysqld 停止mysql服务 说明： ​ 可以设置开机时启动mysql服务，避免每次开机启动mysql。执行如下指令： ​ systemctl enable mysqld 我们可以通过如下两种方式，来判定mysql是否启动： netstat -tunlp 查看已经启动的服务 netstat -tunlp | grep mysql 查看mysql的服务信息 ps –ef | grep mysql 查看mysql进程 备注: ​ A. netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。 ​ 参数说明: ​ -l或–listening：显示监控中的服务器的Socket； ​ -n或–numeric：直接使用ip地址，而不通过域名服务器； ​ -p或–programs：显示正在使用Socket的程序识别码和程序名称； ​ -t或–tcp：显示TCP传输协议的连线状况； ​ -u或–udp：显示UDP传输协议的连线状况； ​ B. ps命令用于查看Linux中的进程数据。 5.4.3 MySQL登录 5.4.3.1 查阅临时密码MySQL启动起来之后，我们就可以测试一下登录操作，但是我们要想登录MySQL，需要一个访问密码，而刚才在安装MySQL的过程中，并没有看到让我们设置访问密码，那这个访问密码是多少呢? 那实际上，对于rpm安装的mysql，在mysql第一次启动时，会自动帮我们生成root用户的访问密码，并且输出在mysql的日志文件 /var/log/mysqld.log中，我们可以查看这份日志文件，从而获取到访问密码。 可以执行如下指令： 1). cat /var/log/mysqld.log 这种方式，可以看到所有的日志数据，文件比较大时，很不方便查看数据。我们可以通过管道符 | 配合grep来对数据进行过滤。 2). cat /var/log/mysqld.log | grep password 我们可以通过上述指令，查询日志文件内容中包含password的行信息。 5.4.3.2 登录MySQL获取到root用户的临时密码之后，我们就可以登录mysql数据库，修改root的密码，为root设置一个新的密码。并且我们还需要开启root用户远程访问该数据库的权限，这样的话，我们就可以在windows上来访问这台MySQL数据库。 执行如下指令： ①. 登录mysql（复制日志中的临时密码登录） mysql -uroot -p ②. 修改密码 set global validate_password_length=4; 设置密码长度最低位数 set global validate_password_policy=LOW; 设置密码安全等级低，便于密码可以修改成root set password = password('root'); 设置密码为root ③. 开启访问权限 grant all on *.* to 'root'@'%' identified by 'root'; flush privileges; 操作完上述的指令之后，数据库root用户的密码以及远程访问我们就配置好了，接下来，可以执行exit退出mysql，再次通过新的密码进行登录。 当然我们也可以使用安装在windows系统中的sqlyog或者Navicat来远程连接linux上的MySQL。 ==注意： 要想在windows上能够访问MySQL，还需要开放防火墙的3306端口，执行如下指令：== firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --reload ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:4","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#54-安装mysql"},{"categories":["Linux"],"content":" 5.4 安装MySQL 5.4.1 MySQL安装对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了解一下什么rpm？ **RPM：**全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安装软件的工具。 我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下： 1). 检测当前系统是否安装过MySQL相关数据库 需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下： rpm -qa 查询当前系统中安装的所有软件 rpm -qa | grep mysql 查询当前系统中安装的名称带mysql的软件 rpm -qa | grep mariadb 查询当前系统中安装的名称带mariadb的软件 通过rpm -qa 查询到系统通过rpm安装的所有软件，太多了，不方便查看，所以我们可以通过管道符 | 配合着grep进行过滤查询。 通过查询，我们发现在当前系统中存在mariadb数据库，是CentOS7中自带的，而这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。 2). 卸载现有的MySQL数据库 在rpm中，卸载软件的语法为： rpm -e --nodeps 软件名称 那么，我们就可以通过指令，卸载 mariadb，具体指令为： rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。 3). 将MySQL安装包上传到Linux并解压 A. 上传MySQL安装包 我们需要将该安装包上传到Linux系统的根目录 / 下面。 B. 解压到/usr/local/mysql 执行如下指令: mkdir /usr/local/mysql tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C /usr/local/mysql 4). 安装顺序安装rpm安装包 cd /usr/local/mysql/ rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm yum install net-tools rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm 说明: 因为rpm安装方式，是不会自动处理依赖关系的，需要我们自己处理，所以对于上面的rpm包的安装顺序不能随意修改。 安装过程中提示缺少net-tools依赖，使用yum安装(yum是一种在线安装方式，需要保证联网) 可以通过指令(yum update)升级现有软件及系统内核 5.4.2 MySQL启动MySQL安装完成之后，会自动注册为系统的服务，服务名为mysqld。那么，我们就可以通过systemctl指令来查看mysql的状态、启动mysql、停止mysql。 systemctl status mysqld 查看mysql服务状态 systemctl start mysqld 启动mysql服务 systemctl stop mysqld 停止mysql服务 说明： ​ 可以设置开机时启动mysql服务，避免每次开机启动mysql。执行如下指令： ​ systemctl enable mysqld 我们可以通过如下两种方式，来判定mysql是否启动： netstat -tunlp 查看已经启动的服务 netstat -tunlp | grep mysql 查看mysql的服务信息 ps –ef | grep mysql 查看mysql进程 备注: ​ A. netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。 ​ 参数说明: ​ -l或–listening：显示监控中的服务器的Socket； ​ -n或–numeric：直接使用ip地址，而不通过域名服务器； ​ -p或–programs：显示正在使用Socket的程序识别码和程序名称； ​ -t或–tcp：显示TCP传输协议的连线状况； ​ -u或–udp：显示UDP传输协议的连线状况； ​ B. ps命令用于查看Linux中的进程数据。 5.4.3 MySQL登录 5.4.3.1 查阅临时密码MySQL启动起来之后，我们就可以测试一下登录操作，但是我们要想登录MySQL，需要一个访问密码，而刚才在安装MySQL的过程中，并没有看到让我们设置访问密码，那这个访问密码是多少呢? 那实际上，对于rpm安装的mysql，在mysql第一次启动时，会自动帮我们生成root用户的访问密码，并且输出在mysql的日志文件 /var/log/mysqld.log中，我们可以查看这份日志文件，从而获取到访问密码。 可以执行如下指令： 1). cat /var/log/mysqld.log 这种方式，可以看到所有的日志数据，文件比较大时，很不方便查看数据。我们可以通过管道符 | 配合grep来对数据进行过滤。 2). cat /var/log/mysqld.log | grep password 我们可以通过上述指令，查询日志文件内容中包含password的行信息。 5.4.3.2 登录MySQL获取到root用户的临时密码之后，我们就可以登录mysql数据库，修改root的密码，为root设置一个新的密码。并且我们还需要开启root用户远程访问该数据库的权限，这样的话，我们就可以在windows上来访问这台MySQL数据库。 执行如下指令： ①. 登录mysql（复制日志中的临时密码登录） mysql -uroot -p ②. 修改密码 set global validate_password_length=4; 设置密码长度最低位数 set global validate_password_policy=LOW; 设置密码安全等级低，便于密码可以修改成root set password = password('root'); 设置密码为root ③. 开启访问权限 grant all on *.* to 'root'@'%' identified by 'root'; flush privileges; 操作完上述的指令之后，数据库root用户的密码以及远程访问我们就配置好了，接下来，可以执行exit退出mysql，再次通过新的密码进行登录。 当然我们也可以使用安装在windows系统中的sqlyog或者Navicat来远程连接linux上的MySQL。 ==注意： 要想在windows上能够访问MySQL，还需要开放防火墙的3306端口，执行如下指令：== firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --reload ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:4","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#541-mysql安装"},{"categories":["Linux"],"content":" 5.4 安装MySQL 5.4.1 MySQL安装对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了解一下什么rpm？ **RPM：**全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安装软件的工具。 我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下： 1). 检测当前系统是否安装过MySQL相关数据库 需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下： rpm -qa 查询当前系统中安装的所有软件 rpm -qa | grep mysql 查询当前系统中安装的名称带mysql的软件 rpm -qa | grep mariadb 查询当前系统中安装的名称带mariadb的软件 通过rpm -qa 查询到系统通过rpm安装的所有软件，太多了，不方便查看，所以我们可以通过管道符 | 配合着grep进行过滤查询。 通过查询，我们发现在当前系统中存在mariadb数据库，是CentOS7中自带的，而这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。 2). 卸载现有的MySQL数据库 在rpm中，卸载软件的语法为： rpm -e --nodeps 软件名称 那么，我们就可以通过指令，卸载 mariadb，具体指令为： rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。 3). 将MySQL安装包上传到Linux并解压 A. 上传MySQL安装包 我们需要将该安装包上传到Linux系统的根目录 / 下面。 B. 解压到/usr/local/mysql 执行如下指令: mkdir /usr/local/mysql tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C /usr/local/mysql 4). 安装顺序安装rpm安装包 cd /usr/local/mysql/ rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm yum install net-tools rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm 说明: 因为rpm安装方式，是不会自动处理依赖关系的，需要我们自己处理，所以对于上面的rpm包的安装顺序不能随意修改。 安装过程中提示缺少net-tools依赖，使用yum安装(yum是一种在线安装方式，需要保证联网) 可以通过指令(yum update)升级现有软件及系统内核 5.4.2 MySQL启动MySQL安装完成之后，会自动注册为系统的服务，服务名为mysqld。那么，我们就可以通过systemctl指令来查看mysql的状态、启动mysql、停止mysql。 systemctl status mysqld 查看mysql服务状态 systemctl start mysqld 启动mysql服务 systemctl stop mysqld 停止mysql服务 说明： ​ 可以设置开机时启动mysql服务，避免每次开机启动mysql。执行如下指令： ​ systemctl enable mysqld 我们可以通过如下两种方式，来判定mysql是否启动： netstat -tunlp 查看已经启动的服务 netstat -tunlp | grep mysql 查看mysql的服务信息 ps –ef | grep mysql 查看mysql进程 备注: ​ A. netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。 ​ 参数说明: ​ -l或–listening：显示监控中的服务器的Socket； ​ -n或–numeric：直接使用ip地址，而不通过域名服务器； ​ -p或–programs：显示正在使用Socket的程序识别码和程序名称； ​ -t或–tcp：显示TCP传输协议的连线状况； ​ -u或–udp：显示UDP传输协议的连线状况； ​ B. ps命令用于查看Linux中的进程数据。 5.4.3 MySQL登录 5.4.3.1 查阅临时密码MySQL启动起来之后，我们就可以测试一下登录操作，但是我们要想登录MySQL，需要一个访问密码，而刚才在安装MySQL的过程中，并没有看到让我们设置访问密码，那这个访问密码是多少呢? 那实际上，对于rpm安装的mysql，在mysql第一次启动时，会自动帮我们生成root用户的访问密码，并且输出在mysql的日志文件 /var/log/mysqld.log中，我们可以查看这份日志文件，从而获取到访问密码。 可以执行如下指令： 1). cat /var/log/mysqld.log 这种方式，可以看到所有的日志数据，文件比较大时，很不方便查看数据。我们可以通过管道符 | 配合grep来对数据进行过滤。 2). cat /var/log/mysqld.log | grep password 我们可以通过上述指令，查询日志文件内容中包含password的行信息。 5.4.3.2 登录MySQL获取到root用户的临时密码之后，我们就可以登录mysql数据库，修改root的密码，为root设置一个新的密码。并且我们还需要开启root用户远程访问该数据库的权限，这样的话，我们就可以在windows上来访问这台MySQL数据库。 执行如下指令： ①. 登录mysql（复制日志中的临时密码登录） mysql -uroot -p ②. 修改密码 set global validate_password_length=4; 设置密码长度最低位数 set global validate_password_policy=LOW; 设置密码安全等级低，便于密码可以修改成root set password = password('root'); 设置密码为root ③. 开启访问权限 grant all on *.* to 'root'@'%' identified by 'root'; flush privileges; 操作完上述的指令之后，数据库root用户的密码以及远程访问我们就配置好了，接下来，可以执行exit退出mysql，再次通过新的密码进行登录。 当然我们也可以使用安装在windows系统中的sqlyog或者Navicat来远程连接linux上的MySQL。 ==注意： 要想在windows上能够访问MySQL，还需要开放防火墙的3306端口，执行如下指令：== firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --reload ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:4","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#542-mysql启动"},{"categories":["Linux"],"content":" 5.4 安装MySQL 5.4.1 MySQL安装对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了解一下什么rpm？ **RPM：**全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安装软件的工具。 我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下： 1). 检测当前系统是否安装过MySQL相关数据库 需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下： rpm -qa 查询当前系统中安装的所有软件 rpm -qa | grep mysql 查询当前系统中安装的名称带mysql的软件 rpm -qa | grep mariadb 查询当前系统中安装的名称带mariadb的软件 通过rpm -qa 查询到系统通过rpm安装的所有软件，太多了，不方便查看，所以我们可以通过管道符 | 配合着grep进行过滤查询。 通过查询，我们发现在当前系统中存在mariadb数据库，是CentOS7中自带的，而这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。 2). 卸载现有的MySQL数据库 在rpm中，卸载软件的语法为： rpm -e --nodeps 软件名称 那么，我们就可以通过指令，卸载 mariadb，具体指令为： rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。 3). 将MySQL安装包上传到Linux并解压 A. 上传MySQL安装包 我们需要将该安装包上传到Linux系统的根目录 / 下面。 B. 解压到/usr/local/mysql 执行如下指令: mkdir /usr/local/mysql tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C /usr/local/mysql 4). 安装顺序安装rpm安装包 cd /usr/local/mysql/ rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm yum install net-tools rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm 说明: 因为rpm安装方式，是不会自动处理依赖关系的，需要我们自己处理，所以对于上面的rpm包的安装顺序不能随意修改。 安装过程中提示缺少net-tools依赖，使用yum安装(yum是一种在线安装方式，需要保证联网) 可以通过指令(yum update)升级现有软件及系统内核 5.4.2 MySQL启动MySQL安装完成之后，会自动注册为系统的服务，服务名为mysqld。那么，我们就可以通过systemctl指令来查看mysql的状态、启动mysql、停止mysql。 systemctl status mysqld 查看mysql服务状态 systemctl start mysqld 启动mysql服务 systemctl stop mysqld 停止mysql服务 说明： ​ 可以设置开机时启动mysql服务，避免每次开机启动mysql。执行如下指令： ​ systemctl enable mysqld 我们可以通过如下两种方式，来判定mysql是否启动： netstat -tunlp 查看已经启动的服务 netstat -tunlp | grep mysql 查看mysql的服务信息 ps –ef | grep mysql 查看mysql进程 备注: ​ A. netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。 ​ 参数说明: ​ -l或–listening：显示监控中的服务器的Socket； ​ -n或–numeric：直接使用ip地址，而不通过域名服务器； ​ -p或–programs：显示正在使用Socket的程序识别码和程序名称； ​ -t或–tcp：显示TCP传输协议的连线状况； ​ -u或–udp：显示UDP传输协议的连线状况； ​ B. ps命令用于查看Linux中的进程数据。 5.4.3 MySQL登录 5.4.3.1 查阅临时密码MySQL启动起来之后，我们就可以测试一下登录操作，但是我们要想登录MySQL，需要一个访问密码，而刚才在安装MySQL的过程中，并没有看到让我们设置访问密码，那这个访问密码是多少呢? 那实际上，对于rpm安装的mysql，在mysql第一次启动时，会自动帮我们生成root用户的访问密码，并且输出在mysql的日志文件 /var/log/mysqld.log中，我们可以查看这份日志文件，从而获取到访问密码。 可以执行如下指令： 1). cat /var/log/mysqld.log 这种方式，可以看到所有的日志数据，文件比较大时，很不方便查看数据。我们可以通过管道符 | 配合grep来对数据进行过滤。 2). cat /var/log/mysqld.log | grep password 我们可以通过上述指令，查询日志文件内容中包含password的行信息。 5.4.3.2 登录MySQL获取到root用户的临时密码之后，我们就可以登录mysql数据库，修改root的密码，为root设置一个新的密码。并且我们还需要开启root用户远程访问该数据库的权限，这样的话，我们就可以在windows上来访问这台MySQL数据库。 执行如下指令： ①. 登录mysql（复制日志中的临时密码登录） mysql -uroot -p ②. 修改密码 set global validate_password_length=4; 设置密码长度最低位数 set global validate_password_policy=LOW; 设置密码安全等级低，便于密码可以修改成root set password = password('root'); 设置密码为root ③. 开启访问权限 grant all on *.* to 'root'@'%' identified by 'root'; flush privileges; 操作完上述的指令之后，数据库root用户的密码以及远程访问我们就配置好了，接下来，可以执行exit退出mysql，再次通过新的密码进行登录。 当然我们也可以使用安装在windows系统中的sqlyog或者Navicat来远程连接linux上的MySQL。 ==注意： 要想在windows上能够访问MySQL，还需要开放防火墙的3306端口，执行如下指令：== firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --reload ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:4","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#543-mysql登录"},{"categories":["Linux"],"content":" 5.4 安装MySQL 5.4.1 MySQL安装对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了解一下什么rpm？ **RPM：**全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安装软件的工具。 我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下： 1). 检测当前系统是否安装过MySQL相关数据库 需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下： rpm -qa 查询当前系统中安装的所有软件 rpm -qa | grep mysql 查询当前系统中安装的名称带mysql的软件 rpm -qa | grep mariadb 查询当前系统中安装的名称带mariadb的软件 通过rpm -qa 查询到系统通过rpm安装的所有软件，太多了，不方便查看，所以我们可以通过管道符 | 配合着grep进行过滤查询。 通过查询，我们发现在当前系统中存在mariadb数据库，是CentOS7中自带的，而这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。 2). 卸载现有的MySQL数据库 在rpm中，卸载软件的语法为： rpm -e --nodeps 软件名称 那么，我们就可以通过指令，卸载 mariadb，具体指令为： rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。 3). 将MySQL安装包上传到Linux并解压 A. 上传MySQL安装包 我们需要将该安装包上传到Linux系统的根目录 / 下面。 B. 解压到/usr/local/mysql 执行如下指令: mkdir /usr/local/mysql tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C /usr/local/mysql 4). 安装顺序安装rpm安装包 cd /usr/local/mysql/ rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm yum install net-tools rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm 说明: 因为rpm安装方式，是不会自动处理依赖关系的，需要我们自己处理，所以对于上面的rpm包的安装顺序不能随意修改。 安装过程中提示缺少net-tools依赖，使用yum安装(yum是一种在线安装方式，需要保证联网) 可以通过指令(yum update)升级现有软件及系统内核 5.4.2 MySQL启动MySQL安装完成之后，会自动注册为系统的服务，服务名为mysqld。那么，我们就可以通过systemctl指令来查看mysql的状态、启动mysql、停止mysql。 systemctl status mysqld 查看mysql服务状态 systemctl start mysqld 启动mysql服务 systemctl stop mysqld 停止mysql服务 说明： ​ 可以设置开机时启动mysql服务，避免每次开机启动mysql。执行如下指令： ​ systemctl enable mysqld 我们可以通过如下两种方式，来判定mysql是否启动： netstat -tunlp 查看已经启动的服务 netstat -tunlp | grep mysql 查看mysql的服务信息 ps –ef | grep mysql 查看mysql进程 备注: ​ A. netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。 ​ 参数说明: ​ -l或–listening：显示监控中的服务器的Socket； ​ -n或–numeric：直接使用ip地址，而不通过域名服务器； ​ -p或–programs：显示正在使用Socket的程序识别码和程序名称； ​ -t或–tcp：显示TCP传输协议的连线状况； ​ -u或–udp：显示UDP传输协议的连线状况； ​ B. ps命令用于查看Linux中的进程数据。 5.4.3 MySQL登录 5.4.3.1 查阅临时密码MySQL启动起来之后，我们就可以测试一下登录操作，但是我们要想登录MySQL，需要一个访问密码，而刚才在安装MySQL的过程中，并没有看到让我们设置访问密码，那这个访问密码是多少呢? 那实际上，对于rpm安装的mysql，在mysql第一次启动时，会自动帮我们生成root用户的访问密码，并且输出在mysql的日志文件 /var/log/mysqld.log中，我们可以查看这份日志文件，从而获取到访问密码。 可以执行如下指令： 1). cat /var/log/mysqld.log 这种方式，可以看到所有的日志数据，文件比较大时，很不方便查看数据。我们可以通过管道符 | 配合grep来对数据进行过滤。 2). cat /var/log/mysqld.log | grep password 我们可以通过上述指令，查询日志文件内容中包含password的行信息。 5.4.3.2 登录MySQL获取到root用户的临时密码之后，我们就可以登录mysql数据库，修改root的密码，为root设置一个新的密码。并且我们还需要开启root用户远程访问该数据库的权限，这样的话，我们就可以在windows上来访问这台MySQL数据库。 执行如下指令： ①. 登录mysql（复制日志中的临时密码登录） mysql -uroot -p ②. 修改密码 set global validate_password_length=4; 设置密码长度最低位数 set global validate_password_policy=LOW; 设置密码安全等级低，便于密码可以修改成root set password = password('root'); 设置密码为root ③. 开启访问权限 grant all on *.* to 'root'@'%' identified by 'root'; flush privileges; 操作完上述的指令之后，数据库root用户的密码以及远程访问我们就配置好了，接下来，可以执行exit退出mysql，再次通过新的密码进行登录。 当然我们也可以使用安装在windows系统中的sqlyog或者Navicat来远程连接linux上的MySQL。 ==注意： 要想在windows上能够访问MySQL，还需要开放防火墙的3306端口，执行如下指令：== firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --reload ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:4","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#5431-查阅临时密码"},{"categories":["Linux"],"content":" 5.4 安装MySQL 5.4.1 MySQL安装对于MySQL数据库的安装，我们将要使用前面讲解的第二种安装方式rpm进行安装。那么首先我们先了解一下什么rpm？ **RPM：**全称为 Red-Hat Package Manager，RPM软件包管理器，是红帽Linux用于管理和安装软件的工具。 我们要通过rpm，进行MySQL数据库的安装，主要的步骤如下： 1). 检测当前系统是否安装过MySQL相关数据库 需要通过rpm相关指令，来查询当前系统中是否存在已安装的mysql软件包，执行指令如下： rpm -qa 查询当前系统中安装的所有软件 rpm -qa | grep mysql 查询当前系统中安装的名称带mysql的软件 rpm -qa | grep mariadb 查询当前系统中安装的名称带mariadb的软件 通过rpm -qa 查询到系统通过rpm安装的所有软件，太多了，不方便查看，所以我们可以通过管道符 | 配合着grep进行过滤查询。 通过查询，我们发现在当前系统中存在mariadb数据库，是CentOS7中自带的，而这个数据库和MySQL数据库是冲突的，所以要想保证MySQL成功安装，需要卸载mariadb数据库。 2). 卸载现有的MySQL数据库 在rpm中，卸载软件的语法为： rpm -e --nodeps 软件名称 那么，我们就可以通过指令，卸载 mariadb，具体指令为： rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 我们看到执行完毕之后， 再次查询 mariadb，就查不到了，因为已经被成功卸载了。 3). 将MySQL安装包上传到Linux并解压 A. 上传MySQL安装包 我们需要将该安装包上传到Linux系统的根目录 / 下面。 B. 解压到/usr/local/mysql 执行如下指令: mkdir /usr/local/mysql tar -zxvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar.gz -C /usr/local/mysql 4). 安装顺序安装rpm安装包 cd /usr/local/mysql/ rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-devel-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-compat-5.7.25-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpm yum install net-tools rpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm 说明: 因为rpm安装方式，是不会自动处理依赖关系的，需要我们自己处理，所以对于上面的rpm包的安装顺序不能随意修改。 安装过程中提示缺少net-tools依赖，使用yum安装(yum是一种在线安装方式，需要保证联网) 可以通过指令(yum update)升级现有软件及系统内核 5.4.2 MySQL启动MySQL安装完成之后，会自动注册为系统的服务，服务名为mysqld。那么，我们就可以通过systemctl指令来查看mysql的状态、启动mysql、停止mysql。 systemctl status mysqld 查看mysql服务状态 systemctl start mysqld 启动mysql服务 systemctl stop mysqld 停止mysql服务 说明： ​ 可以设置开机时启动mysql服务，避免每次开机启动mysql。执行如下指令： ​ systemctl enable mysqld 我们可以通过如下两种方式，来判定mysql是否启动： netstat -tunlp 查看已经启动的服务 netstat -tunlp | grep mysql 查看mysql的服务信息 ps –ef | grep mysql 查看mysql进程 备注: ​ A. netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。 ​ 参数说明: ​ -l或–listening：显示监控中的服务器的Socket； ​ -n或–numeric：直接使用ip地址，而不通过域名服务器； ​ -p或–programs：显示正在使用Socket的程序识别码和程序名称； ​ -t或–tcp：显示TCP传输协议的连线状况； ​ -u或–udp：显示UDP传输协议的连线状况； ​ B. ps命令用于查看Linux中的进程数据。 5.4.3 MySQL登录 5.4.3.1 查阅临时密码MySQL启动起来之后，我们就可以测试一下登录操作，但是我们要想登录MySQL，需要一个访问密码，而刚才在安装MySQL的过程中，并没有看到让我们设置访问密码，那这个访问密码是多少呢? 那实际上，对于rpm安装的mysql，在mysql第一次启动时，会自动帮我们生成root用户的访问密码，并且输出在mysql的日志文件 /var/log/mysqld.log中，我们可以查看这份日志文件，从而获取到访问密码。 可以执行如下指令： 1). cat /var/log/mysqld.log 这种方式，可以看到所有的日志数据，文件比较大时，很不方便查看数据。我们可以通过管道符 | 配合grep来对数据进行过滤。 2). cat /var/log/mysqld.log | grep password 我们可以通过上述指令，查询日志文件内容中包含password的行信息。 5.4.3.2 登录MySQL获取到root用户的临时密码之后，我们就可以登录mysql数据库，修改root的密码，为root设置一个新的密码。并且我们还需要开启root用户远程访问该数据库的权限，这样的话，我们就可以在windows上来访问这台MySQL数据库。 执行如下指令： ①. 登录mysql（复制日志中的临时密码登录） mysql -uroot -p ②. 修改密码 set global validate_password_length=4; 设置密码长度最低位数 set global validate_password_policy=LOW; 设置密码安全等级低，便于密码可以修改成root set password = password('root'); 设置密码为root ③. 开启访问权限 grant all on *.* to 'root'@'%' identified by 'root'; flush privileges; 操作完上述的指令之后，数据库root用户的密码以及远程访问我们就配置好了，接下来，可以执行exit退出mysql，再次通过新的密码进行登录。 当然我们也可以使用安装在windows系统中的sqlyog或者Navicat来远程连接linux上的MySQL。 ==注意： 要想在windows上能够访问MySQL，还需要开放防火墙的3306端口，执行如下指令：== firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --reload ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:4","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#5432-登录mysql"},{"categories":["Linux"],"content":" 5.5 安装lrzszlrzsz 是用于在Linux系统中文件上传下载的软件。大家可能会存在疑问，我们用finalShell图形化界面就可以很方便的完成上传下载，为什么还要使用这个软件来完成上传下载呢？实际上是这样的，Linux的远程连接工具有很多，而finalShell只是其中的一种，而还有很多的远程连接工具并没有上传下载的功能，这个时候就需要依赖于lrzsz这个软件了。 对于lrzsz的安装，我们需要通过第三种软件安装方式yum来进行安装。这里，我们先对yum做一个简单介绍。 Yum： (Yellow dog Updater,Modified)，是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。 安装lrzsz的步骤如下: 1). 搜索lrzsz安装包 yum list lrzsz 2). 在线安装lrzsz yum install lrzsz.x86_64 3). 测试 在命令行中输入 rz , 就会自动打开一个文件选择的窗口，然后选择要上传的文件。 yum拓展知识: ​ 1). 如果在不更改软件来源的情况下，是需要联网才能使用yum的，那么我们安装的软件是从哪儿下载的呢，这里就涉及到一个概念： yum源。 ​ ​ 2). 我们可以通过一个指令，来检查当前的yum源 ​ ​ 从图中，我们可以看到我们安装的 CentOS7 采用的是网易的163yum源。 ​ ​ 3). 网络 yum 源配置文件位于 /etc/yum.repos.d/ 目录下，文件扩展名为\"*.repo\" ​ ​ 可以看到，该目录下有 7 个 yum 配置文件，通常情况下 CentOS-Base.repo 文件生效。 ​ ​ 4). 添加阿里云yum源 ​ A. 先通过 yum install wget ,安装wget命令 ​ B. 备份默认的网易163的yum源，执行指令 ： ​ 切换目录: cd /etc/yum.repos.d/ ​ 创建备份目录: mkdir bak ​ 移动现有的yum源文件到bak: mv *.repo bak/ ​ C. 下载阿里云的yum源 ​ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo ​ D. 执行命令，重新生成cache ​ yum clean all ​ yum makecache ​ E. 再次查看yum源 ​ ​ 之后，我们通过yum指令安装软件，就是从阿里云下载的。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:5:5","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#55-安装lrzsz"},{"categories":["Linux"],"content":" 6. 项目部署之前我们讲解Linux操作系统时，就提到，我们服务端开发工程师学习Linux系统的目的就是将来我们开发的项目绝大部分情况下都需要部署在Linux系统中。那么在本章节，我们将通过两种方式，来演示项目部署，分别是：手动部署项目 和 基于shell脚本自动部署。 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:0","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#6-项目部署"},{"categories":["Linux"],"content":" 6.1 手动部署项目1). 在IDEA中开发SpringBoot项目并打成jar包 项目是一个很简单的springboot项目，结构如下： 可以在本地的idea中先启动当前的demo工程，然后访问一下，看看工程是否正常访问。 执行package指令，进行打包操作，将当前的springboot项目，打成一个jar包。 2). 将jar包上传到Linux服务器 通过 rz 指令，将打好的jar包上传至Linux服务器的 /usr/local/app 目录下。 先执行指令创建app目录。 A. 在/usr/local下创建目录app mkdir /usr/local/app B. 切换到app目录下 cd /usr/local/app C. 执行指令,进行jar包上传 rz 此时这个jar包就上传到 /usr/local/app 目录了。 3). 启动SpringBoot程序 由于我们的项目已经打成jar包上传上来到Linux服务器，我们只需要运行这个jar包项目就启动起来了，所以只需要执行如下指令即可： java -jar helloworld-1.0-SNAPSHOT.jar ==注意： 由于前面安装的Tomcat在启动时，会占用端口号8080，而当前springboot项目我们没有配置端口号，默认也是8080，所以我们要想启动springboot项目，需要把之前运行的Tomcat停止掉。== 4). 检查防火墙，确保8080端口对外开放，访问SpringBoot项目 firewall-cmd --zone=public --list-ports 如果防火墙没有放开8080端口，还需要放开对应的端口号，执行如下指令： firewall-cmd --zone=public --add-port=8080/tcp --permanent 5). 访问测试 http://192.168.138.130:8080/hello 6). 后台运行项目 当前这个demo工程我们已经部署成功了，并且我们也可以访问项目了。但是这个工程目前是存在问题的，就是当前我们项目启动的这个窗口被霸屏占用了，如果我们把这个窗口关闭掉(或ctrl+c)，当前服务也就访问不到了，我们可以试一下。 目前程序运行的问题： A. 线上程序不会采用控制台霸屏的形式运行程序，而是将程序在后台运行 B. 线上程序不会将日志输出到控制台，而是输出到日志文件，方便运维查阅信息 后台运行程序: 要想让我们部署的项目进行后台运行，这个时候我们需要使用到linux中的一个命令 nohup ，接下来，就来介绍一下nohup命令。 **nohup命令：**英文全称 no hang up（不挂起），用于不挂断地运行指定命令，退出终端不会影响程序的运行 语法格式： nohup Command [ Arg … ] [\u0026] 参数说明： ​ Command：要执行的命令 ​ Arg：一些参数，可以指定输出文件 ​ \u0026：让命令在后台运行 举例： ​ nohup java -jar boot工程.jar \u0026\u003e hello.log \u0026 ​ 上述指令的含义为： 后台运行 java -jar 命令，并将日志输出到hello.log文件 那么经过上面的介绍，我们可以推测中，我们要想让当前部署的项目后台运行，就可以使用下面的指令： nohup java -jar helloworld-1.0-SNAPSHOT.jar \u0026\u003e hello.log \u0026 这样的话，我们的项目就已经启动成功了，我们可以通过ps指令，查看到系统的进程。 接下来，我们再次访问我们的项目，来看看服务是否可用。 7). 停止SpringBoot项目 ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:1","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#61-手动部署项目"},{"categories":["Linux"],"content":" 6.2 基于Shell脚本自动部署 6.2.1 介绍前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。 操作步骤如下： 1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中 2). 在Linux中安装Git,克隆代码 3). 在Linux中安装maven 4). 编写Shell脚本（拉取代码、编译、打包、启动） 5). 为用户授予执行Shell脚本的权限 6). 执行Shell脚本 6.2.2 推送代码到远程这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。 A. 创建远程仓库 B. 将idea中的代码提交并推送到远程仓库 6.2.3 Git操作1). Git软件安装 通过yum命令在线安装git，执行如下指令： yum list git 列出git安装包 yum install git 在线安装git 通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。 2). Git克隆代码 cd /usr/local/ git clone https://gitee.com/ChuanZhiBoKe/helloworld.git 6.2.4 Maven安装由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下： 1). 上传资料中提供的maven的安装包 通过rz指令上传课程资料中的maven安装包 2). 解压maven安装包到/usr/local目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 3). 在/etc/profile配置文件中配置环境变量 vim /etc/profile 修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 : export MAVEN_HOME=/usr/local/apache-maven-3.5.4 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH 然后按ESC进入到命令模式，输入 :wq 保存并退出 要想让配置的环境变量生效,还需要执行如下指令: source /etc/profile 4). 修改maven的settings.xml配置文件,配置本地仓库地址 A. 切换目录 cd /usr/local/apache-maven-3.5.4/conf B. 编辑settings.xml配置文件 vim settings.xml 在其中增加如下配置,配置本地仓库地址: \u003clocalRepository\u003e/usr/local/repo\u003c/localRepository\u003e 并在settings.xml中的标签中,配置阿里云的私服(==选做==): \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003c/mirror\u003e 6.2.5 Shell脚本准备 Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。 在/usr/local/目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。 脚本解读: 6.2.6 Linux权限前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。 1). ==chmod==（英文全拼：change mode）命令是控制用户对文件的权限的命令 2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x) 3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 4). 只有文件的所有者和超级用户可以修改文件或目录的权限 5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行 Linux系统中权限描述如下: 解析当前脚本的权限情况: chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r): 值 权限 rwx 7 读 + 写 + 执行 rwx 6 读 + 写 rw- 5 读 + 执行 r-x 4 只读 r– 3 写 + 执行 -wx 2 只写 -w- 1 只执行 –x 0 无 — 举例: chmod 777 bootStart.sh 为所有用户授予读、写、执行权限 chmod 755 bootStart.sh 为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限 chmod 210 bootStart.sh 为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限 ==注意:== 三个数字分别代表不同用户的权限 第1位表示文件拥有者的权限 第2位表示同组用户的权限 第3位表示其他用户的权限 6.2.7 授权并执行脚本在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令： chmod 777 bootStart.sh 权限解读: A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限； B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限； B. 第三个7，代表其他用户，对该文件具有读写执行权限； 执行该shell脚本: ==注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。== 启动完成之后, 我们可以查看java进程： 访问项目： 6.2.8 设置静态IP我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 1). 设置静态IP 设置静态ip，我们就需要修改 /etc/sysconfig/network-scripts/ifcfg-ens33 配置文件，内容如下： TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=\"192.168.138.100\" # 设置的静态IP地址 NETMASK=\"255.255.255.0\" # 子网掩码 GATEWAY=\"192.168.138.2\" # 网关地址 DNS1=\"192.168.138.2\" # DNS服务器 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6 DEVICE=ens33 ONBOOT=yes ZONE=public 上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。 2). 重启网络服务 ip地址修改完毕之后，需要重启网络服务，执行如下指令： systemctl restart network ==注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。== 再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP： ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#62-基于shell脚本自动部署"},{"categories":["Linux"],"content":" 6.2 基于Shell脚本自动部署 6.2.1 介绍前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。 操作步骤如下： 1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中 2). 在Linux中安装Git,克隆代码 3). 在Linux中安装maven 4). 编写Shell脚本（拉取代码、编译、打包、启动） 5). 为用户授予执行Shell脚本的权限 6). 执行Shell脚本 6.2.2 推送代码到远程这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。 A. 创建远程仓库 B. 将idea中的代码提交并推送到远程仓库 6.2.3 Git操作1). Git软件安装 通过yum命令在线安装git，执行如下指令： yum list git 列出git安装包 yum install git 在线安装git 通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。 2). Git克隆代码 cd /usr/local/ git clone https://gitee.com/ChuanZhiBoKe/helloworld.git 6.2.4 Maven安装由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下： 1). 上传资料中提供的maven的安装包 通过rz指令上传课程资料中的maven安装包 2). 解压maven安装包到/usr/local目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 3). 在/etc/profile配置文件中配置环境变量 vim /etc/profile 修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 : export MAVEN_HOME=/usr/local/apache-maven-3.5.4 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH 然后按ESC进入到命令模式，输入 :wq 保存并退出 要想让配置的环境变量生效,还需要执行如下指令: source /etc/profile 4). 修改maven的settings.xml配置文件,配置本地仓库地址 A. 切换目录 cd /usr/local/apache-maven-3.5.4/conf B. 编辑settings.xml配置文件 vim settings.xml 在其中增加如下配置,配置本地仓库地址: /usr/local/repo 并在settings.xml中的标签中,配置阿里云的私服(==选做==): alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ 6.2.5 Shell脚本准备 Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。 在/usr/local/目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。 脚本解读: 6.2.6 Linux权限前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。 1). ==chmod==（英文全拼：change mode）命令是控制用户对文件的权限的命令 2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x) 3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 4). 只有文件的所有者和超级用户可以修改文件或目录的权限 5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行 Linux系统中权限描述如下: 解析当前脚本的权限情况: chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r): 值 权限 rwx 7 读 + 写 + 执行 rwx 6 读 + 写 rw- 5 读 + 执行 r-x 4 只读 r– 3 写 + 执行 -wx 2 只写 -w- 1 只执行 –x 0 无 — 举例: chmod 777 bootStart.sh 为所有用户授予读、写、执行权限 chmod 755 bootStart.sh 为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限 chmod 210 bootStart.sh 为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限 ==注意:== 三个数字分别代表不同用户的权限 第1位表示文件拥有者的权限 第2位表示同组用户的权限 第3位表示其他用户的权限 6.2.7 授权并执行脚本在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令： chmod 777 bootStart.sh 权限解读: A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限； B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限； B. 第三个7，代表其他用户，对该文件具有读写执行权限； 执行该shell脚本: ==注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。== 启动完成之后, 我们可以查看java进程： 访问项目： 6.2.8 设置静态IP我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 1). 设置静态IP 设置静态ip，我们就需要修改 /etc/sysconfig/network-scripts/ifcfg-ens33 配置文件，内容如下： TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=\"192.168.138.100\" # 设置的静态IP地址 NETMASK=\"255.255.255.0\" # 子网掩码 GATEWAY=\"192.168.138.2\" # 网关地址 DNS1=\"192.168.138.2\" # DNS服务器 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6 DEVICE=ens33 ONBOOT=yes ZONE=public 上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。 2). 重启网络服务 ip地址修改完毕之后，需要重启网络服务，执行如下指令： systemctl restart network ==注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。== 再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP： ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#621-介绍"},{"categories":["Linux"],"content":" 6.2 基于Shell脚本自动部署 6.2.1 介绍前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。 操作步骤如下： 1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中 2). 在Linux中安装Git,克隆代码 3). 在Linux中安装maven 4). 编写Shell脚本（拉取代码、编译、打包、启动） 5). 为用户授予执行Shell脚本的权限 6). 执行Shell脚本 6.2.2 推送代码到远程这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。 A. 创建远程仓库 B. 将idea中的代码提交并推送到远程仓库 6.2.3 Git操作1). Git软件安装 通过yum命令在线安装git，执行如下指令： yum list git 列出git安装包 yum install git 在线安装git 通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。 2). Git克隆代码 cd /usr/local/ git clone https://gitee.com/ChuanZhiBoKe/helloworld.git 6.2.4 Maven安装由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下： 1). 上传资料中提供的maven的安装包 通过rz指令上传课程资料中的maven安装包 2). 解压maven安装包到/usr/local目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 3). 在/etc/profile配置文件中配置环境变量 vim /etc/profile 修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 : export MAVEN_HOME=/usr/local/apache-maven-3.5.4 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH 然后按ESC进入到命令模式，输入 :wq 保存并退出 要想让配置的环境变量生效,还需要执行如下指令: source /etc/profile 4). 修改maven的settings.xml配置文件,配置本地仓库地址 A. 切换目录 cd /usr/local/apache-maven-3.5.4/conf B. 编辑settings.xml配置文件 vim settings.xml 在其中增加如下配置,配置本地仓库地址: /usr/local/repo 并在settings.xml中的标签中,配置阿里云的私服(==选做==): alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ 6.2.5 Shell脚本准备 Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。 在/usr/local/目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。 脚本解读: 6.2.6 Linux权限前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。 1). ==chmod==（英文全拼：change mode）命令是控制用户对文件的权限的命令 2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x) 3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 4). 只有文件的所有者和超级用户可以修改文件或目录的权限 5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行 Linux系统中权限描述如下: 解析当前脚本的权限情况: chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r): 值 权限 rwx 7 读 + 写 + 执行 rwx 6 读 + 写 rw- 5 读 + 执行 r-x 4 只读 r– 3 写 + 执行 -wx 2 只写 -w- 1 只执行 –x 0 无 — 举例: chmod 777 bootStart.sh 为所有用户授予读、写、执行权限 chmod 755 bootStart.sh 为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限 chmod 210 bootStart.sh 为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限 ==注意:== 三个数字分别代表不同用户的权限 第1位表示文件拥有者的权限 第2位表示同组用户的权限 第3位表示其他用户的权限 6.2.7 授权并执行脚本在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令： chmod 777 bootStart.sh 权限解读: A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限； B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限； B. 第三个7，代表其他用户，对该文件具有读写执行权限； 执行该shell脚本: ==注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。== 启动完成之后, 我们可以查看java进程： 访问项目： 6.2.8 设置静态IP我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 1). 设置静态IP 设置静态ip，我们就需要修改 /etc/sysconfig/network-scripts/ifcfg-ens33 配置文件，内容如下： TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=\"192.168.138.100\" # 设置的静态IP地址 NETMASK=\"255.255.255.0\" # 子网掩码 GATEWAY=\"192.168.138.2\" # 网关地址 DNS1=\"192.168.138.2\" # DNS服务器 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6 DEVICE=ens33 ONBOOT=yes ZONE=public 上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。 2). 重启网络服务 ip地址修改完毕之后，需要重启网络服务，执行如下指令： systemctl restart network ==注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。== 再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP： ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#622-推送代码到远程"},{"categories":["Linux"],"content":" 6.2 基于Shell脚本自动部署 6.2.1 介绍前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。 操作步骤如下： 1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中 2). 在Linux中安装Git,克隆代码 3). 在Linux中安装maven 4). 编写Shell脚本（拉取代码、编译、打包、启动） 5). 为用户授予执行Shell脚本的权限 6). 执行Shell脚本 6.2.2 推送代码到远程这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。 A. 创建远程仓库 B. 将idea中的代码提交并推送到远程仓库 6.2.3 Git操作1). Git软件安装 通过yum命令在线安装git，执行如下指令： yum list git 列出git安装包 yum install git 在线安装git 通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。 2). Git克隆代码 cd /usr/local/ git clone https://gitee.com/ChuanZhiBoKe/helloworld.git 6.2.4 Maven安装由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下： 1). 上传资料中提供的maven的安装包 通过rz指令上传课程资料中的maven安装包 2). 解压maven安装包到/usr/local目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 3). 在/etc/profile配置文件中配置环境变量 vim /etc/profile 修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 : export MAVEN_HOME=/usr/local/apache-maven-3.5.4 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH 然后按ESC进入到命令模式，输入 :wq 保存并退出 要想让配置的环境变量生效,还需要执行如下指令: source /etc/profile 4). 修改maven的settings.xml配置文件,配置本地仓库地址 A. 切换目录 cd /usr/local/apache-maven-3.5.4/conf B. 编辑settings.xml配置文件 vim settings.xml 在其中增加如下配置,配置本地仓库地址: /usr/local/repo 并在settings.xml中的标签中,配置阿里云的私服(==选做==): alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ 6.2.5 Shell脚本准备 Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。 在/usr/local/目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。 脚本解读: 6.2.6 Linux权限前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。 1). ==chmod==（英文全拼：change mode）命令是控制用户对文件的权限的命令 2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x) 3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 4). 只有文件的所有者和超级用户可以修改文件或目录的权限 5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行 Linux系统中权限描述如下: 解析当前脚本的权限情况: chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r): 值 权限 rwx 7 读 + 写 + 执行 rwx 6 读 + 写 rw- 5 读 + 执行 r-x 4 只读 r– 3 写 + 执行 -wx 2 只写 -w- 1 只执行 –x 0 无 — 举例: chmod 777 bootStart.sh 为所有用户授予读、写、执行权限 chmod 755 bootStart.sh 为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限 chmod 210 bootStart.sh 为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限 ==注意:== 三个数字分别代表不同用户的权限 第1位表示文件拥有者的权限 第2位表示同组用户的权限 第3位表示其他用户的权限 6.2.7 授权并执行脚本在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令： chmod 777 bootStart.sh 权限解读: A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限； B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限； B. 第三个7，代表其他用户，对该文件具有读写执行权限； 执行该shell脚本: ==注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。== 启动完成之后, 我们可以查看java进程： 访问项目： 6.2.8 设置静态IP我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 1). 设置静态IP 设置静态ip，我们就需要修改 /etc/sysconfig/network-scripts/ifcfg-ens33 配置文件，内容如下： TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=\"192.168.138.100\" # 设置的静态IP地址 NETMASK=\"255.255.255.0\" # 子网掩码 GATEWAY=\"192.168.138.2\" # 网关地址 DNS1=\"192.168.138.2\" # DNS服务器 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6 DEVICE=ens33 ONBOOT=yes ZONE=public 上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。 2). 重启网络服务 ip地址修改完毕之后，需要重启网络服务，执行如下指令： systemctl restart network ==注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。== 再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP： ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#623-git操作"},{"categories":["Linux"],"content":" 6.2 基于Shell脚本自动部署 6.2.1 介绍前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。 操作步骤如下： 1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中 2). 在Linux中安装Git,克隆代码 3). 在Linux中安装maven 4). 编写Shell脚本（拉取代码、编译、打包、启动） 5). 为用户授予执行Shell脚本的权限 6). 执行Shell脚本 6.2.2 推送代码到远程这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。 A. 创建远程仓库 B. 将idea中的代码提交并推送到远程仓库 6.2.3 Git操作1). Git软件安装 通过yum命令在线安装git，执行如下指令： yum list git 列出git安装包 yum install git 在线安装git 通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。 2). Git克隆代码 cd /usr/local/ git clone https://gitee.com/ChuanZhiBoKe/helloworld.git 6.2.4 Maven安装由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下： 1). 上传资料中提供的maven的安装包 通过rz指令上传课程资料中的maven安装包 2). 解压maven安装包到/usr/local目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 3). 在/etc/profile配置文件中配置环境变量 vim /etc/profile 修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 : export MAVEN_HOME=/usr/local/apache-maven-3.5.4 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH 然后按ESC进入到命令模式，输入 :wq 保存并退出 要想让配置的环境变量生效,还需要执行如下指令: source /etc/profile 4). 修改maven的settings.xml配置文件,配置本地仓库地址 A. 切换目录 cd /usr/local/apache-maven-3.5.4/conf B. 编辑settings.xml配置文件 vim settings.xml 在其中增加如下配置,配置本地仓库地址: /usr/local/repo 并在settings.xml中的标签中,配置阿里云的私服(==选做==): alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ 6.2.5 Shell脚本准备 Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。 在/usr/local/目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。 脚本解读: 6.2.6 Linux权限前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。 1). ==chmod==（英文全拼：change mode）命令是控制用户对文件的权限的命令 2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x) 3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 4). 只有文件的所有者和超级用户可以修改文件或目录的权限 5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行 Linux系统中权限描述如下: 解析当前脚本的权限情况: chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r): 值 权限 rwx 7 读 + 写 + 执行 rwx 6 读 + 写 rw- 5 读 + 执行 r-x 4 只读 r– 3 写 + 执行 -wx 2 只写 -w- 1 只执行 –x 0 无 — 举例: chmod 777 bootStart.sh 为所有用户授予读、写、执行权限 chmod 755 bootStart.sh 为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限 chmod 210 bootStart.sh 为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限 ==注意:== 三个数字分别代表不同用户的权限 第1位表示文件拥有者的权限 第2位表示同组用户的权限 第3位表示其他用户的权限 6.2.7 授权并执行脚本在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令： chmod 777 bootStart.sh 权限解读: A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限； B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限； B. 第三个7，代表其他用户，对该文件具有读写执行权限； 执行该shell脚本: ==注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。== 启动完成之后, 我们可以查看java进程： 访问项目： 6.2.8 设置静态IP我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 1). 设置静态IP 设置静态ip，我们就需要修改 /etc/sysconfig/network-scripts/ifcfg-ens33 配置文件，内容如下： TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=\"192.168.138.100\" # 设置的静态IP地址 NETMASK=\"255.255.255.0\" # 子网掩码 GATEWAY=\"192.168.138.2\" # 网关地址 DNS1=\"192.168.138.2\" # DNS服务器 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6 DEVICE=ens33 ONBOOT=yes ZONE=public 上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。 2). 重启网络服务 ip地址修改完毕之后，需要重启网络服务，执行如下指令： systemctl restart network ==注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。== 再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP： ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#624-maven安装"},{"categories":["Linux"],"content":" 6.2 基于Shell脚本自动部署 6.2.1 介绍前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。 操作步骤如下： 1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中 2). 在Linux中安装Git,克隆代码 3). 在Linux中安装maven 4). 编写Shell脚本（拉取代码、编译、打包、启动） 5). 为用户授予执行Shell脚本的权限 6). 执行Shell脚本 6.2.2 推送代码到远程这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。 A. 创建远程仓库 B. 将idea中的代码提交并推送到远程仓库 6.2.3 Git操作1). Git软件安装 通过yum命令在线安装git，执行如下指令： yum list git 列出git安装包 yum install git 在线安装git 通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。 2). Git克隆代码 cd /usr/local/ git clone https://gitee.com/ChuanZhiBoKe/helloworld.git 6.2.4 Maven安装由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下： 1). 上传资料中提供的maven的安装包 通过rz指令上传课程资料中的maven安装包 2). 解压maven安装包到/usr/local目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 3). 在/etc/profile配置文件中配置环境变量 vim /etc/profile 修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 : export MAVEN_HOME=/usr/local/apache-maven-3.5.4 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH 然后按ESC进入到命令模式，输入 :wq 保存并退出 要想让配置的环境变量生效,还需要执行如下指令: source /etc/profile 4). 修改maven的settings.xml配置文件,配置本地仓库地址 A. 切换目录 cd /usr/local/apache-maven-3.5.4/conf B. 编辑settings.xml配置文件 vim settings.xml 在其中增加如下配置,配置本地仓库地址: /usr/local/repo 并在settings.xml中的标签中,配置阿里云的私服(==选做==): alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ 6.2.5 Shell脚本准备 Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。 在/usr/local/目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。 脚本解读: 6.2.6 Linux权限前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。 1). ==chmod==（英文全拼：change mode）命令是控制用户对文件的权限的命令 2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x) 3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 4). 只有文件的所有者和超级用户可以修改文件或目录的权限 5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行 Linux系统中权限描述如下: 解析当前脚本的权限情况: chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r): 值 权限 rwx 7 读 + 写 + 执行 rwx 6 读 + 写 rw- 5 读 + 执行 r-x 4 只读 r– 3 写 + 执行 -wx 2 只写 -w- 1 只执行 –x 0 无 — 举例: chmod 777 bootStart.sh 为所有用户授予读、写、执行权限 chmod 755 bootStart.sh 为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限 chmod 210 bootStart.sh 为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限 ==注意:== 三个数字分别代表不同用户的权限 第1位表示文件拥有者的权限 第2位表示同组用户的权限 第3位表示其他用户的权限 6.2.7 授权并执行脚本在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令： chmod 777 bootStart.sh 权限解读: A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限； B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限； B. 第三个7，代表其他用户，对该文件具有读写执行权限； 执行该shell脚本: ==注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。== 启动完成之后, 我们可以查看java进程： 访问项目： 6.2.8 设置静态IP我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 1). 设置静态IP 设置静态ip，我们就需要修改 /etc/sysconfig/network-scripts/ifcfg-ens33 配置文件，内容如下： TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=\"192.168.138.100\" # 设置的静态IP地址 NETMASK=\"255.255.255.0\" # 子网掩码 GATEWAY=\"192.168.138.2\" # 网关地址 DNS1=\"192.168.138.2\" # DNS服务器 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6 DEVICE=ens33 ONBOOT=yes ZONE=public 上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。 2). 重启网络服务 ip地址修改完毕之后，需要重启网络服务，执行如下指令： systemctl restart network ==注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。== 再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP： ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#625-shell脚本准备"},{"categories":["Linux"],"content":" 6.2 基于Shell脚本自动部署 6.2.1 介绍前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。 操作步骤如下： 1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中 2). 在Linux中安装Git,克隆代码 3). 在Linux中安装maven 4). 编写Shell脚本（拉取代码、编译、打包、启动） 5). 为用户授予执行Shell脚本的权限 6). 执行Shell脚本 6.2.2 推送代码到远程这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。 A. 创建远程仓库 B. 将idea中的代码提交并推送到远程仓库 6.2.3 Git操作1). Git软件安装 通过yum命令在线安装git，执行如下指令： yum list git 列出git安装包 yum install git 在线安装git 通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。 2). Git克隆代码 cd /usr/local/ git clone https://gitee.com/ChuanZhiBoKe/helloworld.git 6.2.4 Maven安装由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下： 1). 上传资料中提供的maven的安装包 通过rz指令上传课程资料中的maven安装包 2). 解压maven安装包到/usr/local目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 3). 在/etc/profile配置文件中配置环境变量 vim /etc/profile 修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 : export MAVEN_HOME=/usr/local/apache-maven-3.5.4 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH 然后按ESC进入到命令模式，输入 :wq 保存并退出 要想让配置的环境变量生效,还需要执行如下指令: source /etc/profile 4). 修改maven的settings.xml配置文件,配置本地仓库地址 A. 切换目录 cd /usr/local/apache-maven-3.5.4/conf B. 编辑settings.xml配置文件 vim settings.xml 在其中增加如下配置,配置本地仓库地址: /usr/local/repo 并在settings.xml中的标签中,配置阿里云的私服(==选做==): alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ 6.2.5 Shell脚本准备 Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。 在/usr/local/目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。 脚本解读: 6.2.6 Linux权限前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。 1). ==chmod==（英文全拼：change mode）命令是控制用户对文件的权限的命令 2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x) 3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 4). 只有文件的所有者和超级用户可以修改文件或目录的权限 5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行 Linux系统中权限描述如下: 解析当前脚本的权限情况: chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r): 值 权限 rwx 7 读 + 写 + 执行 rwx 6 读 + 写 rw- 5 读 + 执行 r-x 4 只读 r– 3 写 + 执行 -wx 2 只写 -w- 1 只执行 –x 0 无 — 举例: chmod 777 bootStart.sh 为所有用户授予读、写、执行权限 chmod 755 bootStart.sh 为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限 chmod 210 bootStart.sh 为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限 ==注意:== 三个数字分别代表不同用户的权限 第1位表示文件拥有者的权限 第2位表示同组用户的权限 第3位表示其他用户的权限 6.2.7 授权并执行脚本在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令： chmod 777 bootStart.sh 权限解读: A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限； B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限； B. 第三个7，代表其他用户，对该文件具有读写执行权限； 执行该shell脚本: ==注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。== 启动完成之后, 我们可以查看java进程： 访问项目： 6.2.8 设置静态IP我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 1). 设置静态IP 设置静态ip，我们就需要修改 /etc/sysconfig/network-scripts/ifcfg-ens33 配置文件，内容如下： TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=\"192.168.138.100\" # 设置的静态IP地址 NETMASK=\"255.255.255.0\" # 子网掩码 GATEWAY=\"192.168.138.2\" # 网关地址 DNS1=\"192.168.138.2\" # DNS服务器 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6 DEVICE=ens33 ONBOOT=yes ZONE=public 上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。 2). 重启网络服务 ip地址修改完毕之后，需要重启网络服务，执行如下指令： systemctl restart network ==注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。== 再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP： ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#626-linux权限"},{"categories":["Linux"],"content":" 6.2 基于Shell脚本自动部署 6.2.1 介绍前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。 操作步骤如下： 1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中 2). 在Linux中安装Git,克隆代码 3). 在Linux中安装maven 4). 编写Shell脚本（拉取代码、编译、打包、启动） 5). 为用户授予执行Shell脚本的权限 6). 执行Shell脚本 6.2.2 推送代码到远程这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。 A. 创建远程仓库 B. 将idea中的代码提交并推送到远程仓库 6.2.3 Git操作1). Git软件安装 通过yum命令在线安装git，执行如下指令： yum list git 列出git安装包 yum install git 在线安装git 通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。 2). Git克隆代码 cd /usr/local/ git clone https://gitee.com/ChuanZhiBoKe/helloworld.git 6.2.4 Maven安装由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下： 1). 上传资料中提供的maven的安装包 通过rz指令上传课程资料中的maven安装包 2). 解压maven安装包到/usr/local目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 3). 在/etc/profile配置文件中配置环境变量 vim /etc/profile 修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 : export MAVEN_HOME=/usr/local/apache-maven-3.5.4 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH 然后按ESC进入到命令模式，输入 :wq 保存并退出 要想让配置的环境变量生效,还需要执行如下指令: source /etc/profile 4). 修改maven的settings.xml配置文件,配置本地仓库地址 A. 切换目录 cd /usr/local/apache-maven-3.5.4/conf B. 编辑settings.xml配置文件 vim settings.xml 在其中增加如下配置,配置本地仓库地址: /usr/local/repo 并在settings.xml中的标签中,配置阿里云的私服(==选做==): alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ 6.2.5 Shell脚本准备 Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。 在/usr/local/目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。 脚本解读: 6.2.6 Linux权限前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。 1). ==chmod==（英文全拼：change mode）命令是控制用户对文件的权限的命令 2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x) 3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 4). 只有文件的所有者和超级用户可以修改文件或目录的权限 5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行 Linux系统中权限描述如下: 解析当前脚本的权限情况: chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r): 值 权限 rwx 7 读 + 写 + 执行 rwx 6 读 + 写 rw- 5 读 + 执行 r-x 4 只读 r– 3 写 + 执行 -wx 2 只写 -w- 1 只执行 –x 0 无 — 举例: chmod 777 bootStart.sh 为所有用户授予读、写、执行权限 chmod 755 bootStart.sh 为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限 chmod 210 bootStart.sh 为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限 ==注意:== 三个数字分别代表不同用户的权限 第1位表示文件拥有者的权限 第2位表示同组用户的权限 第3位表示其他用户的权限 6.2.7 授权并执行脚本在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令： chmod 777 bootStart.sh 权限解读: A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限； B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限； B. 第三个7，代表其他用户，对该文件具有读写执行权限； 执行该shell脚本: ==注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。== 启动完成之后, 我们可以查看java进程： 访问项目： 6.2.8 设置静态IP我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 1). 设置静态IP 设置静态ip，我们就需要修改 /etc/sysconfig/network-scripts/ifcfg-ens33 配置文件，内容如下： TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=\"192.168.138.100\" # 设置的静态IP地址 NETMASK=\"255.255.255.0\" # 子网掩码 GATEWAY=\"192.168.138.2\" # 网关地址 DNS1=\"192.168.138.2\" # DNS服务器 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6 DEVICE=ens33 ONBOOT=yes ZONE=public 上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。 2). 重启网络服务 ip地址修改完毕之后，需要重启网络服务，执行如下指令： systemctl restart network ==注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。== 再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP： ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#627-授权并执行脚本"},{"categories":["Linux"],"content":" 6.2 基于Shell脚本自动部署 6.2.1 介绍前面介绍的项目部署是手动部署，也就是部署过程中的每一步操作都需要我们手动操作。接下来，我们需要再讲解一下项目的自动部署，从而来简化项目部署的操作，那么我们先来整体上了解一下项目自动部署的流程及操作步骤。 操作步骤如下： 1). 在Gitee上创建远程仓库，并将本地的项目代码推送到远程仓库中 2). 在Linux中安装Git,克隆代码 3). 在Linux中安装maven 4). 编写Shell脚本（拉取代码、编译、打包、启动） 5). 为用户授予执行Shell脚本的权限 6). 执行Shell脚本 6.2.2 推送代码到远程这部分操作，大家只需要参考之前讲解的Git，来完成helloworld工程代码推送即可。 A. 创建远程仓库 B. 将idea中的代码提交并推送到远程仓库 6.2.3 Git操作1). Git软件安装 通过yum命令在线安装git，执行如下指令： yum list git 列出git安装包 yum install git 在线安装git 通过上述指令，安装好git之后，我们就可以通过 git –version去验证git的环境。 2). Git克隆代码 cd /usr/local/ git clone https://gitee.com/ChuanZhiBoKe/helloworld.git 6.2.4 Maven安装由于我们的工程是maven工程，我们要想进行项目的编译打包，需要用到maven的指令，所以需要安装maven。具体操作步骤如下： 1). 上传资料中提供的maven的安装包 通过rz指令上传课程资料中的maven安装包 2). 解压maven安装包到/usr/local目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 3). 在/etc/profile配置文件中配置环境变量 vim /etc/profile 修改配置文件，进入到命令模式，按G切换到最后一行，按a/i/o进入插入模式，然后在最后加入如下内容 : export MAVEN_HOME=/usr/local/apache-maven-3.5.4 export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH 然后按ESC进入到命令模式，输入 :wq 保存并退出 要想让配置的环境变量生效,还需要执行如下指令: source /etc/profile 4). 修改maven的settings.xml配置文件,配置本地仓库地址 A. 切换目录 cd /usr/local/apache-maven-3.5.4/conf B. 编辑settings.xml配置文件 vim settings.xml 在其中增加如下配置,配置本地仓库地址: /usr/local/repo 并在settings.xml中的标签中,配置阿里云的私服(==选做==): alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ 6.2.5 Shell脚本准备 Shell脚本（shell script），是一种Linux系统中的脚本程序。使用Shell脚本编程跟 JavaScript、Java编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 对于Shell脚本编写不作为本课程重点内容，直接使用课程资料中提供的脚本文件bootStart.sh即可。 在/usr/local/目录下创建一个目录 sh(mkdir sh)，并将shell脚本上传到该目录下。或者直接在sh目录下创建一个脚本bootStart.sh，然后将资料中的bootStart.sh文件打开,内容拷贝过来即可。 脚本解读: 6.2.6 Linux权限前面我们已经把Shell脚本准备好了，但是Shell脚本要想正常的执行，还需要给Shell脚本分配执行权限。 由于linux系统是一个多用户的操作系统，并且针对每一个用户，Linux会严格的控制操作权限。接下来，我们就需要介绍一下Linux系统的权限控制。 1). ==chmod==（英文全拼：change mode）命令是控制用户对文件的权限的命令 2). Linux中的权限分为三种 ：读(r)、写(w)、执行(x) 3). Linux文件权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users） 4). 只有文件的所有者和超级用户可以修改文件或目录的权限 5). 要执行Shell脚本需要有对此脚本文件的执行权限(x)，如果没有则不能执行 Linux系统中权限描述如下: 解析当前脚本的权限情况: chmod命令可以使用八进制数来指定权限(0 - 代表无 , 1 - 执行x , 2 - 写w , 4 - 读r): 值 权限 rwx 7 读 + 写 + 执行 rwx 6 读 + 写 rw- 5 读 + 执行 r-x 4 只读 r– 3 写 + 执行 -wx 2 只写 -w- 1 只执行 –x 0 无 — 举例: chmod 777 bootStart.sh 为所有用户授予读、写、执行权限 chmod 755 bootStart.sh 为文件拥有者授予读、写、执行权限，同组用户和其他用户授予读、执行权限 chmod 210 bootStart.sh 为文件拥有者授予写权限，同组用户授予执行权限，其他用户没有任何权限 ==注意:== 三个数字分别代表不同用户的权限 第1位表示文件拥有者的权限 第2位表示同组用户的权限 第3位表示其他用户的权限 6.2.7 授权并执行脚本在测试阶段，我们可以给所有的人都赋予执行该shell脚本的权限。所以可以执行如下指令： chmod 777 bootStart.sh 权限解读: A. 第一个7，代表当前文件所有者root用户，对该文件具有读写执行权限； B. 第二个7，代表当前文件所有者所属组的用户，对该文件具有读写执行权限； B. 第三个7，代表其他用户，对该文件具有读写执行权限； 执行该shell脚本: ==注意： 在执行maven指令进行打包时，第一次执行可能会耗时比较长，因为在进行maven工程的打包时，需要到中央仓库下载工程依赖的jar包和插件(可以在settings.xml中配置阿里云私服加速下载)。== 启动完成之后, 我们可以查看java进程： 访问项目： 6.2.8 设置静态IP我们目前安装的Linux操作系统，安装完毕之后并没有配置IP地址，默认IP地址是动态获取的，那如果我们使用该Linux服务器部署项目，IP动态获取的话，也就意味着，IP地址可能会发生变动，那我们访问项目的话就会非常繁琐，所以作为服务器，我们一般还需要把IP地址设置为静态的。 1). 设置静态IP 设置静态ip，我们就需要修改 /etc/sysconfig/network-scripts/ifcfg-ens33 配置文件，内容如下： TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static IPADDR=\"192.168.138.100\" # 设置的静态IP地址 NETMASK=\"255.255.255.0\" # 子网掩码 GATEWAY=\"192.168.138.2\" # 网关地址 DNS1=\"192.168.138.2\" # DNS服务器 DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=afd0baa3-8bf4-4e26-8d20-5bc426b75fd6 DEVICE=ens33 ONBOOT=yes ZONE=public 上述我们所设置的网段为138，并不是随意指定的，需要和我们虚拟机中的虚拟网络编辑器中的NAT模式配置的网关保持一致。 2). 重启网络服务 ip地址修改完毕之后，需要重启网络服务，执行如下指令： systemctl restart network ==注意：重启完网络服务后ip地址已经发生了改变，此时FinalShell已经连接不上Linux系统，需要创建一个新连接才能连接到Linux。== 再次连接上Linux之后，我们再次查看IP地址，就可以看到我们所设置的静态IP： ","date":"2023-12-31","objectID":"/linux%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Linux"],"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/#628-设置静态ip"},{"categories":["JS"],"content":"想了想还是决定简单了解一下，暂时不动前端的蛋糕了，毕竟这两年前端工作也不大好找……. 网页三剑客 html:网页布局 css:网页渲染的 js:网页动态特效的 js但是浏览器直接解析执行，不需要编译。js和java没有一毛钱关系。 js直接写在html页面。 ","date":"2023-12-31","objectID":"/js/:0:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#"},{"categories":["JS"],"content":" 一、js入门","date":"2023-12-31","objectID":"/js/:0:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#一js入门"},{"categories":["JS"],"content":" js 代码 js代码出现在html任何位置 js代码自上而下的执行。前面的代码没法获取到后面的标签。（js写在后面） \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003ejs入门案例\u003c/title\u003e \u003c!--js代码需要用\u003cscript\u003e--\u003e \u003cscript\u003e //弹框 // alert(\"哈哈哈head1\"); \u003c/script\u003e \u003c/head\u003e \u003c!--js代码需要用\u003cscript\u003e--\u003e \u003cscript\u003e /*执行顺序的问题。*/ var div1 = document.getElementById(\"div1\"); alert(div1); //弹框 // alert(\"哈哈哈head2\"); \u003c/script\u003e \u003cbody\u003e \u003cdiv id=\"div1\"\u003ediv\u003c/div\u003e \u003c!--js代码需要用\u003cscript\u003e--\u003e \u003cscript\u003e //弹框 // alert(\"哈哈哈body\"); \u003c/script\u003e \u003c/body\u003e \u003c!--js代码需要用\u003cscript\u003e 常用的--\u003e \u003cscript\u003e //弹框 // alert(\"哈哈哈\"); \u003c/script\u003e \u003c/html\u003e ","date":"2023-12-31","objectID":"/js/:1:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#js-代码"},{"categories":["JS"],"content":" 1.2js引入方式 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c!--src：脚本的路径 这个标签不可以自结尾- 早期版本的一个BUG 这个标签里面不要写js代码 --\u003e \u003cscript src=\"js/scripts.js\"\u003e\u003c/script\u003e \u003cscript\u003e alert(\"内部方式\") \u003c/script\u003e \u003c/html\u003e js脚本js/scripts.js alert(\"黑嘿嘿嘿外部引用\"); ","date":"2023-12-31","objectID":"/js/:2:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#12js引入方式"},{"categories":["JS"],"content":" 二、js基础语法","date":"2023-12-31","objectID":"/js/:0:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#二js基础语法"},{"categories":["JS"],"content":" 2.1 语法 注释 注意事项、输出语句 \u003cscript\u003e /*多行注释*/ //单行注释 \u003c!-- 单行注释 --\u003e /*js中语句结束的;可以省略*/ /*js中window调用的方法，window对象名可以省略*/ // 2.输出语句 // 2.1在页面上输出 document.write(\"我是页面输出语句，嘿嘿嘿\") // 2.2弹框输出（测试）- 死亡弹框 // alert(\"我是死亡弹框测试\") window.alert(\"我是死亡弹框测试\") // 2.3控制台输出 console.log(\"我是控制台日志输出\") \u003c/script\u003e ","date":"2023-12-31","objectID":"/js/:1:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#21-语法--注释--注意事项输出语句"},{"categories":["JS"],"content":" 2.2 变量 \u003cscript\u003e // 定义变量 var a = 1; var b = 1.1; var c = \"我是帅哥\"; var d = 'a'; // alert(a); // alert(b); // alert(d); // alert(c); { var e = 10;//全局变量 js5 let a1 = 1;//局部变量 js6 } // alert(e); // alert(a1); // js6常量 const PI = 3.14; // PI=3.1415;//常量不能修改 var a =20;//变量名使用两次，就是覆盖 alert(a); \u003c/script\u003e ","date":"2023-12-31","objectID":"/js/:2:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#22-变量"},{"categories":["JS"],"content":" 2.3 数据类型number、string、boolean 、null 、undefined \u003cscript\u003e // 5种数据类型 var n = 10; console.log(typeof n);//number var s = \"黑呵呵\"; console.log(typeof s);//string var b = true; console.log(typeof b);//boolean var obj = null; console.log(typeof obj);//object null是一个占位符 var a; console.log(typeof a);//undefined 未初始化，默认值就是undefined \u003c/script\u003e ","date":"2023-12-31","objectID":"/js/:3:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#23-数据类型"},{"categories":["JS"],"content":" 2.4 运算符 一元运算符：++，– 算术运算符：+，-，*，/，% 赋值运算符：=，+=，-=… 关系运算符：\u003e，\u003c，\u003e=，\u003c=，!=，\\ ==，===… 逻辑运算符：\u0026\u0026，||，! 三元运算符：条件表达式 ? true_value : false_value \u003cscript\u003e // ++操作 var a1 = 10; a1++; console.log(\"a1=\"+a1); // 三元运算符 var b1 = false; b1?console.log(\"我是true\"):console.log(\"我是false\"); // == 和 === var a2 = 10; var s2 = \"10\"; console.log(a2 == s2);//true == 只比较值，不比较类型，类型强转 console.log(a2 === s2);//false === 比较值和类型 // 类型强转问题 // 1 其他类型-》number var s3 = +\"100\";// string-\u003enumber console.log(s3+1);//101 var s4 = \"100\"; console.log(parseInt(s4)+1);//parseInt(s4) string-\u003enumber var b3 = false;// 布尔值转化为number后，true 1 false 0 console.log(b3+1); var obj3 = null;//不考虑类型转化问题 console.log(obj3+1); // 2. 其他类型-》布尔值 // 2.1 字符串---boolean // 空字符串是false 有内容就是true var s5 = \"\"; s5?console.log(\"==true===\"):console.log(\"===false==\"); // 2.2 number-\u003eboolean // 0是false, 其他都是 true var n5 = 0; n5?console.log(\"=n5=true===\"):console.log(\"=n5==false==\"); // 2.3 undefined null-\u003eboolean // flase var un = null; un?console.log(\"=un=true===\"):console.log(\"=un==false==\"); // 演示一个NaN var str1 = +\"一百\";//NaN var str2 = +\"一百\"; console.log(str1); \u003c/script\u003e 总结类型转换：程序更加健壮 其他类型-》number string-\u003enumber +“100”； paramInt(“100\") NaN 其他类型-》boolean 字符串-》boolean 空字符串—– false 有内容——–true number-\u003eboolean 0——-false 其他都是true undefined null ——— false ","date":"2023-12-31","objectID":"/js/:4:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#24-运算符"},{"categories":["JS"],"content":" 2.5 流程控制语句JavaScript 中提供了和 Java 一样的流程控制语句，如下 if switch for while dowhile 2.5.1 if 语句 var count = 3; if (count == 3) { alert(count); } 3.6.2 switch 语句 var num = 3; switch (num) { case 1: alert(\"星期一\"); break; case 2: alert(\"星期二\"); break; case 3: alert(\"星期三\"); break; case 4: alert(\"星期四\"); break; case 5: alert(\"星期五\"); break; case 6: alert(\"星期六\"); break; case 7: alert(\"星期日\"); break; default: alert(\"输入的星期有误\"); break; } 2.5.3 for 循环语句 var sum = 0; for (let i = 1; i \u003c= 100; i++) { //建议for循环小括号中定义的变量使用let sum += i; } alert(sum); 2.5.4 while 循环语句 var sum = 0; var i = 1; while (i \u003c= 100) { sum += i; i++; } alert(sum); 2.5.5 dowhile 循环语句 var sum = 0; var i = 1; do { sum += i; i++; } while (i \u003c= 100); alert(sum); ","date":"2023-12-31","objectID":"/js/:5:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#25--流程控制语句"},{"categories":["JS"],"content":" 2.5 流程控制语句JavaScript 中提供了和 Java 一样的流程控制语句，如下 if switch for while dowhile 2.5.1 if 语句 var count = 3; if (count == 3) { alert(count); } 3.6.2 switch 语句 var num = 3; switch (num) { case 1: alert(\"星期一\"); break; case 2: alert(\"星期二\"); break; case 3: alert(\"星期三\"); break; case 4: alert(\"星期四\"); break; case 5: alert(\"星期五\"); break; case 6: alert(\"星期六\"); break; case 7: alert(\"星期日\"); break; default: alert(\"输入的星期有误\"); break; } 2.5.3 for 循环语句 var sum = 0; for (let i = 1; i \u003c= 100; i++) { //建议for循环小括号中定义的变量使用let sum += i; } alert(sum); 2.5.4 while 循环语句 var sum = 0; var i = 1; while (i \u003c= 100) { sum += i; i++; } alert(sum); 2.5.5 dowhile 循环语句 var sum = 0; var i = 1; do { sum += i; i++; } while (i \u003c= 100); alert(sum); ","date":"2023-12-31","objectID":"/js/:5:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#251--if-语句"},{"categories":["JS"],"content":" 2.5 流程控制语句JavaScript 中提供了和 Java 一样的流程控制语句，如下 if switch for while dowhile 2.5.1 if 语句 var count = 3; if (count == 3) { alert(count); } 3.6.2 switch 语句 var num = 3; switch (num) { case 1: alert(\"星期一\"); break; case 2: alert(\"星期二\"); break; case 3: alert(\"星期三\"); break; case 4: alert(\"星期四\"); break; case 5: alert(\"星期五\"); break; case 6: alert(\"星期六\"); break; case 7: alert(\"星期日\"); break; default: alert(\"输入的星期有误\"); break; } 2.5.3 for 循环语句 var sum = 0; for (let i = 1; i \u003c= 100; i++) { //建议for循环小括号中定义的变量使用let sum += i; } alert(sum); 2.5.4 while 循环语句 var sum = 0; var i = 1; while (i \u003c= 100) { sum += i; i++; } alert(sum); 2.5.5 dowhile 循环语句 var sum = 0; var i = 1; do { sum += i; i++; } while (i \u003c= 100); alert(sum); ","date":"2023-12-31","objectID":"/js/:5:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#362--switch-语句"},{"categories":["JS"],"content":" 2.5 流程控制语句JavaScript 中提供了和 Java 一样的流程控制语句，如下 if switch for while dowhile 2.5.1 if 语句 var count = 3; if (count == 3) { alert(count); } 3.6.2 switch 语句 var num = 3; switch (num) { case 1: alert(\"星期一\"); break; case 2: alert(\"星期二\"); break; case 3: alert(\"星期三\"); break; case 4: alert(\"星期四\"); break; case 5: alert(\"星期五\"); break; case 6: alert(\"星期六\"); break; case 7: alert(\"星期日\"); break; default: alert(\"输入的星期有误\"); break; } 2.5.3 for 循环语句 var sum = 0; for (let i = 1; i \u003c= 100; i++) { //建议for循环小括号中定义的变量使用let sum += i; } alert(sum); 2.5.4 while 循环语句 var sum = 0; var i = 1; while (i \u003c= 100) { sum += i; i++; } alert(sum); 2.5.5 dowhile 循环语句 var sum = 0; var i = 1; do { sum += i; i++; } while (i \u003c= 100); alert(sum); ","date":"2023-12-31","objectID":"/js/:5:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#253--for-循环语句"},{"categories":["JS"],"content":" 2.5 流程控制语句JavaScript 中提供了和 Java 一样的流程控制语句，如下 if switch for while dowhile 2.5.1 if 语句 var count = 3; if (count == 3) { alert(count); } 3.6.2 switch 语句 var num = 3; switch (num) { case 1: alert(\"星期一\"); break; case 2: alert(\"星期二\"); break; case 3: alert(\"星期三\"); break; case 4: alert(\"星期四\"); break; case 5: alert(\"星期五\"); break; case 6: alert(\"星期六\"); break; case 7: alert(\"星期日\"); break; default: alert(\"输入的星期有误\"); break; } 2.5.3 for 循环语句 var sum = 0; for (let i = 1; i \u003c= 100; i++) { //建议for循环小括号中定义的变量使用let sum += i; } alert(sum); 2.5.4 while 循环语句 var sum = 0; var i = 1; while (i \u003c= 100) { sum += i; i++; } alert(sum); 2.5.5 dowhile 循环语句 var sum = 0; var i = 1; do { sum += i; i++; } while (i \u003c= 100); alert(sum); ","date":"2023-12-31","objectID":"/js/:5:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#254--while-循环语句"},{"categories":["JS"],"content":" 2.5 流程控制语句JavaScript 中提供了和 Java 一样的流程控制语句，如下 if switch for while dowhile 2.5.1 if 语句 var count = 3; if (count == 3) { alert(count); } 3.6.2 switch 语句 var num = 3; switch (num) { case 1: alert(\"星期一\"); break; case 2: alert(\"星期二\"); break; case 3: alert(\"星期三\"); break; case 4: alert(\"星期四\"); break; case 5: alert(\"星期五\"); break; case 6: alert(\"星期六\"); break; case 7: alert(\"星期日\"); break; default: alert(\"输入的星期有误\"); break; } 2.5.3 for 循环语句 var sum = 0; for (let i = 1; i \u003c= 100; i++) { //建议for循环小括号中定义的变量使用let sum += i; } alert(sum); 2.5.4 while 循环语句 var sum = 0; var i = 1; while (i \u003c= 100) { sum += i; i++; } alert(sum); 2.5.5 dowhile 循环语句 var sum = 0; var i = 1; do { sum += i; i++; } while (i \u003c= 100); alert(sum); ","date":"2023-12-31","objectID":"/js/:5:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#255--dowhile-循环语句"},{"categories":["JS"],"content":" 2.6 函数 \u003cscript\u003e //函数方式一 function 函数名(变量1名,变量2名...){ 代码; 返回值 } // public int sum(int i,int j){ return x} function sum(i,j) { var s = i+j; return s; } // 函数方式二 匿名函数方式 变量 = function(参数){代码} 不能额外调用 var sum1 = function(i,j){ alert(i+j); } // 函数调用 var sum1 = sum(2,3); alert(sum1); \u003c/script\u003e ","date":"2023-12-31","objectID":"/js/:6:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#26-函数"},{"categories":["JS"],"content":" 2.7 定义对象 \u003cscript\u003e // 字面量方式定义对象(属性 放法) var obj = { name:\"张三\", age:23, save:function (i) { alert(\"我今天吃饭了\"+i) } } alert(obj.name) alert(obj.age) obj.save(\"大米饭\") \u003c/script\u003e ","date":"2023-12-31","objectID":"/js/:7:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#27-定义对象"},{"categories":["JS"],"content":" 2.8.1 API-Array(数组) /*数组*/ // 1.获取一个数组 var arr1 = [\"a\",\"b\",\"c\"]; var arr3 = [\"a2\",\"b2\",\"c2\"]; // 2.获取一个数组 var arr2 = new Array(\"a\",\"b\",\"c\"); // 获取 // alert(arr1[1]); // alert(arr2[0]); // 遍历1 fori // for (let i = 0; i \u003c arr1.length; i++) { // console.log(arr1[i]); // } // 遍历2 增强forof arr1.forof // for (let s of arr1) { // console.log(s) // } // 遍历3 forEach // arr1.forEach(function (item,index) { // console.log(item+\"的索引为=\"+index) // }) // concat() 连接两个或多个数组，并返回已连接数组的副本。 var concat = arr1.concat(arr2,arr3); console.log(concat); // pop() 删除数组的最后一个元素，并返回该元素。 // var s = arr1.pop(); // console.log(\"s=\"+s); // for (let s of arr1) { // console.log(s) // } // push() 将新元素添加到数组的末尾，并返回新的长度。 // var number = arr1.push(\"d\",\"e\"); // for (let s of arr1) { // console.log(s) // } // console.log(number) // splice() 从数组中添加/删除元素 // index （必须）开始索引 // deletemay （可选）删除的个数 // item... （可选）新增的个数 var arr = [\"a\",\"b\",\"c\"]; // 把1索引的元素替换为e arr.splice(1,1,\"e\",\"到\"); console.log(arr); ","date":"2023-12-31","objectID":"/js/:8:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#281-api-array数组"},{"categories":["JS"],"content":" 2.9Date //https://www.w3school.com.cn/jsref/jsref_obj_date.asp var d = new Date(); console.log(d) var d1 = new Date(\"2022/02/02\"); console.log(d1) var d2 = new Date(0);//1970 console.log(d2) // 获取年 var fullYear = d.getFullYear(); console.log(fullYear) var month = d.getMonth();// month是月份 的索引 0-11 代表月份 ","date":"2023-12-31","objectID":"/js/:9:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#29date"},{"categories":["JS"],"content":" 2.10String // 获取一个字符串 var s = \"abc\"; var s2 = new String(\"嘿嘿嘿\"); // 获取字符串的长度 console.log(s.length) // charAt() 返回在指定位置的字符。 var charAt = s.charAt(0); console.log(charAt) // concat() 连接字符串。 var c = s.concat(s2); console.log(c) // split() 把字符串分割为字符串数组。 var hoppy = \"打篮球、踢足球、乒乓球\"; var split = hoppy.split(\"、\"); for (let str of split) { console.log(str) } //substring() 提取字符串中两个指定的索引号之间的字符。 var hoppy1 = \"打篮球、踢足球、乒乓球\"; var substring = hoppy1.substring(4,7);//[) console.log(substring) // trim() 去掉字符串两端的空格 var str = \" root \"; var s1 = str.trim(); console.log(s1) ","date":"2023-12-31","objectID":"/js/:10:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#210string"},{"categories":["JS"],"content":" 2.11json //定义json数据 {\"键\":\"值\",\"键\":\"值\",\"键\":\"值\"} var myObj = { \"name\":\"Bill\", \"age\":19, \"city\":\"Seattle\" }; //获取数据 console.log(myObj.name) //定义json数据 多个 var myObj1 = [ { \"name\":\"小明\", \"age\":19, \"city\":\"北京\" }, { \"name\":\"小王\", \"age\":19, \"city\":\"上海\" } ] // 获取数据 console.log(myObj1[0].name) // parse() 解析 JSON 字符串-\u003ejson var str = \"{\\\"name\\\":\\\"小明\\\",\\\"age\\\":19}\"; var obj = JSON.parse('{\"firstName\":\"Bill\", \"lastName\":\"Gates\"}'); var p = JSON.parse(str); console.log(p.name); // stringify() 将 JavaScript 对象转换为 JSON 字符串。 var s = JSON.stringify(p); console.log(typeof s) ","date":"2023-12-31","objectID":"/js/:11:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#211json"},{"categories":["JS"],"content":" 三、bomBOM 中包含了如下对象： Window：浏览器窗口对象 Navigator：浏览器对象 Screen：屏幕对象 History：历史记录对象 Location：地址栏对象 下图是 BOM 中的各个对象和浏览器的各个组成部分的对应关系 ","date":"2023-12-31","objectID":"/js/:0:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#三bom"},{"categories":["JS"],"content":" 3.1window //window对象 // window.innerHeight - 浏览器窗口的内高度（以像素计） // window.innerWidth - 浏览器窗口的内宽度（以像素计） var innerHeight = window.innerHeight; var innerWidth = window.innerWidth; console.log(innerHeight) console.log(innerWidth) // 响应式的时候很常用！！！ // 1弹框 确定框 window.alert(\"你爱我吗\") // 2确定取消框 参数就是弹框提示的内容. 返回值就是点确定返回true 点取消返回false var b = window.confirm(\"你爱我吗\"); // console.log(b) // 3.定时器 一次定时器 setTimeout(fun,毫秒值) var time1 = window.setTimeout(function () { alert(\"过了3秒\") },3000) //清除一次定时器 window.clearTimeout(time1) // 4.多次定时器 setInterval(fun,毫秒值) var time2 = window.setInterval(function () { alert(\"过3秒弹一次\") },3000) // 清除多次定时器 window.clearInterval(time2) ","date":"2023-12-31","objectID":"/js/:1:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#31window"},{"categories":["JS"],"content":" 3.2 location //location href 页面跳转 window.location.href = \"http://www.itcast.cn\"; ","date":"2023-12-31","objectID":"/js/:2:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#32-location"},{"categories":["JS"],"content":" 3.3 history // 回退 window.history.back() ","date":"2023-12-31","objectID":"/js/:3:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#33-history"},{"categories":["JS"],"content":" 四、domDOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。 DOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为 Document：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 如下图，左边是 HTML 文档内容，右边是 DOM 树 作用： JavaScript 通过 DOM， 就能够对 HTML进行操作了 改变 HTML 元素的内容 改变 HTML 元素的样式（CSS） 对 HTML DOM 事件作出反应 添加和删除 HTML 元素 \u003cbody\u003e \u003cimg id=\"light\" src=\"../imgs/off.gif\"\u003e \u003cbr\u003e \u003cdiv class=\"cls\"\u003e山东高合 \u003cspan\u003e123\u003c/span\u003e\u003c/div\u003e \u003cbr\u003e \u003cdiv class=\"cls\"\u003e山东高合\u003c/div\u003e \u003cbr\u003e \u003cinput type=\"checkbox\" name=\"hobby\"\u003e 电影 \u003cinput type=\"checkbox\" name=\"hobby\"\u003e 旅游 \u003cinput type=\"checkbox\" name=\"hobby\"\u003e 游戏 \u003cscript\u003e /*获取元素标签*/ //1. 通过ID获取，获取一个标签 var light = document.getElementById(\"light\"); // alert(light); // 2. 通过class获取， 元素数组 var cls = document.getElementsByClassName(\"cls\"); // alert(cls.length); // 3. 通过标签获取，拿到的是元素数组 var divs = document.getElementsByTagName(\"div\"); // alert(divs.length) // 4. 通过name获取 元素数组 var inps = document.getElementsByName(\"hobby\"); // alert(inps.length); /*获取属性*/ /*!tips: 元素数组是没有办法直接拿属性和内容的。精确的哪一个上面 */ // var t = inps[0].type; // console.log(t) // 把高合信息改成红色字体 cls[0].style.color = \"red\"; // 把旅游输入框改成默认选项 inps[1].checked = true; /*获取文本内容*/ // innerHTML innerText var innerHTML1 = cls[0].innerHTML;//innerHTML 这个元素里的包含html的内容 var innerText1 = cls[0].innerText;//innerText 这个元素里的文本内容（没有标签） // alert(innerHTML1) // alert(innerText1) // cls[0].innerHTML = \"\u003ch1\u003e山东高合\u003c/h1\u003e\";//这个会解析标签 cls[0].innerText = \"\u003ch1\u003e山东高合\u003c/h1\u003e\";//这个不会 \u003c/script\u003e ","date":"2023-12-31","objectID":"/js/:0:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#四dom"},{"categories":["JS"],"content":" 五、事件","date":"2023-12-31","objectID":"/js/:0:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#五事件"},{"categories":["JS"],"content":" 7.2 常见事件上面案例中使用到了 onclick 事件属性，那都有哪些事件属性供我们使用呢？下面就给大家列举一些比较常用的事件属性 事件属性名 说明 onclick 鼠标单击事件 onblur 元素失去焦点 onfocus 元素获得焦点 onload 某个页面或图像被完成加载 onsubmit 当表单提交时触发该事件 onmouseover 鼠标被移到某元素之上 onmouseout 鼠标从某元素移开 \u003cbody\u003e \u003cbutton id = \"btn1\" onclick=\"on()\"\u003e点击了1（了解即可）\u003c/button\u003e \u003cbutton id = \"btn2\"\u003e点击了2\u003c/button\u003e \u003cbr\u003e \u003cinput type=\"text\" value=\"123\" id=\"inp\"\u003e \u003cbr\u003e \u003cdiv id=\"div1\"\u003e我是最棒的，你一划过就会变红色\u003c/div\u003e \u003c/body\u003e \u003cscript\u003e /*方式一:侵入式开发 了解*/ function on() { alert(\"我被点击了\") } /*方式二：监听式*/ var btn2 = document.getElementById(\"btn2\"); btn2.onclick = function () { alert(\"你点我干啥\") } /*演示onblur 元素失去焦点*/ document.getElementById(\"inp\").onblur = function () { //获取输入框里面的值是value属性 var value = document.getElementById(\"inp\").value; alert(value) } /*演示onmouseover鼠标被移到某元素之上*/ document.getElementById(\"div1\").onmouseover = function () { document.getElementById(\"div1\").style.color = \"red\"; } \u003c/script\u003e ","date":"2023-12-31","objectID":"/js/:0:1","series":null,"tags":["JS"],"title":"Js","uri":"/js/#72--常见事件"},{"categories":["JS"],"content":" 六、案例略 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e欢迎注册\u003c/title\u003e \u003clink href=\"css/register.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"form-div\"\u003e \u003cdiv class=\"reg-content\"\u003e \u003ch1\u003e欢迎注册\u003c/h1\u003e \u003cspan\u003e已有帐号？\u003c/span\u003e \u003ca href=\"#\"\u003e登录\u003c/a\u003e \u003c/div\u003e \u003cform id=\"reg-form\" action=\"#\" method=\"get\"\u003e \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e用户名\u003c/td\u003e \u003ctd class=\"inputs\"\u003e \u003cinput name=\"username\" type=\"text\" id=\"username\"\u003e \u003cbr\u003e \u003cspan id=\"username_err\" class=\"err_msg\" style=\"display: none\"\u003e用户名不太受欢迎\u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e密码\u003c/td\u003e \u003ctd class=\"inputs\"\u003e \u003cinput name=\"password\" type=\"password\" id=\"password\"\u003e \u003cbr\u003e \u003cspan id=\"password_err\" class=\"err_msg\" style=\"display: none\"\u003e密码格式有误\u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e手机号\u003c/td\u003e \u003ctd class=\"inputs\"\u003e\u003cinput name=\"tel\" type=\"text\" id=\"tel\"\u003e \u003cbr\u003e \u003cspan id=\"tel_err\" class=\"err_msg\" style=\"display: none\"\u003e手机号格式有误\u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003cdiv class=\"buttons\"\u003e \u003cinput value=\"注 册\" type=\"submit\" id=\"reg_btn\"\u003e \u003c/div\u003e \u003cbr class=\"clear\"\u003e \u003c/form\u003e \u003c/div\u003e \u003cscript\u003e // 1.校验用户名 // 1.1获取用户名输入框元素 var usernameInput = document.getElementById(\"username\"); // 1.2各元素添加事件---失去焦点事件 var usernameReg = false; usernameInput.onblur = function () { // 1.3获取用户输入的信息(顺带把输入的前后空格干掉) var username = usernameInput.value.trim(); // 1.4判断这个信息满足要求不(6-12个字符) 满足就OK 不满足就提示 // 请输入6-12个字符的字符串，由字母数字组成 var arg2 = /^[a-zA-Z0-9]{6,12}$/; if(arg2.test(username)){ // 满足条件 document.getElementById(\"username_err\").style.display = \"none\"; usernameReg = true; }else { // 不满足 document.getElementById(\"username_err\").style.display = \"block\"; } } // 2.校验密码框 // 1.1获取用户名输入框元素 var passwordInput = document.getElementById(\"password\"); // 1.2各元素添加事件---失去焦点事件 var passwordReg = false; passwordInput.onblur = function () { // 1.3获取用户输入的信息(顺带把输入的前后空格干掉) var password = passwordInput.value.trim(); // 1.4判断这个信息满足要求不(6-12个字符) 满足就OK 不满足就提示 var arg2 = /^[a-zA-Z0-9]{6,12}$/; if(arg2.test(password)){ // 满足条件 document.getElementById(\"password_err\").style.display = \"none\"; passwordReg = true; }else { // 不满足 document.getElementById(\"password_err\").style.display = \"block\"; } } // 3.校验手机号 // 1.1获取用户名输入框元素 var telInput = document.getElementById(\"tel\"); // 1.2各元素添加事件---失去焦点事件 var telReg = false; telInput.onblur = function () { // 1.3获取用户输入的信息(顺带把输入的前后空格干掉) var tel = telInput.value.trim(); // 1.4判断这个信息满足要求不(11个字符) 满足就OK 不满足就提示 var arg3 = /^1[35789]{1}[0-9]{9}$/; if(arg3.test(tel)){ // 满足条件 document.getElementById(\"tel_err\").style.display = \"none\"; telReg = true; }else { // 不满足 document.getElementById(\"tel_err\").style.display = \"block\"; } } /*监听表单提交事件*/ // 1.获取表单提交按钮 -- 监听的是表单 var regForm = document.getElementById(\"reg-form\"); // 2.加监听事件 regForm.onsubmit = function () { // alert(\"注册了\") //上面三个条件都满足，就提交 if(usernameReg \u0026\u0026 passwordReg \u0026\u0026 telReg){ return true; } // return true 提交表单 return false 不提交 return false; } // 3. 加内容 \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2023-12-31","objectID":"/js/:0:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#六案例"},{"categories":["JS"],"content":" 总结： js引入方式 内部方式 外链式（框架） 基本语法 大多数和java样 定义变量var 类型自动转换 其他类型-》boolean API 数组 Date String json regexp bom操作 窗口对象 历史对象 地址栏对象 dom解析 如何获取元素、操作 如何获取属性、操作 如何获取内容、操作 事件 监听事件！！！ ","date":"2023-12-31","objectID":"/js/:0:0","series":null,"tags":["JS"],"title":"Js","uri":"/js/#总结"},{"categories":["C"],"content":" 1、相关概念 1.1 文件的概念​ 一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。 1.2 流的概念​ 流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。 ​ C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。 1.2.1 文本流​ 文本流，也就是以文本模式读取文件。文本流的某些特性在不同的系统中不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只用一个换行符结尾 ​ 标准的C把文件定义为零个或多个字符，后面跟一个表示结束的换行符\\n。对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式与内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形式而操作文本的外部形式而操作文本的能力简化了可移值程序的创建。 1.2.2 二进制流​ 二进制流中的字节将完全根据程序编写他们的形式写入到文件中，而且完全根据他们从文件或设备读取的形式度入到从程序中。他们并未作任何改变。这种类型的流适用于非文本数据，到那时如果你不希望I/O函数修改文本文件的行末字符，也可以把他们运用于文本文件。 ​ c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。 ​ 我们程序中，经常看到文本方式打开文件的二进制方式打开文件仅仅体现在换行符的处理上。 ​ 比如说，在Windows下，文件的换行符是\\r\\n，而在Linux下换行符是\\n。 ​ 当对文件使用文本方式打开时，读写的Windows文件中的换行符\\r\\n会被替换成\\n读到内存中，当在Windows下写入文件时，\\n会被替换成\\r\\n再写入文件。如果使用二进制的方式打开文件，则不进行\\r\\n和\\n之间的转换，那么由于Linux下的换行符就是\\n，所以文本文件方式和二进制方式无区别。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:1","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#1相关概念"},{"categories":["C"],"content":" 1、相关概念 1.1 文件的概念​ 一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。 1.2 流的概念​ 流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。 ​ C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。 1.2.1 文本流​ 文本流，也就是以文本模式读取文件。文本流的某些特性在不同的系统中不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只用一个换行符结尾 ​ 标准的C把文件定义为零个或多个字符，后面跟一个表示结束的换行符\\n。对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式与内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形式而操作文本的外部形式而操作文本的能力简化了可移值程序的创建。 1.2.2 二进制流​ 二进制流中的字节将完全根据程序编写他们的形式写入到文件中，而且完全根据他们从文件或设备读取的形式度入到从程序中。他们并未作任何改变。这种类型的流适用于非文本数据，到那时如果你不希望I/O函数修改文本文件的行末字符，也可以把他们运用于文本文件。 ​ c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。 ​ 我们程序中，经常看到文本方式打开文件的二进制方式打开文件仅仅体现在换行符的处理上。 ​ 比如说，在Windows下，文件的换行符是\\r\\n，而在Linux下换行符是\\n。 ​ 当对文件使用文本方式打开时，读写的Windows文件中的换行符\\r\\n会被替换成\\n读到内存中，当在Windows下写入文件时，\\n会被替换成\\r\\n再写入文件。如果使用二进制的方式打开文件，则不进行\\r\\n和\\n之间的转换，那么由于Linux下的换行符就是\\n，所以文本文件方式和二进制方式无区别。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:1","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#11-文件的概念"},{"categories":["C"],"content":" 1、相关概念 1.1 文件的概念​ 一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。 1.2 流的概念​ 流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。 ​ C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。 1.2.1 文本流​ 文本流，也就是以文本模式读取文件。文本流的某些特性在不同的系统中不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只用一个换行符结尾 ​ 标准的C把文件定义为零个或多个字符，后面跟一个表示结束的换行符\\n。对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式与内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形式而操作文本的外部形式而操作文本的能力简化了可移值程序的创建。 1.2.2 二进制流​ 二进制流中的字节将完全根据程序编写他们的形式写入到文件中，而且完全根据他们从文件或设备读取的形式度入到从程序中。他们并未作任何改变。这种类型的流适用于非文本数据，到那时如果你不希望I/O函数修改文本文件的行末字符，也可以把他们运用于文本文件。 ​ c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。 ​ 我们程序中，经常看到文本方式打开文件的二进制方式打开文件仅仅体现在换行符的处理上。 ​ 比如说，在Windows下，文件的换行符是\\r\\n，而在Linux下换行符是\\n。 ​ 当对文件使用文本方式打开时，读写的Windows文件中的换行符\\r\\n会被替换成\\n读到内存中，当在Windows下写入文件时，\\n会被替换成\\r\\n再写入文件。如果使用二进制的方式打开文件，则不进行\\r\\n和\\n之间的转换，那么由于Linux下的换行符就是\\n，所以文本文件方式和二进制方式无区别。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:1","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#12-流的概念"},{"categories":["C"],"content":" 1、相关概念 1.1 文件的概念​ 一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。 1.2 流的概念​ 流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。 ​ C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。 1.2.1 文本流​ 文本流，也就是以文本模式读取文件。文本流的某些特性在不同的系统中不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只用一个换行符结尾 ​ 标准的C把文件定义为零个或多个字符，后面跟一个表示结束的换行符\\n。对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式与内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形式而操作文本的外部形式而操作文本的能力简化了可移值程序的创建。 1.2.2 二进制流​ 二进制流中的字节将完全根据程序编写他们的形式写入到文件中，而且完全根据他们从文件或设备读取的形式度入到从程序中。他们并未作任何改变。这种类型的流适用于非文本数据，到那时如果你不希望I/O函数修改文本文件的行末字符，也可以把他们运用于文本文件。 ​ c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。 ​ 我们程序中，经常看到文本方式打开文件的二进制方式打开文件仅仅体现在换行符的处理上。 ​ 比如说，在Windows下，文件的换行符是\\r\\n，而在Linux下换行符是\\n。 ​ 当对文件使用文本方式打开时，读写的Windows文件中的换行符\\r\\n会被替换成\\n读到内存中，当在Windows下写入文件时，\\n会被替换成\\r\\n再写入文件。如果使用二进制的方式打开文件，则不进行\\r\\n和\\n之间的转换，那么由于Linux下的换行符就是\\n，所以文本文件方式和二进制方式无区别。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:1","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#121-文本流"},{"categories":["C"],"content":" 1、相关概念 1.1 文件的概念​ 一个文件通常就是磁盘上一段命名的存储区。但是对于操作系统来说，文件就会更复杂一些。例如，一个大文件可以存储在一些分散的区段中，或者还会包含一些操作系统可以确定其文件类型的附加数据，但是这些是操作系统，而不是我们程序员所要关心的事情。我们应该考虑如何在C程序中处理文件。 1.2 流的概念​ 流是一个动态的概念，可以将一个字节形象地比喻成一滴水，字节在设备、文件和程序之间的传输就是流，类似于水在管道中的传输，可以看出，流是对输入输出源的一种抽象，也是对传输信息的一种抽象。 ​ C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据，特定I/O设备的细节对程序员是隐藏的。 1.2.1 文本流​ 文本流，也就是以文本模式读取文件。文本流的某些特性在不同的系统中不同。其中之一就是文本行的最大长度。标准规定至少允许254个字符。另一个可能不同的特性是文本行的结束方式。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾。但是在Linux下只用一个换行符结尾 ​ 标准的C把文件定义为零个或多个字符，后面跟一个表示结束的换行符\\n。对于那些文本行的外在表现形式与这个定义不同的系统上，库函数负责外部形式与内部形式之间的翻译。例如，在Windows系统中，在输出时，文本的换行符被写成一对回车/换行符。在输入时，文本中的回车符被丢弃。这种不必考虑文本的外部形式而操作文本的外部形式而操作文本的能力简化了可移值程序的创建。 1.2.2 二进制流​ 二进制流中的字节将完全根据程序编写他们的形式写入到文件中，而且完全根据他们从文件或设备读取的形式度入到从程序中。他们并未作任何改变。这种类型的流适用于非文本数据，到那时如果你不希望I/O函数修改文本文件的行末字符，也可以把他们运用于文本文件。 ​ c语言在处理这两种文件的时候并不区分，都看成是字符流，按字节进行处理。 ​ 我们程序中，经常看到文本方式打开文件的二进制方式打开文件仅仅体现在换行符的处理上。 ​ 比如说，在Windows下，文件的换行符是\\r\\n，而在Linux下换行符是\\n。 ​ 当对文件使用文本方式打开时，读写的Windows文件中的换行符\\r\\n会被替换成\\n读到内存中，当在Windows下写入文件时，\\n会被替换成\\r\\n再写入文件。如果使用二进制的方式打开文件，则不进行\\r\\n和\\n之间的转换，那么由于Linux下的换行符就是\\n，所以文本文件方式和二进制方式无区别。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:1","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#122-二进制流"},{"categories":["C"],"content":" 2、文件的操作 2.1 文件流总览 程序为通吃处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当他处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式（读。写、或者读写）。fopen和操作系统验证文件或设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放file结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 2.2 文件指针​ 我们知道，文件是由操作系统管理的单元。当我们想操作一个文件的时候，让操作系统帮我们打开文件，操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指针指向文件的信息。文件指针也可以理解为代指打开的文件。这个指针的类型为FILE类型。该类型定义在stdio.h头文件中。通过文件指针，我们就可以对文件进行各种操作。 ​ 对于每一个ANSI C程序，运行时系统必须提供至少三个流-标准输入(stdin)、标准输出(stdout)、标准错误(stderr)，它们都是一个指向FILE结构的指针。标准输入是缺省情况下的输入来源，标准输出时缺省情况下的输出设置。具体缺省值因编译器而异，通常标准输入为键盘设备、标准输出为终端或者屏幕。 ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。VS下FILE信息如下： struct _iobuf { char *_ptr; //文件输入的下一个位置 int _cnt; //剩余多少字符未被读取 char *_base; //指基础位置(应该是文件的其始位置) int _flag; //文件标志 int _file; //文件的有效性验证 int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取 int _bufsiz; //文件的大小 char *_tmpfname; //临时文件名 }; typedef struct _iobuf FILE; 2.3 文件缓冲区文件缓冲区 ​ ANSI C标准采用“缓冲文件系统”处理数据文件 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲 区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 那么文件缓冲区有什么作用呢？ ​ 如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。 2.4 文件打开关闭 2.4.1 文件打开 fopen​ 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置 返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab\" 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 void test(){ FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } } 应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 2.4.2 文件关闭 fclose​ 文件操作完成后，如果程序没有结束，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。 int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 ​ 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 2.5 文件读写函数 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:2","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#2文件的操作"},{"categories":["C"],"content":" 2、文件的操作 2.1 文件流总览 程序为通吃处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当他处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式（读。写、或者读写）。fopen和操作系统验证文件或设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放file结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 2.2 文件指针​ 我们知道，文件是由操作系统管理的单元。当我们想操作一个文件的时候，让操作系统帮我们打开文件，操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指针指向文件的信息。文件指针也可以理解为代指打开的文件。这个指针的类型为FILE类型。该类型定义在stdio.h头文件中。通过文件指针，我们就可以对文件进行各种操作。 ​ 对于每一个ANSI C程序，运行时系统必须提供至少三个流-标准输入(stdin)、标准输出(stdout)、标准错误(stderr)，它们都是一个指向FILE结构的指针。标准输入是缺省情况下的输入来源，标准输出时缺省情况下的输出设置。具体缺省值因编译器而异，通常标准输入为键盘设备、标准输出为终端或者屏幕。 ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。VS下FILE信息如下： struct _iobuf { char *_ptr; //文件输入的下一个位置 int _cnt; //剩余多少字符未被读取 char *_base; //指基础位置(应该是文件的其始位置) int _flag; //文件标志 int _file; //文件的有效性验证 int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取 int _bufsiz; //文件的大小 char *_tmpfname; //临时文件名 }; typedef struct _iobuf FILE; 2.3 文件缓冲区文件缓冲区 ​ ANSI C标准采用“缓冲文件系统”处理数据文件 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲 区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 那么文件缓冲区有什么作用呢？ ​ 如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。 2.4 文件打开关闭 2.4.1 文件打开 fopen​ 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置 返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab\" 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 void test(){ FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } } 应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 2.4.2 文件关闭 fclose​ 文件操作完成后，如果程序没有结束，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。 int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 ​ 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 2.5 文件读写函数 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:2","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#21-文件流总览"},{"categories":["C"],"content":" 2、文件的操作 2.1 文件流总览 程序为通吃处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当他处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式（读。写、或者读写）。fopen和操作系统验证文件或设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放file结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 2.2 文件指针​ 我们知道，文件是由操作系统管理的单元。当我们想操作一个文件的时候，让操作系统帮我们打开文件，操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指针指向文件的信息。文件指针也可以理解为代指打开的文件。这个指针的类型为FILE类型。该类型定义在stdio.h头文件中。通过文件指针，我们就可以对文件进行各种操作。 ​ 对于每一个ANSI C程序，运行时系统必须提供至少三个流-标准输入(stdin)、标准输出(stdout)、标准错误(stderr)，它们都是一个指向FILE结构的指针。标准输入是缺省情况下的输入来源，标准输出时缺省情况下的输出设置。具体缺省值因编译器而异，通常标准输入为键盘设备、标准输出为终端或者屏幕。 ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。VS下FILE信息如下： struct _iobuf { char *_ptr; //文件输入的下一个位置 int _cnt; //剩余多少字符未被读取 char *_base; //指基础位置(应该是文件的其始位置) int _flag; //文件标志 int _file; //文件的有效性验证 int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取 int _bufsiz; //文件的大小 char *_tmpfname; //临时文件名 }; typedef struct _iobuf FILE; 2.3 文件缓冲区文件缓冲区 ​ ANSI C标准采用“缓冲文件系统”处理数据文件 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲 区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 那么文件缓冲区有什么作用呢？ ​ 如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。 2.4 文件打开关闭 2.4.1 文件打开 fopen​ 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置 返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab\" 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 void test(){ FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } } 应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 2.4.2 文件关闭 fclose​ 文件操作完成后，如果程序没有结束，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。 int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 ​ 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 2.5 文件读写函数 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:2","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#22-文件指针"},{"categories":["C"],"content":" 2、文件的操作 2.1 文件流总览 程序为通吃处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当他处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式（读。写、或者读写）。fopen和操作系统验证文件或设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放file结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 2.2 文件指针​ 我们知道，文件是由操作系统管理的单元。当我们想操作一个文件的时候，让操作系统帮我们打开文件，操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指针指向文件的信息。文件指针也可以理解为代指打开的文件。这个指针的类型为FILE类型。该类型定义在stdio.h头文件中。通过文件指针，我们就可以对文件进行各种操作。 ​ 对于每一个ANSI C程序，运行时系统必须提供至少三个流-标准输入(stdin)、标准输出(stdout)、标准错误(stderr)，它们都是一个指向FILE结构的指针。标准输入是缺省情况下的输入来源，标准输出时缺省情况下的输出设置。具体缺省值因编译器而异，通常标准输入为键盘设备、标准输出为终端或者屏幕。 ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。VS下FILE信息如下： struct _iobuf { char *_ptr; //文件输入的下一个位置 int _cnt; //剩余多少字符未被读取 char *_base; //指基础位置(应该是文件的其始位置) int _flag; //文件标志 int _file; //文件的有效性验证 int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取 int _bufsiz; //文件的大小 char *_tmpfname; //临时文件名 }; typedef struct _iobuf FILE; 2.3 文件缓冲区文件缓冲区 ​ ANSI C标准采用“缓冲文件系统”处理数据文件 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲 区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 那么文件缓冲区有什么作用呢？ ​ 如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。 2.4 文件打开关闭 2.4.1 文件打开 fopen​ 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置 返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab\" 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 void test(){ FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } } 应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 2.4.2 文件关闭 fclose​ 文件操作完成后，如果程序没有结束，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。 int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 ​ 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 2.5 文件读写函数 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:2","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#23-文件缓冲区"},{"categories":["C"],"content":" 2、文件的操作 2.1 文件流总览 程序为通吃处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当他处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式（读。写、或者读写）。fopen和操作系统验证文件或设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放file结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 2.2 文件指针​ 我们知道，文件是由操作系统管理的单元。当我们想操作一个文件的时候，让操作系统帮我们打开文件，操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指针指向文件的信息。文件指针也可以理解为代指打开的文件。这个指针的类型为FILE类型。该类型定义在stdio.h头文件中。通过文件指针，我们就可以对文件进行各种操作。 ​ 对于每一个ANSI C程序，运行时系统必须提供至少三个流-标准输入(stdin)、标准输出(stdout)、标准错误(stderr)，它们都是一个指向FILE结构的指针。标准输入是缺省情况下的输入来源，标准输出时缺省情况下的输出设置。具体缺省值因编译器而异，通常标准输入为键盘设备、标准输出为终端或者屏幕。 ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。VS下FILE信息如下： struct _iobuf { char *_ptr; //文件输入的下一个位置 int _cnt; //剩余多少字符未被读取 char *_base; //指基础位置(应该是文件的其始位置) int _flag; //文件标志 int _file; //文件的有效性验证 int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取 int _bufsiz; //文件的大小 char *_tmpfname; //临时文件名 }; typedef struct _iobuf FILE; 2.3 文件缓冲区文件缓冲区 ​ ANSI C标准采用“缓冲文件系统”处理数据文件 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲 区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 那么文件缓冲区有什么作用呢？ ​ 如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。 2.4 文件打开关闭 2.4.1 文件打开 fopen​ 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置 返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab\" 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 void test(){ FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } } 应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 2.4.2 文件关闭 fclose​ 文件操作完成后，如果程序没有结束，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。 int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 ​ 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 2.5 文件读写函数 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:2","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#24-文件打开关闭"},{"categories":["C"],"content":" 2、文件的操作 2.1 文件流总览 程序为通吃处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当他处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式（读。写、或者读写）。fopen和操作系统验证文件或设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放file结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 2.2 文件指针​ 我们知道，文件是由操作系统管理的单元。当我们想操作一个文件的时候，让操作系统帮我们打开文件，操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指针指向文件的信息。文件指针也可以理解为代指打开的文件。这个指针的类型为FILE类型。该类型定义在stdio.h头文件中。通过文件指针，我们就可以对文件进行各种操作。 ​ 对于每一个ANSI C程序，运行时系统必须提供至少三个流-标准输入(stdin)、标准输出(stdout)、标准错误(stderr)，它们都是一个指向FILE结构的指针。标准输入是缺省情况下的输入来源，标准输出时缺省情况下的输出设置。具体缺省值因编译器而异，通常标准输入为键盘设备、标准输出为终端或者屏幕。 ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。VS下FILE信息如下： struct _iobuf { char *_ptr; //文件输入的下一个位置 int _cnt; //剩余多少字符未被读取 char *_base; //指基础位置(应该是文件的其始位置) int _flag; //文件标志 int _file; //文件的有效性验证 int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取 int _bufsiz; //文件的大小 char *_tmpfname; //临时文件名 }; typedef struct _iobuf FILE; 2.3 文件缓冲区文件缓冲区 ​ ANSI C标准采用“缓冲文件系统”处理数据文件 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲 区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 那么文件缓冲区有什么作用呢？ ​ 如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。 2.4 文件打开关闭 2.4.1 文件打开 fopen​ 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置 返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab\" 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 void test(){ FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } } 应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 2.4.2 文件关闭 fclose​ 文件操作完成后，如果程序没有结束，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。 int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 ​ 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 2.5 文件读写函数 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:2","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#241-文件打开-fopen"},{"categories":["C"],"content":" 2、文件的操作 2.1 文件流总览 程序为通吃处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当他处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式（读。写、或者读写）。fopen和操作系统验证文件或设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放file结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 2.2 文件指针​ 我们知道，文件是由操作系统管理的单元。当我们想操作一个文件的时候，让操作系统帮我们打开文件，操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指针指向文件的信息。文件指针也可以理解为代指打开的文件。这个指针的类型为FILE类型。该类型定义在stdio.h头文件中。通过文件指针，我们就可以对文件进行各种操作。 ​ 对于每一个ANSI C程序，运行时系统必须提供至少三个流-标准输入(stdin)、标准输出(stdout)、标准错误(stderr)，它们都是一个指向FILE结构的指针。标准输入是缺省情况下的输入来源，标准输出时缺省情况下的输出设置。具体缺省值因编译器而异，通常标准输入为键盘设备、标准输出为终端或者屏幕。 ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。VS下FILE信息如下： struct _iobuf { char *_ptr; //文件输入的下一个位置 int _cnt; //剩余多少字符未被读取 char *_base; //指基础位置(应该是文件的其始位置) int _flag; //文件标志 int _file; //文件的有效性验证 int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取 int _bufsiz; //文件的大小 char *_tmpfname; //临时文件名 }; typedef struct _iobuf FILE; 2.3 文件缓冲区文件缓冲区 ​ ANSI C标准采用“缓冲文件系统”处理数据文件 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲 区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 那么文件缓冲区有什么作用呢？ ​ 如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。 2.4 文件打开关闭 2.4.1 文件打开 fopen​ 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置 返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab\" 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 void test(){ FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } } 应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 2.4.2 文件关闭 fclose​ 文件操作完成后，如果程序没有结束，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。 int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 ​ 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 2.5 文件读写函数 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:2","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#242-文件关闭--fclose"},{"categories":["C"],"content":" 2、文件的操作 2.1 文件流总览 程序为通吃处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当他处于活动状态时由流使用。 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式（读。写、或者读写）。fopen和操作系统验证文件或设备是否存在并初始化FILE。 根据需要对文件进行读写操作。 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放file结构。 标准I/O更为简单，因为它们并不需要打开或者关闭。 I/O函数以三种基本的形式处理数据：单个字符、文本行和二进制数据。对于每种形式都有一组特定的函数对它们进行处理。 家族名 目的 可用于所有流 只用于stdin和stdout getchar 字符输入 fgetc、getc getchar putchar 字符输出 fputc、putc putchar gets 文本行输入 fgets gets puts 文本行输出 fputs puts scanf 格式化输入 fscanf scanf printf 格式化输出 fprintf printf 2.2 文件指针​ 我们知道，文件是由操作系统管理的单元。当我们想操作一个文件的时候，让操作系统帮我们打开文件，操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指针指向文件的信息。文件指针也可以理解为代指打开的文件。这个指针的类型为FILE类型。该类型定义在stdio.h头文件中。通过文件指针，我们就可以对文件进行各种操作。 ​ 对于每一个ANSI C程序，运行时系统必须提供至少三个流-标准输入(stdin)、标准输出(stdout)、标准错误(stderr)，它们都是一个指向FILE结构的指针。标准输入是缺省情况下的输入来源，标准输出时缺省情况下的输出设置。具体缺省值因编译器而异，通常标准输入为键盘设备、标准输出为终端或者屏幕。 ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。VS下FILE信息如下： struct _iobuf { char *_ptr; //文件输入的下一个位置 int _cnt; //剩余多少字符未被读取 char *_base; //指基础位置(应该是文件的其始位置) int _flag; //文件标志 int _file; //文件的有效性验证 int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取 int _bufsiz; //文件的大小 char *_tmpfname; //临时文件名 }; typedef struct _iobuf FILE; 2.3 文件缓冲区文件缓冲区 ​ ANSI C标准采用“缓冲文件系统”处理数据文件 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲 区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。 那么文件缓冲区有什么作用呢？ ​ 如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。 2.4 文件打开关闭 2.4.1 文件打开 fopen​ 文件的打开操作表示将给用户指定的文件在内存分配一个FILE结构区，并将该结构的指针返回给用户程序，以后用户程序就可用此FILE指针来实现对指定文件的存取操作了。当使用打开函数时，必须给出文件名、文件操作方式(读、写或读写)。 FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的权限设置 返回值： 成功：文件指针 失败：NULL 方式 含义 “r” 打开，只读，文件必须已经存在。 “w” 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 “a” 只能在文件末尾追加数据,如果文件不存在则创建 “rb” 打开一个二进制文件，只读 “wb” 打开一个二进制文件，只写 “ab\" 打开一个二进制文件，追加 “r+” 允许读和写,文件必须已存在 “w+” 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 “a+” 允许读和追加数据,如果文件不存在则创建 “rb+” 以读/写方式打开一个二进制文件 “wb+” 以读/写方式建立一个新的二进制文件 “ab+” 以读/写方式打开一个二进制文件进行追加 void test(){ FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } } 应该检查fopen的返回值!如何函数失败，它会返回一个NULL值。如果程序不检查错误，这个NULL指针就会传给后续的I/O函数。它们将对这个指针执行间接访问，并将失败. 2.4.2 文件关闭 fclose​ 文件操作完成后，如果程序没有结束，必须要用fclose()函数进行关闭，这是因为对打开的文件进行写入时，若文件缓冲区的空间未被写入的内容填满，这些内容不会写到打开的文件中。只有对打开的文件进行关闭操作时，停留在文件缓冲区的内容才能写到该文件中去，从而使文件完整。再者一旦关闭了文件，该文件对应的FILE结构将被释放，从而使关闭的文件得到保护，因为这时对该文件的存取操作将不会进行。文件的关闭也意味着释放了该文件的缓冲区。 int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 ​ 它表示该函数将关闭FILE指针对应的文件，并返回一个整数值。若成功地关闭了文件，则返回一个0值，否则返回一个非0值. 2.5 文件读写函数 按照字符读写文件：fgetc(), fputc() 按照行读写文件：fputs(), fgets() 按照块读写文件：fread(), fwirte() 按照格式化读写文件：fprintf(), fscanf() 按照随机位置读写文件：fseek(), ftell(), rewind() ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/:0:2","series":null,"tags":["C"],"title":"文件操作pro","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cpro/#25-文件读写函数"},{"categories":["C"],"content":" 1、结构体基础知识 1.1 结构体类型的定义 struct Person{ char name[64]; int age; }; typedef struct _PERSON{ char name[64]; int age; }Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 1.2 结构体变量的定义 struct Person{ char name[64]; int age; }p1; //定义类型同时定义变量 struct{ char name[64]; int age; }p2; //定义类型同时定义变量 struct Person p3; //通过类型直接定义 1.3 结构体变量的初始化 struct Person{ char name[64]; int age; }p1 = {\"john\",10}; //定义类型同时初始化变量 struct{ char name[64]; int age; }p2 = {\"Obama\",30}; //定义类型同时初始化变量 struct Person p3 = {\"Edward\",33}; //通过类型直接定义 1.4 结构体成员的使用 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-\u003ename, \"Obama\"); p2-\u003eage = 33; //如果是指针变量，通过-\u003e操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-\u003ename, p2-\u003eage); } 1.5 结构体赋值 1.5.1 赋值基本概念​ 相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量。 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1 = { \"John\" , 30}; struct Person p2 = { \"Obama\", 33 }; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); //将p2的值赋值给p1 p1 = p2; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); } 1.5.2 深拷贝和浅拷贝 //一个老师有N个学生 typedef struct _TEACHER{ char* name; }Teacher; void test(){ Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL){ free(t1.name); t1.name = NULL; } if (t2.name != NULL){ free(t2.name); t1.name = NULL; } } 1.6 结构体数组 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1[3] = { { \"John\", 30 }, { \"Obama\", 33 }, { \"Edward\", 25} }; struct Person p2[3] = { \"John\", 30, \"Obama\", 33, \"Edward\", 25 }; for (int i = 0; i \u003c 3;i ++){ printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); } printf(\"-----------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); } printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i \u003c 3;i++){ sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; } for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); } } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#1结构体基础知识"},{"categories":["C"],"content":" 1、结构体基础知识 1.1 结构体类型的定义 struct Person{ char name[64]; int age; }; typedef struct _PERSON{ char name[64]; int age; }Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 1.2 结构体变量的定义 struct Person{ char name[64]; int age; }p1; //定义类型同时定义变量 struct{ char name[64]; int age; }p2; //定义类型同时定义变量 struct Person p3; //通过类型直接定义 1.3 结构体变量的初始化 struct Person{ char name[64]; int age; }p1 = {\"john\",10}; //定义类型同时初始化变量 struct{ char name[64]; int age; }p2 = {\"Obama\",30}; //定义类型同时初始化变量 struct Person p3 = {\"Edward\",33}; //通过类型直接定义 1.4 结构体成员的使用 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-\u003ename, \"Obama\"); p2-\u003eage = 33; //如果是指针变量，通过-\u003e操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-\u003ename, p2-\u003eage); } 1.5 结构体赋值 1.5.1 赋值基本概念​ 相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量。 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1 = { \"John\" , 30}; struct Person p2 = { \"Obama\", 33 }; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); //将p2的值赋值给p1 p1 = p2; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); } 1.5.2 深拷贝和浅拷贝 //一个老师有N个学生 typedef struct _TEACHER{ char* name; }Teacher; void test(){ Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL){ free(t1.name); t1.name = NULL; } if (t2.name != NULL){ free(t2.name); t1.name = NULL; } } 1.6 结构体数组 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1[3] = { { \"John\", 30 }, { \"Obama\", 33 }, { \"Edward\", 25} }; struct Person p2[3] = { \"John\", 30, \"Obama\", 33, \"Edward\", 25 }; for (int i = 0; i \u003c 3;i ++){ printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); } printf(\"-----------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); } printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i \u003c 3;i++){ sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; } for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); } } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#11-结构体类型的定义"},{"categories":["C"],"content":" 1、结构体基础知识 1.1 结构体类型的定义 struct Person{ char name[64]; int age; }; typedef struct _PERSON{ char name[64]; int age; }Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 1.2 结构体变量的定义 struct Person{ char name[64]; int age; }p1; //定义类型同时定义变量 struct{ char name[64]; int age; }p2; //定义类型同时定义变量 struct Person p3; //通过类型直接定义 1.3 结构体变量的初始化 struct Person{ char name[64]; int age; }p1 = {\"john\",10}; //定义类型同时初始化变量 struct{ char name[64]; int age; }p2 = {\"Obama\",30}; //定义类型同时初始化变量 struct Person p3 = {\"Edward\",33}; //通过类型直接定义 1.4 结构体成员的使用 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-\u003ename, \"Obama\"); p2-\u003eage = 33; //如果是指针变量，通过-\u003e操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-\u003ename, p2-\u003eage); } 1.5 结构体赋值 1.5.1 赋值基本概念​ 相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量。 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1 = { \"John\" , 30}; struct Person p2 = { \"Obama\", 33 }; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); //将p2的值赋值给p1 p1 = p2; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); } 1.5.2 深拷贝和浅拷贝 //一个老师有N个学生 typedef struct _TEACHER{ char* name; }Teacher; void test(){ Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL){ free(t1.name); t1.name = NULL; } if (t2.name != NULL){ free(t2.name); t1.name = NULL; } } 1.6 结构体数组 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1[3] = { { \"John\", 30 }, { \"Obama\", 33 }, { \"Edward\", 25} }; struct Person p2[3] = { \"John\", 30, \"Obama\", 33, \"Edward\", 25 }; for (int i = 0; i \u003c 3;i ++){ printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); } printf(\"-----------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); } printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i \u003c 3;i++){ sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; } for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); } } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#12-结构体变量的定义"},{"categories":["C"],"content":" 1、结构体基础知识 1.1 结构体类型的定义 struct Person{ char name[64]; int age; }; typedef struct _PERSON{ char name[64]; int age; }Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 1.2 结构体变量的定义 struct Person{ char name[64]; int age; }p1; //定义类型同时定义变量 struct{ char name[64]; int age; }p2; //定义类型同时定义变量 struct Person p3; //通过类型直接定义 1.3 结构体变量的初始化 struct Person{ char name[64]; int age; }p1 = {\"john\",10}; //定义类型同时初始化变量 struct{ char name[64]; int age; }p2 = {\"Obama\",30}; //定义类型同时初始化变量 struct Person p3 = {\"Edward\",33}; //通过类型直接定义 1.4 结构体成员的使用 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-\u003ename, \"Obama\"); p2-\u003eage = 33; //如果是指针变量，通过-\u003e操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-\u003ename, p2-\u003eage); } 1.5 结构体赋值 1.5.1 赋值基本概念​ 相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量。 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1 = { \"John\" , 30}; struct Person p2 = { \"Obama\", 33 }; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); //将p2的值赋值给p1 p1 = p2; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); } 1.5.2 深拷贝和浅拷贝 //一个老师有N个学生 typedef struct _TEACHER{ char* name; }Teacher; void test(){ Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL){ free(t1.name); t1.name = NULL; } if (t2.name != NULL){ free(t2.name); t1.name = NULL; } } 1.6 结构体数组 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1[3] = { { \"John\", 30 }, { \"Obama\", 33 }, { \"Edward\", 25} }; struct Person p2[3] = { \"John\", 30, \"Obama\", 33, \"Edward\", 25 }; for (int i = 0; i \u003c 3;i ++){ printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); } printf(\"-----------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); } printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i \u003c 3;i++){ sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; } for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); } } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#13-结构体变量的初始化"},{"categories":["C"],"content":" 1、结构体基础知识 1.1 结构体类型的定义 struct Person{ char name[64]; int age; }; typedef struct _PERSON{ char name[64]; int age; }Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 1.2 结构体变量的定义 struct Person{ char name[64]; int age; }p1; //定义类型同时定义变量 struct{ char name[64]; int age; }p2; //定义类型同时定义变量 struct Person p3; //通过类型直接定义 1.3 结构体变量的初始化 struct Person{ char name[64]; int age; }p1 = {\"john\",10}; //定义类型同时初始化变量 struct{ char name[64]; int age; }p2 = {\"Obama\",30}; //定义类型同时初始化变量 struct Person p3 = {\"Edward\",33}; //通过类型直接定义 1.4 结构体成员的使用 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-\u003ename, \"Obama\"); p2-\u003eage = 33; //如果是指针变量，通过-\u003e操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-\u003ename, p2-\u003eage); } 1.5 结构体赋值 1.5.1 赋值基本概念​ 相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量。 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1 = { \"John\" , 30}; struct Person p2 = { \"Obama\", 33 }; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); //将p2的值赋值给p1 p1 = p2; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); } 1.5.2 深拷贝和浅拷贝 //一个老师有N个学生 typedef struct _TEACHER{ char* name; }Teacher; void test(){ Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL){ free(t1.name); t1.name = NULL; } if (t2.name != NULL){ free(t2.name); t1.name = NULL; } } 1.6 结构体数组 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1[3] = { { \"John\", 30 }, { \"Obama\", 33 }, { \"Edward\", 25} }; struct Person p2[3] = { \"John\", 30, \"Obama\", 33, \"Edward\", 25 }; for (int i = 0; i \u003c 3;i ++){ printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); } printf(\"-----------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); } printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i \u003c 3;i++){ sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; } for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); } } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#14-结构体成员的使用"},{"categories":["C"],"content":" 1、结构体基础知识 1.1 结构体类型的定义 struct Person{ char name[64]; int age; }; typedef struct _PERSON{ char name[64]; int age; }Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 1.2 结构体变量的定义 struct Person{ char name[64]; int age; }p1; //定义类型同时定义变量 struct{ char name[64]; int age; }p2; //定义类型同时定义变量 struct Person p3; //通过类型直接定义 1.3 结构体变量的初始化 struct Person{ char name[64]; int age; }p1 = {\"john\",10}; //定义类型同时初始化变量 struct{ char name[64]; int age; }p2 = {\"Obama\",30}; //定义类型同时初始化变量 struct Person p3 = {\"Edward\",33}; //通过类型直接定义 1.4 结构体成员的使用 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-\u003ename, \"Obama\"); p2-\u003eage = 33; //如果是指针变量，通过-\u003e操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-\u003ename, p2-\u003eage); } 1.5 结构体赋值 1.5.1 赋值基本概念​ 相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量。 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1 = { \"John\" , 30}; struct Person p2 = { \"Obama\", 33 }; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); //将p2的值赋值给p1 p1 = p2; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); } 1.5.2 深拷贝和浅拷贝 //一个老师有N个学生 typedef struct _TEACHER{ char* name; }Teacher; void test(){ Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL){ free(t1.name); t1.name = NULL; } if (t2.name != NULL){ free(t2.name); t1.name = NULL; } } 1.6 结构体数组 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1[3] = { { \"John\", 30 }, { \"Obama\", 33 }, { \"Edward\", 25} }; struct Person p2[3] = { \"John\", 30, \"Obama\", 33, \"Edward\", 25 }; for (int i = 0; i \u003c 3;i ++){ printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); } printf(\"-----------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); } printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i \u003c 3;i++){ sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; } for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); } } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#15-结构体赋值"},{"categories":["C"],"content":" 1、结构体基础知识 1.1 结构体类型的定义 struct Person{ char name[64]; int age; }; typedef struct _PERSON{ char name[64]; int age; }Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 1.2 结构体变量的定义 struct Person{ char name[64]; int age; }p1; //定义类型同时定义变量 struct{ char name[64]; int age; }p2; //定义类型同时定义变量 struct Person p3; //通过类型直接定义 1.3 结构体变量的初始化 struct Person{ char name[64]; int age; }p1 = {\"john\",10}; //定义类型同时初始化变量 struct{ char name[64]; int age; }p2 = {\"Obama\",30}; //定义类型同时初始化变量 struct Person p3 = {\"Edward\",33}; //通过类型直接定义 1.4 结构体成员的使用 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-\u003ename, \"Obama\"); p2-\u003eage = 33; //如果是指针变量，通过-\u003e操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-\u003ename, p2-\u003eage); } 1.5 结构体赋值 1.5.1 赋值基本概念​ 相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量。 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1 = { \"John\" , 30}; struct Person p2 = { \"Obama\", 33 }; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); //将p2的值赋值给p1 p1 = p2; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); } 1.5.2 深拷贝和浅拷贝 //一个老师有N个学生 typedef struct _TEACHER{ char* name; }Teacher; void test(){ Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL){ free(t1.name); t1.name = NULL; } if (t2.name != NULL){ free(t2.name); t1.name = NULL; } } 1.6 结构体数组 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1[3] = { { \"John\", 30 }, { \"Obama\", 33 }, { \"Edward\", 25} }; struct Person p2[3] = { \"John\", 30, \"Obama\", 33, \"Edward\", 25 }; for (int i = 0; i \u003c 3;i ++){ printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); } printf(\"-----------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); } printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i \u003c 3;i++){ sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; } for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); } } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#151-赋值基本概念"},{"categories":["C"],"content":" 1、结构体基础知识 1.1 结构体类型的定义 struct Person{ char name[64]; int age; }; typedef struct _PERSON{ char name[64]; int age; }Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 1.2 结构体变量的定义 struct Person{ char name[64]; int age; }p1; //定义类型同时定义变量 struct{ char name[64]; int age; }p2; //定义类型同时定义变量 struct Person p3; //通过类型直接定义 1.3 结构体变量的初始化 struct Person{ char name[64]; int age; }p1 = {\"john\",10}; //定义类型同时初始化变量 struct{ char name[64]; int age; }p2 = {\"Obama\",30}; //定义类型同时初始化变量 struct Person p3 = {\"Edward\",33}; //通过类型直接定义 1.4 结构体成员的使用 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-\u003ename, \"Obama\"); p2-\u003eage = 33; //如果是指针变量，通过-\u003e操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-\u003ename, p2-\u003eage); } 1.5 结构体赋值 1.5.1 赋值基本概念​ 相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量。 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1 = { \"John\" , 30}; struct Person p2 = { \"Obama\", 33 }; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); //将p2的值赋值给p1 p1 = p2; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); } 1.5.2 深拷贝和浅拷贝 //一个老师有N个学生 typedef struct _TEACHER{ char* name; }Teacher; void test(){ Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL){ free(t1.name); t1.name = NULL; } if (t2.name != NULL){ free(t2.name); t1.name = NULL; } } 1.6 结构体数组 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1[3] = { { \"John\", 30 }, { \"Obama\", 33 }, { \"Edward\", 25} }; struct Person p2[3] = { \"John\", 30, \"Obama\", 33, \"Edward\", 25 }; for (int i = 0; i \u003c 3;i ++){ printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); } printf(\"-----------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); } printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i \u003c 3;i++){ sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; } for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); } } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#152-深拷贝和浅拷贝"},{"categories":["C"],"content":" 1、结构体基础知识 1.1 结构体类型的定义 struct Person{ char name[64]; int age; }; typedef struct _PERSON{ char name[64]; int age; }Person; 注意：定义结构体类型时不要直接给成员赋值，结构体只是一个类型，编译器还没有为其分配空间，只有根据其类型定义变量时，才分配空间，有空间后才能赋值。 1.2 结构体变量的定义 struct Person{ char name[64]; int age; }p1; //定义类型同时定义变量 struct{ char name[64]; int age; }p2; //定义类型同时定义变量 struct Person p3; //通过类型直接定义 1.3 结构体变量的初始化 struct Person{ char name[64]; int age; }p1 = {\"john\",10}; //定义类型同时初始化变量 struct{ char name[64]; int age; }p2 = {\"Obama\",30}; //定义类型同时初始化变量 struct Person p3 = {\"Edward\",33}; //通过类型直接定义 1.4 结构体成员的使用 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1; strcpy(p1.name, \"John\"); p1.age = 30; //如果是普通变量，通过点运算符操作结构体成员 printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); //在堆上分配空间 struct Person* p2 = (struct Person*)malloc(sizeof(struct Person)); strcpy(p2-\u003ename, \"Obama\"); p2-\u003eage = 33; //如果是指针变量，通过-\u003e操作结构体成员 printf(\"Name:%s Age:%d\\n\", p2-\u003ename, p2-\u003eage); } 1.5 结构体赋值 1.5.1 赋值基本概念​ 相同的两个结构体变量可以相互赋值，把一个结构体变量的值拷贝给另一个结构体，这两个变量还是两个独立的变量。 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1 = { \"John\" , 30}; struct Person p2 = { \"Obama\", 33 }; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); //将p2的值赋值给p1 p1 = p2; printf(\"Name:%s Age:%d\\n\", p1.name, p1.age); printf(\"Name:%s Age:%d\\n\", p2.name, p2.age); } 1.5.2 深拷贝和浅拷贝 //一个老师有N个学生 typedef struct _TEACHER{ char* name; }Teacher; void test(){ Teacher t1; t1.name = malloc(64); strcpy(t1.name , \"John\"); Teacher t2; t2 = t1; //对手动开辟的内存，需要手动拷贝 t2.name = malloc(64); strcpy(t2.name, t1.name); if (t1.name != NULL){ free(t1.name); t1.name = NULL; } if (t2.name != NULL){ free(t2.name); t1.name = NULL; } } 1.6 结构体数组 struct Person{ char name[64]; int age; }; void test(){ //在栈上分配空间 struct Person p1[3] = { { \"John\", 30 }, { \"Obama\", 33 }, { \"Edward\", 25} }; struct Person p2[3] = { \"John\", 30, \"Obama\", 33, \"Edward\", 25 }; for (int i = 0; i \u003c 3;i ++){ printf(\"Name:%s Age:%d\\n\",p1[i].name,p1[i].age); } printf(\"-----------------\\n\"); for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p2[i].name, p2[i].age); } printf(\"-----------------\\n\"); //在堆上分配结构体数组 struct Person* p3 = (struct Person*)malloc(sizeof(struct Person) * 3); for (int i = 0; i \u003c 3;i++){ sprintf(p3[i].name, \"Name_%d\", i + 1); p3[i].age = 20 + i; } for (int i = 0; i \u003c 3; i++){ printf(\"Name:%s Age:%d\\n\", p3[i].name, p3[i].age); } } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#16-结构体数组"},{"categories":["C"],"content":" 2、结构体嵌套指针 2.1 结构体嵌套一级指针 struct Person{ char* name; int age; }; void allocate_memory(struct Person** person){ if (person == NULL){ return; } struct Person* temp = (struct Person*)malloc(sizeof(struct Person)); if (temp == NULL){ return; } //给name指针分配内存 temp-\u003ename = (char*)malloc(sizeof(char)* 64); strcpy(temp-\u003ename, \"John\"); temp-\u003eage = 100; *person = temp; } void print_person(struct Person* person){ printf(\"Name:%s Age:%d\\n\",person-\u003ename,person-\u003eage); } void free_memory(struct Person** person){ if (person == NULL){ return; } struct Person* temp = *person; if (temp-\u003ename != NULL){ free(temp-\u003ename); temp-\u003ename = NULL; } free(temp); } void test(){ struct Person* p = NULL; allocate_memory(\u0026p); print_person(p); free_memory(\u0026p); } 2.2 结构体嵌套二级指针 //一个老师有N个学生 typedef struct _TEACHER{ char name[64]; char** students; }Teacher; void create_teacher(Teacher** teacher,int n,int m){ if (teacher == NULL){ return; } //创建老师数组 Teacher* teachers = (Teacher*)malloc(sizeof(Teacher)* n); if (teachers == NULL){ return; } //给每一个老师分配学生 int num = 0; for (int i = 0; i \u003c n; i ++){ sprintf(teachers[i].name, \"老师_%d\", i + 1); teachers[i].students = (char**)malloc(sizeof(char*) * m); for (int j = 0; j \u003c m;j++){ teachers[i].students[j] = malloc(64); sprintf(teachers[i].students[j], \"学生_%d\", num + 1); num++; } } *teacher = teachers; } void print_teacher(Teacher* teacher,int n,int m){ for (int i = 0; i \u003c n; i ++){ printf(\"%s:\\n\", teacher[i].name); for (int j = 0; j \u003c m;j++){ printf(\" %s\",teacher[i].students[j]); } printf(\"\\n\"); } } void free_memory(Teacher** teacher,int n,int m){ if (teacher == NULL){ return; } Teacher* temp = *teacher; for (int i = 0; i \u003c n; i ++){ for (int j = 0; j \u003c m;j ++){ free(temp[i].students[j]); temp[i].students[j] = NULL; } free(temp[i].students); temp[i].students = NULL; } free(temp); } void test(){ Teacher* p = NULL; create_teacher(\u0026p,2,3); print_teacher(p, 2, 3); free_memory(\u0026p,2,3); } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:2","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#2结构体嵌套指针"},{"categories":["C"],"content":" 2、结构体嵌套指针 2.1 结构体嵌套一级指针 struct Person{ char* name; int age; }; void allocate_memory(struct Person** person){ if (person == NULL){ return; } struct Person* temp = (struct Person*)malloc(sizeof(struct Person)); if (temp == NULL){ return; } //给name指针分配内存 temp-\u003ename = (char*)malloc(sizeof(char)* 64); strcpy(temp-\u003ename, \"John\"); temp-\u003eage = 100; *person = temp; } void print_person(struct Person* person){ printf(\"Name:%s Age:%d\\n\",person-\u003ename,person-\u003eage); } void free_memory(struct Person** person){ if (person == NULL){ return; } struct Person* temp = *person; if (temp-\u003ename != NULL){ free(temp-\u003ename); temp-\u003ename = NULL; } free(temp); } void test(){ struct Person* p = NULL; allocate_memory(\u0026p); print_person(p); free_memory(\u0026p); } 2.2 结构体嵌套二级指针 //一个老师有N个学生 typedef struct _TEACHER{ char name[64]; char** students; }Teacher; void create_teacher(Teacher** teacher,int n,int m){ if (teacher == NULL){ return; } //创建老师数组 Teacher* teachers = (Teacher*)malloc(sizeof(Teacher)* n); if (teachers == NULL){ return; } //给每一个老师分配学生 int num = 0; for (int i = 0; i \u003c n; i ++){ sprintf(teachers[i].name, \"老师_%d\", i + 1); teachers[i].students = (char**)malloc(sizeof(char*) * m); for (int j = 0; j \u003c m;j++){ teachers[i].students[j] = malloc(64); sprintf(teachers[i].students[j], \"学生_%d\", num + 1); num++; } } *teacher = teachers; } void print_teacher(Teacher* teacher,int n,int m){ for (int i = 0; i \u003c n; i ++){ printf(\"%s:\\n\", teacher[i].name); for (int j = 0; j \u003c m;j++){ printf(\" %s\",teacher[i].students[j]); } printf(\"\\n\"); } } void free_memory(Teacher** teacher,int n,int m){ if (teacher == NULL){ return; } Teacher* temp = *teacher; for (int i = 0; i \u003c n; i ++){ for (int j = 0; j \u003c m;j ++){ free(temp[i].students[j]); temp[i].students[j] = NULL; } free(temp[i].students); temp[i].students = NULL; } free(temp); } void test(){ Teacher* p = NULL; create_teacher(\u0026p,2,3); print_teacher(p, 2, 3); free_memory(\u0026p,2,3); } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:2","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#21-结构体嵌套一级指针"},{"categories":["C"],"content":" 2、结构体嵌套指针 2.1 结构体嵌套一级指针 struct Person{ char* name; int age; }; void allocate_memory(struct Person** person){ if (person == NULL){ return; } struct Person* temp = (struct Person*)malloc(sizeof(struct Person)); if (temp == NULL){ return; } //给name指针分配内存 temp-\u003ename = (char*)malloc(sizeof(char)* 64); strcpy(temp-\u003ename, \"John\"); temp-\u003eage = 100; *person = temp; } void print_person(struct Person* person){ printf(\"Name:%s Age:%d\\n\",person-\u003ename,person-\u003eage); } void free_memory(struct Person** person){ if (person == NULL){ return; } struct Person* temp = *person; if (temp-\u003ename != NULL){ free(temp-\u003ename); temp-\u003ename = NULL; } free(temp); } void test(){ struct Person* p = NULL; allocate_memory(\u0026p); print_person(p); free_memory(\u0026p); } 2.2 结构体嵌套二级指针 //一个老师有N个学生 typedef struct _TEACHER{ char name[64]; char** students; }Teacher; void create_teacher(Teacher** teacher,int n,int m){ if (teacher == NULL){ return; } //创建老师数组 Teacher* teachers = (Teacher*)malloc(sizeof(Teacher)* n); if (teachers == NULL){ return; } //给每一个老师分配学生 int num = 0; for (int i = 0; i \u003c n; i ++){ sprintf(teachers[i].name, \"老师_%d\", i + 1); teachers[i].students = (char**)malloc(sizeof(char*) * m); for (int j = 0; j \u003c m;j++){ teachers[i].students[j] = malloc(64); sprintf(teachers[i].students[j], \"学生_%d\", num + 1); num++; } } *teacher = teachers; } void print_teacher(Teacher* teacher,int n,int m){ for (int i = 0; i \u003c n; i ++){ printf(\"%s:\\n\", teacher[i].name); for (int j = 0; j \u003c m;j++){ printf(\" %s\",teacher[i].students[j]); } printf(\"\\n\"); } } void free_memory(Teacher** teacher,int n,int m){ if (teacher == NULL){ return; } Teacher* temp = *teacher; for (int i = 0; i \u003c n; i ++){ for (int j = 0; j \u003c m;j ++){ free(temp[i].students[j]); temp[i].students[j] = NULL; } free(temp[i].students); temp[i].students = NULL; } free(temp); } void test(){ Teacher* p = NULL; create_teacher(\u0026p,2,3); print_teacher(p, 2, 3); free_memory(\u0026p,2,3); } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:2","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#22-结构体嵌套二级指针"},{"categories":["C"],"content":" 3、结构体成员偏移量 //一旦结构体定义下来，则结构体中的成员内存布局就定下了 #include \u003cstddef.h\u003e struct Teacher { char a; int b; }; void test01(){ struct Teacher t1; struct Teacher*p = \u0026t1; int offsize1 = (int)\u0026(p-\u003eb) - (int)p; //成员b 相对于结构体 Teacher的偏移量 int offsize2 = offsetof(struct Teacher, b); printf(\"offsize1:%d \\n\", offsize1); //打印b属性对于首地址的偏移量 printf(\"offsize2:%d \\n\", offsize2); } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:3","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#3结构体成员偏移量"},{"categories":["C"],"content":" 4、结构体字节对齐​ 在用sizeof运算符求某结构体所占空间时，并不是简单的将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。 ​ 从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列，而不是简单的顺序排列，这就是内存对齐。 4.1 内存对齐 4.1.1 内存对齐原因​ 内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，所以内存对我们是如下图这样的： ​ 但实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等， ​ 内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度（这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍）。如果没有对齐，为了访问一个变量可能产生二次访问。 ​ 那么实现内存对齐的好处是： 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要两个读取周期读取该变量。 某些平台只能在特定的地质处访问特定类型的数据，否则抛出硬件异常给操作系统。 对于标准数据类型，它的地址只要是它的长度的整数倍。 对于非标准数据类型，比如结构体，要遵循一下对齐原则： \\1. 数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为***min（当前成员的大小，#pargama pack(n)）***整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。 \\2. 结构体总的大小，也就是sizeof的结果，必须是***min（结构体内部最大成员，#pargama pack(n)）***的整数倍，不足要补齐。 \\3. 结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。 手动设置对齐模数: #pragma pack(show) 显示当前packing alignment的字节数，以warning message的形式被显示。 #pragma pack(n) 指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 4.2 内存对齐案例 #pragma pack(4) typedef struct _STUDENT{ int a; char b; double c; float d; }Student; typedef struct _STUDENT2{ char a; Student b; double c; }Student2; void test01(){ //Student //a从偏移量0位置开始存储 //b从4位置开始存储 //c从8位置开始存储 //d从12位置开存储 //所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24 printf(\"sizeof Student:%d\\n\",sizeof(Student)); //Student2 //a从偏移量为0位置开始 //b从偏移量为Student内部最大成员整数倍开始，也就是8开始 //c从8的整数倍地方开始,也就是32开始 //所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40 printf(\"sizeof Student2:%d\\n\", sizeof(Student2)); } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#4结构体字节对齐"},{"categories":["C"],"content":" 4、结构体字节对齐​ 在用sizeof运算符求某结构体所占空间时，并不是简单的将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。 ​ 从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列，而不是简单的顺序排列，这就是内存对齐。 4.1 内存对齐 4.1.1 内存对齐原因​ 内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，所以内存对我们是如下图这样的： ​ 但实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等， ​ 内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度（这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍）。如果没有对齐，为了访问一个变量可能产生二次访问。 ​ 那么实现内存对齐的好处是： 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要两个读取周期读取该变量。 某些平台只能在特定的地质处访问特定类型的数据，否则抛出硬件异常给操作系统。 对于标准数据类型，它的地址只要是它的长度的整数倍。 对于非标准数据类型，比如结构体，要遵循一下对齐原则： \\1. 数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为***min（当前成员的大小，#pargama pack(n)）***整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。 \\2. 结构体总的大小，也就是sizeof的结果，必须是***min（结构体内部最大成员，#pargama pack(n)）***的整数倍，不足要补齐。 \\3. 结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。 手动设置对齐模数: #pragma pack(show) 显示当前packing alignment的字节数，以warning message的形式被显示。 #pragma pack(n) 指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 4.2 内存对齐案例 #pragma pack(4) typedef struct _STUDENT{ int a; char b; double c; float d; }Student; typedef struct _STUDENT2{ char a; Student b; double c; }Student2; void test01(){ //Student //a从偏移量0位置开始存储 //b从4位置开始存储 //c从8位置开始存储 //d从12位置开存储 //所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24 printf(\"sizeof Student:%d\\n\",sizeof(Student)); //Student2 //a从偏移量为0位置开始 //b从偏移量为Student内部最大成员整数倍开始，也就是8开始 //c从8的整数倍地方开始,也就是32开始 //所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40 printf(\"sizeof Student2:%d\\n\", sizeof(Student2)); } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#41-内存对齐"},{"categories":["C"],"content":" 4、结构体字节对齐​ 在用sizeof运算符求某结构体所占空间时，并不是简单的将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。 ​ 从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列，而不是简单的顺序排列，这就是内存对齐。 4.1 内存对齐 4.1.1 内存对齐原因​ 内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，所以内存对我们是如下图这样的： ​ 但实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等， ​ 内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度（这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍）。如果没有对齐，为了访问一个变量可能产生二次访问。 ​ 那么实现内存对齐的好处是： 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要两个读取周期读取该变量。 某些平台只能在特定的地质处访问特定类型的数据，否则抛出硬件异常给操作系统。 对于标准数据类型，它的地址只要是它的长度的整数倍。 对于非标准数据类型，比如结构体，要遵循一下对齐原则： \\1. 数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为***min（当前成员的大小，#pargama pack(n)）***整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。 \\2. 结构体总的大小，也就是sizeof的结果，必须是***min（结构体内部最大成员，#pargama pack(n)）***的整数倍，不足要补齐。 \\3. 结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。 手动设置对齐模数: #pragma pack(show) 显示当前packing alignment的字节数，以warning message的形式被显示。 #pragma pack(n) 指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 4.2 内存对齐案例 #pragma pack(4) typedef struct _STUDENT{ int a; char b; double c; float d; }Student; typedef struct _STUDENT2{ char a; Student b; double c; }Student2; void test01(){ //Student //a从偏移量0位置开始存储 //b从4位置开始存储 //c从8位置开始存储 //d从12位置开存储 //所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24 printf(\"sizeof Student:%d\\n\",sizeof(Student)); //Student2 //a从偏移量为0位置开始 //b从偏移量为Student内部最大成员整数倍开始，也就是8开始 //c从8的整数倍地方开始,也就是32开始 //所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40 printf(\"sizeof Student2:%d\\n\", sizeof(Student2)); } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#411-内存对齐原因"},{"categories":["C"],"content":" 4、结构体字节对齐​ 在用sizeof运算符求某结构体所占空间时，并不是简单的将结构体中所有元素各自占的空间相加，这里涉及到内存字节对齐的问题。 ​ 从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列，而不是简单的顺序排列，这就是内存对齐。 4.1 内存对齐 4.1.1 内存对齐原因​ 内存的最小单元是一个字节，当cpu从内存中读取数据的时候，是一个一个字节读取，所以内存对我们是如下图这样的： ​ 但实际上cpu将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等， ​ 内存对齐是操作系统为了提高访问内存的策略。操作系统在访问内存的时候，每次读取一定长度（这个长度是操作系统默认的对齐数，或者默认对齐数的整数倍）。如果没有对齐，为了访问一个变量可能产生二次访问。 ​ 那么实现内存对齐的好处是： 提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要两个读取周期读取该变量。 某些平台只能在特定的地质处访问特定类型的数据，否则抛出硬件异常给操作系统。 对于标准数据类型，它的地址只要是它的长度的整数倍。 对于非标准数据类型，比如结构体，要遵循一下对齐原则： \\1. 数组成员对齐规则。第一个数组成员应该放在offset为0的地方，以后每个数组成员应该放在offset为***min（当前成员的大小，#pargama pack(n)）***整数倍的地方开始（比如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地方开始存储）。 \\2. 结构体总的大小，也就是sizeof的结果，必须是***min（结构体内部最大成员，#pargama pack(n)）***的整数倍，不足要补齐。 \\3. 结构体做为成员的对齐规则。如果一个结构体B里嵌套另一个结构体A,还是以最大成员类型的大小对齐，但是结构体A的起点为A内部最大成员的整数倍的地方。（struct B里存有struct A，A里有char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对齐规则仍满足原则1、原则2。 手动设置对齐模数: #pragma pack(show) 显示当前packing alignment的字节数，以warning message的形式被显示。 #pragma pack(n) 指定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1,2,4,8,16。 4.2 内存对齐案例 #pragma pack(4) typedef struct _STUDENT{ int a; char b; double c; float d; }Student; typedef struct _STUDENT2{ char a; Student b; double c; }Student2; void test01(){ //Student //a从偏移量0位置开始存储 //b从4位置开始存储 //c从8位置开始存储 //d从12位置开存储 //所以Student内部对齐之后的大小为20 ，整体对齐，整体为最大类型的整数倍 也就是8的整数倍 为24 printf(\"sizeof Student:%d\\n\",sizeof(Student)); //Student2 //a从偏移量为0位置开始 //b从偏移量为Student内部最大成员整数倍开始，也就是8开始 //c从8的整数倍地方开始,也就是32开始 //所以结构体Sutdnet2内部对齐之后的大小为：40 ， 由于结构体中最大成员为8，必须为8的整数倍 所以大小为40 printf(\"sizeof Student2:%d\\n\", sizeof(Student2)); } ","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"结构体强化","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93%E5%BC%BA%E5%8C%96/#42-内存对齐案例"},{"categories":["C"],"content":" 1、一维数组 元素类型角度：数组是相同类型的变量的有序集合 内存角度：连续的一大片内存空间 1.1 数组名考虑下面这些声明： int a; int b[10]; 我们把a称作标量，因为它是个单一的值，这个变量值的类型是一个整数。我们把b称作数组，因为它是一些值的集合。下标和数组名一起使用，用于标识该集合中某个特定的值。例如，b[0]表示数组b的第1个值，b[4]表示第5个值。每个值都是一个特定的标量。 那么问题是b的类型是什么？它所表示的又是什么？一个合乎逻辑的答案是它表示整个数组，但事实并非如此。在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。它的类型取决于数组元素的类型：如果他们是int类型，那么数组名的类型就是“指向int的常量指针”；如果它们是其他类型，那么数组名的类型也就是“指向其他类型的常量指针”。 请问：指针和数组是等价的吗？ 答案是否定的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下： 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。 当数组名作为\u0026操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。 int arr[10]; //arr = NULL; //arr作为指针常量，不可修改 int *p = arr; //此时arr作为指针常量来使用 printf(\"sizeof(arr):%d\\n\", sizeof(arr)); //此时sizeof结果为整个数组的长度 printf(\"\u0026arr type is %s\\n\", typeid(\u0026arr).name()); //int(*)[10]而不是int* 1.2 下标引用 int arr[] = { 1, 2, 3, 4, 5, 6 }; *(arr + 3) ,这个表达式是什么意思呢？ ​ 首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的： *(arr + 3) arr[3] int arr[] = { 5, 3, 6, 8, 2, 9 }; int *p = arr + 2; printf(\"*p = %d\\n\", *p);//6 printf(\"*p = %d\\n\", p[-1]);//3 1.3 数组和指针指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明： int a[10]; int *b; ​ 声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。 ​ 因此，表达式*a是完全合法的，但是表达式*b却是非法的。*b将访问内存中一个不确定的位置，将会导致程序终止。另一方面b++可以通过编译，a++却不行，因为a是一个常量值。 1.4 作为函数参数的数组名当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的： int print_array(int *arr); int print_array(int arr[]); ​ 我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。同样sizeof arr值是指针的长度，而不是数组的长度。 ​ 现在我们清楚了，为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数。 ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:1","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#1一维数组"},{"categories":["C"],"content":" 1、一维数组 元素类型角度：数组是相同类型的变量的有序集合 内存角度：连续的一大片内存空间 1.1 数组名考虑下面这些声明： int a; int b[10]; 我们把a称作标量，因为它是个单一的值，这个变量值的类型是一个整数。我们把b称作数组，因为它是一些值的集合。下标和数组名一起使用，用于标识该集合中某个特定的值。例如，b[0]表示数组b的第1个值，b[4]表示第5个值。每个值都是一个特定的标量。 那么问题是b的类型是什么？它所表示的又是什么？一个合乎逻辑的答案是它表示整个数组，但事实并非如此。在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。它的类型取决于数组元素的类型：如果他们是int类型，那么数组名的类型就是“指向int的常量指针”；如果它们是其他类型，那么数组名的类型也就是“指向其他类型的常量指针”。 请问：指针和数组是等价的吗？ 答案是否定的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下： 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。 当数组名作为\u0026操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。 int arr[10]; //arr = NULL; //arr作为指针常量，不可修改 int *p = arr; //此时arr作为指针常量来使用 printf(\"sizeof(arr):%d\\n\", sizeof(arr)); //此时sizeof结果为整个数组的长度 printf(\"\u0026arr type is %s\\n\", typeid(\u0026arr).name()); //int(*)[10]而不是int* 1.2 下标引用 int arr[] = { 1, 2, 3, 4, 5, 6 }; *(arr + 3) ,这个表达式是什么意思呢？ ​ 首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的： *(arr + 3) arr[3] int arr[] = { 5, 3, 6, 8, 2, 9 }; int *p = arr + 2; printf(\"*p = %d\\n\", *p);//6 printf(\"*p = %d\\n\", p[-1]);//3 1.3 数组和指针指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明： int a[10]; int *b; ​ 声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。 ​ 因此，表达式*a是完全合法的，但是表达式*b却是非法的。*b将访问内存中一个不确定的位置，将会导致程序终止。另一方面b++可以通过编译，a++却不行，因为a是一个常量值。 1.4 作为函数参数的数组名当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的： int print_array(int *arr); int print_array(int arr[]); ​ 我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。同样sizeof arr值是指针的长度，而不是数组的长度。 ​ 现在我们清楚了，为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数。 ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:1","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#11-数组名"},{"categories":["C"],"content":" 1、一维数组 元素类型角度：数组是相同类型的变量的有序集合 内存角度：连续的一大片内存空间 1.1 数组名考虑下面这些声明： int a; int b[10]; 我们把a称作标量，因为它是个单一的值，这个变量值的类型是一个整数。我们把b称作数组，因为它是一些值的集合。下标和数组名一起使用，用于标识该集合中某个特定的值。例如，b[0]表示数组b的第1个值，b[4]表示第5个值。每个值都是一个特定的标量。 那么问题是b的类型是什么？它所表示的又是什么？一个合乎逻辑的答案是它表示整个数组，但事实并非如此。在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。它的类型取决于数组元素的类型：如果他们是int类型，那么数组名的类型就是“指向int的常量指针”；如果它们是其他类型，那么数组名的类型也就是“指向其他类型的常量指针”。 请问：指针和数组是等价的吗？ 答案是否定的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下： 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。 当数组名作为\u0026操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。 int arr[10]; //arr = NULL; //arr作为指针常量，不可修改 int *p = arr; //此时arr作为指针常量来使用 printf(\"sizeof(arr):%d\\n\", sizeof(arr)); //此时sizeof结果为整个数组的长度 printf(\"\u0026arr type is %s\\n\", typeid(\u0026arr).name()); //int(*)[10]而不是int* 1.2 下标引用 int arr[] = { 1, 2, 3, 4, 5, 6 }; *(arr + 3) ,这个表达式是什么意思呢？ ​ 首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的： *(arr + 3) arr[3] int arr[] = { 5, 3, 6, 8, 2, 9 }; int *p = arr + 2; printf(\"*p = %d\\n\", *p);//6 printf(\"*p = %d\\n\", p[-1]);//3 1.3 数组和指针指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明： int a[10]; int *b; ​ 声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。 ​ 因此，表达式*a是完全合法的，但是表达式*b却是非法的。*b将访问内存中一个不确定的位置，将会导致程序终止。另一方面b++可以通过编译，a++却不行，因为a是一个常量值。 1.4 作为函数参数的数组名当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的： int print_array(int *arr); int print_array(int arr[]); ​ 我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。同样sizeof arr值是指针的长度，而不是数组的长度。 ​ 现在我们清楚了，为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数。 ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:1","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#12-下标引用"},{"categories":["C"],"content":" 1、一维数组 元素类型角度：数组是相同类型的变量的有序集合 内存角度：连续的一大片内存空间 1.1 数组名考虑下面这些声明： int a; int b[10]; 我们把a称作标量，因为它是个单一的值，这个变量值的类型是一个整数。我们把b称作数组，因为它是一些值的集合。下标和数组名一起使用，用于标识该集合中某个特定的值。例如，b[0]表示数组b的第1个值，b[4]表示第5个值。每个值都是一个特定的标量。 那么问题是b的类型是什么？它所表示的又是什么？一个合乎逻辑的答案是它表示整个数组，但事实并非如此。在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。它的类型取决于数组元素的类型：如果他们是int类型，那么数组名的类型就是“指向int的常量指针”；如果它们是其他类型，那么数组名的类型也就是“指向其他类型的常量指针”。 请问：指针和数组是等价的吗？ 答案是否定的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下： 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。 当数组名作为\u0026操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。 int arr[10]; //arr = NULL; //arr作为指针常量，不可修改 int *p = arr; //此时arr作为指针常量来使用 printf(\"sizeof(arr):%d\\n\", sizeof(arr)); //此时sizeof结果为整个数组的长度 printf(\"\u0026arr type is %s\\n\", typeid(\u0026arr).name()); //int(*)[10]而不是int* 1.2 下标引用 int arr[] = { 1, 2, 3, 4, 5, 6 }; *(arr + 3) ,这个表达式是什么意思呢？ ​ 首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的： *(arr + 3) arr[3] int arr[] = { 5, 3, 6, 8, 2, 9 }; int *p = arr + 2; printf(\"*p = %d\\n\", *p);//6 printf(\"*p = %d\\n\", p[-1]);//3 1.3 数组和指针指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明： int a[10]; int *b; ​ 声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。 ​ 因此，表达式*a是完全合法的，但是表达式*b却是非法的。*b将访问内存中一个不确定的位置，将会导致程序终止。另一方面b++可以通过编译，a++却不行，因为a是一个常量值。 1.4 作为函数参数的数组名当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的： int print_array(int *arr); int print_array(int arr[]); ​ 我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。同样sizeof arr值是指针的长度，而不是数组的长度。 ​ 现在我们清楚了，为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数。 ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:1","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#13-数组和指针"},{"categories":["C"],"content":" 1、一维数组 元素类型角度：数组是相同类型的变量的有序集合 内存角度：连续的一大片内存空间 1.1 数组名考虑下面这些声明： int a; int b[10]; 我们把a称作标量，因为它是个单一的值，这个变量值的类型是一个整数。我们把b称作数组，因为它是一些值的集合。下标和数组名一起使用，用于标识该集合中某个特定的值。例如，b[0]表示数组b的第1个值，b[4]表示第5个值。每个值都是一个特定的标量。 那么问题是b的类型是什么？它所表示的又是什么？一个合乎逻辑的答案是它表示整个数组，但事实并非如此。在C中，在几乎所有数组名的表达式中，数组名的值是一个指针常量，也就是数组第一个元素的地址。它的类型取决于数组元素的类型：如果他们是int类型，那么数组名的类型就是“指向int的常量指针”；如果它们是其他类型，那么数组名的类型也就是“指向其他类型的常量指针”。 请问：指针和数组是等价的吗？ 答案是否定的。数组名在表达式中使用的时候，编译器才会产生一个指针常量。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下： 当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。 当数组名作为\u0026操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。 int arr[10]; //arr = NULL; //arr作为指针常量，不可修改 int *p = arr; //此时arr作为指针常量来使用 printf(\"sizeof(arr):%d\\n\", sizeof(arr)); //此时sizeof结果为整个数组的长度 printf(\"\u0026arr type is %s\\n\", typeid(\u0026arr).name()); //int(*)[10]而不是int* 1.2 下标引用 int arr[] = { 1, 2, 3, 4, 5, 6 }; *(arr + 3) ,这个表达式是什么意思呢？ ​ 首先，我们说数组在表达式中是一个指向整型的指针，所以此表达式表示arr指针向后移动了3个元素的长度。然后通过间接访问操作符从这个新地址开始获取这个位置的值。这个和下标的引用的执行过程完全相同。所以如下表达式是等同的： *(arr + 3) arr[3] int arr[] = { 5, 3, 6, 8, 2, 9 }; int *p = arr + 2; printf(\"*p = %d\\n\", *p);//6 printf(\"*p = %d\\n\", p[-1]);//3 1.3 数组和指针指针和数组并不是相等的。为了说明这个概念，请考虑下面两个声明： int a[10]; int *b; ​ 声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。 ​ 因此，表达式*a是完全合法的，但是表达式*b却是非法的。*b将访问内存中一个不确定的位置，将会导致程序终止。另一方面b++可以通过编译，a++却不行，因为a是一个常量值。 1.4 作为函数参数的数组名当一个数组名作为一个参数传递给一个函数的时候发生什么情况呢？我们现在知道数组名其实就是一个指向数组第1个元素的指针，所以很明白此时传递给函数的是一份指针的拷贝。所以函数的形参实际上是一个指针。但是为了使程序员新手容易上手一些，编译器也接受数组形式的函数形参。因此下面两种函数原型是相等的： int print_array(int *arr); int print_array(int arr[]); ​ 我们可以使用任何一种声明，但哪一个更准确一些呢？答案是指针。因为实参实际上是个指针，而不是数组。同样sizeof arr值是指针的长度，而不是数组的长度。 ​ 现在我们清楚了，为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数。 ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:1","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#14-作为函数参数的数组名"},{"categories":["C"],"content":" 2、多维数组​ 如果某个数组的维数不止1个，它就被称为多维数组。接下来的案例讲解以二维数组举例。 void test01(){ //二维数组初始化 int arr1[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //打印二维数组 for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j ++){ printf(\"%d \",arr1[i][j]); } printf(\"\\n\"); } } 2.1 数组名​ 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： int arr[3][10] ​ 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 2.2 指向数组的指针(数组指针) 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：`int array[5]` 的类型为 int[5]；C语言可通过`typedef`定义一个数组类型： 定义数组指针有一下三种方式： //方式一 void test01(){ //先定义数组类型，再用数组类型定义数组指针 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10;i++){ printf(\"%d \",(*pArr)[i]); } printf(\"\\n\"); } //方式二 void test02(){ int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } //方式三 void test03(){ int arr[10]; int(*pArr)[10] = \u0026arr; for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } 2.3 指针数组(元素为指针) 2.3.1 栈区指针数组 //数组做函数函数，退化为指针 void array_sort(char** arr,int len){ for (int i = 0; i \u003c len; i++){ for (int j = len - 1; j \u003e i; j --){ //比较两个字符串 if (strcmp(arr[j-1],arr[j]) \u003e 0){ char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } } } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } void test(){ //主调函数分配内存 //指针数组 char* p[] = { \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"}; //char** p = { \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" }; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len); } 2.3.2 堆区指针数组 //分配内存 char** allocate_memory(int n){ if (n \u003c 0 ){ return NULL; } char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL){ return NULL; } //分别给每一个指针malloc分配内存 for (int i = 0; i \u003c n; i ++){ temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); } return temp; } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } //释放内存 void free_memory(char** buf,int len){ if (buf == NULL){ return; } for (int i = 0; i \u003c len; i ++){ free(buf[i]); buf[i] = NULL; } free(buf); } void test(){ int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n); } 2.4 二维数组三种参数形式 2.4.1 二维数组的线性存储特性 void PrintArray(int* arr, int len){ for (int i = 0; i \u003c len; i++){ printf(\"%d \", arr[i]); } printf(\"\\n\"); } //二维数组的线性存储 void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i \u003c len; i++){ printf(\"%d \", p[i]); } printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len); } 2.4.2 二维数组的3种形式参数 //二维数组的第一种形式 void PrintArray01(int arr[3][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray02(int arr[][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray03(int(*arr)[3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr); } ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:2","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#2多维数组"},{"categories":["C"],"content":" 2、多维数组​ 如果某个数组的维数不止1个，它就被称为多维数组。接下来的案例讲解以二维数组举例。 void test01(){ //二维数组初始化 int arr1[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //打印二维数组 for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j ++){ printf(\"%d \",arr1[i][j]); } printf(\"\\n\"); } } 2.1 数组名​ 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： int arr[3][10] ​ 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 2.2 指向数组的指针(数组指针) 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：`int array[5]` 的类型为 int[5]；C语言可通过`typedef`定义一个数组类型： 定义数组指针有一下三种方式： //方式一 void test01(){ //先定义数组类型，再用数组类型定义数组指针 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10;i++){ printf(\"%d \",(*pArr)[i]); } printf(\"\\n\"); } //方式二 void test02(){ int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } //方式三 void test03(){ int arr[10]; int(*pArr)[10] = \u0026arr; for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } 2.3 指针数组(元素为指针) 2.3.1 栈区指针数组 //数组做函数函数，退化为指针 void array_sort(char** arr,int len){ for (int i = 0; i \u003c len; i++){ for (int j = len - 1; j \u003e i; j --){ //比较两个字符串 if (strcmp(arr[j-1],arr[j]) \u003e 0){ char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } } } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } void test(){ //主调函数分配内存 //指针数组 char* p[] = { \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"}; //char** p = { \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" }; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len); } 2.3.2 堆区指针数组 //分配内存 char** allocate_memory(int n){ if (n \u003c 0 ){ return NULL; } char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL){ return NULL; } //分别给每一个指针malloc分配内存 for (int i = 0; i \u003c n; i ++){ temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); } return temp; } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } //释放内存 void free_memory(char** buf,int len){ if (buf == NULL){ return; } for (int i = 0; i \u003c len; i ++){ free(buf[i]); buf[i] = NULL; } free(buf); } void test(){ int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n); } 2.4 二维数组三种参数形式 2.4.1 二维数组的线性存储特性 void PrintArray(int* arr, int len){ for (int i = 0; i \u003c len; i++){ printf(\"%d \", arr[i]); } printf(\"\\n\"); } //二维数组的线性存储 void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i \u003c len; i++){ printf(\"%d \", p[i]); } printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len); } 2.4.2 二维数组的3种形式参数 //二维数组的第一种形式 void PrintArray01(int arr[3][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray02(int arr[][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray03(int(*arr)[3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr); } ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:2","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#21-数组名"},{"categories":["C"],"content":" 2、多维数组​ 如果某个数组的维数不止1个，它就被称为多维数组。接下来的案例讲解以二维数组举例。 void test01(){ //二维数组初始化 int arr1[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //打印二维数组 for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j ++){ printf(\"%d \",arr1[i][j]); } printf(\"\\n\"); } } 2.1 数组名​ 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： int arr[3][10] ​ 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 2.2 指向数组的指针(数组指针) 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：`int array[5]` 的类型为 int[5]；C语言可通过`typedef`定义一个数组类型： 定义数组指针有一下三种方式： //方式一 void test01(){ //先定义数组类型，再用数组类型定义数组指针 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10;i++){ printf(\"%d \",(*pArr)[i]); } printf(\"\\n\"); } //方式二 void test02(){ int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } //方式三 void test03(){ int arr[10]; int(*pArr)[10] = \u0026arr; for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } 2.3 指针数组(元素为指针) 2.3.1 栈区指针数组 //数组做函数函数，退化为指针 void array_sort(char** arr,int len){ for (int i = 0; i \u003c len; i++){ for (int j = len - 1; j \u003e i; j --){ //比较两个字符串 if (strcmp(arr[j-1],arr[j]) \u003e 0){ char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } } } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } void test(){ //主调函数分配内存 //指针数组 char* p[] = { \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"}; //char** p = { \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" }; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len); } 2.3.2 堆区指针数组 //分配内存 char** allocate_memory(int n){ if (n \u003c 0 ){ return NULL; } char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL){ return NULL; } //分别给每一个指针malloc分配内存 for (int i = 0; i \u003c n; i ++){ temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); } return temp; } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } //释放内存 void free_memory(char** buf,int len){ if (buf == NULL){ return; } for (int i = 0; i \u003c len; i ++){ free(buf[i]); buf[i] = NULL; } free(buf); } void test(){ int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n); } 2.4 二维数组三种参数形式 2.4.1 二维数组的线性存储特性 void PrintArray(int* arr, int len){ for (int i = 0; i \u003c len; i++){ printf(\"%d \", arr[i]); } printf(\"\\n\"); } //二维数组的线性存储 void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i \u003c len; i++){ printf(\"%d \", p[i]); } printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len); } 2.4.2 二维数组的3种形式参数 //二维数组的第一种形式 void PrintArray01(int arr[3][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray02(int arr[][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray03(int(*arr)[3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr); } ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:2","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#22-指向数组的指针数组指针"},{"categories":["C"],"content":" 2、多维数组​ 如果某个数组的维数不止1个，它就被称为多维数组。接下来的案例讲解以二维数组举例。 void test01(){ //二维数组初始化 int arr1[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //打印二维数组 for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j ++){ printf(\"%d \",arr1[i][j]); } printf(\"\\n\"); } } 2.1 数组名​ 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： int arr[3][10] ​ 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 2.2 指向数组的指针(数组指针) 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：`int array[5]` 的类型为 int[5]；C语言可通过`typedef`定义一个数组类型： 定义数组指针有一下三种方式： //方式一 void test01(){ //先定义数组类型，再用数组类型定义数组指针 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10;i++){ printf(\"%d \",(*pArr)[i]); } printf(\"\\n\"); } //方式二 void test02(){ int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } //方式三 void test03(){ int arr[10]; int(*pArr)[10] = \u0026arr; for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } 2.3 指针数组(元素为指针) 2.3.1 栈区指针数组 //数组做函数函数，退化为指针 void array_sort(char** arr,int len){ for (int i = 0; i \u003c len; i++){ for (int j = len - 1; j \u003e i; j --){ //比较两个字符串 if (strcmp(arr[j-1],arr[j]) \u003e 0){ char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } } } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } void test(){ //主调函数分配内存 //指针数组 char* p[] = { \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"}; //char** p = { \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" }; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len); } 2.3.2 堆区指针数组 //分配内存 char** allocate_memory(int n){ if (n \u003c 0 ){ return NULL; } char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL){ return NULL; } //分别给每一个指针malloc分配内存 for (int i = 0; i \u003c n; i ++){ temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); } return temp; } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } //释放内存 void free_memory(char** buf,int len){ if (buf == NULL){ return; } for (int i = 0; i \u003c len; i ++){ free(buf[i]); buf[i] = NULL; } free(buf); } void test(){ int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n); } 2.4 二维数组三种参数形式 2.4.1 二维数组的线性存储特性 void PrintArray(int* arr, int len){ for (int i = 0; i \u003c len; i++){ printf(\"%d \", arr[i]); } printf(\"\\n\"); } //二维数组的线性存储 void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i \u003c len; i++){ printf(\"%d \", p[i]); } printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len); } 2.4.2 二维数组的3种形式参数 //二维数组的第一种形式 void PrintArray01(int arr[3][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray02(int arr[][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray03(int(*arr)[3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr); } ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:2","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#23-指针数组元素为指针"},{"categories":["C"],"content":" 2、多维数组​ 如果某个数组的维数不止1个，它就被称为多维数组。接下来的案例讲解以二维数组举例。 void test01(){ //二维数组初始化 int arr1[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //打印二维数组 for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j ++){ printf(\"%d \",arr1[i][j]); } printf(\"\\n\"); } } 2.1 数组名​ 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： int arr[3][10] ​ 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 2.2 指向数组的指针(数组指针) 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：`int array[5]` 的类型为 int[5]；C语言可通过`typedef`定义一个数组类型： 定义数组指针有一下三种方式： //方式一 void test01(){ //先定义数组类型，再用数组类型定义数组指针 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10;i++){ printf(\"%d \",(*pArr)[i]); } printf(\"\\n\"); } //方式二 void test02(){ int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } //方式三 void test03(){ int arr[10]; int(*pArr)[10] = \u0026arr; for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } 2.3 指针数组(元素为指针) 2.3.1 栈区指针数组 //数组做函数函数，退化为指针 void array_sort(char** arr,int len){ for (int i = 0; i \u003c len; i++){ for (int j = len - 1; j \u003e i; j --){ //比较两个字符串 if (strcmp(arr[j-1],arr[j]) \u003e 0){ char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } } } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } void test(){ //主调函数分配内存 //指针数组 char* p[] = { \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"}; //char** p = { \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" }; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len); } 2.3.2 堆区指针数组 //分配内存 char** allocate_memory(int n){ if (n \u003c 0 ){ return NULL; } char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL){ return NULL; } //分别给每一个指针malloc分配内存 for (int i = 0; i \u003c n; i ++){ temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); } return temp; } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } //释放内存 void free_memory(char** buf,int len){ if (buf == NULL){ return; } for (int i = 0; i \u003c len; i ++){ free(buf[i]); buf[i] = NULL; } free(buf); } void test(){ int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n); } 2.4 二维数组三种参数形式 2.4.1 二维数组的线性存储特性 void PrintArray(int* arr, int len){ for (int i = 0; i \u003c len; i++){ printf(\"%d \", arr[i]); } printf(\"\\n\"); } //二维数组的线性存储 void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i \u003c len; i++){ printf(\"%d \", p[i]); } printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len); } 2.4.2 二维数组的3种形式参数 //二维数组的第一种形式 void PrintArray01(int arr[3][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray02(int arr[][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray03(int(*arr)[3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr); } ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:2","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#231-栈区指针数组"},{"categories":["C"],"content":" 2、多维数组​ 如果某个数组的维数不止1个，它就被称为多维数组。接下来的案例讲解以二维数组举例。 void test01(){ //二维数组初始化 int arr1[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //打印二维数组 for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j ++){ printf(\"%d \",arr1[i][j]); } printf(\"\\n\"); } } 2.1 数组名​ 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： int arr[3][10] ​ 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 2.2 指向数组的指针(数组指针) 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：`int array[5]` 的类型为 int[5]；C语言可通过`typedef`定义一个数组类型： 定义数组指针有一下三种方式： //方式一 void test01(){ //先定义数组类型，再用数组类型定义数组指针 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10;i++){ printf(\"%d \",(*pArr)[i]); } printf(\"\\n\"); } //方式二 void test02(){ int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } //方式三 void test03(){ int arr[10]; int(*pArr)[10] = \u0026arr; for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } 2.3 指针数组(元素为指针) 2.3.1 栈区指针数组 //数组做函数函数，退化为指针 void array_sort(char** arr,int len){ for (int i = 0; i \u003c len; i++){ for (int j = len - 1; j \u003e i; j --){ //比较两个字符串 if (strcmp(arr[j-1],arr[j]) \u003e 0){ char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } } } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } void test(){ //主调函数分配内存 //指针数组 char* p[] = { \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"}; //char** p = { \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" }; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len); } 2.3.2 堆区指针数组 //分配内存 char** allocate_memory(int n){ if (n \u003c 0 ){ return NULL; } char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL){ return NULL; } //分别给每一个指针malloc分配内存 for (int i = 0; i \u003c n; i ++){ temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); } return temp; } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } //释放内存 void free_memory(char** buf,int len){ if (buf == NULL){ return; } for (int i = 0; i \u003c len; i ++){ free(buf[i]); buf[i] = NULL; } free(buf); } void test(){ int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n); } 2.4 二维数组三种参数形式 2.4.1 二维数组的线性存储特性 void PrintArray(int* arr, int len){ for (int i = 0; i \u003c len; i++){ printf(\"%d \", arr[i]); } printf(\"\\n\"); } //二维数组的线性存储 void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i \u003c len; i++){ printf(\"%d \", p[i]); } printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len); } 2.4.2 二维数组的3种形式参数 //二维数组的第一种形式 void PrintArray01(int arr[3][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray02(int arr[][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray03(int(*arr)[3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr); } ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:2","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#232-堆区指针数组"},{"categories":["C"],"content":" 2、多维数组​ 如果某个数组的维数不止1个，它就被称为多维数组。接下来的案例讲解以二维数组举例。 void test01(){ //二维数组初始化 int arr1[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //打印二维数组 for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j ++){ printf(\"%d \",arr1[i][j]); } printf(\"\\n\"); } } 2.1 数组名​ 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： int arr[3][10] ​ 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 2.2 指向数组的指针(数组指针) 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：`int array[5]` 的类型为 int[5]；C语言可通过`typedef`定义一个数组类型： 定义数组指针有一下三种方式： //方式一 void test01(){ //先定义数组类型，再用数组类型定义数组指针 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10;i++){ printf(\"%d \",(*pArr)[i]); } printf(\"\\n\"); } //方式二 void test02(){ int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } //方式三 void test03(){ int arr[10]; int(*pArr)[10] = \u0026arr; for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } 2.3 指针数组(元素为指针) 2.3.1 栈区指针数组 //数组做函数函数，退化为指针 void array_sort(char** arr,int len){ for (int i = 0; i \u003c len; i++){ for (int j = len - 1; j \u003e i; j --){ //比较两个字符串 if (strcmp(arr[j-1],arr[j]) \u003e 0){ char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } } } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } void test(){ //主调函数分配内存 //指针数组 char* p[] = { \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"}; //char** p = { \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" }; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len); } 2.3.2 堆区指针数组 //分配内存 char** allocate_memory(int n){ if (n \u003c 0 ){ return NULL; } char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL){ return NULL; } //分别给每一个指针malloc分配内存 for (int i = 0; i \u003c n; i ++){ temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); } return temp; } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } //释放内存 void free_memory(char** buf,int len){ if (buf == NULL){ return; } for (int i = 0; i \u003c len; i ++){ free(buf[i]); buf[i] = NULL; } free(buf); } void test(){ int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n); } 2.4 二维数组三种参数形式 2.4.1 二维数组的线性存储特性 void PrintArray(int* arr, int len){ for (int i = 0; i \u003c len; i++){ printf(\"%d \", arr[i]); } printf(\"\\n\"); } //二维数组的线性存储 void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i \u003c len; i++){ printf(\"%d \", p[i]); } printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len); } 2.4.2 二维数组的3种形式参数 //二维数组的第一种形式 void PrintArray01(int arr[3][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray02(int arr[][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray03(int(*arr)[3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr); } ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:2","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#24-二维数组三种参数形式"},{"categories":["C"],"content":" 2、多维数组​ 如果某个数组的维数不止1个，它就被称为多维数组。接下来的案例讲解以二维数组举例。 void test01(){ //二维数组初始化 int arr1[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //打印二维数组 for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j ++){ printf(\"%d \",arr1[i][j]); } printf(\"\\n\"); } } 2.1 数组名​ 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： int arr[3][10] ​ 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 2.2 指向数组的指针(数组指针) 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：`int array[5]` 的类型为 int[5]；C语言可通过`typedef`定义一个数组类型： 定义数组指针有一下三种方式： //方式一 void test01(){ //先定义数组类型，再用数组类型定义数组指针 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10;i++){ printf(\"%d \",(*pArr)[i]); } printf(\"\\n\"); } //方式二 void test02(){ int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } //方式三 void test03(){ int arr[10]; int(*pArr)[10] = \u0026arr; for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } 2.3 指针数组(元素为指针) 2.3.1 栈区指针数组 //数组做函数函数，退化为指针 void array_sort(char** arr,int len){ for (int i = 0; i \u003c len; i++){ for (int j = len - 1; j \u003e i; j --){ //比较两个字符串 if (strcmp(arr[j-1],arr[j]) \u003e 0){ char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } } } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } void test(){ //主调函数分配内存 //指针数组 char* p[] = { \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"}; //char** p = { \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" }; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len); } 2.3.2 堆区指针数组 //分配内存 char** allocate_memory(int n){ if (n \u003c 0 ){ return NULL; } char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL){ return NULL; } //分别给每一个指针malloc分配内存 for (int i = 0; i \u003c n; i ++){ temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); } return temp; } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } //释放内存 void free_memory(char** buf,int len){ if (buf == NULL){ return; } for (int i = 0; i \u003c len; i ++){ free(buf[i]); buf[i] = NULL; } free(buf); } void test(){ int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n); } 2.4 二维数组三种参数形式 2.4.1 二维数组的线性存储特性 void PrintArray(int* arr, int len){ for (int i = 0; i \u003c len; i++){ printf(\"%d \", arr[i]); } printf(\"\\n\"); } //二维数组的线性存储 void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i \u003c len; i++){ printf(\"%d \", p[i]); } printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len); } 2.4.2 二维数组的3种形式参数 //二维数组的第一种形式 void PrintArray01(int arr[3][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray02(int arr[][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray03(int(*arr)[3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr); } ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:2","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#241-二维数组的线性存储特性"},{"categories":["C"],"content":" 2、多维数组​ 如果某个数组的维数不止1个，它就被称为多维数组。接下来的案例讲解以二维数组举例。 void test01(){ //二维数组初始化 int arr1[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //打印二维数组 for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j ++){ printf(\"%d \",arr1[i][j]); } printf(\"\\n\"); } } 2.1 数组名​ 一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第1个元素。多维数组也是同理，多维数组的数组名也是指向第一个元素，只不过第一个元素是一个数组。例如： int arr[3][10] ​ 可以理解为这是一个一维数组，包含了3个元素，只是每个元素恰好是包含了10个元素的数组。arr就表示指向它的第1个元素的指针，所以arr是一个指向了包含了10个整型元素的数组的指针。 2.2 指向数组的指针(数组指针) 数组指针，它是指针，指向数组的指针。 数组的类型由元素类型和数组大小共同决定：`int array[5]` 的类型为 int[5]；C语言可通过`typedef`定义一个数组类型： 定义数组指针有一下三种方式： //方式一 void test01(){ //先定义数组类型，再用数组类型定义数组指针 int arr[10] = {1,2,3,4,5,6,7,8,9,10}; //有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType typedef int(ArrayType)[10]; //int ArrayType[10]; //定义一个数组，数组名为ArrayType ArrayType myarr; //等价于 int myarr[10]; ArrayType* pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10;i++){ printf(\"%d \",(*pArr)[i]); } printf(\"\\n\"); } //方式二 void test02(){ int arr[10]; //定义数组指针类型 typedef int(*ArrayType)[10]; ArrayType pArr = \u0026arr; //定义了一个数组指针pArr，并且指针指向数组arr for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } //方式三 void test03(){ int arr[10]; int(*pArr)[10] = \u0026arr; for (int i = 0; i \u003c 10; i++){ (*pArr)[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \", (*pArr)[i]); } printf(\"\\n\"); } 2.3 指针数组(元素为指针) 2.3.1 栈区指针数组 //数组做函数函数，退化为指针 void array_sort(char** arr,int len){ for (int i = 0; i \u003c len; i++){ for (int j = len - 1; j \u003e i; j --){ //比较两个字符串 if (strcmp(arr[j-1],arr[j]) \u003e 0){ char* temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } } } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } void test(){ //主调函数分配内存 //指针数组 char* p[] = { \"bbb\", \"aaa\", \"ccc\", \"eee\", \"ddd\"}; //char** p = { \"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\" }; //错误 int len = sizeof(p) / sizeof(char*); //打印数组 array_print(p, len); //对字符串进行排序 array_sort(p, len); //打印数组 array_print(p, len); } 2.3.2 堆区指针数组 //分配内存 char** allocate_memory(int n){ if (n \u003c 0 ){ return NULL; } char** temp = (char**)malloc(sizeof(char*) * n); if (temp == NULL){ return NULL; } //分别给每一个指针malloc分配内存 for (int i = 0; i \u003c n; i ++){ temp[i] = malloc(sizeof(char)* 30); sprintf(temp[i], \"%2d_hello world!\", i + 1); } return temp; } //打印数组 void array_print(char** arr,int len){ for (int i = 0; i \u003c len;i++){ printf(\"%s\\n\",arr[i]); } printf(\"----------------------\\n\"); } //释放内存 void free_memory(char** buf,int len){ if (buf == NULL){ return; } for (int i = 0; i \u003c len; i ++){ free(buf[i]); buf[i] = NULL; } free(buf); } void test(){ int n = 10; char** p = allocate_memory(n); //打印数组 array_print(p, n); //释放内存 free_memory(p, n); } 2.4 二维数组三种参数形式 2.4.1 二维数组的线性存储特性 void PrintArray(int* arr, int len){ for (int i = 0; i \u003c len; i++){ printf(\"%d \", arr[i]); } printf(\"\\n\"); } //二维数组的线性存储 void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int arr2[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; int len = sizeof(arr2) / sizeof(int); //如何证明二维数组是线性的？ //通过将数组首地址指针转成Int*类型，那么步长就变成了4，就可以遍历整个数组 int* p = (int*)arr; for (int i = 0; i \u003c len; i++){ printf(\"%d \", p[i]); } printf(\"\\n\"); PrintArray((int*)arr, len); PrintArray((int*)arr2, len); } 2.4.2 二维数组的3种形式参数 //二维数组的第一种形式 void PrintArray01(int arr[3][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray02(int arr[][3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } //二维数组的第二种形式 void PrintArray03(int(*arr)[3]){ for (int i = 0; i \u003c 3; i++){ for (int j = 0; j \u003c 3; j++){ printf(\"arr[%d][%d]:%d\\n\", i, j, arr[i][j]); } } } void test(){ int arr[][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; PrintArray01(arr); PrintArray02(arr); PrintArray03(arr); } ","date":"2023-12-31","objectID":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/:0:2","series":null,"tags":["C"],"title":"多维数组","uri":"/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/#242-二维数组的3种形式参数"},{"categories":["C"],"content":" 1、内存分区 1.1 运行之前1）预处理：宏定义展开、头文件展开、条件编译，这里并不会检查语法 2）编译：检查语法，将预处理后文件编译生成汇编文件 3）汇编：将汇编文件生成目标文件(二进制文件) 4）链接：将目标文件链接为可执行程序 当我们编译完成生成可执行文件之后，我们通过在linux下size命令可以查看一个可执行二进制文件基本情况： 通过上图可以得知，在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（text）、数据区（data）和未初始化数据区（bss）3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。 l 代码区存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指t令。另外，代码区还规划了局部变量的相关信息。 l 全局初始化数据区/静态数据区（data段）该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和t）和常量数据（如字符串常量）。 l 未初始化数据区（又叫 bss 区）存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。 *总体来讲说，程序源代码被编译之后主要分成两种段：程序指令(代码区)和程序数据（数据区）。代码段属于程序指令，而数据域段和.bss段属于程序数据。* 那为什么把程序的指令和程序数据分开呢？ 程序被load到内存中之后，可以将数据和代码分别映射到两个内存区域。由于数据区域对进程来说是可读可写的，而指令区域对程序来讲说是只读的，所以分区之后呢，可以将程序指令区域和数据区域分别设置成可读可写或只读。这样可以防止程序的指令有意或者无意被修改； 当系统中运行着多个同样的程序的时候，这些程序执行的指令都是一样的，所以只需要内存中保存一份程序的指令就可以了，只是每一个程序运行中数据不一样而已，这样可以节省大量的内存。比如说之前的Windows Internet Explorer 7.0运行起来之后， 它需要占用112 844KB的内存，它的私有部分数据有大概15 944KB，也就是说有96 900KB空间是共享的，如果程序中运行了几百个这样的进程，可以想象共享的方法可以节省大量的内存。 1.2运行之后程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。 l 代码区（text segment） 加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。 l 未初始化数据区（BSS） 加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 l 全局初始化数据区/静态数据区（data segment） 加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。 l 栈区（stack） 栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。 l 堆区（heap） 堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 类型 作用域 生命周期 存储位置 auto变量 一对{}内 当前函数 栈区 static局部变量 一对{}内 整个程序运行期 初始化在data段，未初始化在BSS段 extern变量 整个程序 整个程序运行期 初始化在data段，未初始化在BSS段 static全局变量 当前文件 整个程序运行期 初始化在data段，未初始化在BSS段 extern函数 整个程序 整个程序运行期 代码区 static函数 当前文件 整个程序运行期 代码区 register变量 一对{}内 当前函数 运行时存储在CPU寄存器 字符串常量 当前文件 整个程序运行期 data段 ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:1","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#1内存分区"},{"categories":["C"],"content":" 1、内存分区 1.1 运行之前1）预处理：宏定义展开、头文件展开、条件编译，这里并不会检查语法 2）编译：检查语法，将预处理后文件编译生成汇编文件 3）汇编：将汇编文件生成目标文件(二进制文件) 4）链接：将目标文件链接为可执行程序 当我们编译完成生成可执行文件之后，我们通过在linux下size命令可以查看一个可执行二进制文件基本情况： 通过上图可以得知，在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（text）、数据区（data）和未初始化数据区（bss）3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。 l 代码区存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指t令。另外，代码区还规划了局部变量的相关信息。 l 全局初始化数据区/静态数据区（data段）该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和t）和常量数据（如字符串常量）。 l 未初始化数据区（又叫 bss 区）存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。 *总体来讲说，程序源代码被编译之后主要分成两种段：程序指令(代码区)和程序数据（数据区）。代码段属于程序指令，而数据域段和.bss段属于程序数据。* 那为什么把程序的指令和程序数据分开呢？ 程序被load到内存中之后，可以将数据和代码分别映射到两个内存区域。由于数据区域对进程来说是可读可写的，而指令区域对程序来讲说是只读的，所以分区之后呢，可以将程序指令区域和数据区域分别设置成可读可写或只读。这样可以防止程序的指令有意或者无意被修改； 当系统中运行着多个同样的程序的时候，这些程序执行的指令都是一样的，所以只需要内存中保存一份程序的指令就可以了，只是每一个程序运行中数据不一样而已，这样可以节省大量的内存。比如说之前的Windows Internet Explorer 7.0运行起来之后， 它需要占用112 844KB的内存，它的私有部分数据有大概15 944KB，也就是说有96 900KB空间是共享的，如果程序中运行了几百个这样的进程，可以想象共享的方法可以节省大量的内存。 1.2运行之后程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。 l 代码区（text segment） 加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。 l 未初始化数据区（BSS） 加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 l 全局初始化数据区/静态数据区（data segment） 加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。 l 栈区（stack） 栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。 l 堆区（heap） 堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 类型 作用域 生命周期 存储位置 auto变量 一对{}内 当前函数 栈区 static局部变量 一对{}内 整个程序运行期 初始化在data段，未初始化在BSS段 extern变量 整个程序 整个程序运行期 初始化在data段，未初始化在BSS段 static全局变量 当前文件 整个程序运行期 初始化在data段，未初始化在BSS段 extern函数 整个程序 整个程序运行期 代码区 static函数 当前文件 整个程序运行期 代码区 register变量 一对{}内 当前函数 运行时存储在CPU寄存器 字符串常量 当前文件 整个程序运行期 data段 ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:1","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#11-运行之前"},{"categories":["C"],"content":" 1、内存分区 1.1 运行之前1）预处理：宏定义展开、头文件展开、条件编译，这里并不会检查语法 2）编译：检查语法，将预处理后文件编译生成汇编文件 3）汇编：将汇编文件生成目标文件(二进制文件) 4）链接：将目标文件链接为可执行程序 当我们编译完成生成可执行文件之后，我们通过在linux下size命令可以查看一个可执行二进制文件基本情况： 通过上图可以得知，在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（text）、数据区（data）和未初始化数据区（bss）3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。 l 代码区存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指t令。另外，代码区还规划了局部变量的相关信息。 l 全局初始化数据区/静态数据区（data段）该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和t）和常量数据（如字符串常量）。 l 未初始化数据区（又叫 bss 区）存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。 *总体来讲说，程序源代码被编译之后主要分成两种段：程序指令(代码区)和程序数据（数据区）。代码段属于程序指令，而数据域段和.bss段属于程序数据。* 那为什么把程序的指令和程序数据分开呢？ 程序被load到内存中之后，可以将数据和代码分别映射到两个内存区域。由于数据区域对进程来说是可读可写的，而指令区域对程序来讲说是只读的，所以分区之后呢，可以将程序指令区域和数据区域分别设置成可读可写或只读。这样可以防止程序的指令有意或者无意被修改； 当系统中运行着多个同样的程序的时候，这些程序执行的指令都是一样的，所以只需要内存中保存一份程序的指令就可以了，只是每一个程序运行中数据不一样而已，这样可以节省大量的内存。比如说之前的Windows Internet Explorer 7.0运行起来之后， 它需要占用112 844KB的内存，它的私有部分数据有大概15 944KB，也就是说有96 900KB空间是共享的，如果程序中运行了几百个这样的进程，可以想象共享的方法可以节省大量的内存。 1.2运行之后程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。 l 代码区（text segment） 加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。 l 未初始化数据区（BSS） 加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 l 全局初始化数据区/静态数据区（data segment） 加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。 l 栈区（stack） 栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。 l 堆区（heap） 堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 类型 作用域 生命周期 存储位置 auto变量 一对{}内 当前函数 栈区 static局部变量 一对{}内 整个程序运行期 初始化在data段，未初始化在BSS段 extern变量 整个程序 整个程序运行期 初始化在data段，未初始化在BSS段 static全局变量 当前文件 整个程序运行期 初始化在data段，未初始化在BSS段 extern函数 整个程序 整个程序运行期 代码区 static函数 当前文件 整个程序运行期 代码区 register变量 一对{}内 当前函数 运行时存储在CPU寄存器 字符串常量 当前文件 整个程序运行期 data段 ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:1","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#12运行之后"},{"categories":["C"],"content":" 2、分区模型 2.1栈区由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。 #char* func(){ char p[] = \"hello world!\"; //在栈区存储 乱码 printf(\"%s\\n\", p); return p; } void test(){ char* p = NULL; p = func(); printf(\"%s\\n\",p); } 2.2堆区由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请。 char* func(){ char* str = malloc(100); strcpy(str, \"hello world!\"); printf(\"%s\\n\",str); return str; } void test01(){ char* p = NULL; p = func(); printf(\"%s\\n\",p); } void allocateSpace(char* p){ p = malloc(100); strcpy(p, \"hello world!\"); printf(\"%s\\n\", p); } void test02(){ char* p = NULL; allocateSpace(p); printf(\"%s\\n\", p); } 堆分配内存API： #include \u003cstdlib.h\u003e void *calloc(size_t nmemb, size_t size); 功能： 在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存 置0。 参数： nmemb：所需内存单元数量 size：每个内存单元的大小（单位：字节） 返回值： 成功：分配空间的起始地址 失败：NULL #include \u003cstdlib.h\u003e void *realloc(void *ptr, size_t size); 功能： 重新分配用malloc或者calloc函数在堆中分配内存空间的大小。 realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。 参数： ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致 size：为重新分配内存的大小, 单位：字节 返回值： 成功：新分配的堆内存地址 失败：NULL void test01(){ int* p1 = calloc(10,sizeof(int)); if (p1 == NULL){ return; } for (int i = 0; i \u003c 10; i ++){ p1[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \",p1[i]); } printf(\"\\n\"); free(p1); } void test02(){ int* p1 = calloc(10, sizeof(int)); if (p1 == NULL){ return; } for (int i = 0; i \u003c 10; i++){ p1[i] = i + 1; } int* p2 = realloc(p1, 15 * sizeof(int)); if (p2 == NULL){ return; } printf(\"%d\\n\", p1); printf(\"%d\\n\", p2); //打印 for (int i = 0; i \u003c 15; i++){ printf(\"%d \", p2[i]); } printf(\"\\n\"); //重新赋值 for (int i = 0; i \u003c 15; i++){ p2[i] = i + 1; } //再次打印 for (int i = 0; i \u003c 15; i++){ printf(\"%d \", p2[i]); } printf(\"\\n\"); free(p2); } ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:2","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#2分区模型"},{"categories":["C"],"content":" 2、分区模型 2.1栈区由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。 #char* func(){ char p[] = \"hello world!\"; //在栈区存储 乱码 printf(\"%s\\n\", p); return p; } void test(){ char* p = NULL; p = func(); printf(\"%s\\n\",p); } 2.2堆区由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请。 char* func(){ char* str = malloc(100); strcpy(str, \"hello world!\"); printf(\"%s\\n\",str); return str; } void test01(){ char* p = NULL; p = func(); printf(\"%s\\n\",p); } void allocateSpace(char* p){ p = malloc(100); strcpy(p, \"hello world!\"); printf(\"%s\\n\", p); } void test02(){ char* p = NULL; allocateSpace(p); printf(\"%s\\n\", p); } 堆分配内存API： #include void *calloc(size_t nmemb, size_t size); 功能： 在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存 置0。 参数： nmemb：所需内存单元数量 size：每个内存单元的大小（单位：字节） 返回值： 成功：分配空间的起始地址 失败：NULL #include void *realloc(void *ptr, size_t size); 功能： 重新分配用malloc或者calloc函数在堆中分配内存空间的大小。 realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。 参数： ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致 size：为重新分配内存的大小, 单位：字节 返回值： 成功：新分配的堆内存地址 失败：NULL void test01(){ int* p1 = calloc(10,sizeof(int)); if (p1 == NULL){ return; } for (int i = 0; i \u003c 10; i ++){ p1[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \",p1[i]); } printf(\"\\n\"); free(p1); } void test02(){ int* p1 = calloc(10, sizeof(int)); if (p1 == NULL){ return; } for (int i = 0; i \u003c 10; i++){ p1[i] = i + 1; } int* p2 = realloc(p1, 15 * sizeof(int)); if (p2 == NULL){ return; } printf(\"%d\\n\", p1); printf(\"%d\\n\", p2); //打印 for (int i = 0; i \u003c 15; i++){ printf(\"%d \", p2[i]); } printf(\"\\n\"); //重新赋值 for (int i = 0; i \u003c 15; i++){ p2[i] = i + 1; } //再次打印 for (int i = 0; i \u003c 15; i++){ printf(\"%d \", p2[i]); } printf(\"\\n\"); free(p2); } ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:2","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#21栈区"},{"categories":["C"],"content":" 2、分区模型 2.1栈区由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。 #char* func(){ char p[] = \"hello world!\"; //在栈区存储 乱码 printf(\"%s\\n\", p); return p; } void test(){ char* p = NULL; p = func(); printf(\"%s\\n\",p); } 2.2堆区由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请。 char* func(){ char* str = malloc(100); strcpy(str, \"hello world!\"); printf(\"%s\\n\",str); return str; } void test01(){ char* p = NULL; p = func(); printf(\"%s\\n\",p); } void allocateSpace(char* p){ p = malloc(100); strcpy(p, \"hello world!\"); printf(\"%s\\n\", p); } void test02(){ char* p = NULL; allocateSpace(p); printf(\"%s\\n\", p); } 堆分配内存API： #include void *calloc(size_t nmemb, size_t size); 功能： 在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存 置0。 参数： nmemb：所需内存单元数量 size：每个内存单元的大小（单位：字节） 返回值： 成功：分配空间的起始地址 失败：NULL #include void *realloc(void *ptr, size_t size); 功能： 重新分配用malloc或者calloc函数在堆中分配内存空间的大小。 realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。 参数： ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致 size：为重新分配内存的大小, 单位：字节 返回值： 成功：新分配的堆内存地址 失败：NULL void test01(){ int* p1 = calloc(10,sizeof(int)); if (p1 == NULL){ return; } for (int i = 0; i \u003c 10; i ++){ p1[i] = i + 1; } for (int i = 0; i \u003c 10; i++){ printf(\"%d \",p1[i]); } printf(\"\\n\"); free(p1); } void test02(){ int* p1 = calloc(10, sizeof(int)); if (p1 == NULL){ return; } for (int i = 0; i \u003c 10; i++){ p1[i] = i + 1; } int* p2 = realloc(p1, 15 * sizeof(int)); if (p2 == NULL){ return; } printf(\"%d\\n\", p1); printf(\"%d\\n\", p2); //打印 for (int i = 0; i \u003c 15; i++){ printf(\"%d \", p2[i]); } printf(\"\\n\"); //重新赋值 for (int i = 0; i \u003c 15; i++){ p2[i] = i + 1; } //再次打印 for (int i = 0; i \u003c 15; i++){ printf(\"%d \", p2[i]); } printf(\"\\n\"); free(p2); } ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:2","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#22堆区"},{"categories":["C"],"content":" 3、全局/静态区​ 全局静态区内的变量在编译阶段已经分配好内存空间并初始化。这块内存在程序运行期间一直存在,它主要存储全局变量、静态变量和常量。 （1）这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。 （2）全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。 （3）字符串常量存储在全局/静态存储区的常量区。 int v1 = 10;//全局/静态区 const int v2 = 20; //常量，一旦初始化，不可修改 static int v3 = 20; //全局/静态区 char *p1; //全局/静态区，编译器默认初始化为NULL //那么全局static int 和 全局int变量有什么区别？ void test(){ static int v4 = 20; //全局/静态区 } char* func(){ static char arr[] = \"hello world!\"; //在静态区存储 可读可写 arr[2] = 'c'; char* p = \"hello world!\"; //全局/静态区-字符串常量区 //p[2] = 'c'; //只读，不可修改 printf(\"%d\\n\",arr); printf(\"%d\\n\",p); printf(\"%s\\n\", arr); return arr; } void test(){ char* p = func(); printf(\"%s\\n\",p); } ANSI C中规定：修改字符串常量，结果是未定义的。 ANSI C并没有规定编译器的实现者对字符串的处理，例如： 1.有些编译器可修改字符串常量，有些编译器则不可修改字符串常量。 2.有些编译器把多个相同的字符串常量看成一个（这种优化可能出现在字符串常量中，节省空间），有些则不进行此优化。如果进行优化，则可能导致修改一个字符串常量导致另外的字符串常量也发生变化，结果不可知。 所以尽量不要去修改字符串常量！ 在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等，初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。 *数据区包括*：堆，栈，全局/静态存储区。 *全局/静态存储区包括*：常量区，全局区、静态区。 *常量区包括*：字符串常量区、常变量区。 *代码区*：存放程序编译后的二进制代码，不可寻址区。 *可以说，C/C++内存分区其实只有两个，即代码区和数据区。* ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:3","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#3全局静态区"},{"categories":["C"],"content":" 4、函数调用模型 4.1函数调用流程栈(stack)是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。在解释为什么栈如此重要之前，我们先了解一下传统的栈的定义： 在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：先入栈的数据最后出栈(First In Last Out,FILO). 在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。 栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面： 函数的返回地址； 函数的参数； 局部变量； 保存的上下文：包括在函数调用前后需要保持不变的寄存器。 我们从下面的代码，分析以下函数的调用过程： int func(int a,int b){ int t_a = a; int t_b = b; return t_a + t_b; } int main(){ int ret = 0; ret = func(10, 20); return EXIT_SUCCESS; } 4.2调用惯例现在，我们大致了解了函数调用的过程，这期间有一个现象，那就是函数的调用者和被调用者对函数调用有着一致的理解，例如，它们双方都一致的认为函数的参数是按照某个固定的方式压入栈中。如果不这样的话，函数将无法正确运行。 如果函数调用方在传递参数的时候先压入a参数，再压入b参数，而被调用函数则认为先压入的是b,后压入的是a,那么被调用函数在使用a,b值时候，就会颠倒。 因此，函数的调用方和被调用方对于函数是如何调用的必须有一个明确的约定，只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为**”****调用惯例(**Calling Convention)”.一个调用惯例一般包含以下几个方面： *函数参数的传递顺序和方式* 函数的传递有很多种方式，最常见的是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：从左向右，还是从右向左。有些调用惯例还允许使用寄存器传递参数，以提高性能。 *栈的维护方式* 在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。 为了在链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。 事实上，在c语言里，存在着多个调用惯例，而默认的是cdecl.任何一个没有显示指定调用惯例的函数都是默认是cdecl惯例。比如我们上面对于func函数的声明，它的完整写法应该是： int _cdecl func(int a,int b); *注意: cdecl不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在_cdecl这样的关键字，而是使用__attribute_((cdecl)).* 调用惯例 出栈方 参数传递 名字修饰 cdecl 函数调用方 从右至左参数入栈 下划线+函数名 stdcall 函数本身 从右至左参数入栈 下划线+函数名+@+参数字节数 fastcall 函数本身 前两个参数由寄存器传递，其余参数通过堆栈传递。 @+函数名+@+参数的字节数 pascal 函数本身 从左至右参数入栈 较为复杂，参见相关文档 4.3函数变量传递分析 4.4栈的生长方向和内存存放方向 //1. 栈的生长方向 void test01(){ int a = 10; int b = 20; int c = 30; int d = 40; printf(\"a = %d\\n\", \u0026a); printf(\"b = %d\\n\", \u0026b); printf(\"c = %d\\n\", \u0026c); printf(\"d = %d\\n\", \u0026d); //a的地址大于b的地址，故而生长方向向下 } //2. 内存生长方向(小端模式) void test02(){ //高位字节 -\u003e 地位字节 int num = 0xaabbccdd; unsigned char* p = \u0026num; //从首地址开始的第一个字节 printf(\"%x\\n\",*p); printf(\"%x\\n\", *(p + 1)); printf(\"%x\\n\", *(p + 2)); printf(\"%x\\n\", *(p + 3)); } ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:4","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#4函数调用模型"},{"categories":["C"],"content":" 4、函数调用模型 4.1函数调用流程栈(stack)是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。在解释为什么栈如此重要之前，我们先了解一下传统的栈的定义： 在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：先入栈的数据最后出栈(First In Last Out,FILO). 在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。 栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面： 函数的返回地址； 函数的参数； 局部变量； 保存的上下文：包括在函数调用前后需要保持不变的寄存器。 我们从下面的代码，分析以下函数的调用过程： int func(int a,int b){ int t_a = a; int t_b = b; return t_a + t_b; } int main(){ int ret = 0; ret = func(10, 20); return EXIT_SUCCESS; } 4.2调用惯例现在，我们大致了解了函数调用的过程，这期间有一个现象，那就是函数的调用者和被调用者对函数调用有着一致的理解，例如，它们双方都一致的认为函数的参数是按照某个固定的方式压入栈中。如果不这样的话，函数将无法正确运行。 如果函数调用方在传递参数的时候先压入a参数，再压入b参数，而被调用函数则认为先压入的是b,后压入的是a,那么被调用函数在使用a,b值时候，就会颠倒。 因此，函数的调用方和被调用方对于函数是如何调用的必须有一个明确的约定，只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为**”****调用惯例(**Calling Convention)”.一个调用惯例一般包含以下几个方面： *函数参数的传递顺序和方式* 函数的传递有很多种方式，最常见的是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：从左向右，还是从右向左。有些调用惯例还允许使用寄存器传递参数，以提高性能。 *栈的维护方式* 在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。 为了在链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。 事实上，在c语言里，存在着多个调用惯例，而默认的是cdecl.任何一个没有显示指定调用惯例的函数都是默认是cdecl惯例。比如我们上面对于func函数的声明，它的完整写法应该是： int _cdecl func(int a,int b); *注意: cdecl不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在_cdecl这样的关键字，而是使用__attribute_((cdecl)).* 调用惯例 出栈方 参数传递 名字修饰 cdecl 函数调用方 从右至左参数入栈 下划线+函数名 stdcall 函数本身 从右至左参数入栈 下划线+函数名+@+参数字节数 fastcall 函数本身 前两个参数由寄存器传递，其余参数通过堆栈传递。 @+函数名+@+参数的字节数 pascal 函数本身 从左至右参数入栈 较为复杂，参见相关文档 4.3函数变量传递分析 4.4栈的生长方向和内存存放方向 //1. 栈的生长方向 void test01(){ int a = 10; int b = 20; int c = 30; int d = 40; printf(\"a = %d\\n\", \u0026a); printf(\"b = %d\\n\", \u0026b); printf(\"c = %d\\n\", \u0026c); printf(\"d = %d\\n\", \u0026d); //a的地址大于b的地址，故而生长方向向下 } //2. 内存生长方向(小端模式) void test02(){ //高位字节 -\u003e 地位字节 int num = 0xaabbccdd; unsigned char* p = # //从首地址开始的第一个字节 printf(\"%x\\n\",*p); printf(\"%x\\n\", *(p + 1)); printf(\"%x\\n\", *(p + 2)); printf(\"%x\\n\", *(p + 3)); } ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:4","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#41函数调用流程"},{"categories":["C"],"content":" 4、函数调用模型 4.1函数调用流程栈(stack)是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。在解释为什么栈如此重要之前，我们先了解一下传统的栈的定义： 在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：先入栈的数据最后出栈(First In Last Out,FILO). 在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。 栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面： 函数的返回地址； 函数的参数； 局部变量； 保存的上下文：包括在函数调用前后需要保持不变的寄存器。 我们从下面的代码，分析以下函数的调用过程： int func(int a,int b){ int t_a = a; int t_b = b; return t_a + t_b; } int main(){ int ret = 0; ret = func(10, 20); return EXIT_SUCCESS; } 4.2调用惯例现在，我们大致了解了函数调用的过程，这期间有一个现象，那就是函数的调用者和被调用者对函数调用有着一致的理解，例如，它们双方都一致的认为函数的参数是按照某个固定的方式压入栈中。如果不这样的话，函数将无法正确运行。 如果函数调用方在传递参数的时候先压入a参数，再压入b参数，而被调用函数则认为先压入的是b,后压入的是a,那么被调用函数在使用a,b值时候，就会颠倒。 因此，函数的调用方和被调用方对于函数是如何调用的必须有一个明确的约定，只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为**”****调用惯例(**Calling Convention)”.一个调用惯例一般包含以下几个方面： *函数参数的传递顺序和方式* 函数的传递有很多种方式，最常见的是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：从左向右，还是从右向左。有些调用惯例还允许使用寄存器传递参数，以提高性能。 *栈的维护方式* 在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。 为了在链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。 事实上，在c语言里，存在着多个调用惯例，而默认的是cdecl.任何一个没有显示指定调用惯例的函数都是默认是cdecl惯例。比如我们上面对于func函数的声明，它的完整写法应该是： int _cdecl func(int a,int b); *注意: cdecl不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在_cdecl这样的关键字，而是使用__attribute_((cdecl)).* 调用惯例 出栈方 参数传递 名字修饰 cdecl 函数调用方 从右至左参数入栈 下划线+函数名 stdcall 函数本身 从右至左参数入栈 下划线+函数名+@+参数字节数 fastcall 函数本身 前两个参数由寄存器传递，其余参数通过堆栈传递。 @+函数名+@+参数的字节数 pascal 函数本身 从左至右参数入栈 较为复杂，参见相关文档 4.3函数变量传递分析 4.4栈的生长方向和内存存放方向 //1. 栈的生长方向 void test01(){ int a = 10; int b = 20; int c = 30; int d = 40; printf(\"a = %d\\n\", \u0026a); printf(\"b = %d\\n\", \u0026b); printf(\"c = %d\\n\", \u0026c); printf(\"d = %d\\n\", \u0026d); //a的地址大于b的地址，故而生长方向向下 } //2. 内存生长方向(小端模式) void test02(){ //高位字节 -\u003e 地位字节 int num = 0xaabbccdd; unsigned char* p = # //从首地址开始的第一个字节 printf(\"%x\\n\",*p); printf(\"%x\\n\", *(p + 1)); printf(\"%x\\n\", *(p + 2)); printf(\"%x\\n\", *(p + 3)); } ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:4","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#42调用惯例"},{"categories":["C"],"content":" 4、函数调用模型 4.1函数调用流程栈(stack)是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。在解释为什么栈如此重要之前，我们先了解一下传统的栈的定义： 在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：先入栈的数据最后出栈(First In Last Out,FILO). 在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。 栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面： 函数的返回地址； 函数的参数； 局部变量； 保存的上下文：包括在函数调用前后需要保持不变的寄存器。 我们从下面的代码，分析以下函数的调用过程： int func(int a,int b){ int t_a = a; int t_b = b; return t_a + t_b; } int main(){ int ret = 0; ret = func(10, 20); return EXIT_SUCCESS; } 4.2调用惯例现在，我们大致了解了函数调用的过程，这期间有一个现象，那就是函数的调用者和被调用者对函数调用有着一致的理解，例如，它们双方都一致的认为函数的参数是按照某个固定的方式压入栈中。如果不这样的话，函数将无法正确运行。 如果函数调用方在传递参数的时候先压入a参数，再压入b参数，而被调用函数则认为先压入的是b,后压入的是a,那么被调用函数在使用a,b值时候，就会颠倒。 因此，函数的调用方和被调用方对于函数是如何调用的必须有一个明确的约定，只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为**”****调用惯例(**Calling Convention)”.一个调用惯例一般包含以下几个方面： *函数参数的传递顺序和方式* 函数的传递有很多种方式，最常见的是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：从左向右，还是从右向左。有些调用惯例还允许使用寄存器传递参数，以提高性能。 *栈的维护方式* 在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。 为了在链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。 事实上，在c语言里，存在着多个调用惯例，而默认的是cdecl.任何一个没有显示指定调用惯例的函数都是默认是cdecl惯例。比如我们上面对于func函数的声明，它的完整写法应该是： int _cdecl func(int a,int b); *注意: cdecl不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在_cdecl这样的关键字，而是使用__attribute_((cdecl)).* 调用惯例 出栈方 参数传递 名字修饰 cdecl 函数调用方 从右至左参数入栈 下划线+函数名 stdcall 函数本身 从右至左参数入栈 下划线+函数名+@+参数字节数 fastcall 函数本身 前两个参数由寄存器传递，其余参数通过堆栈传递。 @+函数名+@+参数的字节数 pascal 函数本身 从左至右参数入栈 较为复杂，参见相关文档 4.3函数变量传递分析 4.4栈的生长方向和内存存放方向 //1. 栈的生长方向 void test01(){ int a = 10; int b = 20; int c = 30; int d = 40; printf(\"a = %d\\n\", \u0026a); printf(\"b = %d\\n\", \u0026b); printf(\"c = %d\\n\", \u0026c); printf(\"d = %d\\n\", \u0026d); //a的地址大于b的地址，故而生长方向向下 } //2. 内存生长方向(小端模式) void test02(){ //高位字节 -\u003e 地位字节 int num = 0xaabbccdd; unsigned char* p = # //从首地址开始的第一个字节 printf(\"%x\\n\",*p); printf(\"%x\\n\", *(p + 1)); printf(\"%x\\n\", *(p + 2)); printf(\"%x\\n\", *(p + 3)); } ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:4","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#43函数变量传递分析"},{"categories":["C"],"content":" 4、函数调用模型 4.1函数调用流程栈(stack)是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。在解释为什么栈如此重要之前，我们先了解一下传统的栈的定义： 在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：先入栈的数据最后出栈(First In Last Out,FILO). 在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。 栈在程序运行中具有极其重要的地位。最重要的，栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面： 函数的返回地址； 函数的参数； 局部变量； 保存的上下文：包括在函数调用前后需要保持不变的寄存器。 我们从下面的代码，分析以下函数的调用过程： int func(int a,int b){ int t_a = a; int t_b = b; return t_a + t_b; } int main(){ int ret = 0; ret = func(10, 20); return EXIT_SUCCESS; } 4.2调用惯例现在，我们大致了解了函数调用的过程，这期间有一个现象，那就是函数的调用者和被调用者对函数调用有着一致的理解，例如，它们双方都一致的认为函数的参数是按照某个固定的方式压入栈中。如果不这样的话，函数将无法正确运行。 如果函数调用方在传递参数的时候先压入a参数，再压入b参数，而被调用函数则认为先压入的是b,后压入的是a,那么被调用函数在使用a,b值时候，就会颠倒。 因此，函数的调用方和被调用方对于函数是如何调用的必须有一个明确的约定，只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为**”****调用惯例(**Calling Convention)”.一个调用惯例一般包含以下几个方面： *函数参数的传递顺序和方式* 函数的传递有很多种方式，最常见的是通过栈传递。函数的调用方将参数压入栈中，函数自己再从栈中将参数取出。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：从左向右，还是从右向左。有些调用惯例还允许使用寄存器传递参数，以提高性能。 *栈的维护方式* 在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。 为了在链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。 事实上，在c语言里，存在着多个调用惯例，而默认的是cdecl.任何一个没有显示指定调用惯例的函数都是默认是cdecl惯例。比如我们上面对于func函数的声明，它的完整写法应该是： int _cdecl func(int a,int b); *注意: cdecl不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在_cdecl这样的关键字，而是使用__attribute_((cdecl)).* 调用惯例 出栈方 参数传递 名字修饰 cdecl 函数调用方 从右至左参数入栈 下划线+函数名 stdcall 函数本身 从右至左参数入栈 下划线+函数名+@+参数字节数 fastcall 函数本身 前两个参数由寄存器传递，其余参数通过堆栈传递。 @+函数名+@+参数的字节数 pascal 函数本身 从左至右参数入栈 较为复杂，参见相关文档 4.3函数变量传递分析 4.4栈的生长方向和内存存放方向 //1. 栈的生长方向 void test01(){ int a = 10; int b = 20; int c = 30; int d = 40; printf(\"a = %d\\n\", \u0026a); printf(\"b = %d\\n\", \u0026b); printf(\"c = %d\\n\", \u0026c); printf(\"d = %d\\n\", \u0026d); //a的地址大于b的地址，故而生长方向向下 } //2. 内存生长方向(小端模式) void test02(){ //高位字节 -\u003e 地位字节 int num = 0xaabbccdd; unsigned char* p = # //从首地址开始的第一个字节 printf(\"%x\\n\",*p); printf(\"%x\\n\", *(p + 1)); printf(\"%x\\n\", *(p + 2)); printf(\"%x\\n\", *(p + 3)); } ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/:0:4","series":null,"tags":["C"],"title":"内存分区","uri":"/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/#44栈的生长方向和内存存放方向"},{"categories":["Linux"],"content":"Linux各目录及每个目录的详细介绍 【常见目录说明】 目录 /bin 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。 /etc 存放系统管理和配置文件 /home 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /usr 用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。/usr/x11r6 存放x window的目录/usr/bin 众多的应用程序 /usr/sbin 超级用户的一些管理程序 /usr/doc linux文档 /usr/include linux下开发和编译应用程序所需要的头文件 /usr/lib 常用的动态链接库和软件包的配置文件 /usr/man 帮助文档 /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里 /usr/local/bin 本地增加的命令 /usr/local/lib 本地增加的库 /opt 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。 /proc 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /root 超级用户（系统管理员）的主目录（特权阶级^o^） /sbin 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。 /dev 用于存放设备文件。 /mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。 /boot 存放用于系统引导时使用的各种文件 /lib 存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。 /tmp 用于存放各种临时文件，是公用的临时文件存储点。 /var 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。 /lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里 Linux目录和Windows目录有着很大的不同，Linux目录类似一个树，最顶层是其根目录，如下图： /bin 二进制可执行命令 /dev 设备特殊文件 /etc 系统管理和配置文件 /etc/rc.d 启动的配置文件和脚本 /home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示 /lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件 /sbin 超级管理命令，这里存放的是系统管理员使用的管理程序 /tmp 公共的临时文件存储点 /root 系统管理员的主目录 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统 /lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里 /proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /var 某些大文件的溢出区，比方说各种服务的日志文件 /usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含： /usr/x11R6 存放x window的目录 /usr/bin 众多的应用程序 /usr/sbin 超级用户的一些管理程序 /usr/doc linux文档 /usr/include linux下开发和编译应用程序所需要的头文件 /usr/lib 常用的动态链接库和软件包的配置文件 /usr/man 帮助文档 /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里 /usr/local/bin 本地增加的命令 /usr/local/lib 本地增加的库根文件系统 通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要经常改动，而且包括严格的文件和一个小的不经常改变的文件系统不容易损坏。 除了可能的一个叫/ vmlinuz标准的系统引导映像之外，根目录一般不含任何文件。所有其他文件在根文件系统的子目录中。 \\1. /bin目录 / b i n目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些命令都是二进制文件的可执行程序( b i n是b i n a r y - -二进制的简称)，多是系统中重要的系统文件。 \\2. /sbin目录 / s b i n目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使用。 \\3. /etc目录 / e t c目录存放着各种系统配置文件，其中包括了用户信息文件/ e t c / p a s s w d，系统初始化文件/ e t c / r c等。l i n u x正是*这些文件才得以正常地运行。 \\4. /root目录 /root 目录是超级用户的目录。 \\5. /lib目录 / l i b目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文件。这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副本，故可以使得可执行文件变得更小，节省空间。 \\6. /lib/modules 目录 /lib/modules 目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重新引导系统所需的模块(例如网络和文件系统驱动)。 \\7. /dev目录 / d e v目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用户可以通过访问/ d e v / m o u s e来访问鼠标的输入，就像访问其他文件一样。 \\8. /tmp目录 /tmp 目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用/ v a r / t m p来代替/tmp ，因为前者可能拥有一个更大的磁盘空间。 \\9. /boot目录 / b o o t目录存放引导加载器(bootstrap loader)使用的文件，如l i lo，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在i d e硬盘的前1 0 2 4柱面内。 \\10. /mnt目录 / m n t目录是系统管理员临时安装( m o u n t )文件系统的安装点。程序并不自动支持安装到/mnt 。/mnt 下面可以分为许多子目录，例如/mnt/dosa 可能是使用m s d o s文件系统的软驱，而/mnt/exta 可能是使用e x t 2文件系统的软驱，/mnt/cdrom 光驱等等。 \\11. /proc, /usr,/var,/home目录 其他文件系统的安装点。 下面详细介绍； /etc文件系统 /etc 目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个程序，并阅读该程序的m a n页。许多网络配置文件也在/etc 中。 \\1. /etc/rc或/etc/rc.d或/etc/rc?.d 启动、或改变运行级时运行的脚本或脚本的目录。 \\2. /etc/passwd 用户数据库，其中的域给出了用户名、真实姓名、用户起始目录、加密口令和用户的其 他信息。 \\3. /etc/fdprm 软盘参数表，用以说明不同的软盘格式。可用setfdprm 进行设置。更多的信息见s e t f d p r m 的帮助页。 \\4. /etc/fstab 指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的s w a p区的信息。 \\5. /etc/group 类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。 \\6. /etc/inittab init 的配置文件。 \\7. /etc/issue 包括用户在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内容由系统管理员确定。 \\8. /etc/magic “f i l e”的配置文件。包含不同文件格式的说明，“f i l e”基于它猜测文件类型。 \\9. /etc/motd m o t d是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。常用于通告信息，如计划关机时间的警告等。 \\10. /etc/mtab 当前安装的文件系统列表。由脚本( s c r i t p )初始化，并由mount 命令自动更新。当需要一个当前安装的文件系统的列表时使用(例如df 命令)。 \\11. /etc/shadow 在安装了影子( s h a d o w )口令软件的系统上的影子口令文件。影子口令文件将/ e t c / p a s s wd文件中的加密口令移动到/ e t c / s h a d o w中，而后者只对超级用户( r o o t)可读。这使破译口令更困难，以此增加系统的安全性。 \\12. /etc/login.defs l o g i n命令的配置文件。 \\13. /etc/printcap 类似/etc/termcap ，但针对打印机。语法不同。 \\14. /etc/prof","date":"2023-12-31","objectID":"/linux%E5%90%84%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B/:0:0","series":null,"tags":["Linux"],"title":"Linux各级目录简介","uri":"/linux%E5%90%84%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B/#"},{"categories":["Linux"],"content":"Vim命令合集 *命令历史* 以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。 *启动vim* 在命令行窗口中输入以下命令即可 vim 直接启动vim vim filename 打开vim并创建名为filename的文件 *文件命令* 打开单个文件 vim file 同时打开多个文件 vim file1 file2 file3 … 在vim窗口中打开一个新文件 :open file 在新窗口中打开文件 :split file 切换到下一个文件 :bn 切换到上一个文件 :bp 查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。 :args 打开远程文件，比如ftp或者share folder :e ftp://192.168.10.76/abc.txt :e \\qadrive\\test\\1.txt *vim的模式* 正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空 插入模式（按i键进入） 左下角显示–INSERT– 可视模式（不知道如何进入） 左下角显示–VISUAL– *导航命令* % 括号匹配 *插入命令* i 在当前位置生前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 *查找命令* /text　查找text，按n健查找下一个，按N健查找前一个。 ?text　查找text，反向查找，按n健查找下一个，按N健查找前一个。 vim中有一些特殊字符在查找时需要转义　.*[]^%/?~$ :set ignorecase　忽略大小写的查找 :set noignorecase　不忽略大小写的查找 查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。 :set hlsearch　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。 :set nohlsearch　关闭高亮搜索显示 :nohlsearch　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。 :set incsearch　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。 :set wrapscan　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。 *替换命令* ra 将当前字符替换为a，当期字符即光标所在字符。 s/old/new/ 用old替换new，替换当前行的第一个匹配 s/old/new/g 用old替换new，替换当前行的所有匹配 %s/old/new/ 用old替换new，替换所有行的第一个匹配 %s/old/new/g 用old替换new，替换整个文件的所有匹配 :10,20 s/^/ /g 在第10行知第20行每行前面加四个空格，用于缩进。 ddp 交换光标所在行和其下紧邻的一行。 *移动命令* h 左移一个字符 l 右移一个字符，这个命令很少用，一般用w代替。 k 上移一个字符 j 下移一个字符 以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！，这里的Esc是必须的，否则命令不生效。 w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。 b 向后移动一个单词 2b 向后移动2个单词 e，同w，只不过是光标停在单词尾部 ge，同b，光标停在单词尾部。 ^ 移动到本行第一个非空白字符上。 0（数字0）移动到本行第一个字符上， 移动到本行第一个字符。同0健。 $ 移动到行尾 3$ 移动到下面3行的行尾 gg 移动到文件头。 = [[ G（shift + g） 移动到文件尾。 = ]] f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。 F 同f，反向查找。 跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。 Ctrl + e 向下滚动一行 Ctrl + y 向上滚动一行 Ctrl + d 向下滚动半屏 Ctrl + u 向上滚动半屏 Ctrl + f 向下滚动一屏 Ctrl + b 向上滚动一屏 *撤销和重做* u 撤销（Undo） U 撤销对整行的操作 Ctrl + r 重做（Redo），即撤销的撤销。 *删除命令* x 删除当前字符 3x 删除当前光标开始向后三个字符 X 删除当前字符的前一个字符。X=dh dl 删除当前字符， dl=x dh 删除前一个字符 dd 删除当前行 dj 删除上一行 dk 删除下一行 10d 删除当前行开始的10行。 D 删除当前字符至行尾。D=d$ d$ 删除当前字符之后的所有字符（本行） kdgg 删除当前行之前所有行（不包括当前行） jdG（jd shift + g） 删除当前行之后所有行（不包括当前行） :1,10d 删除1-10行 :11,$d 删除11行及以后所有的行 :1,$d 删除所有行 J(shift + j)　删除两行之间的空行，实际上是合并两行。 *拷贝和粘贴* yy 拷贝当前行 nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。 p 在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。 shift+p 在当前行前粘贴 :1,10 co 20 将1-10行插入到第20行之后。 :1,$ co $ 将整个文件复制一份并添加到文件尾部。 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制 ddp交换当前行和其下一行 xp交换当前字符和其后一个字符 *剪切命令* 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切 ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴 :1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。 :1, 10 m 20 将第1-10行移动到第20行之后。 *退出命令* :wq 保存并退出 ZZ 保存并退出 :q! 强制退出并忽略所有更改 :e! 放弃所有修改，并打开原来文件。 *窗口命令* :split或new 打开一个新窗口，光标停在顶层的窗口上 :split file或:new file 用新窗口打开文件 split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。 Ctrl+ww 移动到下一个窗口 Ctrl+wj 移动到下方的窗口 Ctrl+wk 移动到上方的窗口 关闭窗口 :close 最后一个窗口不能使用此命令，可以防止意外退出vim。 :q 如果是最后一个被关闭的窗口，那么将退出vim。 ZZ 保存并退出。 关闭所有窗口，只保留当前窗口 :only 录制宏 按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。 *执行shell命令* :!command :!ls 列出当前目录下文件 :!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。 :!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。 :suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。 *注释命令* perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入# 3,5 s/^/#/g 注释第3-5行 3,5 s/^#//g 解除3-5行的注释 1,$ s/^/#/g 注释整个文档。 :%s/^/#/g 注释整个文档，此法更快。 *帮助命令* :help or F1 显示整个帮助 :help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。 :help ’number’ Vim选项的帮助用单引号括起 :help 特殊键的帮助用\u003c\u003e扩起 :help -t Vim启动参数的帮助用- ：help i_ 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式 帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回 *其他非编辑命令* . 重复前一次命令 :set ruler?　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看 :scriptnames　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。 :set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:\u003e-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。 Vim教程 在Unix系统上 $ vimtutor 在Windows系统上 :help tutor :syntax 列出已经定义的语法项 :syntax clear 清除已定义的语法规则 :syntax case match 大小写敏感，int和Int将视为不同的语法元素 :syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案 ","date":"2023-12-31","objectID":"/linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/:0:0","series":null,"tags":["Linux"],"title":"Linux命令大全","uri":"/linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/#"},{"categories":["Linux"],"content":"vi使用方法详细介绍 vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 1、vi的基本概念 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下： 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 2、vi的基本操作 a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： $ vi myfile 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： w filename （输入 「w filename」将文章以指定的文件名filename保存） wq (输入「wq」，存盘并退出vi) q! (输入q!， 不存盘强制退出vi) 3、命令行模式（command mode）功能键 1）. 插入模式 按「i」切换进入插入模式「insert mode」，按\"i\"进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往\"后\"移动一页。 按「ctrl」+「f」：屏幕往\"前\"移动一页。 按「ctrl」+「u」：屏幕往\"后\"移动半页。 按「ctrl」+「d」：屏幕往\"前\"移动半页。 按数字「0」：移到文章的开头。 按「G」：移动到文章的最后。 按「$」：移动到光标所在行的\"行尾\"。 按「^」：移动到光标所在行的\"行首\" 按「w」：光标跳到下个字的开头 按「e」：光标跳到下个字的字尾 按「b」：光标回到上个字的开头 按「#l」：光标移到该行的第#个位置，如：5l,56l。 4）. 删除文字 「x」：每按一次，删除光标所在位置的\"后面\"一个字符。 「#x」：例如，「6x」表示删除光标所在位置的\"后面\"6个字符。 「X」：大写的X，每按一次，删除光标所在位置的\"前面\"一个字符。 「#X」：例如，「20X」表示删除光标所在位置的\"前面\"20个字符。 「dd」：删除光标所在行。 「#dd」：从光标所在行开始删除#行 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中。 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区。 「#yy」：例如，「6yy」表示拷贝从光标所在的该行\"往下数\"6行文字。 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与\"y\"有关的复制命令都必须与\"p\"配合才能完成复制与粘贴功能。 6）. 替换 「r」：替换光标所在处的字符。 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次\"u\"可以执行多次回复。 8）. 更改 「cw」：更改光标所在处的字到字尾处 「c#w」：例如，「c3w」表示更改3个字 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号。 「#G」：例如，「15G」，表示移动光标至文章的第15行行首。 4、Last line mode下命令简介 在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来。 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 5、vi命令列表 1、下表列出命令模式下的一些键的功能： h 左移光标一个字符 l 右移光标一个字符 k 光标上移一行 j 光标下移一行 ^ 光标移动至行首 0 数字\"0\"，光标移至文章的开头 G 光标移至文章的最后 $ 光标移动至行尾 Ctrl+f 向前翻屏 Ctrl+b 向后翻屏 Ctrl+d 向前翻半屏 Ctrl+u 向后翻半屏 i 在光标位置前插入字符 a 在光标所在位置的后一个字符开始增加 o 插入新的一行，从行首开始输入 ESC 从输入状态退至命令状态 x 删除光标后面的字符 #x 删除光标后的＃个字符 X (大写X)，删除光标前面的字符 #X 删除光标前面的#个字符 dd 删除光标所在的行 #dd 删除从光标所在行数的#行 yw 复制光标所在位置的一个字 #yw 复制光标所在位置的#个字 yy 复制光标所在位置的一行 #yy 复制从光标所在行数的#行 p 粘贴 u 取消操作 cw 更改光标所在位置的一个字 #cw 更改光标所在位置的#个字 2、下表列出行命令模式下的一些指令 w filename 储存正在编辑的文件为filename wq filename 储存正在编辑的文件为filename，并退出vi q! 放弃所有修改，退出vi set nu 显示行号 /或? 查找，在/后输入要查找的内容 n 与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止。 对于第一次用vi，有几点注意要提醒一下： 1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。切换方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键。 3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的） *vi使用手册* VI是unix上最常用的文本编辑工具，作为unix软件测试人员，有必要熟练掌握它。 进入vi的命令 vi filename :打开或新建文件，并将光标置于第一行首 vi +n filename ：打开文件，并将光标置于第n行首 vi + filename ：打开文件，并将光标置于最后一行首 vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处 vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename vi filename….filename ：打开多个文件，依次编辑 移动光标类命令 h ：光标左移一个字符 l ：光标右移一个字符 space：光标右移一个字符 Backspace：光标左移一个字符 k或Ctrl+p：光标上移一行 j或Ctrl+n ：光标下移一行 Enter ：光标下移一行 w或W ：光标右移一个字至字首 b或B ：光标左移一个字","date":"2023-12-31","objectID":"/vi%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":["Linux"],"title":"Vi使用方法","uri":"/vi%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#"},{"categories":["疑难杂症"],"content":"一、如何彻底删除VM ware虚拟机 ​ 很显然，对于这类瘤氓软件来说，在控制面板里常规删除已经不能满足它的癖好了，在这里我要对csdn上的一些牛马表示讽刺，他们的一些言论严重误导了真正遇到问题的小白，在这里就不说过多的脏话了，依郭某所见，他们只配在阴暗的角落里扭曲爬行，他们每呼吸一口空气便是对自然的污染，每活着的一秒都是对生命的侮辱！！！ 我们先打开服务，找到VM开头的，把它们全部停止（这是为了防止在之后的删除的时候，会报错此文件正在被其他文件所占用）。 然后再打开C:\\Program Files (x86)\\VMware，看看是不是为空文件，如果不是，把它们全部删除 退出到VMware这层目录, 右键删除\"VMware\"文件夹，删除完成: 然后使用强力清理软件，https://www.alipan.com/s/cQYUvKeVa6z，https://www.alipan.com/s/p5R79Spm2ZA，https://www.alipan.com/s/5qyi5ncm4H9，https://www.alipan.com/s/wkwF87uYacq，每个都打开清除一遍 卸载Vmware之后, 一定一定要清理Vmware的注册表信息 ; 按住Windows + R , 在弹出框中输入 “regedit” 调出注册表 打开“HKEY_CURRENT_USER”文件夹，找到“Software”文件夹并打开 找到“VMware.Inc”，右键删除 ","date":"2023-12-31","objectID":"/%E5%90%84%E7%A7%8D%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/:0:0","series":null,"tags":["疑难杂症"],"title":"各种疑难杂症","uri":"/%E5%90%84%E7%A7%8D%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/#"},{"categories":["C"],"content":" 1、指针是一种数据类型 1.1 指针变量指针是一种数据类型，占用内存空间，用来保存内存地址。 void test01(){ int* p1 = 0x1234; int*** p2 = 0x1111; printf(\"p1 size:%d\\n\",sizeof(p1)); printf(\"p2 size:%d\\n\",sizeof(p2)); //指针是变量，指针本身也占内存空间，指针也可以被赋值 int a = 10; p1 = \u0026a; printf(\"p1 address:%p\\n\", \u0026p1); printf(\"p1 address:%p\\n\", p1); printf(\"a address:%p\\n\", \u0026a); } 1.2 野指针和空指针 1.2.1 空指针标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。 对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未指向任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。 不允许向NULL和非法地址拷贝内存 void test(){ char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, \"1111\"); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, \"2222\"); //err } 1.2.2 野指针在使用指针时，要避免野指针的出现： 野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 什么情况下回导致野指针？ 指针变量未初始化 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针释放后未置空 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。 指针操作超越变量作用域 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。 void test(){ int* p = 0x001; //未初始化 printf(\"%p\\n\",p); *p = 100; } 操作野指针是非常危险的操作，应该规避野指针的出现： 初始化时置 NULL 指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置 NULL 当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。 1.3 指针的步长指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。 思考如下问题： int a = 0xaabbccdd; unsigned int *p1 = \u0026a; unsigned char *p2 = \u0026a; //为什么*p1打印出来正确结果？ printf(\"%x\\n\", *p1); //为什么*p2没有打印出来正确结果？ printf(\"%x\\n\", *p2); //为什么p1指针+1加了4字节？ printf(\"p1 =%d\\n\", p1); printf(\"p1+1=%d\\n\", p1 + 1); //为什么p2指针+1加了1字节？ printf(\"p2 =%d\\n\", p2); printf(\"p2+1=%d\\n\", p2 + 1); 指针的步长通常使用 sizeof 运算符来获取，该运算符返回指定类型或对象的大小（以字节为单位）。因此，获取指针的步长可以通过 sizeof 应用到指针所指的类型上。 下面是一个简单的例子，说明如何获取指针的步长： cCopy code#include \u003cstdio.h\u003e int main() { int arr[] = {1, 2, 3, 4, 5}; int *ptr = arr; // 获取指针的步长 size_t stepSize = sizeof(*ptr); printf(\"Step size of the pointer: %zu bytes\\n\", stepSize); // 演示使用步长移动到下一个元素 for (int i = 0; i \u003c 5; ++i) { printf(\"Element %d: %d\\n\", i, *ptr); // 移动到下一个元素 ptr += 1; // 此处的 1 表示移动一个步长，即一个元素的大小 } return 0; } 在这个例子中，ptr 是一个指向整数的指针，sizeof(*ptr) 返回整数的大小，因此 stepSize 的值表示指针的步长。然后，通过不断增加指针的值，我们可以在数组中移动到下一个元素。 请注意，这里使用 size_t 类型来保存步长，因为 sizeof 的返回类型是 size_t。 1.4 间接访问操作符通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是*。 注意：对一个int类型指针解引用会产生一个整型值，类似地，对一个float指针解引用会产生了一个float类型的值。 在指针声明时，* 号表示所声明的变量为指针 在指针使用时，* 号表示操作指针所指向的内存空间 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存 放在等号的左边赋值（给内存赋值，写内存） 放在等号的右边取值（从内存中取值，读内存） //解引用 void test01(){ //定义指针 int* p = NULL; //指针指向谁，就把谁的地址赋给指针 int a = 10; p = \u0026a; *p = 20;//*在左边当左值，必须确保内存可写 //*号放右面，从内存中读值 int b = *p; //必须确保内存可写 char* str = \"hello world!\"; *str = 'm'; printf(\"a:%d\\n\", a); printf(\"*p:%d\\n\", *p); printf(\"b:%d\\n\", b); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#1指针是一种数据类型"},{"categories":["C"],"content":" 1、指针是一种数据类型 1.1 指针变量指针是一种数据类型，占用内存空间，用来保存内存地址。 void test01(){ int* p1 = 0x1234; int*** p2 = 0x1111; printf(\"p1 size:%d\\n\",sizeof(p1)); printf(\"p2 size:%d\\n\",sizeof(p2)); //指针是变量，指针本身也占内存空间，指针也可以被赋值 int a = 10; p1 = \u0026a; printf(\"p1 address:%p\\n\", \u0026p1); printf(\"p1 address:%p\\n\", p1); printf(\"a address:%p\\n\", \u0026a); } 1.2 野指针和空指针 1.2.1 空指针标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。 对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未指向任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。 不允许向NULL和非法地址拷贝内存 void test(){ char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, \"1111\"); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, \"2222\"); //err } 1.2.2 野指针在使用指针时，要避免野指针的出现： 野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 什么情况下回导致野指针？ 指针变量未初始化 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针释放后未置空 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。 指针操作超越变量作用域 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。 void test(){ int* p = 0x001; //未初始化 printf(\"%p\\n\",p); *p = 100; } 操作野指针是非常危险的操作，应该规避野指针的出现： 初始化时置 NULL 指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置 NULL 当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。 1.3 指针的步长指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。 思考如下问题： int a = 0xaabbccdd; unsigned int *p1 = \u0026a; unsigned char *p2 = \u0026a; //为什么*p1打印出来正确结果？ printf(\"%x\\n\", *p1); //为什么*p2没有打印出来正确结果？ printf(\"%x\\n\", *p2); //为什么p1指针+1加了4字节？ printf(\"p1 =%d\\n\", p1); printf(\"p1+1=%d\\n\", p1 + 1); //为什么p2指针+1加了1字节？ printf(\"p2 =%d\\n\", p2); printf(\"p2+1=%d\\n\", p2 + 1); 指针的步长通常使用 sizeof 运算符来获取，该运算符返回指定类型或对象的大小（以字节为单位）。因此，获取指针的步长可以通过 sizeof 应用到指针所指的类型上。 下面是一个简单的例子，说明如何获取指针的步长： cCopy code#include int main() { int arr[] = {1, 2, 3, 4, 5}; int *ptr = arr; // 获取指针的步长 size_t stepSize = sizeof(*ptr); printf(\"Step size of the pointer: %zu bytes\\n\", stepSize); // 演示使用步长移动到下一个元素 for (int i = 0; i \u003c 5; ++i) { printf(\"Element %d: %d\\n\", i, *ptr); // 移动到下一个元素 ptr += 1; // 此处的 1 表示移动一个步长，即一个元素的大小 } return 0; } 在这个例子中，ptr 是一个指向整数的指针，sizeof(*ptr) 返回整数的大小，因此 stepSize 的值表示指针的步长。然后，通过不断增加指针的值，我们可以在数组中移动到下一个元素。 请注意，这里使用 size_t 类型来保存步长，因为 sizeof 的返回类型是 size_t。 1.4 间接访问操作符通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是*。 注意：对一个int类型指针解引用会产生一个整型值，类似地，对一个float指针解引用会产生了一个float类型的值。 在指针声明时，* 号表示所声明的变量为指针 在指针使用时，* 号表示操作指针所指向的内存空间 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存 放在等号的左边赋值（给内存赋值，写内存） 放在等号的右边取值（从内存中取值，读内存） //解引用 void test01(){ //定义指针 int* p = NULL; //指针指向谁，就把谁的地址赋给指针 int a = 10; p = \u0026a; *p = 20;//*在左边当左值，必须确保内存可写 //*号放右面，从内存中读值 int b = *p; //必须确保内存可写 char* str = \"hello world!\"; *str = 'm'; printf(\"a:%d\\n\", a); printf(\"*p:%d\\n\", *p); printf(\"b:%d\\n\", b); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#11-指针变量"},{"categories":["C"],"content":" 1、指针是一种数据类型 1.1 指针变量指针是一种数据类型，占用内存空间，用来保存内存地址。 void test01(){ int* p1 = 0x1234; int*** p2 = 0x1111; printf(\"p1 size:%d\\n\",sizeof(p1)); printf(\"p2 size:%d\\n\",sizeof(p2)); //指针是变量，指针本身也占内存空间，指针也可以被赋值 int a = 10; p1 = \u0026a; printf(\"p1 address:%p\\n\", \u0026p1); printf(\"p1 address:%p\\n\", p1); printf(\"a address:%p\\n\", \u0026a); } 1.2 野指针和空指针 1.2.1 空指针标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。 对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未指向任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。 不允许向NULL和非法地址拷贝内存 void test(){ char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, \"1111\"); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, \"2222\"); //err } 1.2.2 野指针在使用指针时，要避免野指针的出现： 野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 什么情况下回导致野指针？ 指针变量未初始化 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针释放后未置空 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。 指针操作超越变量作用域 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。 void test(){ int* p = 0x001; //未初始化 printf(\"%p\\n\",p); *p = 100; } 操作野指针是非常危险的操作，应该规避野指针的出现： 初始化时置 NULL 指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置 NULL 当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。 1.3 指针的步长指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。 思考如下问题： int a = 0xaabbccdd; unsigned int *p1 = \u0026a; unsigned char *p2 = \u0026a; //为什么*p1打印出来正确结果？ printf(\"%x\\n\", *p1); //为什么*p2没有打印出来正确结果？ printf(\"%x\\n\", *p2); //为什么p1指针+1加了4字节？ printf(\"p1 =%d\\n\", p1); printf(\"p1+1=%d\\n\", p1 + 1); //为什么p2指针+1加了1字节？ printf(\"p2 =%d\\n\", p2); printf(\"p2+1=%d\\n\", p2 + 1); 指针的步长通常使用 sizeof 运算符来获取，该运算符返回指定类型或对象的大小（以字节为单位）。因此，获取指针的步长可以通过 sizeof 应用到指针所指的类型上。 下面是一个简单的例子，说明如何获取指针的步长： cCopy code#include int main() { int arr[] = {1, 2, 3, 4, 5}; int *ptr = arr; // 获取指针的步长 size_t stepSize = sizeof(*ptr); printf(\"Step size of the pointer: %zu bytes\\n\", stepSize); // 演示使用步长移动到下一个元素 for (int i = 0; i \u003c 5; ++i) { printf(\"Element %d: %d\\n\", i, *ptr); // 移动到下一个元素 ptr += 1; // 此处的 1 表示移动一个步长，即一个元素的大小 } return 0; } 在这个例子中，ptr 是一个指向整数的指针，sizeof(*ptr) 返回整数的大小，因此 stepSize 的值表示指针的步长。然后，通过不断增加指针的值，我们可以在数组中移动到下一个元素。 请注意，这里使用 size_t 类型来保存步长，因为 sizeof 的返回类型是 size_t。 1.4 间接访问操作符通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是*。 注意：对一个int类型指针解引用会产生一个整型值，类似地，对一个float指针解引用会产生了一个float类型的值。 在指针声明时，* 号表示所声明的变量为指针 在指针使用时，* 号表示操作指针所指向的内存空间 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存 放在等号的左边赋值（给内存赋值，写内存） 放在等号的右边取值（从内存中取值，读内存） //解引用 void test01(){ //定义指针 int* p = NULL; //指针指向谁，就把谁的地址赋给指针 int a = 10; p = \u0026a; *p = 20;//*在左边当左值，必须确保内存可写 //*号放右面，从内存中读值 int b = *p; //必须确保内存可写 char* str = \"hello world!\"; *str = 'm'; printf(\"a:%d\\n\", a); printf(\"*p:%d\\n\", *p); printf(\"b:%d\\n\", b); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#12-野指针和空指针"},{"categories":["C"],"content":" 1、指针是一种数据类型 1.1 指针变量指针是一种数据类型，占用内存空间，用来保存内存地址。 void test01(){ int* p1 = 0x1234; int*** p2 = 0x1111; printf(\"p1 size:%d\\n\",sizeof(p1)); printf(\"p2 size:%d\\n\",sizeof(p2)); //指针是变量，指针本身也占内存空间，指针也可以被赋值 int a = 10; p1 = \u0026a; printf(\"p1 address:%p\\n\", \u0026p1); printf(\"p1 address:%p\\n\", p1); printf(\"a address:%p\\n\", \u0026a); } 1.2 野指针和空指针 1.2.1 空指针标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。 对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未指向任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。 不允许向NULL和非法地址拷贝内存 void test(){ char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, \"1111\"); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, \"2222\"); //err } 1.2.2 野指针在使用指针时，要避免野指针的出现： 野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 什么情况下回导致野指针？ 指针变量未初始化 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针释放后未置空 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。 指针操作超越变量作用域 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。 void test(){ int* p = 0x001; //未初始化 printf(\"%p\\n\",p); *p = 100; } 操作野指针是非常危险的操作，应该规避野指针的出现： 初始化时置 NULL 指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置 NULL 当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。 1.3 指针的步长指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。 思考如下问题： int a = 0xaabbccdd; unsigned int *p1 = \u0026a; unsigned char *p2 = \u0026a; //为什么*p1打印出来正确结果？ printf(\"%x\\n\", *p1); //为什么*p2没有打印出来正确结果？ printf(\"%x\\n\", *p2); //为什么p1指针+1加了4字节？ printf(\"p1 =%d\\n\", p1); printf(\"p1+1=%d\\n\", p1 + 1); //为什么p2指针+1加了1字节？ printf(\"p2 =%d\\n\", p2); printf(\"p2+1=%d\\n\", p2 + 1); 指针的步长通常使用 sizeof 运算符来获取，该运算符返回指定类型或对象的大小（以字节为单位）。因此，获取指针的步长可以通过 sizeof 应用到指针所指的类型上。 下面是一个简单的例子，说明如何获取指针的步长： cCopy code#include int main() { int arr[] = {1, 2, 3, 4, 5}; int *ptr = arr; // 获取指针的步长 size_t stepSize = sizeof(*ptr); printf(\"Step size of the pointer: %zu bytes\\n\", stepSize); // 演示使用步长移动到下一个元素 for (int i = 0; i \u003c 5; ++i) { printf(\"Element %d: %d\\n\", i, *ptr); // 移动到下一个元素 ptr += 1; // 此处的 1 表示移动一个步长，即一个元素的大小 } return 0; } 在这个例子中，ptr 是一个指向整数的指针，sizeof(*ptr) 返回整数的大小，因此 stepSize 的值表示指针的步长。然后，通过不断增加指针的值，我们可以在数组中移动到下一个元素。 请注意，这里使用 size_t 类型来保存步长，因为 sizeof 的返回类型是 size_t。 1.4 间接访问操作符通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是*。 注意：对一个int类型指针解引用会产生一个整型值，类似地，对一个float指针解引用会产生了一个float类型的值。 在指针声明时，* 号表示所声明的变量为指针 在指针使用时，* 号表示操作指针所指向的内存空间 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存 放在等号的左边赋值（给内存赋值，写内存） 放在等号的右边取值（从内存中取值，读内存） //解引用 void test01(){ //定义指针 int* p = NULL; //指针指向谁，就把谁的地址赋给指针 int a = 10; p = \u0026a; *p = 20;//*在左边当左值，必须确保内存可写 //*号放右面，从内存中读值 int b = *p; //必须确保内存可写 char* str = \"hello world!\"; *str = 'm'; printf(\"a:%d\\n\", a); printf(\"*p:%d\\n\", *p); printf(\"b:%d\\n\", b); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#121-空指针"},{"categories":["C"],"content":" 1、指针是一种数据类型 1.1 指针变量指针是一种数据类型，占用内存空间，用来保存内存地址。 void test01(){ int* p1 = 0x1234; int*** p2 = 0x1111; printf(\"p1 size:%d\\n\",sizeof(p1)); printf(\"p2 size:%d\\n\",sizeof(p2)); //指针是变量，指针本身也占内存空间，指针也可以被赋值 int a = 10; p1 = \u0026a; printf(\"p1 address:%p\\n\", \u0026p1); printf(\"p1 address:%p\\n\", p1); printf(\"a address:%p\\n\", \u0026a); } 1.2 野指针和空指针 1.2.1 空指针标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。 对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未指向任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。 不允许向NULL和非法地址拷贝内存 void test(){ char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, \"1111\"); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, \"2222\"); //err } 1.2.2 野指针在使用指针时，要避免野指针的出现： 野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 什么情况下回导致野指针？ 指针变量未初始化 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针释放后未置空 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。 指针操作超越变量作用域 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。 void test(){ int* p = 0x001; //未初始化 printf(\"%p\\n\",p); *p = 100; } 操作野指针是非常危险的操作，应该规避野指针的出现： 初始化时置 NULL 指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置 NULL 当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。 1.3 指针的步长指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。 思考如下问题： int a = 0xaabbccdd; unsigned int *p1 = \u0026a; unsigned char *p2 = \u0026a; //为什么*p1打印出来正确结果？ printf(\"%x\\n\", *p1); //为什么*p2没有打印出来正确结果？ printf(\"%x\\n\", *p2); //为什么p1指针+1加了4字节？ printf(\"p1 =%d\\n\", p1); printf(\"p1+1=%d\\n\", p1 + 1); //为什么p2指针+1加了1字节？ printf(\"p2 =%d\\n\", p2); printf(\"p2+1=%d\\n\", p2 + 1); 指针的步长通常使用 sizeof 运算符来获取，该运算符返回指定类型或对象的大小（以字节为单位）。因此，获取指针的步长可以通过 sizeof 应用到指针所指的类型上。 下面是一个简单的例子，说明如何获取指针的步长： cCopy code#include int main() { int arr[] = {1, 2, 3, 4, 5}; int *ptr = arr; // 获取指针的步长 size_t stepSize = sizeof(*ptr); printf(\"Step size of the pointer: %zu bytes\\n\", stepSize); // 演示使用步长移动到下一个元素 for (int i = 0; i \u003c 5; ++i) { printf(\"Element %d: %d\\n\", i, *ptr); // 移动到下一个元素 ptr += 1; // 此处的 1 表示移动一个步长，即一个元素的大小 } return 0; } 在这个例子中，ptr 是一个指向整数的指针，sizeof(*ptr) 返回整数的大小，因此 stepSize 的值表示指针的步长。然后，通过不断增加指针的值，我们可以在数组中移动到下一个元素。 请注意，这里使用 size_t 类型来保存步长，因为 sizeof 的返回类型是 size_t。 1.4 间接访问操作符通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是*。 注意：对一个int类型指针解引用会产生一个整型值，类似地，对一个float指针解引用会产生了一个float类型的值。 在指针声明时，* 号表示所声明的变量为指针 在指针使用时，* 号表示操作指针所指向的内存空间 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存 放在等号的左边赋值（给内存赋值，写内存） 放在等号的右边取值（从内存中取值，读内存） //解引用 void test01(){ //定义指针 int* p = NULL; //指针指向谁，就把谁的地址赋给指针 int a = 10; p = \u0026a; *p = 20;//*在左边当左值，必须确保内存可写 //*号放右面，从内存中读值 int b = *p; //必须确保内存可写 char* str = \"hello world!\"; *str = 'm'; printf(\"a:%d\\n\", a); printf(\"*p:%d\\n\", *p); printf(\"b:%d\\n\", b); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#122-野指针"},{"categories":["C"],"content":" 1、指针是一种数据类型 1.1 指针变量指针是一种数据类型，占用内存空间，用来保存内存地址。 void test01(){ int* p1 = 0x1234; int*** p2 = 0x1111; printf(\"p1 size:%d\\n\",sizeof(p1)); printf(\"p2 size:%d\\n\",sizeof(p2)); //指针是变量，指针本身也占内存空间，指针也可以被赋值 int a = 10; p1 = \u0026a; printf(\"p1 address:%p\\n\", \u0026p1); printf(\"p1 address:%p\\n\", p1); printf(\"a address:%p\\n\", \u0026a); } 1.2 野指针和空指针 1.2.1 空指针标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。 对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未指向任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。 不允许向NULL和非法地址拷贝内存 void test(){ char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, \"1111\"); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, \"2222\"); //err } 1.2.2 野指针在使用指针时，要避免野指针的出现： 野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 什么情况下回导致野指针？ 指针变量未初始化 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针释放后未置空 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。 指针操作超越变量作用域 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。 void test(){ int* p = 0x001; //未初始化 printf(\"%p\\n\",p); *p = 100; } 操作野指针是非常危险的操作，应该规避野指针的出现： 初始化时置 NULL 指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置 NULL 当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。 1.3 指针的步长指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。 思考如下问题： int a = 0xaabbccdd; unsigned int *p1 = \u0026a; unsigned char *p2 = \u0026a; //为什么*p1打印出来正确结果？ printf(\"%x\\n\", *p1); //为什么*p2没有打印出来正确结果？ printf(\"%x\\n\", *p2); //为什么p1指针+1加了4字节？ printf(\"p1 =%d\\n\", p1); printf(\"p1+1=%d\\n\", p1 + 1); //为什么p2指针+1加了1字节？ printf(\"p2 =%d\\n\", p2); printf(\"p2+1=%d\\n\", p2 + 1); 指针的步长通常使用 sizeof 运算符来获取，该运算符返回指定类型或对象的大小（以字节为单位）。因此，获取指针的步长可以通过 sizeof 应用到指针所指的类型上。 下面是一个简单的例子，说明如何获取指针的步长： cCopy code#include int main() { int arr[] = {1, 2, 3, 4, 5}; int *ptr = arr; // 获取指针的步长 size_t stepSize = sizeof(*ptr); printf(\"Step size of the pointer: %zu bytes\\n\", stepSize); // 演示使用步长移动到下一个元素 for (int i = 0; i \u003c 5; ++i) { printf(\"Element %d: %d\\n\", i, *ptr); // 移动到下一个元素 ptr += 1; // 此处的 1 表示移动一个步长，即一个元素的大小 } return 0; } 在这个例子中，ptr 是一个指向整数的指针，sizeof(*ptr) 返回整数的大小，因此 stepSize 的值表示指针的步长。然后，通过不断增加指针的值，我们可以在数组中移动到下一个元素。 请注意，这里使用 size_t 类型来保存步长，因为 sizeof 的返回类型是 size_t。 1.4 间接访问操作符通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是*。 注意：对一个int类型指针解引用会产生一个整型值，类似地，对一个float指针解引用会产生了一个float类型的值。 在指针声明时，* 号表示所声明的变量为指针 在指针使用时，* 号表示操作指针所指向的内存空间 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存 放在等号的左边赋值（给内存赋值，写内存） 放在等号的右边取值（从内存中取值，读内存） //解引用 void test01(){ //定义指针 int* p = NULL; //指针指向谁，就把谁的地址赋给指针 int a = 10; p = \u0026a; *p = 20;//*在左边当左值，必须确保内存可写 //*号放右面，从内存中读值 int b = *p; //必须确保内存可写 char* str = \"hello world!\"; *str = 'm'; printf(\"a:%d\\n\", a); printf(\"*p:%d\\n\", *p); printf(\"b:%d\\n\", b); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#13-指针的步长"},{"categories":["C"],"content":" 1、指针是一种数据类型 1.1 指针变量指针是一种数据类型，占用内存空间，用来保存内存地址。 void test01(){ int* p1 = 0x1234; int*** p2 = 0x1111; printf(\"p1 size:%d\\n\",sizeof(p1)); printf(\"p2 size:%d\\n\",sizeof(p2)); //指针是变量，指针本身也占内存空间，指针也可以被赋值 int a = 10; p1 = \u0026a; printf(\"p1 address:%p\\n\", \u0026p1); printf(\"p1 address:%p\\n\", p1); printf(\"a address:%p\\n\", \u0026a); } 1.2 野指针和空指针 1.2.1 空指针标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针为NULL,可以给它赋值一个零值。为了测试一个指针百年来那个是否为NULL,你可以将它与零值进行比较。 对指针解引用操作可以获得它所指向的值。但从定义上看，NULL指针并未指向任何东西，因为对一个NULL指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个NULL指针。 如果对一个NULL指针间接访问会发生什么呢？结果因编译器而异。 不允许向NULL和非法地址拷贝内存 void test(){ char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, \"1111\"); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, \"2222\"); //err } 1.2.2 野指针在使用指针时，要避免野指针的出现： 野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。 什么情况下回导致野指针？ 指针变量未初始化 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 指针释放后未置空 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。 指针操作超越变量作用域 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。 void test(){ int* p = 0x001; //未初始化 printf(\"%p\\n\",p); *p = 100; } 操作野指针是非常危险的操作，应该规避野指针的出现： 初始化时置 NULL 指针变量一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。 释放时置 NULL 当指针p指向的内存空间释放时，没有设置指针p的值为NULL。delete和free只是把内存空间释放了，但是并没有将指针p的值赋为NULL。通常判断一个指针是否合法，都是使用if语句测试该指针是否为NULL。 1.3 指针的步长指针是一种数据类型，是指它指向的内存空间的数据类型。指针所指向的内存空间决定了指针的步长。指针的步长指的是，当指针+1时候，移动多少字节单位。 思考如下问题： int a = 0xaabbccdd; unsigned int *p1 = \u0026a; unsigned char *p2 = \u0026a; //为什么*p1打印出来正确结果？ printf(\"%x\\n\", *p1); //为什么*p2没有打印出来正确结果？ printf(\"%x\\n\", *p2); //为什么p1指针+1加了4字节？ printf(\"p1 =%d\\n\", p1); printf(\"p1+1=%d\\n\", p1 + 1); //为什么p2指针+1加了1字节？ printf(\"p2 =%d\\n\", p2); printf(\"p2+1=%d\\n\", p2 + 1); 指针的步长通常使用 sizeof 运算符来获取，该运算符返回指定类型或对象的大小（以字节为单位）。因此，获取指针的步长可以通过 sizeof 应用到指针所指的类型上。 下面是一个简单的例子，说明如何获取指针的步长： cCopy code#include int main() { int arr[] = {1, 2, 3, 4, 5}; int *ptr = arr; // 获取指针的步长 size_t stepSize = sizeof(*ptr); printf(\"Step size of the pointer: %zu bytes\\n\", stepSize); // 演示使用步长移动到下一个元素 for (int i = 0; i \u003c 5; ++i) { printf(\"Element %d: %d\\n\", i, *ptr); // 移动到下一个元素 ptr += 1; // 此处的 1 表示移动一个步长，即一个元素的大小 } return 0; } 在这个例子中，ptr 是一个指向整数的指针，sizeof(*ptr) 返回整数的大小，因此 stepSize 的值表示指针的步长。然后，通过不断增加指针的值，我们可以在数组中移动到下一个元素。 请注意，这里使用 size_t 类型来保存步长，因为 sizeof 的返回类型是 size_t。 1.4 间接访问操作符通过一个指针访问它所指向的地址的过程叫做间接访问，或者叫解引用指针，这个用于执行间接访问的操作符是*。 注意：对一个int类型指针解引用会产生一个整型值，类似地，对一个float指针解引用会产生了一个float类型的值。 在指针声明时，* 号表示所声明的变量为指针 在指针使用时，* 号表示操作指针所指向的内存空间 相当通过地址(指针变量的值)找到指针指向的内存，再操作内存 放在等号的左边赋值（给内存赋值，写内存） 放在等号的右边取值（从内存中取值，读内存） //解引用 void test01(){ //定义指针 int* p = NULL; //指针指向谁，就把谁的地址赋给指针 int a = 10; p = \u0026a; *p = 20;//*在左边当左值，必须确保内存可写 //*号放右面，从内存中读值 int b = *p; //必须确保内存可写 char* str = \"hello world!\"; *str = 'm'; printf(\"a:%d\\n\", a); printf(\"*p:%d\\n\", *p); printf(\"b:%d\\n\", b); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:1","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#14-间接访问操作符"},{"categories":["C"],"content":" 2、指针的意义_间接赋值 2.1 间接赋值的三大条件通过指针间接赋值成立的三大条件： 2个变量（一个普通变量一个指针变量、或者一个实参一个形参） 建立关系 通过 * 操作指针指向的内存 void test(){ int a = 100; //两个变量 int *p = NULL; //建立关系 //指针指向谁，就把谁的地址赋值给指针 p = \u0026a; //通过*操作内存 *p = 22; } 2.2 如何定义合适的指针变量 void test(){ int b; int *q = \u0026b; //0级指针 int **t = \u0026q; int ***m = \u0026t; } 2.3 间接赋值：从0级指针到1级指针 int func1(){ return 10; } void func2(int a){ a = 100; } //指针的意义_间接赋值 void test02(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //为什么没有修改？ func2(a); printf(\"a = %d\\n\", a); } //指针的间接赋值 void func3(int* a){ *a = 100; } void test03(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //修改 func3(\u0026a); printf(\"a = %d\\n\", a); } 2.4 间接赋值：从1级指针到2级指针 void AllocateSpace(char** p){ *p = (char*)malloc(100); strcpy(*p, \"hello world!\"); } void FreeSpace(char** p){ if (p == NULL){ return; } if (*p != NULL){ free(*p); *p = NULL; } } void test(){ char* p = NULL; AllocateSpace(\u0026p); printf(\"%s\\n\",p); FreeSpace(\u0026p); if (p == NULL){ printf(\"p内存释放!\\n\"); } } 用1级指针形参，去间接修改了0级指针(实参)的值。 用2级指针形参，去间接修改了1级指针(实参)的值。 用3级指针形参，去间接修改了2级指针(实参)的值。 用n级指针形参，去间接修改了n-1级指针(实参)的值。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:2","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#2指针的意义_间接赋值"},{"categories":["C"],"content":" 2、指针的意义_间接赋值 2.1 间接赋值的三大条件通过指针间接赋值成立的三大条件： 2个变量（一个普通变量一个指针变量、或者一个实参一个形参） 建立关系 通过 * 操作指针指向的内存 void test(){ int a = 100; //两个变量 int *p = NULL; //建立关系 //指针指向谁，就把谁的地址赋值给指针 p = \u0026a; //通过*操作内存 *p = 22; } 2.2 如何定义合适的指针变量 void test(){ int b; int *q = \u0026b; //0级指针 int **t = \u0026q; int ***m = \u0026t; } 2.3 间接赋值：从0级指针到1级指针 int func1(){ return 10; } void func2(int a){ a = 100; } //指针的意义_间接赋值 void test02(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //为什么没有修改？ func2(a); printf(\"a = %d\\n\", a); } //指针的间接赋值 void func3(int* a){ *a = 100; } void test03(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //修改 func3(\u0026a); printf(\"a = %d\\n\", a); } 2.4 间接赋值：从1级指针到2级指针 void AllocateSpace(char** p){ *p = (char*)malloc(100); strcpy(*p, \"hello world!\"); } void FreeSpace(char** p){ if (p == NULL){ return; } if (*p != NULL){ free(*p); *p = NULL; } } void test(){ char* p = NULL; AllocateSpace(\u0026p); printf(\"%s\\n\",p); FreeSpace(\u0026p); if (p == NULL){ printf(\"p内存释放!\\n\"); } } 用1级指针形参，去间接修改了0级指针(实参)的值。 用2级指针形参，去间接修改了1级指针(实参)的值。 用3级指针形参，去间接修改了2级指针(实参)的值。 用n级指针形参，去间接修改了n-1级指针(实参)的值。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:2","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#21-间接赋值的三大条件"},{"categories":["C"],"content":" 2、指针的意义_间接赋值 2.1 间接赋值的三大条件通过指针间接赋值成立的三大条件： 2个变量（一个普通变量一个指针变量、或者一个实参一个形参） 建立关系 通过 * 操作指针指向的内存 void test(){ int a = 100; //两个变量 int *p = NULL; //建立关系 //指针指向谁，就把谁的地址赋值给指针 p = \u0026a; //通过*操作内存 *p = 22; } 2.2 如何定义合适的指针变量 void test(){ int b; int *q = \u0026b; //0级指针 int **t = \u0026q; int ***m = \u0026t; } 2.3 间接赋值：从0级指针到1级指针 int func1(){ return 10; } void func2(int a){ a = 100; } //指针的意义_间接赋值 void test02(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //为什么没有修改？ func2(a); printf(\"a = %d\\n\", a); } //指针的间接赋值 void func3(int* a){ *a = 100; } void test03(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //修改 func3(\u0026a); printf(\"a = %d\\n\", a); } 2.4 间接赋值：从1级指针到2级指针 void AllocateSpace(char** p){ *p = (char*)malloc(100); strcpy(*p, \"hello world!\"); } void FreeSpace(char** p){ if (p == NULL){ return; } if (*p != NULL){ free(*p); *p = NULL; } } void test(){ char* p = NULL; AllocateSpace(\u0026p); printf(\"%s\\n\",p); FreeSpace(\u0026p); if (p == NULL){ printf(\"p内存释放!\\n\"); } } 用1级指针形参，去间接修改了0级指针(实参)的值。 用2级指针形参，去间接修改了1级指针(实参)的值。 用3级指针形参，去间接修改了2级指针(实参)的值。 用n级指针形参，去间接修改了n-1级指针(实参)的值。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:2","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#22-如何定义合适的指针变量"},{"categories":["C"],"content":" 2、指针的意义_间接赋值 2.1 间接赋值的三大条件通过指针间接赋值成立的三大条件： 2个变量（一个普通变量一个指针变量、或者一个实参一个形参） 建立关系 通过 * 操作指针指向的内存 void test(){ int a = 100; //两个变量 int *p = NULL; //建立关系 //指针指向谁，就把谁的地址赋值给指针 p = \u0026a; //通过*操作内存 *p = 22; } 2.2 如何定义合适的指针变量 void test(){ int b; int *q = \u0026b; //0级指针 int **t = \u0026q; int ***m = \u0026t; } 2.3 间接赋值：从0级指针到1级指针 int func1(){ return 10; } void func2(int a){ a = 100; } //指针的意义_间接赋值 void test02(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //为什么没有修改？ func2(a); printf(\"a = %d\\n\", a); } //指针的间接赋值 void func3(int* a){ *a = 100; } void test03(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //修改 func3(\u0026a); printf(\"a = %d\\n\", a); } 2.4 间接赋值：从1级指针到2级指针 void AllocateSpace(char** p){ *p = (char*)malloc(100); strcpy(*p, \"hello world!\"); } void FreeSpace(char** p){ if (p == NULL){ return; } if (*p != NULL){ free(*p); *p = NULL; } } void test(){ char* p = NULL; AllocateSpace(\u0026p); printf(\"%s\\n\",p); FreeSpace(\u0026p); if (p == NULL){ printf(\"p内存释放!\\n\"); } } 用1级指针形参，去间接修改了0级指针(实参)的值。 用2级指针形参，去间接修改了1级指针(实参)的值。 用3级指针形参，去间接修改了2级指针(实参)的值。 用n级指针形参，去间接修改了n-1级指针(实参)的值。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:2","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#23-间接赋值从0级指针到1级指针"},{"categories":["C"],"content":" 2、指针的意义_间接赋值 2.1 间接赋值的三大条件通过指针间接赋值成立的三大条件： 2个变量（一个普通变量一个指针变量、或者一个实参一个形参） 建立关系 通过 * 操作指针指向的内存 void test(){ int a = 100; //两个变量 int *p = NULL; //建立关系 //指针指向谁，就把谁的地址赋值给指针 p = \u0026a; //通过*操作内存 *p = 22; } 2.2 如何定义合适的指针变量 void test(){ int b; int *q = \u0026b; //0级指针 int **t = \u0026q; int ***m = \u0026t; } 2.3 间接赋值：从0级指针到1级指针 int func1(){ return 10; } void func2(int a){ a = 100; } //指针的意义_间接赋值 void test02(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //为什么没有修改？ func2(a); printf(\"a = %d\\n\", a); } //指针的间接赋值 void func3(int* a){ *a = 100; } void test03(){ int a = 0; a = func1(); printf(\"a = %d\\n\", a); //修改 func3(\u0026a); printf(\"a = %d\\n\", a); } 2.4 间接赋值：从1级指针到2级指针 void AllocateSpace(char** p){ *p = (char*)malloc(100); strcpy(*p, \"hello world!\"); } void FreeSpace(char** p){ if (p == NULL){ return; } if (*p != NULL){ free(*p); *p = NULL; } } void test(){ char* p = NULL; AllocateSpace(\u0026p); printf(\"%s\\n\",p); FreeSpace(\u0026p); if (p == NULL){ printf(\"p内存释放!\\n\"); } } 用1级指针形参，去间接修改了0级指针(实参)的值。 用2级指针形参，去间接修改了1级指针(实参)的值。 用3级指针形参，去间接修改了2级指针(实参)的值。 用n级指针形参，去间接修改了n-1级指针(实参)的值。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:2","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#24-间接赋值从1级指针到2级指针"},{"categories":["C"],"content":" 3、指针做函数参数指针做函数参数，具备输入和输出特性： 输入：主调函数分配内存 输出：被调用函数分配内存 3.1 输入特性 void fun(char *p /* in */) { //给p指向的内存区域拷贝内容 strcpy(p, \"abcddsgsd\"); } void test(void) { //输入，主调函数分配内存 char buf[100] = { 0 }; fun(buf); printf(\"buf = %s\\n\", buf); } 3.2 输出特性 void fun(char **p /* out */, int *len) { char *tmp = (char *)malloc(100); if (tmp == NULL) { return; } strcpy(tmp, \"adlsgjldsk\"); //间接赋值 *p = tmp; *len = strlen(tmp); } void test(void) { //输出，被调用函数分配内存，地址传递 char *p = NULL; int len = 0; fun(\u0026p, \u0026len); if (p != NULL) { printf(\"p = %s, len = %d\\n\", p, len); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:3","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#3指针做函数参数"},{"categories":["C"],"content":" 3、指针做函数参数指针做函数参数，具备输入和输出特性： 输入：主调函数分配内存 输出：被调用函数分配内存 3.1 输入特性 void fun(char *p /* in */) { //给p指向的内存区域拷贝内容 strcpy(p, \"abcddsgsd\"); } void test(void) { //输入，主调函数分配内存 char buf[100] = { 0 }; fun(buf); printf(\"buf = %s\\n\", buf); } 3.2 输出特性 void fun(char **p /* out */, int *len) { char *tmp = (char *)malloc(100); if (tmp == NULL) { return; } strcpy(tmp, \"adlsgjldsk\"); //间接赋值 *p = tmp; *len = strlen(tmp); } void test(void) { //输出，被调用函数分配内存，地址传递 char *p = NULL; int len = 0; fun(\u0026p, \u0026len); if (p != NULL) { printf(\"p = %s, len = %d\\n\", p, len); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:3","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#31-输入特性"},{"categories":["C"],"content":" 3、指针做函数参数指针做函数参数，具备输入和输出特性： 输入：主调函数分配内存 输出：被调用函数分配内存 3.1 输入特性 void fun(char *p /* in */) { //给p指向的内存区域拷贝内容 strcpy(p, \"abcddsgsd\"); } void test(void) { //输入，主调函数分配内存 char buf[100] = { 0 }; fun(buf); printf(\"buf = %s\\n\", buf); } 3.2 输出特性 void fun(char **p /* out */, int *len) { char *tmp = (char *)malloc(100); if (tmp == NULL) { return; } strcpy(tmp, \"adlsgjldsk\"); //间接赋值 *p = tmp; *len = strlen(tmp); } void test(void) { //输出，被调用函数分配内存，地址传递 char *p = NULL; int len = 0; fun(\u0026p, \u0026len); if (p != NULL) { printf(\"p = %s, len = %d\\n\", p, len); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:3","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#32-输出特性"},{"categories":["C"],"content":" 4、字符串指针 4.1 字符串指针做函数参数 4.1.1 字符串基本操作 //字符串基本操作 //字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价) void test01(){ //字符数组只能初始化5个字符，当输出的时候，从开始位置直到找到0结束 char str1[] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\",str1); //字符数组部分初始化，剩余填0 char str2[100] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\", str2); //如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0' char str3[] = \"hello\"; printf(\"%s\\n\",str3); printf(\"sizeof str:%d\\n\",sizeof(str3)); printf(\"strlen str:%d\\n\",strlen(str3)); //sizeof计算数组大小，数组包含'\\0'字符 //strlen计算字符串的长度，到'\\0'结束 //那么如果我这么写,结果是多少呢？ char str4[100] = \"hello\"; printf(\"sizeof str:%d\\n\", sizeof(str4)); printf(\"strlen str:%d\\n\", strlen(str4)); //请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str5[] = \"hello\\0world\"; printf(\"%s\\n\",str5); printf(\"sizeof str5:%d\\n\",sizeof(str5)); printf(\"strlen str5:%d\\n\",strlen(str5)); //再请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str6[] = \"hello\\012world\"; printf(\"%s\\n\", str6); printf(\"sizeof str6:%d\\n\", sizeof(str6)); printf(\"strlen str6:%d\\n\", strlen(str6)); } 八进制和十六进制转义字符： 在C中有两种特殊的字符，八进制转义字符和十六进制转义字符，八进制字符的一般形式是’\\ddd’，d是0-7的数字。十六进制字符的一般形式是’\\xhh’，h是0-9或A-F内的一个。八进制字符和十六进制字符表示的是字符的ASCII码对应的数值。比如 ： n ‘\\063’表示的是字符'3’，因为'3’的ASCII码是30（十六进制），48（十进制），63（八进制）。n ‘\\x41’表示的是字符’A’，因为’A’的ASCII码是41（十六进制），65（十进制），101（八进制）。 4.1.2 字符串拷贝功能实现 //拷贝方法1 void copy_string01(char* dest, char* source ){ for (int i = 0; source[i] != '\\0';i++){ dest[i] = source[i]; } } //拷贝方法2 void copy_string02(char* dest, char* source){ while (*source != '\\0' /* *source != 0 */){ *dest = *source; source++; dest++; } } //拷贝方法3 void copy_string03(char* dest, char* source){ //判断*dest是否为0，0则退出循环 while (*dest++ = *source++){} } 4.1.3 字符串反转模型 void reverse_string(char* str){ if (str == NULL){ return; } int begin = 0; int end = strlen(str) - 1; while (begin \u003c end){ //交换两个字符元素 char temp = str[begin]; str[begin] = str[end]; str[end] = temp; begin++; end--; } } void test(){ char str[] = \"abcdefghijklmn\"; printf(\"str:%s\\n\", str); reverse_string(str); printf(\"str:%s\\n\", str); } 4.2 字符串的格式化 4.2.1 sprintf #include \u003cstdio.h\u003e int sprintf(char *str, const char *format, ...); 功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到 出现字符串结束符 '\\0' 为止。 参数： str：字符串首地址 format：字符串格式，用法和printf()一样 返回值： 成功：实际格式化的字符个数 失败： - 1 void test(){ //1. 格式化字符串 char buf[1024] = { 0 }; sprintf(buf, \"你好,%s,欢迎加入我们!\", \"John\"); printf(\"buf:%s\\n\",buf); memset(buf, 0, 1024); sprintf(buf, \"我今年%d岁了!\", 20); printf(\"buf:%s\\n\", buf); //2. 拼接字符串 memset(buf, 0, 1024); char str1[] = \"hello\"; char str2[] = \"world\"; int len = sprintf(buf,\"%s %s\",str1,str2); printf(\"buf:%s len:%d\\n\", buf,len); //3. 数字转字符串 memset(buf, 0, 1024); int num = 100; sprintf(buf, \"%d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 右对齐 memset(buf, 0, 1024); sprintf(buf, \"%8d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 左对齐 memset(buf, 0, 1024); sprintf(buf, \"%-8d\", num); printf(\"buf:%s\\n\", buf); //转成16进制字符串 小写 memset(buf, 0, 1024); sprintf(buf, \"0x%x\", num); printf(\"buf:%s\\n\", buf); //转成8进制字符串 memset(buf, 0, 1024); sprintf(buf, \"0%o\", num); printf(\"buf:%s\\n\", buf); } 4.2.2 sscanf*#include \u003cstdio.h\u003e* int sscanf*(**const char *str, const char format, …); 功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。 参数： ​ str：指定的字符串首地址 ​ format：字符串格式，用法和scanf*()*一样 返回值： ​ 成功：成功则返回参数数目，失败则返回-1 ​ 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 //1. 跳过数据 void test01(){ char buf[1024] = { 0 }; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf(\"123456aaaa\", \"%*d%s\", buf); printf(\"buf:%s\\n\",buf); } //2. 读取指定宽度数据 void test02(){ char buf[1024] = { 0 }; //跳过前面的数字 sscanf(\"123456aaaa\", \"%7s\", buf); printf(\"buf:%s\\n\", buf); } //3. 匹配a-z中任意字符 void test03(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf(\"abcdefg123456\", \"%[a-z]\", buf); printf(\"buf:%s\\n\", buf); } //4. 匹配aBc中的任何一个 void test04(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 //如果匹配失败，则后续不再匹配 sscanf(\"abcdefg123456\", \"%[aBc]\", buf); printf(\"buf:%s\\n\", buf); } //5. 匹配非a的任意字符 void test05(){ char","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#4字符串指针"},{"categories":["C"],"content":" 4、字符串指针 4.1 字符串指针做函数参数 4.1.1 字符串基本操作 //字符串基本操作 //字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价) void test01(){ //字符数组只能初始化5个字符，当输出的时候，从开始位置直到找到0结束 char str1[] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\",str1); //字符数组部分初始化，剩余填0 char str2[100] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\", str2); //如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0' char str3[] = \"hello\"; printf(\"%s\\n\",str3); printf(\"sizeof str:%d\\n\",sizeof(str3)); printf(\"strlen str:%d\\n\",strlen(str3)); //sizeof计算数组大小，数组包含'\\0'字符 //strlen计算字符串的长度，到'\\0'结束 //那么如果我这么写,结果是多少呢？ char str4[100] = \"hello\"; printf(\"sizeof str:%d\\n\", sizeof(str4)); printf(\"strlen str:%d\\n\", strlen(str4)); //请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str5[] = \"hello\\0world\"; printf(\"%s\\n\",str5); printf(\"sizeof str5:%d\\n\",sizeof(str5)); printf(\"strlen str5:%d\\n\",strlen(str5)); //再请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str6[] = \"hello\\012world\"; printf(\"%s\\n\", str6); printf(\"sizeof str6:%d\\n\", sizeof(str6)); printf(\"strlen str6:%d\\n\", strlen(str6)); } 八进制和十六进制转义字符： 在C中有两种特殊的字符，八进制转义字符和十六进制转义字符，八进制字符的一般形式是’\\ddd’，d是0-7的数字。十六进制字符的一般形式是’\\xhh’，h是0-9或A-F内的一个。八进制字符和十六进制字符表示的是字符的ASCII码对应的数值。比如 ： n ‘\\063’表示的是字符'3’，因为'3’的ASCII码是30（十六进制），48（十进制），63（八进制）。n ‘\\x41’表示的是字符’A’，因为’A’的ASCII码是41（十六进制），65（十进制），101（八进制）。 4.1.2 字符串拷贝功能实现 //拷贝方法1 void copy_string01(char* dest, char* source ){ for (int i = 0; source[i] != '\\0';i++){ dest[i] = source[i]; } } //拷贝方法2 void copy_string02(char* dest, char* source){ while (*source != '\\0' /* *source != 0 */){ *dest = *source; source++; dest++; } } //拷贝方法3 void copy_string03(char* dest, char* source){ //判断*dest是否为0，0则退出循环 while (*dest++ = *source++){} } 4.1.3 字符串反转模型 void reverse_string(char* str){ if (str == NULL){ return; } int begin = 0; int end = strlen(str) - 1; while (begin \u003c end){ //交换两个字符元素 char temp = str[begin]; str[begin] = str[end]; str[end] = temp; begin++; end--; } } void test(){ char str[] = \"abcdefghijklmn\"; printf(\"str:%s\\n\", str); reverse_string(str); printf(\"str:%s\\n\", str); } 4.2 字符串的格式化 4.2.1 sprintf #include int sprintf(char *str, const char *format, ...); 功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到 出现字符串结束符 '\\0' 为止。 参数： str：字符串首地址 format：字符串格式，用法和printf()一样 返回值： 成功：实际格式化的字符个数 失败： - 1 void test(){ //1. 格式化字符串 char buf[1024] = { 0 }; sprintf(buf, \"你好,%s,欢迎加入我们!\", \"John\"); printf(\"buf:%s\\n\",buf); memset(buf, 0, 1024); sprintf(buf, \"我今年%d岁了!\", 20); printf(\"buf:%s\\n\", buf); //2. 拼接字符串 memset(buf, 0, 1024); char str1[] = \"hello\"; char str2[] = \"world\"; int len = sprintf(buf,\"%s %s\",str1,str2); printf(\"buf:%s len:%d\\n\", buf,len); //3. 数字转字符串 memset(buf, 0, 1024); int num = 100; sprintf(buf, \"%d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 右对齐 memset(buf, 0, 1024); sprintf(buf, \"%8d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 左对齐 memset(buf, 0, 1024); sprintf(buf, \"%-8d\", num); printf(\"buf:%s\\n\", buf); //转成16进制字符串 小写 memset(buf, 0, 1024); sprintf(buf, \"0x%x\", num); printf(\"buf:%s\\n\", buf); //转成8进制字符串 memset(buf, 0, 1024); sprintf(buf, \"0%o\", num); printf(\"buf:%s\\n\", buf); } 4.2.2 sscanf*#include * int sscanf*(**const char *str, const char format, …); 功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。 参数： ​ str：指定的字符串首地址 ​ format：字符串格式，用法和scanf*()*一样 返回值： ​ 成功：成功则返回参数数目，失败则返回-1 ​ 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 //1. 跳过数据 void test01(){ char buf[1024] = { 0 }; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf(\"123456aaaa\", \"%*d%s\", buf); printf(\"buf:%s\\n\",buf); } //2. 读取指定宽度数据 void test02(){ char buf[1024] = { 0 }; //跳过前面的数字 sscanf(\"123456aaaa\", \"%7s\", buf); printf(\"buf:%s\\n\", buf); } //3. 匹配a-z中任意字符 void test03(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf(\"abcdefg123456\", \"%[a-z]\", buf); printf(\"buf:%s\\n\", buf); } //4. 匹配aBc中的任何一个 void test04(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 //如果匹配失败，则后续不再匹配 sscanf(\"abcdefg123456\", \"%[aBc]\", buf); printf(\"buf:%s\\n\", buf); } //5. 匹配非a的任意字符 void test05(){ char","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#41-字符串指针做函数参数"},{"categories":["C"],"content":" 4、字符串指针 4.1 字符串指针做函数参数 4.1.1 字符串基本操作 //字符串基本操作 //字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价) void test01(){ //字符数组只能初始化5个字符，当输出的时候，从开始位置直到找到0结束 char str1[] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\",str1); //字符数组部分初始化，剩余填0 char str2[100] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\", str2); //如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0' char str3[] = \"hello\"; printf(\"%s\\n\",str3); printf(\"sizeof str:%d\\n\",sizeof(str3)); printf(\"strlen str:%d\\n\",strlen(str3)); //sizeof计算数组大小，数组包含'\\0'字符 //strlen计算字符串的长度，到'\\0'结束 //那么如果我这么写,结果是多少呢？ char str4[100] = \"hello\"; printf(\"sizeof str:%d\\n\", sizeof(str4)); printf(\"strlen str:%d\\n\", strlen(str4)); //请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str5[] = \"hello\\0world\"; printf(\"%s\\n\",str5); printf(\"sizeof str5:%d\\n\",sizeof(str5)); printf(\"strlen str5:%d\\n\",strlen(str5)); //再请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str6[] = \"hello\\012world\"; printf(\"%s\\n\", str6); printf(\"sizeof str6:%d\\n\", sizeof(str6)); printf(\"strlen str6:%d\\n\", strlen(str6)); } 八进制和十六进制转义字符： 在C中有两种特殊的字符，八进制转义字符和十六进制转义字符，八进制字符的一般形式是’\\ddd’，d是0-7的数字。十六进制字符的一般形式是’\\xhh’，h是0-9或A-F内的一个。八进制字符和十六进制字符表示的是字符的ASCII码对应的数值。比如 ： n ‘\\063’表示的是字符'3’，因为'3’的ASCII码是30（十六进制），48（十进制），63（八进制）。n ‘\\x41’表示的是字符’A’，因为’A’的ASCII码是41（十六进制），65（十进制），101（八进制）。 4.1.2 字符串拷贝功能实现 //拷贝方法1 void copy_string01(char* dest, char* source ){ for (int i = 0; source[i] != '\\0';i++){ dest[i] = source[i]; } } //拷贝方法2 void copy_string02(char* dest, char* source){ while (*source != '\\0' /* *source != 0 */){ *dest = *source; source++; dest++; } } //拷贝方法3 void copy_string03(char* dest, char* source){ //判断*dest是否为0，0则退出循环 while (*dest++ = *source++){} } 4.1.3 字符串反转模型 void reverse_string(char* str){ if (str == NULL){ return; } int begin = 0; int end = strlen(str) - 1; while (begin \u003c end){ //交换两个字符元素 char temp = str[begin]; str[begin] = str[end]; str[end] = temp; begin++; end--; } } void test(){ char str[] = \"abcdefghijklmn\"; printf(\"str:%s\\n\", str); reverse_string(str); printf(\"str:%s\\n\", str); } 4.2 字符串的格式化 4.2.1 sprintf #include int sprintf(char *str, const char *format, ...); 功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到 出现字符串结束符 '\\0' 为止。 参数： str：字符串首地址 format：字符串格式，用法和printf()一样 返回值： 成功：实际格式化的字符个数 失败： - 1 void test(){ //1. 格式化字符串 char buf[1024] = { 0 }; sprintf(buf, \"你好,%s,欢迎加入我们!\", \"John\"); printf(\"buf:%s\\n\",buf); memset(buf, 0, 1024); sprintf(buf, \"我今年%d岁了!\", 20); printf(\"buf:%s\\n\", buf); //2. 拼接字符串 memset(buf, 0, 1024); char str1[] = \"hello\"; char str2[] = \"world\"; int len = sprintf(buf,\"%s %s\",str1,str2); printf(\"buf:%s len:%d\\n\", buf,len); //3. 数字转字符串 memset(buf, 0, 1024); int num = 100; sprintf(buf, \"%d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 右对齐 memset(buf, 0, 1024); sprintf(buf, \"%8d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 左对齐 memset(buf, 0, 1024); sprintf(buf, \"%-8d\", num); printf(\"buf:%s\\n\", buf); //转成16进制字符串 小写 memset(buf, 0, 1024); sprintf(buf, \"0x%x\", num); printf(\"buf:%s\\n\", buf); //转成8进制字符串 memset(buf, 0, 1024); sprintf(buf, \"0%o\", num); printf(\"buf:%s\\n\", buf); } 4.2.2 sscanf*#include * int sscanf*(**const char *str, const char format, …); 功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。 参数： ​ str：指定的字符串首地址 ​ format：字符串格式，用法和scanf*()*一样 返回值： ​ 成功：成功则返回参数数目，失败则返回-1 ​ 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 //1. 跳过数据 void test01(){ char buf[1024] = { 0 }; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf(\"123456aaaa\", \"%*d%s\", buf); printf(\"buf:%s\\n\",buf); } //2. 读取指定宽度数据 void test02(){ char buf[1024] = { 0 }; //跳过前面的数字 sscanf(\"123456aaaa\", \"%7s\", buf); printf(\"buf:%s\\n\", buf); } //3. 匹配a-z中任意字符 void test03(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf(\"abcdefg123456\", \"%[a-z]\", buf); printf(\"buf:%s\\n\", buf); } //4. 匹配aBc中的任何一个 void test04(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 //如果匹配失败，则后续不再匹配 sscanf(\"abcdefg123456\", \"%[aBc]\", buf); printf(\"buf:%s\\n\", buf); } //5. 匹配非a的任意字符 void test05(){ char","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#411-字符串基本操作"},{"categories":["C"],"content":" 4、字符串指针 4.1 字符串指针做函数参数 4.1.1 字符串基本操作 //字符串基本操作 //字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价) void test01(){ //字符数组只能初始化5个字符，当输出的时候，从开始位置直到找到0结束 char str1[] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\",str1); //字符数组部分初始化，剩余填0 char str2[100] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\", str2); //如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0' char str3[] = \"hello\"; printf(\"%s\\n\",str3); printf(\"sizeof str:%d\\n\",sizeof(str3)); printf(\"strlen str:%d\\n\",strlen(str3)); //sizeof计算数组大小，数组包含'\\0'字符 //strlen计算字符串的长度，到'\\0'结束 //那么如果我这么写,结果是多少呢？ char str4[100] = \"hello\"; printf(\"sizeof str:%d\\n\", sizeof(str4)); printf(\"strlen str:%d\\n\", strlen(str4)); //请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str5[] = \"hello\\0world\"; printf(\"%s\\n\",str5); printf(\"sizeof str5:%d\\n\",sizeof(str5)); printf(\"strlen str5:%d\\n\",strlen(str5)); //再请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str6[] = \"hello\\012world\"; printf(\"%s\\n\", str6); printf(\"sizeof str6:%d\\n\", sizeof(str6)); printf(\"strlen str6:%d\\n\", strlen(str6)); } 八进制和十六进制转义字符： 在C中有两种特殊的字符，八进制转义字符和十六进制转义字符，八进制字符的一般形式是’\\ddd’，d是0-7的数字。十六进制字符的一般形式是’\\xhh’，h是0-9或A-F内的一个。八进制字符和十六进制字符表示的是字符的ASCII码对应的数值。比如 ： n ‘\\063’表示的是字符'3’，因为'3’的ASCII码是30（十六进制），48（十进制），63（八进制）。n ‘\\x41’表示的是字符’A’，因为’A’的ASCII码是41（十六进制），65（十进制），101（八进制）。 4.1.2 字符串拷贝功能实现 //拷贝方法1 void copy_string01(char* dest, char* source ){ for (int i = 0; source[i] != '\\0';i++){ dest[i] = source[i]; } } //拷贝方法2 void copy_string02(char* dest, char* source){ while (*source != '\\0' /* *source != 0 */){ *dest = *source; source++; dest++; } } //拷贝方法3 void copy_string03(char* dest, char* source){ //判断*dest是否为0，0则退出循环 while (*dest++ = *source++){} } 4.1.3 字符串反转模型 void reverse_string(char* str){ if (str == NULL){ return; } int begin = 0; int end = strlen(str) - 1; while (begin \u003c end){ //交换两个字符元素 char temp = str[begin]; str[begin] = str[end]; str[end] = temp; begin++; end--; } } void test(){ char str[] = \"abcdefghijklmn\"; printf(\"str:%s\\n\", str); reverse_string(str); printf(\"str:%s\\n\", str); } 4.2 字符串的格式化 4.2.1 sprintf #include int sprintf(char *str, const char *format, ...); 功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到 出现字符串结束符 '\\0' 为止。 参数： str：字符串首地址 format：字符串格式，用法和printf()一样 返回值： 成功：实际格式化的字符个数 失败： - 1 void test(){ //1. 格式化字符串 char buf[1024] = { 0 }; sprintf(buf, \"你好,%s,欢迎加入我们!\", \"John\"); printf(\"buf:%s\\n\",buf); memset(buf, 0, 1024); sprintf(buf, \"我今年%d岁了!\", 20); printf(\"buf:%s\\n\", buf); //2. 拼接字符串 memset(buf, 0, 1024); char str1[] = \"hello\"; char str2[] = \"world\"; int len = sprintf(buf,\"%s %s\",str1,str2); printf(\"buf:%s len:%d\\n\", buf,len); //3. 数字转字符串 memset(buf, 0, 1024); int num = 100; sprintf(buf, \"%d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 右对齐 memset(buf, 0, 1024); sprintf(buf, \"%8d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 左对齐 memset(buf, 0, 1024); sprintf(buf, \"%-8d\", num); printf(\"buf:%s\\n\", buf); //转成16进制字符串 小写 memset(buf, 0, 1024); sprintf(buf, \"0x%x\", num); printf(\"buf:%s\\n\", buf); //转成8进制字符串 memset(buf, 0, 1024); sprintf(buf, \"0%o\", num); printf(\"buf:%s\\n\", buf); } 4.2.2 sscanf*#include * int sscanf*(**const char *str, const char format, …); 功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。 参数： ​ str：指定的字符串首地址 ​ format：字符串格式，用法和scanf*()*一样 返回值： ​ 成功：成功则返回参数数目，失败则返回-1 ​ 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 //1. 跳过数据 void test01(){ char buf[1024] = { 0 }; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf(\"123456aaaa\", \"%*d%s\", buf); printf(\"buf:%s\\n\",buf); } //2. 读取指定宽度数据 void test02(){ char buf[1024] = { 0 }; //跳过前面的数字 sscanf(\"123456aaaa\", \"%7s\", buf); printf(\"buf:%s\\n\", buf); } //3. 匹配a-z中任意字符 void test03(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf(\"abcdefg123456\", \"%[a-z]\", buf); printf(\"buf:%s\\n\", buf); } //4. 匹配aBc中的任何一个 void test04(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 //如果匹配失败，则后续不再匹配 sscanf(\"abcdefg123456\", \"%[aBc]\", buf); printf(\"buf:%s\\n\", buf); } //5. 匹配非a的任意字符 void test05(){ char","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#412-字符串拷贝功能实现"},{"categories":["C"],"content":" 4、字符串指针 4.1 字符串指针做函数参数 4.1.1 字符串基本操作 //字符串基本操作 //字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价) void test01(){ //字符数组只能初始化5个字符，当输出的时候，从开始位置直到找到0结束 char str1[] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\",str1); //字符数组部分初始化，剩余填0 char str2[100] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\", str2); //如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0' char str3[] = \"hello\"; printf(\"%s\\n\",str3); printf(\"sizeof str:%d\\n\",sizeof(str3)); printf(\"strlen str:%d\\n\",strlen(str3)); //sizeof计算数组大小，数组包含'\\0'字符 //strlen计算字符串的长度，到'\\0'结束 //那么如果我这么写,结果是多少呢？ char str4[100] = \"hello\"; printf(\"sizeof str:%d\\n\", sizeof(str4)); printf(\"strlen str:%d\\n\", strlen(str4)); //请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str5[] = \"hello\\0world\"; printf(\"%s\\n\",str5); printf(\"sizeof str5:%d\\n\",sizeof(str5)); printf(\"strlen str5:%d\\n\",strlen(str5)); //再请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str6[] = \"hello\\012world\"; printf(\"%s\\n\", str6); printf(\"sizeof str6:%d\\n\", sizeof(str6)); printf(\"strlen str6:%d\\n\", strlen(str6)); } 八进制和十六进制转义字符： 在C中有两种特殊的字符，八进制转义字符和十六进制转义字符，八进制字符的一般形式是’\\ddd’，d是0-7的数字。十六进制字符的一般形式是’\\xhh’，h是0-9或A-F内的一个。八进制字符和十六进制字符表示的是字符的ASCII码对应的数值。比如 ： n ‘\\063’表示的是字符'3’，因为'3’的ASCII码是30（十六进制），48（十进制），63（八进制）。n ‘\\x41’表示的是字符’A’，因为’A’的ASCII码是41（十六进制），65（十进制），101（八进制）。 4.1.2 字符串拷贝功能实现 //拷贝方法1 void copy_string01(char* dest, char* source ){ for (int i = 0; source[i] != '\\0';i++){ dest[i] = source[i]; } } //拷贝方法2 void copy_string02(char* dest, char* source){ while (*source != '\\0' /* *source != 0 */){ *dest = *source; source++; dest++; } } //拷贝方法3 void copy_string03(char* dest, char* source){ //判断*dest是否为0，0则退出循环 while (*dest++ = *source++){} } 4.1.3 字符串反转模型 void reverse_string(char* str){ if (str == NULL){ return; } int begin = 0; int end = strlen(str) - 1; while (begin \u003c end){ //交换两个字符元素 char temp = str[begin]; str[begin] = str[end]; str[end] = temp; begin++; end--; } } void test(){ char str[] = \"abcdefghijklmn\"; printf(\"str:%s\\n\", str); reverse_string(str); printf(\"str:%s\\n\", str); } 4.2 字符串的格式化 4.2.1 sprintf #include int sprintf(char *str, const char *format, ...); 功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到 出现字符串结束符 '\\0' 为止。 参数： str：字符串首地址 format：字符串格式，用法和printf()一样 返回值： 成功：实际格式化的字符个数 失败： - 1 void test(){ //1. 格式化字符串 char buf[1024] = { 0 }; sprintf(buf, \"你好,%s,欢迎加入我们!\", \"John\"); printf(\"buf:%s\\n\",buf); memset(buf, 0, 1024); sprintf(buf, \"我今年%d岁了!\", 20); printf(\"buf:%s\\n\", buf); //2. 拼接字符串 memset(buf, 0, 1024); char str1[] = \"hello\"; char str2[] = \"world\"; int len = sprintf(buf,\"%s %s\",str1,str2); printf(\"buf:%s len:%d\\n\", buf,len); //3. 数字转字符串 memset(buf, 0, 1024); int num = 100; sprintf(buf, \"%d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 右对齐 memset(buf, 0, 1024); sprintf(buf, \"%8d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 左对齐 memset(buf, 0, 1024); sprintf(buf, \"%-8d\", num); printf(\"buf:%s\\n\", buf); //转成16进制字符串 小写 memset(buf, 0, 1024); sprintf(buf, \"0x%x\", num); printf(\"buf:%s\\n\", buf); //转成8进制字符串 memset(buf, 0, 1024); sprintf(buf, \"0%o\", num); printf(\"buf:%s\\n\", buf); } 4.2.2 sscanf*#include * int sscanf*(**const char *str, const char format, …); 功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。 参数： ​ str：指定的字符串首地址 ​ format：字符串格式，用法和scanf*()*一样 返回值： ​ 成功：成功则返回参数数目，失败则返回-1 ​ 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 //1. 跳过数据 void test01(){ char buf[1024] = { 0 }; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf(\"123456aaaa\", \"%*d%s\", buf); printf(\"buf:%s\\n\",buf); } //2. 读取指定宽度数据 void test02(){ char buf[1024] = { 0 }; //跳过前面的数字 sscanf(\"123456aaaa\", \"%7s\", buf); printf(\"buf:%s\\n\", buf); } //3. 匹配a-z中任意字符 void test03(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf(\"abcdefg123456\", \"%[a-z]\", buf); printf(\"buf:%s\\n\", buf); } //4. 匹配aBc中的任何一个 void test04(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 //如果匹配失败，则后续不再匹配 sscanf(\"abcdefg123456\", \"%[aBc]\", buf); printf(\"buf:%s\\n\", buf); } //5. 匹配非a的任意字符 void test05(){ char","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#413-字符串反转模型"},{"categories":["C"],"content":" 4、字符串指针 4.1 字符串指针做函数参数 4.1.1 字符串基本操作 //字符串基本操作 //字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价) void test01(){ //字符数组只能初始化5个字符，当输出的时候，从开始位置直到找到0结束 char str1[] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\",str1); //字符数组部分初始化，剩余填0 char str2[100] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\", str2); //如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0' char str3[] = \"hello\"; printf(\"%s\\n\",str3); printf(\"sizeof str:%d\\n\",sizeof(str3)); printf(\"strlen str:%d\\n\",strlen(str3)); //sizeof计算数组大小，数组包含'\\0'字符 //strlen计算字符串的长度，到'\\0'结束 //那么如果我这么写,结果是多少呢？ char str4[100] = \"hello\"; printf(\"sizeof str:%d\\n\", sizeof(str4)); printf(\"strlen str:%d\\n\", strlen(str4)); //请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str5[] = \"hello\\0world\"; printf(\"%s\\n\",str5); printf(\"sizeof str5:%d\\n\",sizeof(str5)); printf(\"strlen str5:%d\\n\",strlen(str5)); //再请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str6[] = \"hello\\012world\"; printf(\"%s\\n\", str6); printf(\"sizeof str6:%d\\n\", sizeof(str6)); printf(\"strlen str6:%d\\n\", strlen(str6)); } 八进制和十六进制转义字符： 在C中有两种特殊的字符，八进制转义字符和十六进制转义字符，八进制字符的一般形式是’\\ddd’，d是0-7的数字。十六进制字符的一般形式是’\\xhh’，h是0-9或A-F内的一个。八进制字符和十六进制字符表示的是字符的ASCII码对应的数值。比如 ： n ‘\\063’表示的是字符'3’，因为'3’的ASCII码是30（十六进制），48（十进制），63（八进制）。n ‘\\x41’表示的是字符’A’，因为’A’的ASCII码是41（十六进制），65（十进制），101（八进制）。 4.1.2 字符串拷贝功能实现 //拷贝方法1 void copy_string01(char* dest, char* source ){ for (int i = 0; source[i] != '\\0';i++){ dest[i] = source[i]; } } //拷贝方法2 void copy_string02(char* dest, char* source){ while (*source != '\\0' /* *source != 0 */){ *dest = *source; source++; dest++; } } //拷贝方法3 void copy_string03(char* dest, char* source){ //判断*dest是否为0，0则退出循环 while (*dest++ = *source++){} } 4.1.3 字符串反转模型 void reverse_string(char* str){ if (str == NULL){ return; } int begin = 0; int end = strlen(str) - 1; while (begin \u003c end){ //交换两个字符元素 char temp = str[begin]; str[begin] = str[end]; str[end] = temp; begin++; end--; } } void test(){ char str[] = \"abcdefghijklmn\"; printf(\"str:%s\\n\", str); reverse_string(str); printf(\"str:%s\\n\", str); } 4.2 字符串的格式化 4.2.1 sprintf #include int sprintf(char *str, const char *format, ...); 功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到 出现字符串结束符 '\\0' 为止。 参数： str：字符串首地址 format：字符串格式，用法和printf()一样 返回值： 成功：实际格式化的字符个数 失败： - 1 void test(){ //1. 格式化字符串 char buf[1024] = { 0 }; sprintf(buf, \"你好,%s,欢迎加入我们!\", \"John\"); printf(\"buf:%s\\n\",buf); memset(buf, 0, 1024); sprintf(buf, \"我今年%d岁了!\", 20); printf(\"buf:%s\\n\", buf); //2. 拼接字符串 memset(buf, 0, 1024); char str1[] = \"hello\"; char str2[] = \"world\"; int len = sprintf(buf,\"%s %s\",str1,str2); printf(\"buf:%s len:%d\\n\", buf,len); //3. 数字转字符串 memset(buf, 0, 1024); int num = 100; sprintf(buf, \"%d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 右对齐 memset(buf, 0, 1024); sprintf(buf, \"%8d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 左对齐 memset(buf, 0, 1024); sprintf(buf, \"%-8d\", num); printf(\"buf:%s\\n\", buf); //转成16进制字符串 小写 memset(buf, 0, 1024); sprintf(buf, \"0x%x\", num); printf(\"buf:%s\\n\", buf); //转成8进制字符串 memset(buf, 0, 1024); sprintf(buf, \"0%o\", num); printf(\"buf:%s\\n\", buf); } 4.2.2 sscanf*#include * int sscanf*(**const char *str, const char format, …); 功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。 参数： ​ str：指定的字符串首地址 ​ format：字符串格式，用法和scanf*()*一样 返回值： ​ 成功：成功则返回参数数目，失败则返回-1 ​ 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 //1. 跳过数据 void test01(){ char buf[1024] = { 0 }; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf(\"123456aaaa\", \"%*d%s\", buf); printf(\"buf:%s\\n\",buf); } //2. 读取指定宽度数据 void test02(){ char buf[1024] = { 0 }; //跳过前面的数字 sscanf(\"123456aaaa\", \"%7s\", buf); printf(\"buf:%s\\n\", buf); } //3. 匹配a-z中任意字符 void test03(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf(\"abcdefg123456\", \"%[a-z]\", buf); printf(\"buf:%s\\n\", buf); } //4. 匹配aBc中的任何一个 void test04(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 //如果匹配失败，则后续不再匹配 sscanf(\"abcdefg123456\", \"%[aBc]\", buf); printf(\"buf:%s\\n\", buf); } //5. 匹配非a的任意字符 void test05(){ char","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#42-字符串的格式化"},{"categories":["C"],"content":" 4、字符串指针 4.1 字符串指针做函数参数 4.1.1 字符串基本操作 //字符串基本操作 //字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价) void test01(){ //字符数组只能初始化5个字符，当输出的时候，从开始位置直到找到0结束 char str1[] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\",str1); //字符数组部分初始化，剩余填0 char str2[100] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\", str2); //如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0' char str3[] = \"hello\"; printf(\"%s\\n\",str3); printf(\"sizeof str:%d\\n\",sizeof(str3)); printf(\"strlen str:%d\\n\",strlen(str3)); //sizeof计算数组大小，数组包含'\\0'字符 //strlen计算字符串的长度，到'\\0'结束 //那么如果我这么写,结果是多少呢？ char str4[100] = \"hello\"; printf(\"sizeof str:%d\\n\", sizeof(str4)); printf(\"strlen str:%d\\n\", strlen(str4)); //请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str5[] = \"hello\\0world\"; printf(\"%s\\n\",str5); printf(\"sizeof str5:%d\\n\",sizeof(str5)); printf(\"strlen str5:%d\\n\",strlen(str5)); //再请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str6[] = \"hello\\012world\"; printf(\"%s\\n\", str6); printf(\"sizeof str6:%d\\n\", sizeof(str6)); printf(\"strlen str6:%d\\n\", strlen(str6)); } 八进制和十六进制转义字符： 在C中有两种特殊的字符，八进制转义字符和十六进制转义字符，八进制字符的一般形式是’\\ddd’，d是0-7的数字。十六进制字符的一般形式是’\\xhh’，h是0-9或A-F内的一个。八进制字符和十六进制字符表示的是字符的ASCII码对应的数值。比如 ： n ‘\\063’表示的是字符'3’，因为'3’的ASCII码是30（十六进制），48（十进制），63（八进制）。n ‘\\x41’表示的是字符’A’，因为’A’的ASCII码是41（十六进制），65（十进制），101（八进制）。 4.1.2 字符串拷贝功能实现 //拷贝方法1 void copy_string01(char* dest, char* source ){ for (int i = 0; source[i] != '\\0';i++){ dest[i] = source[i]; } } //拷贝方法2 void copy_string02(char* dest, char* source){ while (*source != '\\0' /* *source != 0 */){ *dest = *source; source++; dest++; } } //拷贝方法3 void copy_string03(char* dest, char* source){ //判断*dest是否为0，0则退出循环 while (*dest++ = *source++){} } 4.1.3 字符串反转模型 void reverse_string(char* str){ if (str == NULL){ return; } int begin = 0; int end = strlen(str) - 1; while (begin \u003c end){ //交换两个字符元素 char temp = str[begin]; str[begin] = str[end]; str[end] = temp; begin++; end--; } } void test(){ char str[] = \"abcdefghijklmn\"; printf(\"str:%s\\n\", str); reverse_string(str); printf(\"str:%s\\n\", str); } 4.2 字符串的格式化 4.2.1 sprintf #include int sprintf(char *str, const char *format, ...); 功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到 出现字符串结束符 '\\0' 为止。 参数： str：字符串首地址 format：字符串格式，用法和printf()一样 返回值： 成功：实际格式化的字符个数 失败： - 1 void test(){ //1. 格式化字符串 char buf[1024] = { 0 }; sprintf(buf, \"你好,%s,欢迎加入我们!\", \"John\"); printf(\"buf:%s\\n\",buf); memset(buf, 0, 1024); sprintf(buf, \"我今年%d岁了!\", 20); printf(\"buf:%s\\n\", buf); //2. 拼接字符串 memset(buf, 0, 1024); char str1[] = \"hello\"; char str2[] = \"world\"; int len = sprintf(buf,\"%s %s\",str1,str2); printf(\"buf:%s len:%d\\n\", buf,len); //3. 数字转字符串 memset(buf, 0, 1024); int num = 100; sprintf(buf, \"%d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 右对齐 memset(buf, 0, 1024); sprintf(buf, \"%8d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 左对齐 memset(buf, 0, 1024); sprintf(buf, \"%-8d\", num); printf(\"buf:%s\\n\", buf); //转成16进制字符串 小写 memset(buf, 0, 1024); sprintf(buf, \"0x%x\", num); printf(\"buf:%s\\n\", buf); //转成8进制字符串 memset(buf, 0, 1024); sprintf(buf, \"0%o\", num); printf(\"buf:%s\\n\", buf); } 4.2.2 sscanf*#include * int sscanf*(**const char *str, const char format, …); 功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。 参数： ​ str：指定的字符串首地址 ​ format：字符串格式，用法和scanf*()*一样 返回值： ​ 成功：成功则返回参数数目，失败则返回-1 ​ 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 //1. 跳过数据 void test01(){ char buf[1024] = { 0 }; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf(\"123456aaaa\", \"%*d%s\", buf); printf(\"buf:%s\\n\",buf); } //2. 读取指定宽度数据 void test02(){ char buf[1024] = { 0 }; //跳过前面的数字 sscanf(\"123456aaaa\", \"%7s\", buf); printf(\"buf:%s\\n\", buf); } //3. 匹配a-z中任意字符 void test03(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf(\"abcdefg123456\", \"%[a-z]\", buf); printf(\"buf:%s\\n\", buf); } //4. 匹配aBc中的任何一个 void test04(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 //如果匹配失败，则后续不再匹配 sscanf(\"abcdefg123456\", \"%[aBc]\", buf); printf(\"buf:%s\\n\", buf); } //5. 匹配非a的任意字符 void test05(){ char","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#421-sprintf"},{"categories":["C"],"content":" 4、字符串指针 4.1 字符串指针做函数参数 4.1.1 字符串基本操作 //字符串基本操作 //字符串是以0或者'\\0'结尾的字符数组，(数字0和字符'\\0'等价) void test01(){ //字符数组只能初始化5个字符，当输出的时候，从开始位置直到找到0结束 char str1[] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\",str1); //字符数组部分初始化，剩余填0 char str2[100] = { 'h', 'e', 'l', 'l', 'o' }; printf(\"%s\\n\", str2); //如果以字符串初始化，那么编译器默认会在字符串尾部添加'\\0' char str3[] = \"hello\"; printf(\"%s\\n\",str3); printf(\"sizeof str:%d\\n\",sizeof(str3)); printf(\"strlen str:%d\\n\",strlen(str3)); //sizeof计算数组大小，数组包含'\\0'字符 //strlen计算字符串的长度，到'\\0'结束 //那么如果我这么写,结果是多少呢？ char str4[100] = \"hello\"; printf(\"sizeof str:%d\\n\", sizeof(str4)); printf(\"strlen str:%d\\n\", strlen(str4)); //请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str5[] = \"hello\\0world\"; printf(\"%s\\n\",str5); printf(\"sizeof str5:%d\\n\",sizeof(str5)); printf(\"strlen str5:%d\\n\",strlen(str5)); //再请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？ char str6[] = \"hello\\012world\"; printf(\"%s\\n\", str6); printf(\"sizeof str6:%d\\n\", sizeof(str6)); printf(\"strlen str6:%d\\n\", strlen(str6)); } 八进制和十六进制转义字符： 在C中有两种特殊的字符，八进制转义字符和十六进制转义字符，八进制字符的一般形式是’\\ddd’，d是0-7的数字。十六进制字符的一般形式是’\\xhh’，h是0-9或A-F内的一个。八进制字符和十六进制字符表示的是字符的ASCII码对应的数值。比如 ： n ‘\\063’表示的是字符'3’，因为'3’的ASCII码是30（十六进制），48（十进制），63（八进制）。n ‘\\x41’表示的是字符’A’，因为’A’的ASCII码是41（十六进制），65（十进制），101（八进制）。 4.1.2 字符串拷贝功能实现 //拷贝方法1 void copy_string01(char* dest, char* source ){ for (int i = 0; source[i] != '\\0';i++){ dest[i] = source[i]; } } //拷贝方法2 void copy_string02(char* dest, char* source){ while (*source != '\\0' /* *source != 0 */){ *dest = *source; source++; dest++; } } //拷贝方法3 void copy_string03(char* dest, char* source){ //判断*dest是否为0，0则退出循环 while (*dest++ = *source++){} } 4.1.3 字符串反转模型 void reverse_string(char* str){ if (str == NULL){ return; } int begin = 0; int end = strlen(str) - 1; while (begin \u003c end){ //交换两个字符元素 char temp = str[begin]; str[begin] = str[end]; str[end] = temp; begin++; end--; } } void test(){ char str[] = \"abcdefghijklmn\"; printf(\"str:%s\\n\", str); reverse_string(str); printf(\"str:%s\\n\", str); } 4.2 字符串的格式化 4.2.1 sprintf #include int sprintf(char *str, const char *format, ...); 功能： 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到 出现字符串结束符 '\\0' 为止。 参数： str：字符串首地址 format：字符串格式，用法和printf()一样 返回值： 成功：实际格式化的字符个数 失败： - 1 void test(){ //1. 格式化字符串 char buf[1024] = { 0 }; sprintf(buf, \"你好,%s,欢迎加入我们!\", \"John\"); printf(\"buf:%s\\n\",buf); memset(buf, 0, 1024); sprintf(buf, \"我今年%d岁了!\", 20); printf(\"buf:%s\\n\", buf); //2. 拼接字符串 memset(buf, 0, 1024); char str1[] = \"hello\"; char str2[] = \"world\"; int len = sprintf(buf,\"%s %s\",str1,str2); printf(\"buf:%s len:%d\\n\", buf,len); //3. 数字转字符串 memset(buf, 0, 1024); int num = 100; sprintf(buf, \"%d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 右对齐 memset(buf, 0, 1024); sprintf(buf, \"%8d\", num); printf(\"buf:%s\\n\", buf); //设置宽度 左对齐 memset(buf, 0, 1024); sprintf(buf, \"%-8d\", num); printf(\"buf:%s\\n\", buf); //转成16进制字符串 小写 memset(buf, 0, 1024); sprintf(buf, \"0x%x\", num); printf(\"buf:%s\\n\", buf); //转成8进制字符串 memset(buf, 0, 1024); sprintf(buf, \"0%o\", num); printf(\"buf:%s\\n\", buf); } 4.2.2 sscanf*#include * int sscanf*(**const char *str, const char format, …); 功能： 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。 参数： ​ str：指定的字符串首地址 ​ format：字符串格式，用法和scanf*()*一样 返回值： ​ 成功：成功则返回参数数目，失败则返回-1 ​ 失败： - 1 格式 作用 %*s或%*d 跳过数据 %[width]s 读指定宽度的数据 %[a-z] 匹配a到z中任意字符(尽可能多的匹配) %[aBc] 匹配a、B、c中一员，贪婪性 %[^a] 匹配非a的任意字符，贪婪性 %[^a-z] 表示读取除a-z以外的所有字符 //1. 跳过数据 void test01(){ char buf[1024] = { 0 }; //跳过前面的数字 //匹配第一个字符是否是数字，如果是，则跳过 //如果不是则停止匹配 sscanf(\"123456aaaa\", \"%*d%s\", buf); printf(\"buf:%s\\n\",buf); } //2. 读取指定宽度数据 void test02(){ char buf[1024] = { 0 }; //跳过前面的数字 sscanf(\"123456aaaa\", \"%7s\", buf); printf(\"buf:%s\\n\", buf); } //3. 匹配a-z中任意字符 void test03(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符，判断字符是否是a-z中的字符，如果是匹配 //如果不是停止匹配 sscanf(\"abcdefg123456\", \"%[a-z]\", buf); printf(\"buf:%s\\n\", buf); } //4. 匹配aBc中的任何一个 void test04(){ char buf[1024] = { 0 }; //跳过前面的数字 //先匹配第一个字符是否是aBc中的一个，如果是，则匹配，如果不是则停止匹配 //如果匹配失败，则后续不再匹配 sscanf(\"abcdefg123456\", \"%[aBc]\", buf); printf(\"buf:%s\\n\", buf); } //5. 匹配非a的任意字符 void test05(){ char","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:4","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#422-sscanf"},{"categories":["C"],"content":" 5、const使用 //const修饰变量 void test01(){ //1. const基本概念 const int i = 0; //i = 100; //错误，只读变量初始化之后不能修改 //2. 定义const变量最好初始化 const int j; //j = 100; //错误，不能再次赋值 //3. c语言的const是一个只读变量，并不是一个常量，可通过指针间接修改 const int k = 10; //k = 100; //错误，不可直接修改，我们可通过指针间接修改 printf(\"k:%d\\n\", k); int* p = \u0026k; *p = 100; printf(\"k:%d\\n\", k); } //const 修饰指针 void test02(){ int a = 10; int b = 20; //const放在*号左侧 修饰p_a指针指向的内存空间不能修改,但可修改指针的指向 const int* p_a = \u0026a; //*p_a = 100; //不可修改指针指向的内存空间 p_a = \u0026b; //可修改指针的指向 //const放在*号的右侧， 修饰指针的指向不能修改，但是可修改指针指向的内存空间 int* const p_b = \u0026a; //p_b = \u0026b; //不可修改指针的指向 *p_b = 100; //可修改指针指向的内存空间 //指针的指向和指针指向的内存空间都不能修改 const int* const p_c = \u0026a; } //const指针用法 struct Person{ char name[64]; int id; int age; int score; }; //每次都对对象进行拷贝，效率低，应该用指针 void printPersonByValue(struct Person person){ printf(\"Name:%s\\n\", person.name); printf(\"Name:%d\\n\", person.id); printf(\"Name:%d\\n\", person.age); printf(\"Name:%d\\n\", person.score); } //但是用指针会有副作用，可能会不小心修改原数据 void printPersonByPointer(const struct Person *person){ printf(\"Name:%s\\n\", person-\u003ename); printf(\"Name:%d\\n\", person-\u003eid); printf(\"Name:%d\\n\", person-\u003eage); printf(\"Name:%d\\n\", person-\u003escore); } void test03(){ struct Person p = { \"Obama\", 1101, 23, 87 }; //printPersonByValue(p); printPersonByPointer(\u0026p); } ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:5","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#5const使用"},{"categories":["C"],"content":" 6、位运算​ 可以使用C对变量中的个别位进行操作。您可能对人们想这样做的原因感到奇怪。这种能力有时确实是必须的，或者至少是有用的。C提供位的逻辑运算符和移位运算符。在以下例子中，我们将使用二进制计数法写出值，以便您可以了解对位发生的操作。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。 6.1位逻辑运算符​ 4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(\u0026\u0026 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 6.1.1 按位取反 ~一元运算符~将每个1变为0，将每个0变为1，如下面的例子： ~(10011010) 01100101 假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。 unsigned char a = 2; //00000010 unsigned char b = ~a; //11111101 printf(\"ret = %d\\n\", a); //ret = 2 printf(\"ret = %d\\n\", b); //ret = 253 6.1.2 位与（AND）：\u0026二进制运算符\u0026通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 (10010011) \u0026 (00111101) = (00010001) C也有一个组合的位与-赋值运算符：\u0026=。下面两个将产生相同的结果： val \u0026= 0377 val = val \u0026 0377 6.1.3 位或（OR）：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. (10010011) | (00111101) = (10111111) C也有组合位或-赋值运算符： |= val |= 0377 val = val | 0377 6.1.4 位异或：二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. (10010011) ^ (00111101) = (10101110) C也有一个组合的位异或-赋值运算符： ^= val ^= 0377 val = val ^ 0377 6.2移位运算符 6.2.1左移\u003c\u003c左移运算符«将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 (10001010) \u003c\u003c 2 (00101000) 该操作将产生一个新位置，但是不改变其操作数。 1 \u003c\u003c 1 = 2; 2 \u003c\u003c 1 = 4; 4 \u003c\u003c 1 = 8; 8 \u003c\u003c 2 = 32 左移一位相当于原值*2。 6.2.2右移\u003e\u003e右移运算符»将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 //有符号值 (10001010) \u003e\u003e 2 (00100010) //在某些系统上的结果值 (10001010) \u003e\u003e 2 (11100010) //在另一些系统上的结果 //无符号值 (10001010) \u003e\u003e 2 (00100010) //所有系统上的结果值 右移一位相当于原值/2。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:6","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#6位运算"},{"categories":["C"],"content":" 6、位运算​ 可以使用C对变量中的个别位进行操作。您可能对人们想这样做的原因感到奇怪。这种能力有时确实是必须的，或者至少是有用的。C提供位的逻辑运算符和移位运算符。在以下例子中，我们将使用二进制计数法写出值，以便您可以了解对位发生的操作。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。 6.1位逻辑运算符​ 4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(\u0026\u0026 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 6.1.1 按位取反 ~一元运算符~将每个1变为0，将每个0变为1，如下面的例子： ~(10011010) 01100101 假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。 unsigned char a = 2; //00000010 unsigned char b = ~a; //11111101 printf(\"ret = %d\\n\", a); //ret = 2 printf(\"ret = %d\\n\", b); //ret = 253 6.1.2 位与（AND）：\u0026二进制运算符\u0026通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 (10010011) \u0026 (00111101) = (00010001) C也有一个组合的位与-赋值运算符：\u0026=。下面两个将产生相同的结果： val \u0026= 0377 val = val \u0026 0377 6.1.3 位或（OR）：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. (10010011) | (00111101) = (10111111) C也有组合位或-赋值运算符： |= val |= 0377 val = val | 0377 6.1.4 位异或：二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. (10010011) ^ (00111101) = (10101110) C也有一个组合的位异或-赋值运算符： ^= val ^= 0377 val = val ^ 0377 6.2移位运算符 6.2.1左移\u003c\u003c左移运算符«将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 (10001010) \u003c\u003c 2 (00101000) 该操作将产生一个新位置，但是不改变其操作数。 1 \u003c\u003c 1 = 2; 2 \u003c\u003c 1 = 4; 4 \u003c\u003c 1 = 8; 8 \u003c\u003c 2 = 32 左移一位相当于原值*2。 6.2.2右移\u003e\u003e右移运算符»将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 //有符号值 (10001010) \u003e\u003e 2 (00100010) //在某些系统上的结果值 (10001010) \u003e\u003e 2 (11100010) //在另一些系统上的结果 //无符号值 (10001010) \u003e\u003e 2 (00100010) //所有系统上的结果值 右移一位相当于原值/2。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:6","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#61位逻辑运算符"},{"categories":["C"],"content":" 6、位运算​ 可以使用C对变量中的个别位进行操作。您可能对人们想这样做的原因感到奇怪。这种能力有时确实是必须的，或者至少是有用的。C提供位的逻辑运算符和移位运算符。在以下例子中，我们将使用二进制计数法写出值，以便您可以了解对位发生的操作。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。 6.1位逻辑运算符​ 4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(\u0026\u0026 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 6.1.1 按位取反 ~一元运算符~将每个1变为0，将每个0变为1，如下面的例子： ~(10011010) 01100101 假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。 unsigned char a = 2; //00000010 unsigned char b = ~a; //11111101 printf(\"ret = %d\\n\", a); //ret = 2 printf(\"ret = %d\\n\", b); //ret = 253 6.1.2 位与（AND）：\u0026二进制运算符\u0026通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 (10010011) \u0026 (00111101) = (00010001) C也有一个组合的位与-赋值运算符：\u0026=。下面两个将产生相同的结果： val \u0026= 0377 val = val \u0026 0377 6.1.3 位或（OR）：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. (10010011) | (00111101) = (10111111) C也有组合位或-赋值运算符： |= val |= 0377 val = val | 0377 6.1.4 位异或：二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. (10010011) ^ (00111101) = (10101110) C也有一个组合的位异或-赋值运算符： ^= val ^= 0377 val = val ^ 0377 6.2移位运算符 6.2.1左移\u003c\u003c左移运算符«将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 (10001010) \u003c\u003c 2 (00101000) 该操作将产生一个新位置，但是不改变其操作数。 1 \u003c\u003c 1 = 2; 2 \u003c\u003c 1 = 4; 4 \u003c\u003c 1 = 8; 8 \u003c\u003c 2 = 32 左移一位相当于原值*2。 6.2.2右移\u003e\u003e右移运算符»将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 //有符号值 (10001010) \u003e\u003e 2 (00100010) //在某些系统上的结果值 (10001010) \u003e\u003e 2 (11100010) //在另一些系统上的结果 //无符号值 (10001010) \u003e\u003e 2 (00100010) //所有系统上的结果值 右移一位相当于原值/2。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:6","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#611-按位取反-"},{"categories":["C"],"content":" 6、位运算​ 可以使用C对变量中的个别位进行操作。您可能对人们想这样做的原因感到奇怪。这种能力有时确实是必须的，或者至少是有用的。C提供位的逻辑运算符和移位运算符。在以下例子中，我们将使用二进制计数法写出值，以便您可以了解对位发生的操作。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。 6.1位逻辑运算符​ 4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(\u0026\u0026 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 6.1.1 按位取反 ~一元运算符~将每个1变为0，将每个0变为1，如下面的例子： ~(10011010) 01100101 假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。 unsigned char a = 2; //00000010 unsigned char b = ~a; //11111101 printf(\"ret = %d\\n\", a); //ret = 2 printf(\"ret = %d\\n\", b); //ret = 253 6.1.2 位与（AND）：\u0026二进制运算符\u0026通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 (10010011) \u0026 (00111101) = (00010001) C也有一个组合的位与-赋值运算符：\u0026=。下面两个将产生相同的结果： val \u0026= 0377 val = val \u0026 0377 6.1.3 位或（OR）：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. (10010011) | (00111101) = (10111111) C也有组合位或-赋值运算符： |= val |= 0377 val = val | 0377 6.1.4 位异或：二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. (10010011) ^ (00111101) = (10101110) C也有一个组合的位异或-赋值运算符： ^= val ^= 0377 val = val ^ 0377 6.2移位运算符 6.2.1左移\u003c\u003c左移运算符«将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 (10001010) \u003c\u003c 2 (00101000) 该操作将产生一个新位置，但是不改变其操作数。 1 \u003c\u003c 1 = 2; 2 \u003c\u003c 1 = 4; 4 \u003c\u003c 1 = 8; 8 \u003c\u003c 2 = 32 左移一位相当于原值*2。 6.2.2右移\u003e\u003e右移运算符»将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 //有符号值 (10001010) \u003e\u003e 2 (00100010) //在某些系统上的结果值 (10001010) \u003e\u003e 2 (11100010) //在另一些系统上的结果 //无符号值 (10001010) \u003e\u003e 2 (00100010) //所有系统上的结果值 右移一位相当于原值/2。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:6","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#612-位与and"},{"categories":["C"],"content":" 6、位运算​ 可以使用C对变量中的个别位进行操作。您可能对人们想这样做的原因感到奇怪。这种能力有时确实是必须的，或者至少是有用的。C提供位的逻辑运算符和移位运算符。在以下例子中，我们将使用二进制计数法写出值，以便您可以了解对位发生的操作。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。 6.1位逻辑运算符​ 4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(\u0026\u0026 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 6.1.1 按位取反 ~一元运算符~将每个1变为0，将每个0变为1，如下面的例子： ~(10011010) 01100101 假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。 unsigned char a = 2; //00000010 unsigned char b = ~a; //11111101 printf(\"ret = %d\\n\", a); //ret = 2 printf(\"ret = %d\\n\", b); //ret = 253 6.1.2 位与（AND）：\u0026二进制运算符\u0026通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 (10010011) \u0026 (00111101) = (00010001) C也有一个组合的位与-赋值运算符：\u0026=。下面两个将产生相同的结果： val \u0026= 0377 val = val \u0026 0377 6.1.3 位或（OR）：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. (10010011) | (00111101) = (10111111) C也有组合位或-赋值运算符： |= val |= 0377 val = val | 0377 6.1.4 位异或：二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. (10010011) ^ (00111101) = (10101110) C也有一个组合的位异或-赋值运算符： ^= val ^= 0377 val = val ^ 0377 6.2移位运算符 6.2.1左移\u003c\u003c左移运算符«将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 (10001010) \u003c\u003c 2 (00101000) 该操作将产生一个新位置，但是不改变其操作数。 1 \u003c\u003c 1 = 2; 2 \u003c\u003c 1 = 4; 4 \u003c\u003c 1 = 8; 8 \u003c\u003c 2 = 32 左移一位相当于原值*2。 6.2.2右移\u003e\u003e右移运算符»将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 //有符号值 (10001010) \u003e\u003e 2 (00100010) //在某些系统上的结果值 (10001010) \u003e\u003e 2 (11100010) //在另一些系统上的结果 //无符号值 (10001010) \u003e\u003e 2 (00100010) //所有系统上的结果值 右移一位相当于原值/2。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:6","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#613-位或or"},{"categories":["C"],"content":" 6、位运算​ 可以使用C对变量中的个别位进行操作。您可能对人们想这样做的原因感到奇怪。这种能力有时确实是必须的，或者至少是有用的。C提供位的逻辑运算符和移位运算符。在以下例子中，我们将使用二进制计数法写出值，以便您可以了解对位发生的操作。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。 6.1位逻辑运算符​ 4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(\u0026\u0026 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 6.1.1 按位取反 ~一元运算符~将每个1变为0，将每个0变为1，如下面的例子： ~(10011010) 01100101 假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。 unsigned char a = 2; //00000010 unsigned char b = ~a; //11111101 printf(\"ret = %d\\n\", a); //ret = 2 printf(\"ret = %d\\n\", b); //ret = 253 6.1.2 位与（AND）：\u0026二进制运算符\u0026通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 (10010011) \u0026 (00111101) = (00010001) C也有一个组合的位与-赋值运算符：\u0026=。下面两个将产生相同的结果： val \u0026= 0377 val = val \u0026 0377 6.1.3 位或（OR）：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. (10010011) | (00111101) = (10111111) C也有组合位或-赋值运算符： |= val |= 0377 val = val | 0377 6.1.4 位异或：二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. (10010011) ^ (00111101) = (10101110) C也有一个组合的位异或-赋值运算符： ^= val ^= 0377 val = val ^ 0377 6.2移位运算符 6.2.1左移\u003c\u003c左移运算符«将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 (10001010) \u003c\u003c 2 (00101000) 该操作将产生一个新位置，但是不改变其操作数。 1 \u003c\u003c 1 = 2; 2 \u003c\u003c 1 = 4; 4 \u003c\u003c 1 = 8; 8 \u003c\u003c 2 = 32 左移一位相当于原值*2。 6.2.2右移\u003e\u003e右移运算符»将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 //有符号值 (10001010) \u003e\u003e 2 (00100010) //在某些系统上的结果值 (10001010) \u003e\u003e 2 (11100010) //在另一些系统上的结果 //无符号值 (10001010) \u003e\u003e 2 (00100010) //所有系统上的结果值 右移一位相当于原值/2。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:6","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#614-位异或"},{"categories":["C"],"content":" 6、位运算​ 可以使用C对变量中的个别位进行操作。您可能对人们想这样做的原因感到奇怪。这种能力有时确实是必须的，或者至少是有用的。C提供位的逻辑运算符和移位运算符。在以下例子中，我们将使用二进制计数法写出值，以便您可以了解对位发生的操作。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。 6.1位逻辑运算符​ 4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(\u0026\u0026 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 6.1.1 按位取反 ~一元运算符~将每个1变为0，将每个0变为1，如下面的例子： ~(10011010) 01100101 假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。 unsigned char a = 2; //00000010 unsigned char b = ~a; //11111101 printf(\"ret = %d\\n\", a); //ret = 2 printf(\"ret = %d\\n\", b); //ret = 253 6.1.2 位与（AND）：\u0026二进制运算符\u0026通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 (10010011) \u0026 (00111101) = (00010001) C也有一个组合的位与-赋值运算符：\u0026=。下面两个将产生相同的结果： val \u0026= 0377 val = val \u0026 0377 6.1.3 位或（OR）：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. (10010011) | (00111101) = (10111111) C也有组合位或-赋值运算符： |= val |= 0377 val = val | 0377 6.1.4 位异或：二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. (10010011) ^ (00111101) = (10101110) C也有一个组合的位异或-赋值运算符： ^= val ^= 0377 val = val ^ 0377 6.2移位运算符 6.2.1左移\u003c\u003c左移运算符«将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 (10001010) \u003c\u003c 2 (00101000) 该操作将产生一个新位置，但是不改变其操作数。 1 \u003c\u003c 1 = 2; 2 \u003c\u003c 1 = 4; 4 \u003c\u003c 1 = 8; 8 \u003c\u003c 2 = 32 左移一位相当于原值*2。 6.2.2右移\u003e\u003e右移运算符»将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 //有符号值 (10001010) \u003e\u003e 2 (00100010) //在某些系统上的结果值 (10001010) \u003e\u003e 2 (11100010) //在另一些系统上的结果 //无符号值 (10001010) \u003e\u003e 2 (00100010) //所有系统上的结果值 右移一位相当于原值/2。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:6","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#62移位运算符"},{"categories":["C"],"content":" 6、位运算​ 可以使用C对变量中的个别位进行操作。您可能对人们想这样做的原因感到奇怪。这种能力有时确实是必须的，或者至少是有用的。C提供位的逻辑运算符和移位运算符。在以下例子中，我们将使用二进制计数法写出值，以便您可以了解对位发生的操作。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。 6.1位逻辑运算符​ 4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(\u0026\u0026 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 6.1.1 按位取反 ~一元运算符~将每个1变为0，将每个0变为1，如下面的例子： ~(10011010) 01100101 假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。 unsigned char a = 2; //00000010 unsigned char b = ~a; //11111101 printf(\"ret = %d\\n\", a); //ret = 2 printf(\"ret = %d\\n\", b); //ret = 253 6.1.2 位与（AND）：\u0026二进制运算符\u0026通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 (10010011) \u0026 (00111101) = (00010001) C也有一个组合的位与-赋值运算符：\u0026=。下面两个将产生相同的结果： val \u0026= 0377 val = val \u0026 0377 6.1.3 位或（OR）：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. (10010011) | (00111101) = (10111111) C也有组合位或-赋值运算符： |= val |= 0377 val = val | 0377 6.1.4 位异或：二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. (10010011) ^ (00111101) = (10101110) C也有一个组合的位异或-赋值运算符： ^= val ^= 0377 val = val ^ 0377 6.2移位运算符 6.2.1左移\u003c\u003c左移运算符«将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 (10001010) \u003c\u003c 2 (00101000) 该操作将产生一个新位置，但是不改变其操作数。 1 \u003c\u003c 1 = 2; 2 \u003c\u003c 1 = 4; 4 \u003c\u003c 1 = 8; 8 \u003c\u003c 2 = 32 左移一位相当于原值*2。 6.2.2右移\u003e\u003e右移运算符»将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 //有符号值 (10001010) \u003e\u003e 2 (00100010) //在某些系统上的结果值 (10001010) \u003e\u003e 2 (11100010) //在另一些系统上的结果 //无符号值 (10001010) \u003e\u003e 2 (00100010) //所有系统上的结果值 右移一位相当于原值/2。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:6","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#621左移"},{"categories":["C"],"content":" 6、位运算​ 可以使用C对变量中的个别位进行操作。您可能对人们想这样做的原因感到奇怪。这种能力有时确实是必须的，或者至少是有用的。C提供位的逻辑运算符和移位运算符。在以下例子中，我们将使用二进制计数法写出值，以便您可以了解对位发生的操作。在一个实际程序中，您可以使用一般的形式的整数变量或常量。例如不适用00011001的形式，而写为25或者031或者0x19.在我们的例子中，我们将使用8位数字，从左到右，每位的编号是7到0。 6.1位逻辑运算符​ 4个位运算符用于整型数据，包括char.将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位。请不要将这些运算符与常规的逻辑运算符(\u0026\u0026 、||和!)相混淆，常规的位的逻辑运算符对整个值进行操作。 6.1.1 按位取反 ~一元运算符~将每个1变为0，将每个0变为1，如下面的例子： ~(10011010) 01100101 假设a是一个unsigned char，已赋值为2.在二进制中，2是00000010.于是-a的值为11111101或者253。请注意该运算符不会改变a的值，a仍为2。 unsigned char a = 2; //00000010 unsigned char b = ~a; //11111101 printf(\"ret = %d\\n\", a); //ret = 2 printf(\"ret = %d\\n\", b); //ret = 253 6.1.2 位与（AND）：\u0026二进制运算符\u0026通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是1时结果才为1。 (10010011) \u0026 (00111101) = (00010001) C也有一个组合的位与-赋值运算符：\u0026=。下面两个将产生相同的结果： val \u0026= 0377 val = val \u0026 0377 6.1.3 位或（OR）：|二进制运算符|通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为1，那么结果位就为1. (10010011) | (00111101) = (10111111) C也有组合位或-赋值运算符： |= val |= 0377 val = val | 0377 6.1.4 位异或：二进制运算符^对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是1(但不是都是1)，那么结果是1.如果都是0或者都是1，则结果位0. (10010011) ^ (00111101) = (10101110) C也有一个组合的位异或-赋值运算符： ^= val ^= 0377 val = val ^ 0377 6.2移位运算符 6.2.1左移\u003c\u003c左移运算符«将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用0填充，并且丢弃移出左侧操作数末端的位。在下面例子中，每位向左移动两个位置。 (10001010) \u003c\u003c 2 (00101000) 该操作将产生一个新位置，但是不改变其操作数。 1 \u003c\u003c 1 = 2; 2 \u003c\u003c 1 = 4; 4 \u003c\u003c 1 = 8; 8 \u003c\u003c 2 = 32 左移一位相当于原值*2。 6.2.2右移\u003e\u003e右移运算符»将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于unsigned类型，使用0填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。 //有符号值 (10001010) \u003e\u003e 2 (00100010) //在某些系统上的结果值 (10001010) \u003e\u003e 2 (11100010) //在另一些系统上的结果 //无符号值 (10001010) \u003e\u003e 2 (00100010) //所有系统上的结果值 右移一位相当于原值/2。 ","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/:0:6","series":null,"tags":["C"],"title":"指针强化","uri":"/%E6%8C%87%E9%92%88%E5%BC%BA%E5%8C%96/#622右移"},{"categories":["Linux"],"content":"Linux的Top命令解析 ","date":"2023-12-31","objectID":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/:0:0","series":null,"tags":["Linux"],"title":"Linux的top命令解析","uri":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/#"},{"categories":["Linux"],"content":" *Top命令是什么*TOP命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。 TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定. ","date":"2023-12-31","objectID":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/:0:0","series":null,"tags":["Linux"],"title":"Linux的top命令解析","uri":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/#top命令是什么"},{"categories":["Linux"],"content":" *一.* *统计信息区*统计信息区前五行是系统整体的统计信息。 ","date":"2023-12-31","objectID":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/:0:0","series":null,"tags":["Linux"],"title":"Linux的top命令解析","uri":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/#一-统计信息区"},{"categories":["Linux"],"content":" *1. 第一行是任务队列信息*同 uptime 命令的执行结果: [root@localhost ~]# uptime 13:22:30 up 8 min, 4 users, load average: 0.14, 0.38, 0.25 其内容如下： 12:38:33 当前时间 up 50days 系统运行时间，格式为时:分 1 user 当前登录用户数 load average: 0.06, 0.60, 0.48 系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 ","date":"2023-12-31","objectID":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/:1:0","series":null,"tags":["Linux"],"title":"Linux的top命令解析","uri":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/#1-第一行是任务队列信息"},{"categories":["Linux"],"content":" *2. 第二、三行为进程和CPU的信息*当有多个CPU时，这些内容可能会超过两行。内容如下： Tasks: 29 total 进程总数 1 running 正在运行的进程数 28 sleeping 睡眠的进程数 0 stopped 停止的进程数 0 zombie 僵尸进程数 Cpu(s): 0.3% us 用户空间占用CPU百分比 1.0% sy 内核空间占用CPU百分比 0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比 98.7% id 空闲CPU百分比 0.0% wa 等待输入输出的CPU时间百分比 0.0% hi 0.0% si ","date":"2023-12-31","objectID":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/:2:0","series":null,"tags":["Linux"],"title":"Linux的top命令解析","uri":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/#2-第二三行为进程和cpu的信息"},{"categories":["Linux"],"content":" *3. 第四五行为内存信息。*内容如下： Mem: 191272k total 物理内存总量 173656k used 使用的物理内存总量 17616k free 空闲内存总量 22052k buffers 用作内核缓存的内存量 Swap: 192772k total 交换区总量 0k used 使用的交换区总量 192772k free 空闲交换区总量 123988k cached 缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些****内容已存在于内存中****的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。 ","date":"2023-12-31","objectID":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/:3:0","series":null,"tags":["Linux"],"title":"Linux的top命令解析","uri":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/#3-第四五行为内存信息"},{"categories":["Linux"],"content":" *二. 进程信息区*统计信息区域的下方显示了各个进程的详细信息。我们来认识一下各列的含义： ","date":"2023-12-31","objectID":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/:0:0","series":null,"tags":["Linux"],"title":"Linux的top命令解析","uri":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/#二-进程信息区"},{"categories":["Linux"],"content":" *1.**列信息* 列名 含义 PID 进程id PPID 父进程id RUSER Real user name UID 进程所有者的用户id USER 进程所有者的用户名 GROUP 进程所有者的组名 TTY 启动进程的终端名。不是从终端启动的进程则显示为 ? PR 优先级 NI nice值。负值表示高优先级，正值表示低优先级 P 最后使用的CPU，仅在多CPU环境下有意义 %CPU 上次更新到现在的CPU时间占用百分比 TIME 进程使用的CPU时间总计，单位秒 TIME+ 进程使用的CPU时间总计，单位1/100秒 %MEM 进程使用的物理内存百分比 VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。 RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA CODE 可执行代码占用的物理内存大小，单位kb DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb SHR 共享内存大小，单位kb nFLT 页面错误次数 nDRT 最后一次写入到现在，被修改过的页面数。 S 进程状态。 D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 COMMAND 命令名/命令行 WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名 Flags 任务标志，参考 sched.h ","date":"2023-12-31","objectID":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/:1:0","series":null,"tags":["Linux"],"title":"Linux的top命令解析","uri":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/#1列信息"},{"categories":["Linux"],"content":" *2.用快捷键更改显示内容*h或者? : 显示帮助画面，给出一些简短的命令总结说明。 k ：终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。 i：忽略闲置和僵死进程。这是一个开关式命令。 q： 退出程序。 r： 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。 S：切换到累计模式。 s : 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。 f或者F :从当前显示中添加或者删除项目。 o或者O :改变显示项目的顺序。 l: 切换显示平均负载和启动时间信息。即显示影藏第一行 m： 切换显示内存信息。即显示影藏内存行 t ： 切换显示进程和CPU状态信息。即显示影藏CPU行 c： 切换显示命令名称和完整命令行。 显示完整的命令。 这个功能很有用。 M ： 根据驻留内存大小进行排序。 P：根据CPU使用百分比大小进行排序。 T： 根据时间/累计时间进行排序。 W： 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。 z：改变显示的颜色 ","date":"2023-12-31","objectID":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/:2:0","series":null,"tags":["Linux"],"title":"Linux的top命令解析","uri":"/linux%E7%9A%84top%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/#2用快捷键更改显示内容"},{"categories":["JVAV"],"content":" 1.网络编程入门","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#1网络编程入门"},{"categories":["JVAV"],"content":" 1.1 网络编程概述 计算机网络 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统 网络编程 在网络通信协议下，不同计算机上运行的程序，可以进行数据传输 ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:1","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#11-网络编程概述"},{"categories":["JVAV"],"content":" 1.2 网络编程三要素 IP地址 要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识 端口 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识 协议 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议 ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:2","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#12-网络编程三要素"},{"categories":["JVAV"],"content":" 1.3 IP地址IP地址：是网络中设备的唯一标识 IP地址分为两大类 IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题 DOS常用命令： ipconfig：查看本机IP地址 ping IP地址：检查网络是否连通 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用 ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:3","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#13-ip地址"},{"categories":["JVAV"],"content":" 1.4 InetAddress【应用】InetAddress：此类表示Internet协议（IP）地址 相关方法 方法名 说明 static InetAddress getByName(String host) 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 String getHostName() 获取此IP地址的主机名 String getHostAddress() 返回文本显示中的IP地址字符串 代码演示 public class InetAddressDemo { public static void main(String[] args) throws UnknownHostException { //InetAddress address = InetAddress.getByName(\"itheima\"); InetAddress address = InetAddress.getByName(\"192.168.1.66\"); //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.getHostAddress(); System.out.println(\"主机名：\" + name); System.out.println(\"IP地址：\" + ip); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:4","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#14-inetaddress应用"},{"categories":["JVAV"],"content":" 1.5 端口和协议 端口 设备上应用程序的唯一标识 端口号 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败 协议 计算机网络中，连接和通信的规则被称为网络通信协议 UDP协议 用户数据报协议(User Datagram Protocol) UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议 TCP协议 传输控制协议 (Transmission Control Protocol) TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手” 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端发送确认信息，确认连接 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等 ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:1:5","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#15-端口和协议"},{"categories":["JVAV"],"content":" 2.UDP通信程序","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:0","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#2udp通信程序"},{"categories":["JVAV"],"content":" 2.1 UDP发送数据【应用】 Java中的UDP通信 UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 Java提供了DatagramSocket类作为基于UDP协议的Socket 构造方法 方法名 说明 DatagramSocket() 创建数据报套接字并将其绑定到本机地址上的任何可用端口 DatagramPacket(byte[] buf,int len,InetAddress add,int port) 创建数据包,发送长度为len的数据包到指定主机的指定端口 相关方法 方法名 说明 void send(DatagramPacket p) 发送数据报包 void close() 关闭数据报套接字 void receive(DatagramPacket p) 从此套接字接受数据报包 发送数据的步骤 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包 调用DatagramSocket对象的方法发送数据 关闭发送端 代码演示 public class SendDemo { public static void main(String[] args) throws IOException { //创建发送端的Socket对象(DatagramSocket) // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口 DatagramSocket ds = new DatagramSocket(); //创建数据，并把数据打包 //DatagramPacket(byte[] buf, int length, InetAddress address, int port) //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。 byte[] bys = \"hello,udp,我来了\".getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName(\"127.0.0.1\"),10086); //调用DatagramSocket对象的方法发送数据 //void send(DatagramPacket p) 从此套接字发送数据报包 ds.send(dp); //关闭发送端 //void close() 关闭此数据报套接字 ds.close(); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:1","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#21-udp发送数据应用"},{"categories":["JVAV"],"content":" 2.2UDP接收数据【应用】 接收数据的步骤 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 构造方法 方法名 说明 DatagramPacket(byte[] buf, int len) 创建一个DatagramPacket用于接收长度为len的数据包 相关方法 方法名 说明 byte[] getData() 返回数据缓冲区 int getLength() 返回要发送的数据的长度或接收的数据的长度 示例代码 public class ReceiveDemo { public static void main(String[] args) throws IOException { //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(\"数据是：\" + new String(dp.getData(), 0, dp.getLength())); } } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:2","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#22udp接收数据应用"},{"categories":["JVAV"],"content":" 2.3UDP通信程序练习【应用】 案例需求 UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收 代码实现 /* UDP发送数据： 数据来自于键盘录入，直到输入的数据是886，发送数据结束 */ public class SendDemo { public static void main(String[] args) throws IOException { //创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); //键盘录入数据 Scanner sc = new Scanner(System.in); while (true) { String s = sc.nextLine(); //输入的数据是886，发送数据结束 if (\"886\".equals(s)) { break; } //创建数据，并把数据打包 byte[] bys = s.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName(\"192.168.1.66\"), 12345); //调用DatagramSocket对象的方法发送数据 ds.send(dp); } //关闭发送端 ds.close(); } } /* UDP接收数据： 因为接收端不知道发送端什么时候停止发送，故采用死循环接收 */ public class ReceiveDemo { public static void main(String[] args) throws IOException { //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) { //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(\"数据是：\" + new String(dp.getData(), 0, dp.getLength())); } //关闭接收端 // ds.close(); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:3","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#23udp通信程序练习应用"},{"categories":["JVAV"],"content":" 2.4UDP三种通讯方式 单播 单播用于两个主机之间的端对端通信 组播 组播用于对一组特定的主机进行通信 广播 广播用于一个主机对整个局域网上所有主机上的数据通信 ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:4","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#24udp三种通讯方式"},{"categories":["JVAV"],"content":" 2.5UDP组播实现 实现步骤 发送端 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包(DatagramPacket) 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) 释放资源 接收端 创建接收端Socket对象(MulticastSocket) 创建一个箱子,用于接收数据 把当前计算机绑定一个组播地址 将数据接收到箱子中 解析数据包,并打印数据 释放资源 代码实现 // 发送端 public class ClinetDemo { public static void main(String[] args) throws IOException { // 1. 创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); String s = \"hello 组播\"; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(\"224.0.1.0\"); int port = 10000; // 2. 创建数据，并把数据打包(DatagramPacket) DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) ds.send(dp); // 4. 释放资源 ds.close(); } } // 接收端 public class ServerDemo { public static void main(String[] args) throws IOException { // 1. 创建接收端Socket对象(MulticastSocket) MulticastSocket ms = new MulticastSocket(10000); // 2. 创建一个箱子,用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中. ms.joinGroup(InetAddress.getByName(\"224.0.1.0\")); // 4. 将数据接收到箱子中 ms.receive(dp); // 5. 解析数据包,并打印数据 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 6. 释放资源 ms.close(); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:5","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#25udp组播实现"},{"categories":["JVAV"],"content":" 2.6UDP广播实现 实现步骤 发送端 创建发送端Socket对象(DatagramSocket) 创建存储数据的箱子,将广播地址封装进去 发送数据 释放资源 接收端 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 代码实现 // 发送端 public class ClientDemo { public static void main(String[] args) throws IOException { // 1. 创建发送端Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); // 2. 创建存储数据的箱子,将广播地址封装进去 String s = \"广播 hello\"; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(\"255.255.255.255\"); int port = 10000; DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 发送数据 ds.send(dp); // 4. 释放资源 ds.close(); } } // 接收端 public class ServerDemo { public static void main(String[] args) throws IOException { // 1. 创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(10000); // 2. 创建一个数据包，用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 调用DatagramSocket对象的方法接收数据 ds.receive(dp); // 4. 解析数据包，并把数据在控制台显示 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 5. 关闭接收端 ds.close(); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:2:6","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#26udp广播实现"},{"categories":["JVAV"],"content":" 3.TCP通信程序","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:0","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#3tcp通信程序"},{"categories":["JVAV"],"content":" 3.1TCP发送数据【应用】 Java中的TCP通信 Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。 Java为客户端提供了Socket类，为服务器端提供了ServerSocket类 构造方法 方法名 说明 Socket(InetAddress address,int port) 创建流套接字并将其连接到指定IP指定端口号 Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 相关方法 方法名 说明 InputStream getInputStream() 返回此套接字的输入流 OutputStream getOutputStream() 返回此套接字的输出流 示例代码 public class ClientDemo { public static void main(String[] args) throws IOException { //创建客户端的Socket对象(Socket) //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 Socket s = new Socket(\"127.0.0.1\",10000); //获取输出流，写数据 //OutputStream getOutputStream() 返回此套接字的输出流 OutputStream os = s.getOutputStream(); os.write(\"hello,tcp,我来了\".getBytes()); //释放资源 s.close(); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:1","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#31tcp发送数据应用"},{"categories":["JVAV"],"content":" 3.2TCP接收数据【应用】 构造方法 方法名 说明 ServletSocket(int port) 创建绑定到指定端口的服务器套接字 相关方法 方法名 说明 Socket accept() 监听要连接到此的套接字并接受它 注意事项 accept方法是阻塞的,作用就是等待客户端连接 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接 针对客户端来讲,是往外写的,所以是输出流 针对服务器来讲,是往里读的,所以是输入流 read方法也是阻塞的 客户端在关流的时候,还多了一个往服务器写结束标记的动作 最后一步断开连接,通过四次挥手协议保证连接终止 三次握手和四次挥手 三次握手 四次挥手 示例代码 public class ServerDemo { public static void main(String[] args) throws IOException { //创建服务器端的Socket对象(ServerSocket) //ServerSocket(int port) 创建绑定到指定端口的服务器套接字 ServerSocket ss = new ServerSocket(10000); //Socket accept() 侦听要连接到此套接字并接受它 Socket s = ss.accept(); //获取输入流，读数据，并把数据显示在控制台 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); String data = new String(bys,0,len); System.out.println(\"数据是：\" + data); //释放资源 s.close(); ss.close(); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:2","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#32tcp接收数据应用"},{"categories":["JVAV"],"content":" 3.3TCP程序练习【应用】 案例需求 客户端：发送数据，接受服务器反馈 服务器：收到消息后给出反馈 案例分析 客户端创建对象，使用输出流输出数据 服务端创建对象，使用输入流接受数据 服务端使用输出流给出反馈数据 客户端使用输入流接受反馈数据 代码实现 // 客户端 public class ClientDemo { public static void main(String[] args) throws IOException { Socket socket = new Socket(\"127.0.0.1\",10000); OutputStream os = socket.getOutputStream(); os.write(\"hello\".getBytes()); // os.close();如果在这里关流,会导致整个socket都无法使用 socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; while((line = br.readLine())!=null){ System.out.println(line); } br.close(); os.close(); socket.close(); } } // 服务器 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); Socket accept = ss.accept(); InputStream is = accept.getInputStream(); int b; while((b = is.read())!=-1){ System.out.println((char) b); } System.out.println(\"看看我执行了吗?\"); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"你谁啊?\"); bw.newLine(); bw.flush(); bw.close(); is.close(); accept.close(); ss.close(); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:3","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#33tcp程序练习应用"},{"categories":["JVAV"],"content":" 3.4TCP程序文件上传练习【应用】 案例需求 客户端：数据来自于本地文件，接收服务器反馈 服务器：接收到的数据写入本地文件，给出反馈 案例分析 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息 客户端接受服务端的回馈信息 相关方法 方法名 说明 void shutdownInput() 将此套接字的输入流放置在“流的末尾” void shutdownOutput() 禁止用此套接字的输出流 代码实现 // 客户端 public class ClientDemo { public static void main(String[] args) throws IOException { Socket socket = new Socket(\"127.0.0.1\",10000); //是本地的流,用来读取本地文件的. BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"socketmodule\\\\ClientDir\\\\1.jpg\")); //写到服务器 --- 网络中的流 OutputStream os = socket.getOutputStream(); BufferedOutputStream bos = new BufferedOutputStream(os); int b; while((b = bis.read())!=-1){ bos.write(b);//通过网络写到服务器中 } bos.flush(); //给服务器一个结束标记,告诉服务器文件已经传输完毕 socket.shutdownOutput(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; while((line = br.readLine()) !=null){ System.out.println(line); } bis.close(); socket.close(); } } // 服务器 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"socketmodule\\\\ServerDir\\\\copy.jpg\")); int b; while((b = bis.read()) !=-1){ bos.write(b); } BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); bos.close(); accept.close(); ss.close(); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:4","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#34tcp程序文件上传练习应用"},{"categories":["JVAV"],"content":" 3.5TCP程序服务器优化【应用】 优化方案一 需求 服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。 解决方案 使用循环 代码实现 // 服务器代码如下,客户端代码同上个案例,此处不再给出 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); while (true) { Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"optimizeserver\\\\ServerDir\\\\copy.jpg\")); int b; while((b = bis.read()) !=-1){ bos.write(b); } BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); bos.close(); accept.close(); } //ss.close(); } } 优化方案二 需求 第二次上传文件的时候，会把第一次的文件给覆盖。 解决方案 UUID. randomUUID()方法生成随机的文件名 代码实现 // 服务器代码如下,客户端代码同上个案例,此处不再给出 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); while (true) { Socket accept = ss.accept(); //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"optimizeserver\\\\ServerDir\\\\\" + UUID.randomUUID().toString() + \".jpg\")); int b; while((b = bis.read()) !=-1){ bos.write(b); } BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); bos.close(); accept.close(); } //ss.close(); } } 优化方案三 需求 使用循环虽然可以让服务器处理多个客户端请求。但是还是无法同时跟多个客户端进行通信。 解决方案 开启多线程处理 代码实现 // 线程任务类 public class ThreadSocket implements Runnable { private Socket acceptSocket; public ThreadSocket(Socket accept) { this.acceptSocket = accept; } @Override public void run() { BufferedOutputStream bos = null; try { //网络中的流,从客户端读取数据的 BufferedInputStream bis = new BufferedInputStream(acceptSocket.getInputStream()); //本地的IO流,把数据写到本地中,实现永久化存储 bos = new BufferedOutputStream(new FileOutputStream(\"optimizeserver\\\\ServerDir\\\\\" + UUID.randomUUID().toString() + \".jpg\")); int b; while((b = bis.read()) !=-1){ bos.write(b); } BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(acceptSocket.getOutputStream())); bw.write(\"上传成功\"); bw.newLine(); bw.flush(); } catch (IOException e) { e.printStackTrace(); } finally { if(bos != null){ try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } if (acceptSocket != null){ try { acceptSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } // 服务器代码 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); while (true) { Socket accept = ss.accept(); ThreadSocket ts = new ThreadSocket(accept); new Thread(ts).start(); } //ss.close(); } } 优化方案四 需求 使用多线程虽然可以让服务器同时处理多个客户端请求。但是资源消耗太大。 解决方案 加入线程池 代码实现 // 服务器代码如下,线程任务类代码同上,此处不再给出 public class ServerDemo { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(10000); ThreadPoolExecutor pool = new ThreadPoolExecutor( 3,//核心线程数量 10, //线程池的总数量 60, //临时线程空闲时间 TimeUnit.SECONDS, //临时线程空闲时间的单位 new ArrayBlockingQueue\u003c\u003e(5),//阻塞队列 Executors.defaultThreadFactory(),//创建线程的方式 new ThreadPoolExecutor.AbortPolicy()//任务拒绝策略 ); while (true) { Socket accept = ss.accept(); ThreadSocket ts = new ThreadSocket(accept); //new Thread(ts).start(); pool.submit(ts); } //ss.close(); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:3:5","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#35tcp程序服务器优化应用"},{"categories":["JVAV"],"content":" 4.日志","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:0","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#4日志"},{"categories":["JVAV"],"content":" 4.1概述 概述 程序中的日志可以用来记录程序在运行的时候点点滴滴。并可以进行永久存储。 日志与输出语句的区别 输出语句 日志技术 取消日志 需要修改代码，灵活性比较差 不需要修改代码，灵活性比较好 输出位置 只能是控制台 可以将日志信息写入到文件或者数据库中 多线程 和业务代码处于一个线程中 多线程方式记录日志，不影响业务代码的性能 ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:1","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#41概述"},{"categories":["JVAV"],"content":" 4.2日志体系结构和logback 体系结构 logback 通过使用logback，我们可以控制日志信息输送的目的地是控制台、文件等位置。 我们也可以控制每一条日志的输出格式。 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:2","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#42日志体系结构和logback"},{"categories":["JVAV"],"content":" 4.3入门案例【应用】 使用步骤 导入logback的相关jar包 编写logback配置文件 在代码中获取日志的对象 按照级别设置记录日志信息 代码示例 // 测试类 public class Test01 { //获取日志的对象 private static final Logger LOGGER = LoggerFactory.getLogger(Test01.class); public static void main(String[] args) { //1.导入jar包 //2.编写配置文件 //3.在代码中获取日志的对象 //4.按照日志级别设置日志信息 LOGGER.debug(\"debug级别的日志\"); LOGGER.info(\"info级别的日志\"); LOGGER.warn(\"warn级别的日志\"); LOGGER.error(\"error级别的日志\"); } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:4:3","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#43入门案例应用"},{"categories":["JVAV"],"content":" 5.枚举","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:0","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#5枚举"},{"categories":["JVAV"],"content":" 5.1概述为了间接的表示一些固定的值，Java就给我们提供了枚举 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内 ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:1","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#51概述"},{"categories":["JVAV"],"content":" 5.2定义格式【应用】 格式 public enum s { 枚举项1,枚举项2,枚举项3; } 注意: 定义枚举类要用关键字enum 示例代码 // 定义一个枚举类，用来表示春，夏，秋，冬这四个固定值 public enum Season { SPRING,SUMMER,AUTUMN,WINTER; } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:2","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#52定义格式应用"},{"categories":["JVAV"],"content":" 5.3枚举的特点 特点 所有枚举类都是Enum的子类 我们可以通过\"枚举类名.枚举项名称\"去访问指定的枚举项 每一个枚举项其实就是该枚举的一个对象 枚举也是一个类，也可以去定义成员变量 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略 枚举类可以有构造器，但必须是private的，它默认的也是private的。 枚举项的用法比较特殊：枚举(\"\"); 枚举类也可以有抽象方法，但是枚举项必须重写该方法 示例代码 public enum Season { SPRING(\"春\"){ //如果枚举类中有抽象方法 //那么在枚举项中必须要全部重写 @Override public void show() { System.out.println(this.name); } }, SUMMER(\"夏\"){ @Override public void show() { System.out.println(this.name); } }, AUTUMN(\"秋\"){ @Override public void show() { System.out.println(this.name); } }, WINTER(\"冬\"){ @Override public void show() { System.out.println(this.name); } }; public String name; //空参构造 //private Season(){} //有参构造 private Season(String name){ this.name = name; } //抽象方法 public abstract void show(); } public class EnumDemo { public static void main(String[] args) { /* 1.所有枚举类都是Enum的子类 2.我们可以通过\"枚举类名.枚举项名称\"去访问指定的枚举项 3.每一个枚举项其实就是该枚举的一个对象 4.枚举也是一个类，也可以去定义成员变量 5.枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的， 但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略 6.枚举类可以有构造器，但必须是private的，它默认的也是private的。 枚举项的用法比较特殊：枚举(\"\"); 7.枚举类也可以有抽象方法，但是枚举项必须重写该方法 */ //第二个特点的演示 //我们可以通过\"枚举类名.枚举项名称\"去访问指定的枚举项 System.out.println(Season.SPRING); System.out.println(Season.SUMMER); System.out.println(Season.AUTUMN); System.out.println(Season.WINTER); //第三个特点的演示 //每一个枚举项其实就是该枚举的一个对象 Season spring = Season.SPRING; } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:3","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#53枚举的特点"},{"categories":["JVAV"],"content":" 5.4枚举的方法【应用】 方法介绍 方法名 说明 String name() 获取枚举项的名称 int ordinal() 返回枚举项在枚举类中的索引值 int compareTo(E o) 比较两个枚举项，返回的是索引值的差值 String toString() 返回枚举常量的名称 static T valueOf(Class type,String name) 获取指定枚举类中的指定名称的枚举值 values() 获得所有的枚举项 示例代码 public enum Season { SPRING,SUMMER,AUTUMN,WINTER; } public class EnumDemo { public static void main(String[] args) { // String name() 获取枚举项的名称 String name = Season.SPRING.name(); System.out.println(name); System.out.println(\"-----------------------------\"); // int ordinal() 返回枚举项在枚举类中的索引值 int index1 = Season.SPRING.ordinal(); int index2 = Season.SUMMER.ordinal(); int index3 = Season.AUTUMN.ordinal(); int index4 = Season.WINTER.ordinal(); System.out.println(index1); System.out.println(index2); System.out.println(index3); System.out.println(index4); System.out.println(\"-----------------------------\"); // int compareTo(E o) 比较两个枚举项，返回的是索引值的差值 int result = Season.SPRING.compareTo(Season.WINTER); System.out.println(result);//-3 System.out.println(\"-----------------------------\"); // String toString() 返回枚举常量的名称 String s = Season.SPRING.toString(); System.out.println(s); System.out.println(\"-----------------------------\"); // static \u003cT\u003e T valueOf(Class\u003cT\u003e type,String name) // 获取指定枚举类中的指定名称的枚举值 Season spring = Enum.valueOf(Season.class, \"SPRING\"); System.out.println(spring); System.out.println(Season.SPRING == spring); System.out.println(\"-----------------------------\"); // values() 获得所有的枚举项 Season[] values = Season.values(); for (Season value : values) { System.out.println(value); } } } ","date":"2023-12-31","objectID":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/:5:4","series":null,"tags":["JVAV"],"title":"网络编程","uri":"/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/#54枚举的方法应用"},{"categories":["JVAVA"],"content":" 类加载器类加载器（Class Loader）是 Java 虚拟机（JVM）的一个重要组成部分，它负责将类的字节码加载到 JVM 中，并将其转换为运行时的实例。类加载器实际上是一个 Java 类，它通过查找类的字节码文件并创建类的定义来完成加载过程。 Java 类加载器的主要功能包括以下几个方面： \\1. 加载（Loading）：类加载器负责在运行时查找并加载类的字节码文件。它根据类的名称或其他标识符，从文件系统、网络或其他来源获取类的字节码，并创建一个表示该类的 Class 对象。 \\2. 验证（Verification）：类加载器在加载类的过程中进行验证，确保类的字节码文件符合 Java 虚拟机规范，不会造成安全问题或导致系统崩溃。 \\3. 准备（Preparation）：准备阶段是类加载过程的一部分，其中类加载器为类的静态变量分配内存并设置默认初始值。 \\4. 解析（Resolution）：解析阶段是类加载过程的一部分，其中类加载器将符号引用解析为直接引用。符号引用是一种符号名称，它在编译时用于引用类、方法、字段等，而直接引用是对实际内存地址的引用。 \\5. 初始化（Initialization）：初始化阶段是类加载过程的最后一步，在该阶段，类的静态变量被分配所定义的初始值，并执行类的静态初始化块。 \\6. 使用（Usage）：类加载器加载的类可以被 JVM 使用，包括创建类的实例、调用类的方法等。 Java 类加载器采用了双亲委派模型（Parent Delegation Model）来组织类加载器之间的关系。根据这个模型，当一个类加载器收到类加载请求时，它首先将该请求委派给父加载器进行处理。只有当父加载器无法找到所请求的类时，子加载器才会尝试加载该类。这种层级关系保证了类的一致性和安全性。 常见的类加载器包括以下几种： \\1. 启动类加载器（Bootstrap Class Loader）：负责加载 Java 核心库（rt.jar）等核心类，是最顶层的类加载器，通常由 JVM 实现，并不是一个普通的 Java 类。 \\2. 扩展类加载器（Extension Class Loader）：负责加载 Java 扩展库（jre/lib/ext目录下的JAR文件）中的类。 \\3. 应用程序类加载器（Application Class Loader）：也称为系统类加载器，负责加载应用程序类路径（Classpath）下的类，开发者自定义的类通常由该类加载器加载。 此外，还可以自定义类加载器来加载非标准的类文件，实现特定的加载需求，如加载网络资源、动态生成类等。 类加载器在 Java 应用程序的运行过程中起着重要的作用，它通过动态加载类的方式提供了灵活性和扩展性，使得应用程序能够根据需要加载和使用不同的类和模块。了解类加载器的工作原理和机制有助于编写更高效、安全和可扩展的 Java 代码。 ","date":"2023-12-31","objectID":"/se%E5%A2%9E%E5%BC%BA%E7%89%88/:0:1","series":null,"tags":["JVAV"],"title":"SE增强版","uri":"/se%E5%A2%9E%E5%BC%BA%E7%89%88/#类加载器"},{"categories":["JVAVA"],"content":" 双亲委派模型双亲委派模型（Parent Delegation Model）是 Java 类加载器的一种工作机制，它是为了解决类加载的安全性和一致性问题而引入的。 在双亲委派模型中，类加载器之间形成了一个层级关系，每个类加载器都有一个父加载器（除了顶层的启动类加载器）。当一个类加载器需要加载某个类时，它首先将加载请求委派给其父加载器进行处理，只有当父加载器无法找到该类时，才由子加载器尝试加载。这个过程被称为委派（Delegation）。 具体的委派过程如下： \\1. 当一个类加载器收到加载请求时，它首先检查自己是否已经加载了该类。如果已经加载，则直接返回已加载的 Class 对象。 \\2. 如果该类尚未加载，则委派给父加载器进行加载。父加载器也按照相同的方式进行检查，首先检查自己是否已经加载了该类，如果已经加载，则直接返回 Class 对象。 \\3. 如果父加载器无法加载该类，则再次将加载请求委派给父加载器的父加载器，依次往上委派，直到达到顶层的启动类加载器。 \\4. 如果顶层的启动类加载器仍无法加载该类，则子加载器尝试自己加载该类。 通过这种委派机制，类加载器可以确保类的一致性和安全性。它可以防止不同的加载器重复加载同一个类，保证类的唯一性。同时，由于父加载器优先加载，可以确保核心类库由启动类加载器加载，从而保证了核心类库的安全性。 双亲委派模型的优势在于它能够有效地避免类的重复加载和冲突，提高了类加载的效率和安全性。它也为自定义类加载器提供了灵活的扩展机制，可以根据具体需求实现特定的类加载行为，例如加载非标准的类文件或动态生成类。 需要注意的是，虽然双亲委派模型是 Java 类加载器的默认行为，但在某些情况下可以通过自定义类加载器来打破这种机制，实现特定的加载需求。 ","date":"2023-12-31","objectID":"/se%E5%A2%9E%E5%BC%BA%E7%89%88/:0:2","series":null,"tags":["JVAV"],"title":"SE增强版","uri":"/se%E5%A2%9E%E5%BC%BA%E7%89%88/#双亲委派模型"},{"categories":["JVAVA"],"content":" 反射反射（Reflection）是一种在运行时检查和操作类、对象、方法和属性的能力。Java的反射机制提供了一组API，允许开发人员在运行时获取和使用类的信息，以及动态地调用类的方法、访问和修改对象的属性。 通过反射，可以在运行时获取类的各种信息，包括类的名称、修饰符、父类、实现的接口等。它使得程序可以在编译时不知道具体类的情况下操作类和对象。反射提供了以下常见的类和接口： \\1. Class类：java.lang.Class类是反射的核心类之一。每个类在内存中都有一个对应的Class对象，它提供了获取类的信息和执行反射操作的方法。通过Class类可以获取类的构造函数、字段、方法等信息，以及创建类的实例对象。 getName()：获取类的全限定名（包括包名和类名）。 示例： Class\u003c?\u003e clazz = MyClass.class; String className = clazz.getName(); // 获取类名 getSimpleName()：获取类的简单名称（只包括类名）。 示例： Class\u003c?\u003e clazz = MyClass.class; String simpleName = clazz.getSimpleName(); // 获取简单类名 getPackage()：获取类所在的包。 示例： Class\u003c?\u003e clazz = MyClass.class; Package pkg = clazz.getPackage(); // 获取包信息 getSuperclass()：获取类的父类。 示例： Class\u003c?\u003e clazz = MyClass.class; Class\u003c?\u003e superclass = clazz.getSuperclass(); // 获取父类信息 getInterfaces()：获取类实现的接口。 示例： Class\u003c?\u003e clazz = MyClass.class; Class\u003c?\u003e[] interfaces = clazz.getInterfaces(); // 获取实现的接口信息 getModifiers()：获取类的修饰符。 示例： Class\u003c?\u003e clazz = MyClass.class; int modifiers = clazz.getModifiers(); // 获取修饰符 getFields()：获取类的公共字段（包括父类的公共字段）。 示例： Class\u003c?\u003e clazz = MyClass.class; Field[] fields = clazz.getFields(); // 获取公共字段 getDeclaredFields()：获取类声明的所有字段（包括私有字段）。 示例： Class\u003c?\u003e clazz = MyClass.class; Field[] declaredFields = clazz.getDeclaredFields(); // 获取所有字段 getMethods()：获取类的公共方法（包括父类的公共方法）。 示例： Class\u003c?\u003e clazz = MyClass.class; Method[] methods = clazz.getMethods(); // 获取公共方法 getDeclaredMethods()：获取类声明的所有方法（包括私有方法）。 示例： Class\u003c?\u003e clazz = MyClass.class; Method[] declaredMethods = clazz.getDeclaredMethods(); // 获取所有方法 getConstructors()：获取类的公共构造函数。 示例： Class\u003c?\u003e clazz = MyClass.class; Constructor\u003c?\u003e[] constructors = clazz.getConstructors(); // 获取公共构造函数 getDeclaredConstructors()：获取类声明的所有构造函数。 示例： Class\u003c?\u003e clazz = MyClass.class; Constructor\u003c?\u003e[] declaredConstructors = clazz.getDeclaredConstructors(); // 获取所有构造函数 这些方法可以通过Class对象来获取类的相关信息，如类名、包名、父类、接口、字段、方法和构造函数等。通过这些信息，可以实现动态地操作类和对象，例如创建对象、调用方法和修改字段值等。需要根据具体需求选择合适的方法来获取所需的类信息。 2. Constructor类：java.lang.reflect.Constructor类代表类的构造函数。通过Constructor类可以获取构造函数的信息，包括名称、参数类型、修饰符等。可以使用Constructor类创建类的实例对象。 Constructor类提供了以下功能和方法： 获取构造方法信息：Constructor类可以提供关于构造方法的详细信息，例如构造方法的名称、参数列表、修饰符等。 - getName()：获取构造方法的名称。 - getParameterTypes()：获取构造方法的参数类型，返回一个Class数组。 - getModifiers()：获取构造方法的修饰符，返回一个代表修饰符的整数值。 - isVarArgs()：判断构造方法是否使用了可变参数。 - getExceptionTypes()：获取构造方法声明抛出的异常类型，返回一个Class数组。 创建实例：Constructor类可以用于创建类的实例。 - newInstance(Object... initargs)：通过构造方法创建类的实例，并传递初始化参数。 下面是一个示例，展示了如何使用Constructor类来获取和使用构造方法： import java.lang.reflect.Constructor; public class ReflectionExample { public static void main(String[] args) { try { // 获取类的构造方法 Class\u003c?\u003e clazz = MyClass.class; Constructor\u003c?\u003e constructor = clazz.getConstructor(String.class, int.class); ​ // 获取构造方法信息 ​ String constructorName = constructor.getName(); ​ Class\u003c?\u003e[] parameterTypes = constructor.getParameterTypes(); ​ int modifiers = constructor.getModifiers(); ​ // 输出构造方法信息 ​ System.out.println(\"Constructor Name: \" + constructorName); ​ System.out.println(\"Parameter Types: \"); ​ for (Class\u003c?\u003e parameterType : parameterTypes) { ​ System.out.println(parameterType.getName()); ​ } ​ System.out.println(\"Modifiers: \" + modifiers); ​ // 创建实例 ​ Object instance = constructor.newInstance(\"example\", 10); ​ System.out.println(\"Instance created: \" + instance); ​ } catch (Exception e) { ​ e.printStackTrace(); ​ } } } class MyClass { public MyClass(String name, int value) { // 构造方法的实现 } } 在上面的示例中，我们使用反射获取了MyClass类的构造方法，并输出了构造方法的名称、参数类型和修饰符信息。然后，通过构造方法创建了一个MyClass类的实例。 3. Field类：java.lang.reflect.Field类代表类的字段。通过Field类可以获取字段的信息，包括名称、类型、修饰符等。可以使用Field类访问和修改对象的字段值。 Field类提供了以下功能和方法： \\1. 获取字段信息：Field类可以提供关于字段的详细信息，例如字段的名称、类型、修饰符等。 - getName()：获取字段的名称。 - getType()：获取字段的类型，返回一个Class对象。 - getModifiers()：获取字段的修饰符，返回一个代表修饰符的整数值。 \\2. 访问和修改字段值：Field类提供了访问和修改字段值的方法。 - get(Object obj)：获取指定对象上该字段的值。 - set(Object obj, Object value)：将指定对象上该字段的值设置为给定的值。 下面是一个示例，展示了如何使用Field类来获取和修改字段值： import java.lang.reflect.Field; public class ReflectionExample { public static void main(String[] args) { try { // 获取字段信息 Class\u003c?\u003e clazz = MyC","date":"2023-12-31","objectID":"/se%E5%A2%9E%E5%BC%BA%E7%89%88/:0:3","series":null,"tags":["JVAV"],"title":"SE增强版","uri":"/se%E5%A2%9E%E5%BC%BA%E7%89%88/#反射"},{"categories":["tool"],"content":" Git 分布式版本控制工具","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:0:0","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#git-分布式版本控制工具"},{"categories":["tool"],"content":" 课程内容 Git概述 Git代码托管服务 Git常用命令 在IDEA中使用Git ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:1:0","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#课程内容"},{"categories":["tool"],"content":" 1. 前言","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:2:0","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#1-前言"},{"categories":["tool"],"content":" 1.1 什么是GitGit是一个分布式版本控制工具，主要用于管理开发过程中的源代码文件（Java类、xml文件、html页面等），在软件开发过程中被广泛使用。 在IDEA开发工具中可以集成Git（后面会讲解Git安装和集成过程）： 集成后在IDEA中可以看到Git相关图标： 可以通过启动两个IDEA窗口模拟两个开发人员来展示Git的使用： 其他的版本控制工具： SVN CVS VSS ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:2:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#11-什么是git"},{"categories":["tool"],"content":" 1.2 使用Git能做什么 代码回溯：Git在管理文件过程中会记录日志，方便回退到历史版本 版本切换：Git存在分支的概念，一个项目可以有多个分支（版本），可以任意切换 多人协作：Git支持多人协作，即一个团队共同开发一个项目，每个团队成员负责一部分代码，通过Git就可以管理和协调 远程备份：Git通过仓库管理文件，在Git中存在远程仓库，如果本地文件丢失还可以从远程仓库获取 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:2:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#12-使用git能做什么"},{"categories":["tool"],"content":" 2. Git概述","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:3:0","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#2-git概述"},{"categories":["tool"],"content":" 2.1 Git简介Git 是一个分布式版本控制工具，通常用来对软件开发过程中的源代码文件进行管理。通过Git 仓库来存储和管理这些文件，Git 仓库分为两种： 本地仓库：开发人员自己电脑上的 Git 仓库 远程仓库：远程服务器上的 Git 仓库 解释说明： commit：提交,将本地文件和版本信息保存到本地仓库 push：推送,将本地仓库文件和版本信息上传到远程仓库 pull：拉取,将远程仓库文件和版本信息下载到本地仓库 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:3:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#21-git简介"},{"categories":["tool"],"content":" 2.2 Git下载与安装下载地址： https://git-scm.com/download 下载完成后得到安装文件： 直接双击完成安装即可，安装完成后可以在任意目录下点击鼠标右键，如果能够看到如下菜单则说明安装成功： Git GUI Here：打开Git 图形界面 Git Bash Here：打开Git 命令行 Git安装目录结构如下： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:3:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#22-git下载与安装"},{"categories":["tool"],"content":" 3. Git代码托管服务","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:4:0","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#3-git代码托管服务"},{"categories":["tool"],"content":" 3.1 常用的Git代码托管服务Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？ 我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。 名称 网址 说明 gitHub https://github.com/ 一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub 码云 https://gitee.com/ 国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快 GitLab https://about.gitlab.com/ 一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务 BitBucket https://bitbucket.org/ 一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:4:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#31-常用的git代码托管服务"},{"categories":["tool"],"content":" 3.2 码云代码托管服务码云网址：https://gitee.com/ 使用码云的操作流程如下： 注册码云账号 登录码云 创建远程仓库 邀请其他用户成为仓库成员 3.2.1 注册码云账号注册网址： https://gitee.com/signup 3.2.2 登录码云注册完成后可以使用刚刚注册的邮箱进行登录（地址： https://gitee.com/login ） 3.2.3 创建远程仓库登录成功后可以创建远程仓库，操作方式如下： 页面跳转到新建仓库页面： 解释说明： 仓库名称：必填，每个仓库都需要有一个名称，同一个码云账号下的仓库名称不能重复 路径：访问远程仓库时会使用到，一般无需手动指定，和仓库名称自动保持一致 开源：所有人都可以查看此仓库 私有：只有此仓库的成员可见，其他人不可见 创建完成后可以查看仓库信息： 注意：每个Git远程仓库都会对应一个网络地址，点击【克隆/下载】按钮，在弹出窗口点击【复制】按钮即可复制网络地址，地址如下： https://gitee.com/ChuanZhiBoKe/myGitRepo.git 3.2.4 邀请其他用户成为仓库成员前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。 点击管理按钮进入仓库管理页面，左侧菜单中可以看到【仓库成员管理】： 点击【开发者】菜单，跳转到如下页面： 点击【添加仓库成员】菜单下的【邀请用户】菜单，跳转到如下页面： 可以看到邀请用户有多种方式：链接邀请、直接添加、通过仓库邀请成员 注意：被邀请用户必须为码云的注册用户，否则无法成为仓库成员 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:4:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#32-码云代码托管服务"},{"categories":["tool"],"content":" 3.2 码云代码托管服务码云网址：https://gitee.com/ 使用码云的操作流程如下： 注册码云账号 登录码云 创建远程仓库 邀请其他用户成为仓库成员 3.2.1 注册码云账号注册网址： https://gitee.com/signup 3.2.2 登录码云注册完成后可以使用刚刚注册的邮箱进行登录（地址： https://gitee.com/login ） 3.2.3 创建远程仓库登录成功后可以创建远程仓库，操作方式如下： 页面跳转到新建仓库页面： 解释说明： 仓库名称：必填，每个仓库都需要有一个名称，同一个码云账号下的仓库名称不能重复 路径：访问远程仓库时会使用到，一般无需手动指定，和仓库名称自动保持一致 开源：所有人都可以查看此仓库 私有：只有此仓库的成员可见，其他人不可见 创建完成后可以查看仓库信息： 注意：每个Git远程仓库都会对应一个网络地址，点击【克隆/下载】按钮，在弹出窗口点击【复制】按钮即可复制网络地址，地址如下： https://gitee.com/ChuanZhiBoKe/myGitRepo.git 3.2.4 邀请其他用户成为仓库成员前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。 点击管理按钮进入仓库管理页面，左侧菜单中可以看到【仓库成员管理】： 点击【开发者】菜单，跳转到如下页面： 点击【添加仓库成员】菜单下的【邀请用户】菜单，跳转到如下页面： 可以看到邀请用户有多种方式：链接邀请、直接添加、通过仓库邀请成员 注意：被邀请用户必须为码云的注册用户，否则无法成为仓库成员 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:4:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#321-注册码云账号"},{"categories":["tool"],"content":" 3.2 码云代码托管服务码云网址：https://gitee.com/ 使用码云的操作流程如下： 注册码云账号 登录码云 创建远程仓库 邀请其他用户成为仓库成员 3.2.1 注册码云账号注册网址： https://gitee.com/signup 3.2.2 登录码云注册完成后可以使用刚刚注册的邮箱进行登录（地址： https://gitee.com/login ） 3.2.3 创建远程仓库登录成功后可以创建远程仓库，操作方式如下： 页面跳转到新建仓库页面： 解释说明： 仓库名称：必填，每个仓库都需要有一个名称，同一个码云账号下的仓库名称不能重复 路径：访问远程仓库时会使用到，一般无需手动指定，和仓库名称自动保持一致 开源：所有人都可以查看此仓库 私有：只有此仓库的成员可见，其他人不可见 创建完成后可以查看仓库信息： 注意：每个Git远程仓库都会对应一个网络地址，点击【克隆/下载】按钮，在弹出窗口点击【复制】按钮即可复制网络地址，地址如下： https://gitee.com/ChuanZhiBoKe/myGitRepo.git 3.2.4 邀请其他用户成为仓库成员前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。 点击管理按钮进入仓库管理页面，左侧菜单中可以看到【仓库成员管理】： 点击【开发者】菜单，跳转到如下页面： 点击【添加仓库成员】菜单下的【邀请用户】菜单，跳转到如下页面： 可以看到邀请用户有多种方式：链接邀请、直接添加、通过仓库邀请成员 注意：被邀请用户必须为码云的注册用户，否则无法成为仓库成员 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:4:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#322-登录码云"},{"categories":["tool"],"content":" 3.2 码云代码托管服务码云网址：https://gitee.com/ 使用码云的操作流程如下： 注册码云账号 登录码云 创建远程仓库 邀请其他用户成为仓库成员 3.2.1 注册码云账号注册网址： https://gitee.com/signup 3.2.2 登录码云注册完成后可以使用刚刚注册的邮箱进行登录（地址： https://gitee.com/login ） 3.2.3 创建远程仓库登录成功后可以创建远程仓库，操作方式如下： 页面跳转到新建仓库页面： 解释说明： 仓库名称：必填，每个仓库都需要有一个名称，同一个码云账号下的仓库名称不能重复 路径：访问远程仓库时会使用到，一般无需手动指定，和仓库名称自动保持一致 开源：所有人都可以查看此仓库 私有：只有此仓库的成员可见，其他人不可见 创建完成后可以查看仓库信息： 注意：每个Git远程仓库都会对应一个网络地址，点击【克隆/下载】按钮，在弹出窗口点击【复制】按钮即可复制网络地址，地址如下： https://gitee.com/ChuanZhiBoKe/myGitRepo.git 3.2.4 邀请其他用户成为仓库成员前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。 点击管理按钮进入仓库管理页面，左侧菜单中可以看到【仓库成员管理】： 点击【开发者】菜单，跳转到如下页面： 点击【添加仓库成员】菜单下的【邀请用户】菜单，跳转到如下页面： 可以看到邀请用户有多种方式：链接邀请、直接添加、通过仓库邀请成员 注意：被邀请用户必须为码云的注册用户，否则无法成为仓库成员 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:4:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#323-创建远程仓库"},{"categories":["tool"],"content":" 3.2 码云代码托管服务码云网址：https://gitee.com/ 使用码云的操作流程如下： 注册码云账号 登录码云 创建远程仓库 邀请其他用户成为仓库成员 3.2.1 注册码云账号注册网址： https://gitee.com/signup 3.2.2 登录码云注册完成后可以使用刚刚注册的邮箱进行登录（地址： https://gitee.com/login ） 3.2.3 创建远程仓库登录成功后可以创建远程仓库，操作方式如下： 页面跳转到新建仓库页面： 解释说明： 仓库名称：必填，每个仓库都需要有一个名称，同一个码云账号下的仓库名称不能重复 路径：访问远程仓库时会使用到，一般无需手动指定，和仓库名称自动保持一致 开源：所有人都可以查看此仓库 私有：只有此仓库的成员可见，其他人不可见 创建完成后可以查看仓库信息： 注意：每个Git远程仓库都会对应一个网络地址，点击【克隆/下载】按钮，在弹出窗口点击【复制】按钮即可复制网络地址，地址如下： https://gitee.com/ChuanZhiBoKe/myGitRepo.git 3.2.4 邀请其他用户成为仓库成员前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。 点击管理按钮进入仓库管理页面，左侧菜单中可以看到【仓库成员管理】： 点击【开发者】菜单，跳转到如下页面： 点击【添加仓库成员】菜单下的【邀请用户】菜单，跳转到如下页面： 可以看到邀请用户有多种方式：链接邀请、直接添加、通过仓库邀请成员 注意：被邀请用户必须为码云的注册用户，否则无法成为仓库成员 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:4:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#324-邀请其他用户成为仓库成员"},{"categories":["tool"],"content":" 4. Git常用命令","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:0","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#4-git常用命令"},{"categories":["tool"],"content":" 4.1配置github和gitee背景：由于个人博客(www.alphaguo.vip)是存于github仓库托管，现在项目需要用到gitee，于是需要在一台电脑上同时配置两个用户，进行不同的仓库操作 4.1.1清除之前的配置在这里由于之前配置github用户时使用的是全局配置，所以需要先把用户信息清除，并分别为两个仓库配置local用户信息 # 列出全局用户名，邮箱配置 git config --**global** --**list # 重置用户名和邮箱 git config --**global** --**unset** user.name git config --**global** --**unset** user.email 4.1.2秘钥删除旧的秘钥： 旧的秘钥存放在用户目录的.ssh文件夹中，删除其中的 id_rsa、id_rsa.pub 之类的公钥和密钥文件。 生成新的秘钥： GitHub 的钥匙 ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C \"邮箱一\" 1 回车即可。 邮箱换一个。不要跟上面相同就行了。 ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C \"邮箱二\" 1 回车即可。 完成后会在~/.ssh / 目录下生成以下文件。 id_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pub 报错：Could not open a connection to your authentication agent.解决方法 ssh-agent bash 4.1.3 识别 SSH keys 新的私钥默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中。这一步也需要再探索一下，我没有设置也可以成功。 ssh-agent bash ssh-add ~/.ssh/id_rsa.github ssh-add ~/.ssh/id_rsa.gitee 123 4.1.4 多账号配置 config 文件创建config文件： touch ~/.ssh/config config 中填写的内容： #Default gitHub user Self Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github # gitee Host gitee.com Port 22 HostName gitee.com User git IdentityFile ~/.ssh/id_rsa.gitee 123456789101112 4.1.5 添加 ssh分别添加SSH到Gitee和Github： Github： https://github.com/settings/keys 将 id_rsa.github.pub 中的内容填进去，起名的话随意。 Gitee: https://gitee.com/profile/sshkeys 将 id_rsa.gitee.pub 中的内容填进去，起名的话随意。 4.1.6 测试成功 ssh -T git@gitee.com ssh -T git@github.com 如果提示没有设置用户信息，需要在各仓库里设置local用户信息 找到仓库目录（就是有.git子目录的目录） git config --local user.name \"username\" git config --local user.email \"username@qq.com\" ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#41配置github和gitee"},{"categories":["tool"],"content":" 4.1配置github和gitee背景：由于个人博客(www.alphaguo.vip)是存于github仓库托管，现在项目需要用到gitee，于是需要在一台电脑上同时配置两个用户，进行不同的仓库操作 4.1.1清除之前的配置在这里由于之前配置github用户时使用的是全局配置，所以需要先把用户信息清除，并分别为两个仓库配置local用户信息 # 列出全局用户名，邮箱配置 git config --**global** --**list # 重置用户名和邮箱 git config --**global** --**unset** user.name git config --**global** --**unset** user.email 4.1.2秘钥删除旧的秘钥： 旧的秘钥存放在用户目录的.ssh文件夹中，删除其中的 id_rsa、id_rsa.pub 之类的公钥和密钥文件。 生成新的秘钥： GitHub 的钥匙 ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C \"邮箱一\" 1 回车即可。 邮箱换一个。不要跟上面相同就行了。 ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C \"邮箱二\" 1 回车即可。 完成后会在~/.ssh / 目录下生成以下文件。 id_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pub 报错：Could not open a connection to your authentication agent.解决方法 ssh-agent bash 4.1.3 识别 SSH keys 新的私钥默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中。这一步也需要再探索一下，我没有设置也可以成功。 ssh-agent bash ssh-add ~/.ssh/id_rsa.github ssh-add ~/.ssh/id_rsa.gitee 123 4.1.4 多账号配置 config 文件创建config文件： touch ~/.ssh/config config 中填写的内容： #Default gitHub user Self Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github # gitee Host gitee.com Port 22 HostName gitee.com User git IdentityFile ~/.ssh/id_rsa.gitee 123456789101112 4.1.5 添加 ssh分别添加SSH到Gitee和Github： Github： https://github.com/settings/keys 将 id_rsa.github.pub 中的内容填进去，起名的话随意。 Gitee: https://gitee.com/profile/sshkeys 将 id_rsa.gitee.pub 中的内容填进去，起名的话随意。 4.1.6 测试成功 ssh -T git@gitee.com ssh -T git@github.com 如果提示没有设置用户信息，需要在各仓库里设置local用户信息 找到仓库目录（就是有.git子目录的目录） git config --local user.name \"username\" git config --local user.email \"username@qq.com\" ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#411清除之前的配置"},{"categories":["tool"],"content":" 4.1配置github和gitee背景：由于个人博客(www.alphaguo.vip)是存于github仓库托管，现在项目需要用到gitee，于是需要在一台电脑上同时配置两个用户，进行不同的仓库操作 4.1.1清除之前的配置在这里由于之前配置github用户时使用的是全局配置，所以需要先把用户信息清除，并分别为两个仓库配置local用户信息 # 列出全局用户名，邮箱配置 git config --**global** --**list # 重置用户名和邮箱 git config --**global** --**unset** user.name git config --**global** --**unset** user.email 4.1.2秘钥删除旧的秘钥： 旧的秘钥存放在用户目录的.ssh文件夹中，删除其中的 id_rsa、id_rsa.pub 之类的公钥和密钥文件。 生成新的秘钥： GitHub 的钥匙 ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C \"邮箱一\" 1 回车即可。 邮箱换一个。不要跟上面相同就行了。 ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C \"邮箱二\" 1 回车即可。 完成后会在~/.ssh / 目录下生成以下文件。 id_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pub 报错：Could not open a connection to your authentication agent.解决方法 ssh-agent bash 4.1.3 识别 SSH keys 新的私钥默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中。这一步也需要再探索一下，我没有设置也可以成功。 ssh-agent bash ssh-add ~/.ssh/id_rsa.github ssh-add ~/.ssh/id_rsa.gitee 123 4.1.4 多账号配置 config 文件创建config文件： touch ~/.ssh/config config 中填写的内容： #Default gitHub user Self Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github # gitee Host gitee.com Port 22 HostName gitee.com User git IdentityFile ~/.ssh/id_rsa.gitee 123456789101112 4.1.5 添加 ssh分别添加SSH到Gitee和Github： Github： https://github.com/settings/keys 将 id_rsa.github.pub 中的内容填进去，起名的话随意。 Gitee: https://gitee.com/profile/sshkeys 将 id_rsa.gitee.pub 中的内容填进去，起名的话随意。 4.1.6 测试成功 ssh -T git@gitee.com ssh -T git@github.com 如果提示没有设置用户信息，需要在各仓库里设置local用户信息 找到仓库目录（就是有.git子目录的目录） git config --local user.name \"username\" git config --local user.email \"username@qq.com\" ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#412秘钥"},{"categories":["tool"],"content":" 4.1配置github和gitee背景：由于个人博客(www.alphaguo.vip)是存于github仓库托管，现在项目需要用到gitee，于是需要在一台电脑上同时配置两个用户，进行不同的仓库操作 4.1.1清除之前的配置在这里由于之前配置github用户时使用的是全局配置，所以需要先把用户信息清除，并分别为两个仓库配置local用户信息 # 列出全局用户名，邮箱配置 git config --**global** --**list # 重置用户名和邮箱 git config --**global** --**unset** user.name git config --**global** --**unset** user.email 4.1.2秘钥删除旧的秘钥： 旧的秘钥存放在用户目录的.ssh文件夹中，删除其中的 id_rsa、id_rsa.pub 之类的公钥和密钥文件。 生成新的秘钥： GitHub 的钥匙 ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C \"邮箱一\" 1 回车即可。 邮箱换一个。不要跟上面相同就行了。 ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C \"邮箱二\" 1 回车即可。 完成后会在~/.ssh / 目录下生成以下文件。 id_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pub 报错：Could not open a connection to your authentication agent.解决方法 ssh-agent bash 4.1.3 识别 SSH keys 新的私钥默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中。这一步也需要再探索一下，我没有设置也可以成功。 ssh-agent bash ssh-add ~/.ssh/id_rsa.github ssh-add ~/.ssh/id_rsa.gitee 123 4.1.4 多账号配置 config 文件创建config文件： touch ~/.ssh/config config 中填写的内容： #Default gitHub user Self Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github # gitee Host gitee.com Port 22 HostName gitee.com User git IdentityFile ~/.ssh/id_rsa.gitee 123456789101112 4.1.5 添加 ssh分别添加SSH到Gitee和Github： Github： https://github.com/settings/keys 将 id_rsa.github.pub 中的内容填进去，起名的话随意。 Gitee: https://gitee.com/profile/sshkeys 将 id_rsa.gitee.pub 中的内容填进去，起名的话随意。 4.1.6 测试成功 ssh -T git@gitee.com ssh -T git@github.com 如果提示没有设置用户信息，需要在各仓库里设置local用户信息 找到仓库目录（就是有.git子目录的目录） git config --local user.name \"username\" git config --local user.email \"username@qq.com\" ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#413-识别-ssh-keys-新的私钥"},{"categories":["tool"],"content":" 4.1配置github和gitee背景：由于个人博客(www.alphaguo.vip)是存于github仓库托管，现在项目需要用到gitee，于是需要在一台电脑上同时配置两个用户，进行不同的仓库操作 4.1.1清除之前的配置在这里由于之前配置github用户时使用的是全局配置，所以需要先把用户信息清除，并分别为两个仓库配置local用户信息 # 列出全局用户名，邮箱配置 git config --**global** --**list # 重置用户名和邮箱 git config --**global** --**unset** user.name git config --**global** --**unset** user.email 4.1.2秘钥删除旧的秘钥： 旧的秘钥存放在用户目录的.ssh文件夹中，删除其中的 id_rsa、id_rsa.pub 之类的公钥和密钥文件。 生成新的秘钥： GitHub 的钥匙 ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C \"邮箱一\" 1 回车即可。 邮箱换一个。不要跟上面相同就行了。 ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C \"邮箱二\" 1 回车即可。 完成后会在~/.ssh / 目录下生成以下文件。 id_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pub 报错：Could not open a connection to your authentication agent.解决方法 ssh-agent bash 4.1.3 识别 SSH keys 新的私钥默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中。这一步也需要再探索一下，我没有设置也可以成功。 ssh-agent bash ssh-add ~/.ssh/id_rsa.github ssh-add ~/.ssh/id_rsa.gitee 123 4.1.4 多账号配置 config 文件创建config文件： touch ~/.ssh/config config 中填写的内容： #Default gitHub user Self Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github # gitee Host gitee.com Port 22 HostName gitee.com User git IdentityFile ~/.ssh/id_rsa.gitee 123456789101112 4.1.5 添加 ssh分别添加SSH到Gitee和Github： Github： https://github.com/settings/keys 将 id_rsa.github.pub 中的内容填进去，起名的话随意。 Gitee: https://gitee.com/profile/sshkeys 将 id_rsa.gitee.pub 中的内容填进去，起名的话随意。 4.1.6 测试成功 ssh -T git@gitee.com ssh -T git@github.com 如果提示没有设置用户信息，需要在各仓库里设置local用户信息 找到仓库目录（就是有.git子目录的目录） git config --local user.name \"username\" git config --local user.email \"username@qq.com\" ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#414-多账号配置-config-文件"},{"categories":["tool"],"content":" 4.1配置github和gitee背景：由于个人博客(www.alphaguo.vip)是存于github仓库托管，现在项目需要用到gitee，于是需要在一台电脑上同时配置两个用户，进行不同的仓库操作 4.1.1清除之前的配置在这里由于之前配置github用户时使用的是全局配置，所以需要先把用户信息清除，并分别为两个仓库配置local用户信息 # 列出全局用户名，邮箱配置 git config --**global** --**list # 重置用户名和邮箱 git config --**global** --**unset** user.name git config --**global** --**unset** user.email 4.1.2秘钥删除旧的秘钥： 旧的秘钥存放在用户目录的.ssh文件夹中，删除其中的 id_rsa、id_rsa.pub 之类的公钥和密钥文件。 生成新的秘钥： GitHub 的钥匙 ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C \"邮箱一\" 1 回车即可。 邮箱换一个。不要跟上面相同就行了。 ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C \"邮箱二\" 1 回车即可。 完成后会在~/.ssh / 目录下生成以下文件。 id_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pub 报错：Could not open a connection to your authentication agent.解决方法 ssh-agent bash 4.1.3 识别 SSH keys 新的私钥默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中。这一步也需要再探索一下，我没有设置也可以成功。 ssh-agent bash ssh-add ~/.ssh/id_rsa.github ssh-add ~/.ssh/id_rsa.gitee 123 4.1.4 多账号配置 config 文件创建config文件： touch ~/.ssh/config config 中填写的内容： #Default gitHub user Self Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github # gitee Host gitee.com Port 22 HostName gitee.com User git IdentityFile ~/.ssh/id_rsa.gitee 123456789101112 4.1.5 添加 ssh分别添加SSH到Gitee和Github： Github： https://github.com/settings/keys 将 id_rsa.github.pub 中的内容填进去，起名的话随意。 Gitee: https://gitee.com/profile/sshkeys 将 id_rsa.gitee.pub 中的内容填进去，起名的话随意。 4.1.6 测试成功 ssh -T git@gitee.com ssh -T git@github.com 如果提示没有设置用户信息，需要在各仓库里设置local用户信息 找到仓库目录（就是有.git子目录的目录） git config --local user.name \"username\" git config --local user.email \"username@qq.com\" ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#415-添加-ssh"},{"categories":["tool"],"content":" 4.1配置github和gitee背景：由于个人博客(www.alphaguo.vip)是存于github仓库托管，现在项目需要用到gitee，于是需要在一台电脑上同时配置两个用户，进行不同的仓库操作 4.1.1清除之前的配置在这里由于之前配置github用户时使用的是全局配置，所以需要先把用户信息清除，并分别为两个仓库配置local用户信息 # 列出全局用户名，邮箱配置 git config --**global** --**list # 重置用户名和邮箱 git config --**global** --**unset** user.name git config --**global** --**unset** user.email 4.1.2秘钥删除旧的秘钥： 旧的秘钥存放在用户目录的.ssh文件夹中，删除其中的 id_rsa、id_rsa.pub 之类的公钥和密钥文件。 生成新的秘钥： GitHub 的钥匙 ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C \"邮箱一\" 1 回车即可。 邮箱换一个。不要跟上面相同就行了。 ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C \"邮箱二\" 1 回车即可。 完成后会在~/.ssh / 目录下生成以下文件。 id_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pub 报错：Could not open a connection to your authentication agent.解决方法 ssh-agent bash 4.1.3 识别 SSH keys 新的私钥默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中。这一步也需要再探索一下，我没有设置也可以成功。 ssh-agent bash ssh-add ~/.ssh/id_rsa.github ssh-add ~/.ssh/id_rsa.gitee 123 4.1.4 多账号配置 config 文件创建config文件： touch ~/.ssh/config config 中填写的内容： #Default gitHub user Self Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github # gitee Host gitee.com Port 22 HostName gitee.com User git IdentityFile ~/.ssh/id_rsa.gitee 123456789101112 4.1.5 添加 ssh分别添加SSH到Gitee和Github： Github： https://github.com/settings/keys 将 id_rsa.github.pub 中的内容填进去，起名的话随意。 Gitee: https://gitee.com/profile/sshkeys 将 id_rsa.gitee.pub 中的内容填进去，起名的话随意。 4.1.6 测试成功 ssh -T git@gitee.com ssh -T git@github.com 如果提示没有设置用户信息，需要在各仓库里设置local用户信息 找到仓库目录（就是有.git子目录的目录） git config --local user.name \"username\" git config --local user.email \"username@qq.com\" ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#416-测试成功"},{"categories":["tool"],"content":" 4.2 获取Git仓库要使用Git对我们的代码进行管理，首先需要获得Git仓库。 获取Git仓库通常有两种方式： 在本地初始化Git仓库（不常用） 从远程仓库克隆（常用） 4.2.1 在本地初始化Git仓库操作步骤如下： 在任意目录下创建一个空目录（例如repo1）作为我们的本地Git仓库 进入这个目录中，点击右键打开Git bash窗口 执行命令git init 如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功 4.2.2 从远程仓库克隆可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地 命令格式：git clone 远程仓库地址 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#42-获取git仓库"},{"categories":["tool"],"content":" 4.2 获取Git仓库要使用Git对我们的代码进行管理，首先需要获得Git仓库。 获取Git仓库通常有两种方式： 在本地初始化Git仓库（不常用） 从远程仓库克隆（常用） 4.2.1 在本地初始化Git仓库操作步骤如下： 在任意目录下创建一个空目录（例如repo1）作为我们的本地Git仓库 进入这个目录中，点击右键打开Git bash窗口 执行命令git init 如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功 4.2.2 从远程仓库克隆可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地 命令格式：git clone 远程仓库地址 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#421-在本地初始化git仓库"},{"categories":["tool"],"content":" 4.2 获取Git仓库要使用Git对我们的代码进行管理，首先需要获得Git仓库。 获取Git仓库通常有两种方式： 在本地初始化Git仓库（不常用） 从远程仓库克隆（常用） 4.2.1 在本地初始化Git仓库操作步骤如下： 在任意目录下创建一个空目录（例如repo1）作为我们的本地Git仓库 进入这个目录中，点击右键打开Git bash窗口 执行命令git init 如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功 4.2.2 从远程仓库克隆可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地 命令格式：git clone 远程仓库地址 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#422-从远程仓库克隆"},{"categories":["tool"],"content":" 4.3 工作区、暂存区、版本库为了更好的学习Git，我们需要了解Git相关的一些概念，这些概念在后面的学习中会经常提到。 版本库：前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等 工作区：包含.git文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码 暂存区：.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:3","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#43-工作区暂存区版本库"},{"categories":["tool"],"content":" 4.4 Git工作区中文件的状态Git工作区中的文件存在两种状态： untracked 未跟踪（未被纳入版本控制） tracked 已跟踪（被纳入版本控制） ​ 1）Unmodified 未修改状态 ​ 2）Modified 已修改状态 ​ 3）Staged 已暂存状态 注意：文件的状态会随着我们执行Git的命令发生变化 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:4","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#44-git工作区中文件的状态"},{"categories":["tool"],"content":" 4.5 本地仓库操作本地仓库常用命令如下： git status 查看文件状态 git add 将文件的修改加入暂存区 git reset 将暂存区的文件取消暂存或者是切换到指定版本 git commit 将暂存区的文件修改提交到版本库 git log 查看日志 4.5.1 git statusgit status 命令用于查看文件状态 注意：由于工作区中文件状态的不同，执行 git status 命令后的输出也会不同 4.5.2 git addgit add 命令的作用是将文件的修改加入暂存区，命令格式：git add fileName 加入暂存区后再执行 git status 命令，可以发现文件的状态已经发生变化。 4.5.3 git resetgit reset 命令的作用是将暂存区的文件取消暂存或者是切换到指定版本 取消暂存命令格式：git reset 文件名 切换到指定版本命令格式：git reset –hard 版本号 注意：每次Git提交都会产生新的版本号，通过版本号就可以回到历史版本 4.5.4 git commitgit commit 命令的作用是将暂存区的文件修改提交到版本库，命令格式：git commit -m msg 文件名 解释说明： -m：代表message，每次提交时需要设置，会记录到日志中 可以使用通配符*一次提交多个文件 4.5.5 git loggit log 命令的作用是查看提交日志 通过git log命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的message、提交人、邮箱、提交时间等信息都会记录到日志中 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#45-本地仓库操作"},{"categories":["tool"],"content":" 4.5 本地仓库操作本地仓库常用命令如下： git status 查看文件状态 git add 将文件的修改加入暂存区 git reset 将暂存区的文件取消暂存或者是切换到指定版本 git commit 将暂存区的文件修改提交到版本库 git log 查看日志 4.5.1 git statusgit status 命令用于查看文件状态 注意：由于工作区中文件状态的不同，执行 git status 命令后的输出也会不同 4.5.2 git addgit add 命令的作用是将文件的修改加入暂存区，命令格式：git add fileName 加入暂存区后再执行 git status 命令，可以发现文件的状态已经发生变化。 4.5.3 git resetgit reset 命令的作用是将暂存区的文件取消暂存或者是切换到指定版本 取消暂存命令格式：git reset 文件名 切换到指定版本命令格式：git reset –hard 版本号 注意：每次Git提交都会产生新的版本号，通过版本号就可以回到历史版本 4.5.4 git commitgit commit 命令的作用是将暂存区的文件修改提交到版本库，命令格式：git commit -m msg 文件名 解释说明： -m：代表message，每次提交时需要设置，会记录到日志中 可以使用通配符*一次提交多个文件 4.5.5 git loggit log 命令的作用是查看提交日志 通过git log命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的message、提交人、邮箱、提交时间等信息都会记录到日志中 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#451-git-status"},{"categories":["tool"],"content":" 4.5 本地仓库操作本地仓库常用命令如下： git status 查看文件状态 git add 将文件的修改加入暂存区 git reset 将暂存区的文件取消暂存或者是切换到指定版本 git commit 将暂存区的文件修改提交到版本库 git log 查看日志 4.5.1 git statusgit status 命令用于查看文件状态 注意：由于工作区中文件状态的不同，执行 git status 命令后的输出也会不同 4.5.2 git addgit add 命令的作用是将文件的修改加入暂存区，命令格式：git add fileName 加入暂存区后再执行 git status 命令，可以发现文件的状态已经发生变化。 4.5.3 git resetgit reset 命令的作用是将暂存区的文件取消暂存或者是切换到指定版本 取消暂存命令格式：git reset 文件名 切换到指定版本命令格式：git reset –hard 版本号 注意：每次Git提交都会产生新的版本号，通过版本号就可以回到历史版本 4.5.4 git commitgit commit 命令的作用是将暂存区的文件修改提交到版本库，命令格式：git commit -m msg 文件名 解释说明： -m：代表message，每次提交时需要设置，会记录到日志中 可以使用通配符*一次提交多个文件 4.5.5 git loggit log 命令的作用是查看提交日志 通过git log命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的message、提交人、邮箱、提交时间等信息都会记录到日志中 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#452-git-add"},{"categories":["tool"],"content":" 4.5 本地仓库操作本地仓库常用命令如下： git status 查看文件状态 git add 将文件的修改加入暂存区 git reset 将暂存区的文件取消暂存或者是切换到指定版本 git commit 将暂存区的文件修改提交到版本库 git log 查看日志 4.5.1 git statusgit status 命令用于查看文件状态 注意：由于工作区中文件状态的不同，执行 git status 命令后的输出也会不同 4.5.2 git addgit add 命令的作用是将文件的修改加入暂存区，命令格式：git add fileName 加入暂存区后再执行 git status 命令，可以发现文件的状态已经发生变化。 4.5.3 git resetgit reset 命令的作用是将暂存区的文件取消暂存或者是切换到指定版本 取消暂存命令格式：git reset 文件名 切换到指定版本命令格式：git reset –hard 版本号 注意：每次Git提交都会产生新的版本号，通过版本号就可以回到历史版本 4.5.4 git commitgit commit 命令的作用是将暂存区的文件修改提交到版本库，命令格式：git commit -m msg 文件名 解释说明： -m：代表message，每次提交时需要设置，会记录到日志中 可以使用通配符*一次提交多个文件 4.5.5 git loggit log 命令的作用是查看提交日志 通过git log命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的message、提交人、邮箱、提交时间等信息都会记录到日志中 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#453-git-reset"},{"categories":["tool"],"content":" 4.5 本地仓库操作本地仓库常用命令如下： git status 查看文件状态 git add 将文件的修改加入暂存区 git reset 将暂存区的文件取消暂存或者是切换到指定版本 git commit 将暂存区的文件修改提交到版本库 git log 查看日志 4.5.1 git statusgit status 命令用于查看文件状态 注意：由于工作区中文件状态的不同，执行 git status 命令后的输出也会不同 4.5.2 git addgit add 命令的作用是将文件的修改加入暂存区，命令格式：git add fileName 加入暂存区后再执行 git status 命令，可以发现文件的状态已经发生变化。 4.5.3 git resetgit reset 命令的作用是将暂存区的文件取消暂存或者是切换到指定版本 取消暂存命令格式：git reset 文件名 切换到指定版本命令格式：git reset –hard 版本号 注意：每次Git提交都会产生新的版本号，通过版本号就可以回到历史版本 4.5.4 git commitgit commit 命令的作用是将暂存区的文件修改提交到版本库，命令格式：git commit -m msg 文件名 解释说明： -m：代表message，每次提交时需要设置，会记录到日志中 可以使用通配符*一次提交多个文件 4.5.5 git loggit log 命令的作用是查看提交日志 通过git log命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的message、提交人、邮箱、提交时间等信息都会记录到日志中 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#454-git-commit"},{"categories":["tool"],"content":" 4.5 本地仓库操作本地仓库常用命令如下： git status 查看文件状态 git add 将文件的修改加入暂存区 git reset 将暂存区的文件取消暂存或者是切换到指定版本 git commit 将暂存区的文件修改提交到版本库 git log 查看日志 4.5.1 git statusgit status 命令用于查看文件状态 注意：由于工作区中文件状态的不同，执行 git status 命令后的输出也会不同 4.5.2 git addgit add 命令的作用是将文件的修改加入暂存区，命令格式：git add fileName 加入暂存区后再执行 git status 命令，可以发现文件的状态已经发生变化。 4.5.3 git resetgit reset 命令的作用是将暂存区的文件取消暂存或者是切换到指定版本 取消暂存命令格式：git reset 文件名 切换到指定版本命令格式：git reset –hard 版本号 注意：每次Git提交都会产生新的版本号，通过版本号就可以回到历史版本 4.5.4 git commitgit commit 命令的作用是将暂存区的文件修改提交到版本库，命令格式：git commit -m msg 文件名 解释说明： -m：代表message，每次提交时需要设置，会记录到日志中 可以使用通配符*一次提交多个文件 4.5.5 git loggit log 命令的作用是查看提交日志 通过git log命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的message、提交人、邮箱、提交时间等信息都会记录到日志中 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#455-git-log"},{"categories":["tool"],"content":" 4.6 远程仓库操作前面执行的命令操作都是针对的本地仓库，本节我们会学习关于远程仓库的一些操作，具体包括： git remote 查看远程仓库 git remote add 添加远程仓库 git clone 从远程仓库克隆 git pull 从远程仓库拉取 git push 推送到远程仓库 4.6.1 git remote如果要查看已经配置的远程仓库服务器，可以执行 git remote 命令，它会列出每一个远程服务器的简称。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字。 解释说明： 可以通过-v参数查看远程仓库更加详细的信息 本地仓库配置的远程仓库都需要一个简称，后续在和远程仓库交互时会使用到这个简称 4.6.2 git remote add添加远程仓库命令格式：git remote add 简称 远程仓库地址 注意：一个本地仓库可以关联多个远程仓库 4.6.3 git clone如果你想获得一份已经存在了的 Git 远程仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等）。 克隆仓库的命令格式： git clone 远程仓库地址 4.6.4 git push将本地仓库内容推送到远程仓库，命令格式：git push 远程仓库简称 分支名称 在使用git push命令将本地文件推送至码云远程仓库时，如果是第一次操作，需要进行身份认证，认证通过才可以推送，如下： 注意：上面的用户名和密码对应的就是我们在码云上注册的用户名和密码，认证通过后会将用户名和密码保存到windows系统中（如下图），后续再推送则无需重复输入用户名和密码。 推送完成后可以到远程仓库中查看文件的变化。 解释说明： 一个仓库可以有多个分支，默认情况下在创建仓库后会自动创建一个master分支 后面会讲解分支相关的操作 4.6.5 git pullgit pull 命令的作用是从远程仓库获取最新版本并合并到本地仓库 命令格式：git pull 远程仓库简称 分支名称 注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ） 解决此问题可以在git pull命令后加入参数–allow-unrelated-histories ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#46-远程仓库操作"},{"categories":["tool"],"content":" 4.6 远程仓库操作前面执行的命令操作都是针对的本地仓库，本节我们会学习关于远程仓库的一些操作，具体包括： git remote 查看远程仓库 git remote add 添加远程仓库 git clone 从远程仓库克隆 git pull 从远程仓库拉取 git push 推送到远程仓库 4.6.1 git remote如果要查看已经配置的远程仓库服务器，可以执行 git remote 命令，它会列出每一个远程服务器的简称。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字。 解释说明： 可以通过-v参数查看远程仓库更加详细的信息 本地仓库配置的远程仓库都需要一个简称，后续在和远程仓库交互时会使用到这个简称 4.6.2 git remote add添加远程仓库命令格式：git remote add 简称 远程仓库地址 注意：一个本地仓库可以关联多个远程仓库 4.6.3 git clone如果你想获得一份已经存在了的 Git 远程仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等）。 克隆仓库的命令格式： git clone 远程仓库地址 4.6.4 git push将本地仓库内容推送到远程仓库，命令格式：git push 远程仓库简称 分支名称 在使用git push命令将本地文件推送至码云远程仓库时，如果是第一次操作，需要进行身份认证，认证通过才可以推送，如下： 注意：上面的用户名和密码对应的就是我们在码云上注册的用户名和密码，认证通过后会将用户名和密码保存到windows系统中（如下图），后续再推送则无需重复输入用户名和密码。 推送完成后可以到远程仓库中查看文件的变化。 解释说明： 一个仓库可以有多个分支，默认情况下在创建仓库后会自动创建一个master分支 后面会讲解分支相关的操作 4.6.5 git pullgit pull 命令的作用是从远程仓库获取最新版本并合并到本地仓库 命令格式：git pull 远程仓库简称 分支名称 注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ） 解决此问题可以在git pull命令后加入参数–allow-unrelated-histories ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#461-git-remote"},{"categories":["tool"],"content":" 4.6 远程仓库操作前面执行的命令操作都是针对的本地仓库，本节我们会学习关于远程仓库的一些操作，具体包括： git remote 查看远程仓库 git remote add 添加远程仓库 git clone 从远程仓库克隆 git pull 从远程仓库拉取 git push 推送到远程仓库 4.6.1 git remote如果要查看已经配置的远程仓库服务器，可以执行 git remote 命令，它会列出每一个远程服务器的简称。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字。 解释说明： 可以通过-v参数查看远程仓库更加详细的信息 本地仓库配置的远程仓库都需要一个简称，后续在和远程仓库交互时会使用到这个简称 4.6.2 git remote add添加远程仓库命令格式：git remote add 简称 远程仓库地址 注意：一个本地仓库可以关联多个远程仓库 4.6.3 git clone如果你想获得一份已经存在了的 Git 远程仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等）。 克隆仓库的命令格式： git clone 远程仓库地址 4.6.4 git push将本地仓库内容推送到远程仓库，命令格式：git push 远程仓库简称 分支名称 在使用git push命令将本地文件推送至码云远程仓库时，如果是第一次操作，需要进行身份认证，认证通过才可以推送，如下： 注意：上面的用户名和密码对应的就是我们在码云上注册的用户名和密码，认证通过后会将用户名和密码保存到windows系统中（如下图），后续再推送则无需重复输入用户名和密码。 推送完成后可以到远程仓库中查看文件的变化。 解释说明： 一个仓库可以有多个分支，默认情况下在创建仓库后会自动创建一个master分支 后面会讲解分支相关的操作 4.6.5 git pullgit pull 命令的作用是从远程仓库获取最新版本并合并到本地仓库 命令格式：git pull 远程仓库简称 分支名称 注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ） 解决此问题可以在git pull命令后加入参数–allow-unrelated-histories ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#462-git-remote-add"},{"categories":["tool"],"content":" 4.6 远程仓库操作前面执行的命令操作都是针对的本地仓库，本节我们会学习关于远程仓库的一些操作，具体包括： git remote 查看远程仓库 git remote add 添加远程仓库 git clone 从远程仓库克隆 git pull 从远程仓库拉取 git push 推送到远程仓库 4.6.1 git remote如果要查看已经配置的远程仓库服务器，可以执行 git remote 命令，它会列出每一个远程服务器的简称。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字。 解释说明： 可以通过-v参数查看远程仓库更加详细的信息 本地仓库配置的远程仓库都需要一个简称，后续在和远程仓库交互时会使用到这个简称 4.6.2 git remote add添加远程仓库命令格式：git remote add 简称 远程仓库地址 注意：一个本地仓库可以关联多个远程仓库 4.6.3 git clone如果你想获得一份已经存在了的 Git 远程仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等）。 克隆仓库的命令格式： git clone 远程仓库地址 4.6.4 git push将本地仓库内容推送到远程仓库，命令格式：git push 远程仓库简称 分支名称 在使用git push命令将本地文件推送至码云远程仓库时，如果是第一次操作，需要进行身份认证，认证通过才可以推送，如下： 注意：上面的用户名和密码对应的就是我们在码云上注册的用户名和密码，认证通过后会将用户名和密码保存到windows系统中（如下图），后续再推送则无需重复输入用户名和密码。 推送完成后可以到远程仓库中查看文件的变化。 解释说明： 一个仓库可以有多个分支，默认情况下在创建仓库后会自动创建一个master分支 后面会讲解分支相关的操作 4.6.5 git pullgit pull 命令的作用是从远程仓库获取最新版本并合并到本地仓库 命令格式：git pull 远程仓库简称 分支名称 注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ） 解决此问题可以在git pull命令后加入参数–allow-unrelated-histories ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#463-git-clone"},{"categories":["tool"],"content":" 4.6 远程仓库操作前面执行的命令操作都是针对的本地仓库，本节我们会学习关于远程仓库的一些操作，具体包括： git remote 查看远程仓库 git remote add 添加远程仓库 git clone 从远程仓库克隆 git pull 从远程仓库拉取 git push 推送到远程仓库 4.6.1 git remote如果要查看已经配置的远程仓库服务器，可以执行 git remote 命令，它会列出每一个远程服务器的简称。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字。 解释说明： 可以通过-v参数查看远程仓库更加详细的信息 本地仓库配置的远程仓库都需要一个简称，后续在和远程仓库交互时会使用到这个简称 4.6.2 git remote add添加远程仓库命令格式：git remote add 简称 远程仓库地址 注意：一个本地仓库可以关联多个远程仓库 4.6.3 git clone如果你想获得一份已经存在了的 Git 远程仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等）。 克隆仓库的命令格式： git clone 远程仓库地址 4.6.4 git push将本地仓库内容推送到远程仓库，命令格式：git push 远程仓库简称 分支名称 在使用git push命令将本地文件推送至码云远程仓库时，如果是第一次操作，需要进行身份认证，认证通过才可以推送，如下： 注意：上面的用户名和密码对应的就是我们在码云上注册的用户名和密码，认证通过后会将用户名和密码保存到windows系统中（如下图），后续再推送则无需重复输入用户名和密码。 推送完成后可以到远程仓库中查看文件的变化。 解释说明： 一个仓库可以有多个分支，默认情况下在创建仓库后会自动创建一个master分支 后面会讲解分支相关的操作 4.6.5 git pullgit pull 命令的作用是从远程仓库获取最新版本并合并到本地仓库 命令格式：git pull 远程仓库简称 分支名称 注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ） 解决此问题可以在git pull命令后加入参数–allow-unrelated-histories ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#464-git-push"},{"categories":["tool"],"content":" 4.6 远程仓库操作前面执行的命令操作都是针对的本地仓库，本节我们会学习关于远程仓库的一些操作，具体包括： git remote 查看远程仓库 git remote add 添加远程仓库 git clone 从远程仓库克隆 git pull 从远程仓库拉取 git push 推送到远程仓库 4.6.1 git remote如果要查看已经配置的远程仓库服务器，可以执行 git remote 命令，它会列出每一个远程服务器的简称。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字。 解释说明： 可以通过-v参数查看远程仓库更加详细的信息 本地仓库配置的远程仓库都需要一个简称，后续在和远程仓库交互时会使用到这个简称 4.6.2 git remote add添加远程仓库命令格式：git remote add 简称 远程仓库地址 注意：一个本地仓库可以关联多个远程仓库 4.6.3 git clone如果你想获得一份已经存在了的 Git 远程仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等）。 克隆仓库的命令格式： git clone 远程仓库地址 4.6.4 git push将本地仓库内容推送到远程仓库，命令格式：git push 远程仓库简称 分支名称 在使用git push命令将本地文件推送至码云远程仓库时，如果是第一次操作，需要进行身份认证，认证通过才可以推送，如下： 注意：上面的用户名和密码对应的就是我们在码云上注册的用户名和密码，认证通过后会将用户名和密码保存到windows系统中（如下图），后续再推送则无需重复输入用户名和密码。 推送完成后可以到远程仓库中查看文件的变化。 解释说明： 一个仓库可以有多个分支，默认情况下在创建仓库后会自动创建一个master分支 后面会讲解分支相关的操作 4.6.5 git pullgit pull 命令的作用是从远程仓库获取最新版本并合并到本地仓库 命令格式：git pull 远程仓库简称 分支名称 注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ） 解决此问题可以在git pull命令后加入参数–allow-unrelated-histories ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#465-git-pull"},{"categories":["tool"],"content":" 4.7 分支操作分支是Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。 通过git init 命令创建本地仓库时默认会创建一个master分支。 本节我们会学习关于分支的相关命令，具体命令如下： git branch 查看分支 git branch [name] 创建分支 git checkout [name] 切换分支 git push [shortName] [name] 推送至远程仓库分支 git merge [name] 合并分支 4.7.1 查看分支查看分支命令：git branch git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 4.7.2 创建分支创建分支命令格式：git branch 分支名称 4.7.3 切换分支一个仓库中可以有多个分支，切换分支命令格式：git checkout 分支名称 注意：在命令行中会显示出当前所在分支，如上图所示。 4.7.4 推送至远程仓库分支推送至远程仓库分支命令格式：git push 远程仓库简称 分支命令 推送完成后可以查看远程仓库： 4.7.5 合并分支合并分支就是将两个分支的文件进行合并处理，命令格式：git merge 分支命令 注意：分支合并时需注意合并的方向，如上图所示，在Master分支执行操作，结果就是将b3分支合并到Master分支。 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:7","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#47-分支操作"},{"categories":["tool"],"content":" 4.7 分支操作分支是Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。 通过git init 命令创建本地仓库时默认会创建一个master分支。 本节我们会学习关于分支的相关命令，具体命令如下： git branch 查看分支 git branch [name] 创建分支 git checkout [name] 切换分支 git push [shortName] [name] 推送至远程仓库分支 git merge [name] 合并分支 4.7.1 查看分支查看分支命令：git branch git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 4.7.2 创建分支创建分支命令格式：git branch 分支名称 4.7.3 切换分支一个仓库中可以有多个分支，切换分支命令格式：git checkout 分支名称 注意：在命令行中会显示出当前所在分支，如上图所示。 4.7.4 推送至远程仓库分支推送至远程仓库分支命令格式：git push 远程仓库简称 分支命令 推送完成后可以查看远程仓库： 4.7.5 合并分支合并分支就是将两个分支的文件进行合并处理，命令格式：git merge 分支命令 注意：分支合并时需注意合并的方向，如上图所示，在Master分支执行操作，结果就是将b3分支合并到Master分支。 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:7","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#471-查看分支"},{"categories":["tool"],"content":" 4.7 分支操作分支是Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。 通过git init 命令创建本地仓库时默认会创建一个master分支。 本节我们会学习关于分支的相关命令，具体命令如下： git branch 查看分支 git branch [name] 创建分支 git checkout [name] 切换分支 git push [shortName] [name] 推送至远程仓库分支 git merge [name] 合并分支 4.7.1 查看分支查看分支命令：git branch git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 4.7.2 创建分支创建分支命令格式：git branch 分支名称 4.7.3 切换分支一个仓库中可以有多个分支，切换分支命令格式：git checkout 分支名称 注意：在命令行中会显示出当前所在分支，如上图所示。 4.7.4 推送至远程仓库分支推送至远程仓库分支命令格式：git push 远程仓库简称 分支命令 推送完成后可以查看远程仓库： 4.7.5 合并分支合并分支就是将两个分支的文件进行合并处理，命令格式：git merge 分支命令 注意：分支合并时需注意合并的方向，如上图所示，在Master分支执行操作，结果就是将b3分支合并到Master分支。 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:7","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#472-创建分支"},{"categories":["tool"],"content":" 4.7 分支操作分支是Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。 通过git init 命令创建本地仓库时默认会创建一个master分支。 本节我们会学习关于分支的相关命令，具体命令如下： git branch 查看分支 git branch [name] 创建分支 git checkout [name] 切换分支 git push [shortName] [name] 推送至远程仓库分支 git merge [name] 合并分支 4.7.1 查看分支查看分支命令：git branch git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 4.7.2 创建分支创建分支命令格式：git branch 分支名称 4.7.3 切换分支一个仓库中可以有多个分支，切换分支命令格式：git checkout 分支名称 注意：在命令行中会显示出当前所在分支，如上图所示。 4.7.4 推送至远程仓库分支推送至远程仓库分支命令格式：git push 远程仓库简称 分支命令 推送完成后可以查看远程仓库： 4.7.5 合并分支合并分支就是将两个分支的文件进行合并处理，命令格式：git merge 分支命令 注意：分支合并时需注意合并的方向，如上图所示，在Master分支执行操作，结果就是将b3分支合并到Master分支。 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:7","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#473-切换分支"},{"categories":["tool"],"content":" 4.7 分支操作分支是Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。 通过git init 命令创建本地仓库时默认会创建一个master分支。 本节我们会学习关于分支的相关命令，具体命令如下： git branch 查看分支 git branch [name] 创建分支 git checkout [name] 切换分支 git push [shortName] [name] 推送至远程仓库分支 git merge [name] 合并分支 4.7.1 查看分支查看分支命令：git branch git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 4.7.2 创建分支创建分支命令格式：git branch 分支名称 4.7.3 切换分支一个仓库中可以有多个分支，切换分支命令格式：git checkout 分支名称 注意：在命令行中会显示出当前所在分支，如上图所示。 4.7.4 推送至远程仓库分支推送至远程仓库分支命令格式：git push 远程仓库简称 分支命令 推送完成后可以查看远程仓库： 4.7.5 合并分支合并分支就是将两个分支的文件进行合并处理，命令格式：git merge 分支命令 注意：分支合并时需注意合并的方向，如上图所示，在Master分支执行操作，结果就是将b3分支合并到Master分支。 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:7","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#474-推送至远程仓库分支"},{"categories":["tool"],"content":" 4.7 分支操作分支是Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。 通过git init 命令创建本地仓库时默认会创建一个master分支。 本节我们会学习关于分支的相关命令，具体命令如下： git branch 查看分支 git branch [name] 创建分支 git checkout [name] 切换分支 git push [shortName] [name] 推送至远程仓库分支 git merge [name] 合并分支 4.7.1 查看分支查看分支命令：git branch git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 4.7.2 创建分支创建分支命令格式：git branch 分支名称 4.7.3 切换分支一个仓库中可以有多个分支，切换分支命令格式：git checkout 分支名称 注意：在命令行中会显示出当前所在分支，如上图所示。 4.7.4 推送至远程仓库分支推送至远程仓库分支命令格式：git push 远程仓库简称 分支命令 推送完成后可以查看远程仓库： 4.7.5 合并分支合并分支就是将两个分支的文件进行合并处理，命令格式：git merge 分支命令 注意：分支合并时需注意合并的方向，如上图所示，在Master分支执行操作，结果就是将b3分支合并到Master分支。 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:7","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#475-合并分支"},{"categories":["tool"],"content":" 4.8 标签操作Git 中的标签，指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2等）。下面是mybatis-plus的标签： 在本节中，我们将学习如下和标签相关的命令： git tag 查看标签 git tag [name] 创建标签 git push [shortName] [name] 将标签推送至远程仓库 git checkout -b [branch] [name] 检出标签 4.8.1 查看标签查看标签命令：git tag 4.8.2 创建标签创建标签命令：git tag 标签名 4.8.3 将标签推送至远程仓库将标签推送至远程仓库命令：git push 远程仓库简称 标签名 推送完成后可以在远程仓库中查看标签。 4.8.4 检出标签检出标签时需要新建一个分支来指向某个标签，检出标签的命令格式：git checkout -b 分支名 标签名 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:8","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#48-标签操作"},{"categories":["tool"],"content":" 4.8 标签操作Git 中的标签，指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2等）。下面是mybatis-plus的标签： 在本节中，我们将学习如下和标签相关的命令： git tag 查看标签 git tag [name] 创建标签 git push [shortName] [name] 将标签推送至远程仓库 git checkout -b [branch] [name] 检出标签 4.8.1 查看标签查看标签命令：git tag 4.8.2 创建标签创建标签命令：git tag 标签名 4.8.3 将标签推送至远程仓库将标签推送至远程仓库命令：git push 远程仓库简称 标签名 推送完成后可以在远程仓库中查看标签。 4.8.4 检出标签检出标签时需要新建一个分支来指向某个标签，检出标签的命令格式：git checkout -b 分支名 标签名 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:8","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#481-查看标签"},{"categories":["tool"],"content":" 4.8 标签操作Git 中的标签，指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2等）。下面是mybatis-plus的标签： 在本节中，我们将学习如下和标签相关的命令： git tag 查看标签 git tag [name] 创建标签 git push [shortName] [name] 将标签推送至远程仓库 git checkout -b [branch] [name] 检出标签 4.8.1 查看标签查看标签命令：git tag 4.8.2 创建标签创建标签命令：git tag 标签名 4.8.3 将标签推送至远程仓库将标签推送至远程仓库命令：git push 远程仓库简称 标签名 推送完成后可以在远程仓库中查看标签。 4.8.4 检出标签检出标签时需要新建一个分支来指向某个标签，检出标签的命令格式：git checkout -b 分支名 标签名 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:8","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#482-创建标签"},{"categories":["tool"],"content":" 4.8 标签操作Git 中的标签，指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2等）。下面是mybatis-plus的标签： 在本节中，我们将学习如下和标签相关的命令： git tag 查看标签 git tag [name] 创建标签 git push [shortName] [name] 将标签推送至远程仓库 git checkout -b [branch] [name] 检出标签 4.8.1 查看标签查看标签命令：git tag 4.8.2 创建标签创建标签命令：git tag 标签名 4.8.3 将标签推送至远程仓库将标签推送至远程仓库命令：git push 远程仓库简称 标签名 推送完成后可以在远程仓库中查看标签。 4.8.4 检出标签检出标签时需要新建一个分支来指向某个标签，检出标签的命令格式：git checkout -b 分支名 标签名 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:8","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#483-将标签推送至远程仓库"},{"categories":["tool"],"content":" 4.8 标签操作Git 中的标签，指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2等）。下面是mybatis-plus的标签： 在本节中，我们将学习如下和标签相关的命令： git tag 查看标签 git tag [name] 创建标签 git push [shortName] [name] 将标签推送至远程仓库 git checkout -b [branch] [name] 检出标签 4.8.1 查看标签查看标签命令：git tag 4.8.2 创建标签创建标签命令：git tag 标签名 4.8.3 将标签推送至远程仓库将标签推送至远程仓库命令：git push 远程仓库简称 标签名 推送完成后可以在远程仓库中查看标签。 4.8.4 检出标签检出标签时需要新建一个分支来指向某个标签，检出标签的命令格式：git checkout -b 分支名 标签名 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:5:8","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#484-检出标签"},{"categories":["tool"],"content":" 5. 在IDEA中使用Git通过Git命令可以完成Git相关操作，为了简化操作过程，我们可以在IEDA中配置Git，配置好后就可以在IDEA中通过图形化的方式来操作Git。 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:0","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#5-在idea中使用git"},{"categories":["tool"],"content":" 5.1 在IDEA中配置Git在IDEA中使用Git，本质上还是使用的本地安装的Git软件，所以需要提前安装好Git并在IDEA中配置Git。 Git安装目录： 解释说明： git.exe：Git安装目录下的可执行文件，前面执行的git命令，其实就是执行的这个文件 IDEA中的配置： 说明：如果Git安装在默认目录中（C:\\Program Files\\Git），则IDEA中无需再手动配置，直接就可以使用。 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:1","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#51-在idea中配置git"},{"categories":["tool"],"content":" 5.2 获取Git仓库在IDEA中获取Git仓库有两种方式： 本地初始化仓库，本质就是执行 git init 命令 从远程仓库克隆，本质就是执行 git clone 命令 5.2.1 本地初始化仓库在IDEA中通过如下操作可以在本地初始化一个本地仓库，其实底层就是执行的 git init 命令。操作过程如下： 1）依次选择菜单【VCS】—【Import into Version Control】—【Create Git Repository】 2）在弹出的【Create Git Repository】对话框中选择当前项目根目录，点击【OK】按钮： 操作完成后可以看到当前项目根目录下出现了.git隐藏目录： 操作完成后可以在IDEA的工具栏中看到Git的相关操作图标： 5.2.2 从远程仓库克隆在IDEA中从远程仓库克隆本质就是执行的 git clone 命令，具体操作过程如下： 1）在IDEA开始窗口中点击【Get from Version Control】 2）在弹出的【Get from Version Control】窗口中输入远程仓库的URL地址和对应的本地仓库存放目录，点击【Clone】按钮进行仓库克隆操作 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#52-获取git仓库"},{"categories":["tool"],"content":" 5.2 获取Git仓库在IDEA中获取Git仓库有两种方式： 本地初始化仓库，本质就是执行 git init 命令 从远程仓库克隆，本质就是执行 git clone 命令 5.2.1 本地初始化仓库在IDEA中通过如下操作可以在本地初始化一个本地仓库，其实底层就是执行的 git init 命令。操作过程如下： 1）依次选择菜单【VCS】—【Import into Version Control】—【Create Git Repository】 2）在弹出的【Create Git Repository】对话框中选择当前项目根目录，点击【OK】按钮： 操作完成后可以看到当前项目根目录下出现了.git隐藏目录： 操作完成后可以在IDEA的工具栏中看到Git的相关操作图标： 5.2.2 从远程仓库克隆在IDEA中从远程仓库克隆本质就是执行的 git clone 命令，具体操作过程如下： 1）在IDEA开始窗口中点击【Get from Version Control】 2）在弹出的【Get from Version Control】窗口中输入远程仓库的URL地址和对应的本地仓库存放目录，点击【Clone】按钮进行仓库克隆操作 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#521-本地初始化仓库"},{"categories":["tool"],"content":" 5.2 获取Git仓库在IDEA中获取Git仓库有两种方式： 本地初始化仓库，本质就是执行 git init 命令 从远程仓库克隆，本质就是执行 git clone 命令 5.2.1 本地初始化仓库在IDEA中通过如下操作可以在本地初始化一个本地仓库，其实底层就是执行的 git init 命令。操作过程如下： 1）依次选择菜单【VCS】—【Import into Version Control】—【Create Git Repository】 2）在弹出的【Create Git Repository】对话框中选择当前项目根目录，点击【OK】按钮： 操作完成后可以看到当前项目根目录下出现了.git隐藏目录： 操作完成后可以在IDEA的工具栏中看到Git的相关操作图标： 5.2.2 从远程仓库克隆在IDEA中从远程仓库克隆本质就是执行的 git clone 命令，具体操作过程如下： 1）在IDEA开始窗口中点击【Get from Version Control】 2）在弹出的【Get from Version Control】窗口中输入远程仓库的URL地址和对应的本地仓库存放目录，点击【Clone】按钮进行仓库克隆操作 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:2","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#522-从远程仓库克隆"},{"categories":["tool"],"content":" 5.3 Git忽略文件在Git工作区中有一个特殊的文件 .gitignore，通过此文件可以指定工作区中的哪些文件不需要Git管理。我们在码云上创建Git远程仓库时可以指定生成此文件，如下： 创建完成后效果如下： 解释说明： 1）我们在使用Git管理项目代码时，并不是所有文件都需要Git管理，例如Java项目中编译的.class文件、开发工具自带的配置文件等，这些文件没有必要交给Git管理，所以也就不需要提交到Git版本库中 2）注意忽略文件的名称是固定的，不能修改 3）添加到忽略列表中的文件后续Git工具就会忽略它 一个参考的.gitignore文件内容如下： .git logs rebel.xml target/ !.mvn/wrapper/maven-wrapper.jar log.path_IS_UNDEFINED .DS_Store offline_user.md *.class ### IntelliJ IDEA ### .idea *.iws *.iml *.ipr ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:3","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#53-git忽略文件"},{"categories":["tool"],"content":" 5.4 本地仓库操作本地仓库操作： 将文件加入暂存区，本质就是执行 git add 命令 将暂存区的文件提交到版本库，本质就是执行 git commit 命令 查看日志，本质就是执行 git log 命令 5.4.1 将文件加入暂存区当在Git工作区新增文件或者对已有文件修改后，就需要将文件的修改加入暂存区，具体操作如下： 5.4.2 将暂存区文件提交到版本库将暂存区文件提交到版本库，可以选择一个文件进行提交，也可以选择整个项目提交多个文件。在IEDA中对文件的提交进行了简化操作，也就是如果文件修改后，无需再加入暂存区，可以直接提交。 1）提交一个文件： 可以看到，如果选中一个文件提交，则菜单名称为【Commit File…】 2）提交多个文件： 可以看到，如果提交多个文件，则菜单名称为【Commit Directory…】 由于提交操作属于高频操作，所以为了进一步方便操作，在IDEA的工具栏中提供了提交操作的快捷按钮： 5.4.3 查看日志查看日志，既可以查看整个仓库的提交日志，也可以查看某个文件的提交日志。 1）查看整个项目的提交日志： 2）查看某个文件的提交日志 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:4","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#54-本地仓库操作"},{"categories":["tool"],"content":" 5.4 本地仓库操作本地仓库操作： 将文件加入暂存区，本质就是执行 git add 命令 将暂存区的文件提交到版本库，本质就是执行 git commit 命令 查看日志，本质就是执行 git log 命令 5.4.1 将文件加入暂存区当在Git工作区新增文件或者对已有文件修改后，就需要将文件的修改加入暂存区，具体操作如下： 5.4.2 将暂存区文件提交到版本库将暂存区文件提交到版本库，可以选择一个文件进行提交，也可以选择整个项目提交多个文件。在IEDA中对文件的提交进行了简化操作，也就是如果文件修改后，无需再加入暂存区，可以直接提交。 1）提交一个文件： 可以看到，如果选中一个文件提交，则菜单名称为【Commit File…】 2）提交多个文件： 可以看到，如果提交多个文件，则菜单名称为【Commit Directory…】 由于提交操作属于高频操作，所以为了进一步方便操作，在IDEA的工具栏中提供了提交操作的快捷按钮： 5.4.3 查看日志查看日志，既可以查看整个仓库的提交日志，也可以查看某个文件的提交日志。 1）查看整个项目的提交日志： 2）查看某个文件的提交日志 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:4","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#541-将文件加入暂存区"},{"categories":["tool"],"content":" 5.4 本地仓库操作本地仓库操作： 将文件加入暂存区，本质就是执行 git add 命令 将暂存区的文件提交到版本库，本质就是执行 git commit 命令 查看日志，本质就是执行 git log 命令 5.4.1 将文件加入暂存区当在Git工作区新增文件或者对已有文件修改后，就需要将文件的修改加入暂存区，具体操作如下： 5.4.2 将暂存区文件提交到版本库将暂存区文件提交到版本库，可以选择一个文件进行提交，也可以选择整个项目提交多个文件。在IEDA中对文件的提交进行了简化操作，也就是如果文件修改后，无需再加入暂存区，可以直接提交。 1）提交一个文件： 可以看到，如果选中一个文件提交，则菜单名称为【Commit File…】 2）提交多个文件： 可以看到，如果提交多个文件，则菜单名称为【Commit Directory…】 由于提交操作属于高频操作，所以为了进一步方便操作，在IDEA的工具栏中提供了提交操作的快捷按钮： 5.4.3 查看日志查看日志，既可以查看整个仓库的提交日志，也可以查看某个文件的提交日志。 1）查看整个项目的提交日志： 2）查看某个文件的提交日志 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:4","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#542-将暂存区文件提交到版本库"},{"categories":["tool"],"content":" 5.4 本地仓库操作本地仓库操作： 将文件加入暂存区，本质就是执行 git add 命令 将暂存区的文件提交到版本库，本质就是执行 git commit 命令 查看日志，本质就是执行 git log 命令 5.4.1 将文件加入暂存区当在Git工作区新增文件或者对已有文件修改后，就需要将文件的修改加入暂存区，具体操作如下： 5.4.2 将暂存区文件提交到版本库将暂存区文件提交到版本库，可以选择一个文件进行提交，也可以选择整个项目提交多个文件。在IEDA中对文件的提交进行了简化操作，也就是如果文件修改后，无需再加入暂存区，可以直接提交。 1）提交一个文件： 可以看到，如果选中一个文件提交，则菜单名称为【Commit File…】 2）提交多个文件： 可以看到，如果提交多个文件，则菜单名称为【Commit Directory…】 由于提交操作属于高频操作，所以为了进一步方便操作，在IDEA的工具栏中提供了提交操作的快捷按钮： 5.4.3 查看日志查看日志，既可以查看整个仓库的提交日志，也可以查看某个文件的提交日志。 1）查看整个项目的提交日志： 2）查看某个文件的提交日志 ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:4","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#543-查看日志"},{"categories":["tool"],"content":" 5.5 远程仓库操作远程仓库操作： 查看远程仓库，本质就是执行 git remote 命令 添加远程仓库，本质就是执行 git remote add 命令 推送至远程仓库，本质就是执行 git push 命令 从远程仓库拉取，本质就是执行 git pull 命令 5.5.1 查看远程仓库操作过程如下： 在弹出的【Git Remotes】窗口中可以看到配置的远程仓库： 5.5.2 添加远程仓库一个本地仓库可以配置多个远程仓库，在【Git Remotes】窗口中点击【+】来添加一个新的远程仓库： 5.5.3 推送至远程仓库可以通过如下操作将本地仓库文件推送至远程仓库： 在弹出的【Push Commits】窗口中可以看到本次推送的文件，点击【Push】按钮即可推送至远程仓库： 由于推送至远程仓库操作属于高频操作，所以可以通过IDEA工具栏中的提交快捷按钮同时完成提交和推送： 点击【Commit and Push…】按钮同时完成提交和推送操作 5.5.4 从远程仓库拉取可以通过如下操作从远程仓库拉取： 由于从远程仓库拉取文件属于高频操作，所以在IDEA的工具栏中提供了对应的快捷按钮： 在弹出的【Update Project】窗口中点击【OK】： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#55-远程仓库操作"},{"categories":["tool"],"content":" 5.5 远程仓库操作远程仓库操作： 查看远程仓库，本质就是执行 git remote 命令 添加远程仓库，本质就是执行 git remote add 命令 推送至远程仓库，本质就是执行 git push 命令 从远程仓库拉取，本质就是执行 git pull 命令 5.5.1 查看远程仓库操作过程如下： 在弹出的【Git Remotes】窗口中可以看到配置的远程仓库： 5.5.2 添加远程仓库一个本地仓库可以配置多个远程仓库，在【Git Remotes】窗口中点击【+】来添加一个新的远程仓库： 5.5.3 推送至远程仓库可以通过如下操作将本地仓库文件推送至远程仓库： 在弹出的【Push Commits】窗口中可以看到本次推送的文件，点击【Push】按钮即可推送至远程仓库： 由于推送至远程仓库操作属于高频操作，所以可以通过IDEA工具栏中的提交快捷按钮同时完成提交和推送： 点击【Commit and Push…】按钮同时完成提交和推送操作 5.5.4 从远程仓库拉取可以通过如下操作从远程仓库拉取： 由于从远程仓库拉取文件属于高频操作，所以在IDEA的工具栏中提供了对应的快捷按钮： 在弹出的【Update Project】窗口中点击【OK】： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#551-查看远程仓库"},{"categories":["tool"],"content":" 5.5 远程仓库操作远程仓库操作： 查看远程仓库，本质就是执行 git remote 命令 添加远程仓库，本质就是执行 git remote add 命令 推送至远程仓库，本质就是执行 git push 命令 从远程仓库拉取，本质就是执行 git pull 命令 5.5.1 查看远程仓库操作过程如下： 在弹出的【Git Remotes】窗口中可以看到配置的远程仓库： 5.5.2 添加远程仓库一个本地仓库可以配置多个远程仓库，在【Git Remotes】窗口中点击【+】来添加一个新的远程仓库： 5.5.3 推送至远程仓库可以通过如下操作将本地仓库文件推送至远程仓库： 在弹出的【Push Commits】窗口中可以看到本次推送的文件，点击【Push】按钮即可推送至远程仓库： 由于推送至远程仓库操作属于高频操作，所以可以通过IDEA工具栏中的提交快捷按钮同时完成提交和推送： 点击【Commit and Push…】按钮同时完成提交和推送操作 5.5.4 从远程仓库拉取可以通过如下操作从远程仓库拉取： 由于从远程仓库拉取文件属于高频操作，所以在IDEA的工具栏中提供了对应的快捷按钮： 在弹出的【Update Project】窗口中点击【OK】： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#552-添加远程仓库"},{"categories":["tool"],"content":" 5.5 远程仓库操作远程仓库操作： 查看远程仓库，本质就是执行 git remote 命令 添加远程仓库，本质就是执行 git remote add 命令 推送至远程仓库，本质就是执行 git push 命令 从远程仓库拉取，本质就是执行 git pull 命令 5.5.1 查看远程仓库操作过程如下： 在弹出的【Git Remotes】窗口中可以看到配置的远程仓库： 5.5.2 添加远程仓库一个本地仓库可以配置多个远程仓库，在【Git Remotes】窗口中点击【+】来添加一个新的远程仓库： 5.5.3 推送至远程仓库可以通过如下操作将本地仓库文件推送至远程仓库： 在弹出的【Push Commits】窗口中可以看到本次推送的文件，点击【Push】按钮即可推送至远程仓库： 由于推送至远程仓库操作属于高频操作，所以可以通过IDEA工具栏中的提交快捷按钮同时完成提交和推送： 点击【Commit and Push…】按钮同时完成提交和推送操作 5.5.4 从远程仓库拉取可以通过如下操作从远程仓库拉取： 由于从远程仓库拉取文件属于高频操作，所以在IDEA的工具栏中提供了对应的快捷按钮： 在弹出的【Update Project】窗口中点击【OK】： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#553-推送至远程仓库"},{"categories":["tool"],"content":" 5.5 远程仓库操作远程仓库操作： 查看远程仓库，本质就是执行 git remote 命令 添加远程仓库，本质就是执行 git remote add 命令 推送至远程仓库，本质就是执行 git push 命令 从远程仓库拉取，本质就是执行 git pull 命令 5.5.1 查看远程仓库操作过程如下： 在弹出的【Git Remotes】窗口中可以看到配置的远程仓库： 5.5.2 添加远程仓库一个本地仓库可以配置多个远程仓库，在【Git Remotes】窗口中点击【+】来添加一个新的远程仓库： 5.5.3 推送至远程仓库可以通过如下操作将本地仓库文件推送至远程仓库： 在弹出的【Push Commits】窗口中可以看到本次推送的文件，点击【Push】按钮即可推送至远程仓库： 由于推送至远程仓库操作属于高频操作，所以可以通过IDEA工具栏中的提交快捷按钮同时完成提交和推送： 点击【Commit and Push…】按钮同时完成提交和推送操作 5.5.4 从远程仓库拉取可以通过如下操作从远程仓库拉取： 由于从远程仓库拉取文件属于高频操作，所以在IDEA的工具栏中提供了对应的快捷按钮： 在弹出的【Update Project】窗口中点击【OK】： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:5","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#554-从远程仓库拉取"},{"categories":["tool"],"content":" 5.6 分支操作分支操作： 查看分支，本质就是执行 git branch 命令 创建分支，本质就是执行 git branch 分支名 命令 切换分支，本质就是执行 git checkout 命令 将分支推送到远程仓库，本质就是执行 git push 命令 合并分支，本质就是执行 git merge 命令 5.6.1 查看分支可以通过如下操作查看分支： 在弹出的窗口中可以看到本地分支和远程分支： 由于分支操作属于高频操作，所以在IDEA的状态栏中提供了分支操作的快捷按钮： 点击【master】快捷按钮即可弹出【Git Branches】分支窗口： 5.6.2 创建分支在【Git Branches】分支窗口中点击【New Branch】，弹出如下窗口： 在弹出的【Create New Branch】窗口中输入新分支的名称，点击【Create】按钮完成分支创建 5.6.3 切换分支通过如下操作可以切换分支： 5.6.4 将分支推送到远程仓库通过如下操作可以将分支推送到远程仓库： 5.6.5 合并分支通过下面操作可以进行分支的合并： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#56-分支操作"},{"categories":["tool"],"content":" 5.6 分支操作分支操作： 查看分支，本质就是执行 git branch 命令 创建分支，本质就是执行 git branch 分支名 命令 切换分支，本质就是执行 git checkout 命令 将分支推送到远程仓库，本质就是执行 git push 命令 合并分支，本质就是执行 git merge 命令 5.6.1 查看分支可以通过如下操作查看分支： 在弹出的窗口中可以看到本地分支和远程分支： 由于分支操作属于高频操作，所以在IDEA的状态栏中提供了分支操作的快捷按钮： 点击【master】快捷按钮即可弹出【Git Branches】分支窗口： 5.6.2 创建分支在【Git Branches】分支窗口中点击【New Branch】，弹出如下窗口： 在弹出的【Create New Branch】窗口中输入新分支的名称，点击【Create】按钮完成分支创建 5.6.3 切换分支通过如下操作可以切换分支： 5.6.4 将分支推送到远程仓库通过如下操作可以将分支推送到远程仓库： 5.6.5 合并分支通过下面操作可以进行分支的合并： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#561-查看分支"},{"categories":["tool"],"content":" 5.6 分支操作分支操作： 查看分支，本质就是执行 git branch 命令 创建分支，本质就是执行 git branch 分支名 命令 切换分支，本质就是执行 git checkout 命令 将分支推送到远程仓库，本质就是执行 git push 命令 合并分支，本质就是执行 git merge 命令 5.6.1 查看分支可以通过如下操作查看分支： 在弹出的窗口中可以看到本地分支和远程分支： 由于分支操作属于高频操作，所以在IDEA的状态栏中提供了分支操作的快捷按钮： 点击【master】快捷按钮即可弹出【Git Branches】分支窗口： 5.6.2 创建分支在【Git Branches】分支窗口中点击【New Branch】，弹出如下窗口： 在弹出的【Create New Branch】窗口中输入新分支的名称，点击【Create】按钮完成分支创建 5.6.3 切换分支通过如下操作可以切换分支： 5.6.4 将分支推送到远程仓库通过如下操作可以将分支推送到远程仓库： 5.6.5 合并分支通过下面操作可以进行分支的合并： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#562-创建分支"},{"categories":["tool"],"content":" 5.6 分支操作分支操作： 查看分支，本质就是执行 git branch 命令 创建分支，本质就是执行 git branch 分支名 命令 切换分支，本质就是执行 git checkout 命令 将分支推送到远程仓库，本质就是执行 git push 命令 合并分支，本质就是执行 git merge 命令 5.6.1 查看分支可以通过如下操作查看分支： 在弹出的窗口中可以看到本地分支和远程分支： 由于分支操作属于高频操作，所以在IDEA的状态栏中提供了分支操作的快捷按钮： 点击【master】快捷按钮即可弹出【Git Branches】分支窗口： 5.6.2 创建分支在【Git Branches】分支窗口中点击【New Branch】，弹出如下窗口： 在弹出的【Create New Branch】窗口中输入新分支的名称，点击【Create】按钮完成分支创建 5.6.3 切换分支通过如下操作可以切换分支： 5.6.4 将分支推送到远程仓库通过如下操作可以将分支推送到远程仓库： 5.6.5 合并分支通过下面操作可以进行分支的合并： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#563-切换分支"},{"categories":["tool"],"content":" 5.6 分支操作分支操作： 查看分支，本质就是执行 git branch 命令 创建分支，本质就是执行 git branch 分支名 命令 切换分支，本质就是执行 git checkout 命令 将分支推送到远程仓库，本质就是执行 git push 命令 合并分支，本质就是执行 git merge 命令 5.6.1 查看分支可以通过如下操作查看分支： 在弹出的窗口中可以看到本地分支和远程分支： 由于分支操作属于高频操作，所以在IDEA的状态栏中提供了分支操作的快捷按钮： 点击【master】快捷按钮即可弹出【Git Branches】分支窗口： 5.6.2 创建分支在【Git Branches】分支窗口中点击【New Branch】，弹出如下窗口： 在弹出的【Create New Branch】窗口中输入新分支的名称，点击【Create】按钮完成分支创建 5.6.3 切换分支通过如下操作可以切换分支： 5.6.4 将分支推送到远程仓库通过如下操作可以将分支推送到远程仓库： 5.6.5 合并分支通过下面操作可以进行分支的合并： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#564-将分支推送到远程仓库"},{"categories":["tool"],"content":" 5.6 分支操作分支操作： 查看分支，本质就是执行 git branch 命令 创建分支，本质就是执行 git branch 分支名 命令 切换分支，本质就是执行 git checkout 命令 将分支推送到远程仓库，本质就是执行 git push 命令 合并分支，本质就是执行 git merge 命令 5.6.1 查看分支可以通过如下操作查看分支： 在弹出的窗口中可以看到本地分支和远程分支： 由于分支操作属于高频操作，所以在IDEA的状态栏中提供了分支操作的快捷按钮： 点击【master】快捷按钮即可弹出【Git Branches】分支窗口： 5.6.2 创建分支在【Git Branches】分支窗口中点击【New Branch】，弹出如下窗口： 在弹出的【Create New Branch】窗口中输入新分支的名称，点击【Create】按钮完成分支创建 5.6.3 切换分支通过如下操作可以切换分支： 5.6.4 将分支推送到远程仓库通过如下操作可以将分支推送到远程仓库： 5.6.5 合并分支通过下面操作可以进行分支的合并： ","date":"2023-12-31","objectID":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/:6:6","series":null,"tags":["tool"],"title":"Git同时连接github和gitee","uri":"/git%E5%90%8C%E6%97%B6%E8%BF%9E%E6%8E%A5github%E5%92%8Cgitee/#565-合并分支"},{"categories":["C"],"content":" 数据类型 1.1、数据类型的基本概念 类型是对数据的抽象; 类型相同的数据具有相同的表示形式、存储格式以及相关操作; 程序中所有的数据都必定属于某种数据类型; 数据类型可以理解为创建变量的模具: *固定大小内存的别名*; 1.2、数据类型别名 typedef unsigned int u32; typedef struct _PERSON{ char name[64]; int age; }Person; void test(){ u32 val; //相当于 unsigned int val; Person person; //相当于 struct PERSON person; } 1.3、void数据类型void字面意思是”无类型”,void* 无类型指针，无类型指针可以指向任何类型的数据。 void定义变量是没有任何意义的，当你定义void a，编译器会报错。 void真正用在以下两个方面： 对函数返回的限定； Ø对函数参数的限定； //1. void修饰函数参数和函数返回 void test01(void){ printf(\"hello world\"); } //2. 不能定义void类型变量 void test02(){ void val; //报错 } //3. void* 可以指向任何类型的数据，被称为万能指针 void test03(){ int a = 10; void* p = NULL; p = \u0026a; printf(\"a:%d\\n\",*(int*)p); char c = 'a'; p = \u0026c; printf(\"c:%c\\n\",*(char*)p); } //4. void* 常用于数据类型的封装 void test04(){ //void * memcpy(void * _Dst, const void * _Src, size_t _Size); } 1.4、 sizeof操作符sizeof是c语言中的一个操作符，类似于++、--等等。sizeof能够告诉我们编译器为某一特定数据或者某一个类型的数据在内存中分配空间时分配的大小，大小以字节为单位。 基本语法： sizeof(变量); sizeof 变量； sizeof(类型); *sizeof 注意点：* sizeof返回的占用空间大小是为这个变量开辟的大小，而不只是它用到的空间。和现今住房的建筑面积和实用面积的概念差不多。所以对结构体用的时候，大多情况下就得考虑字节对齐的问题了； sizeof返回的数据结果类型是unsigned int； 要注意数组名和指针变量的区别。通常情况下，我们总觉得数组名和指针变量差不多，但是在用sizeof的时候差别很大，对数组名用sizeof返回的是整个数组的大小，而对指针变量进行操作的时候返回的则是指针变量本身所占得空间，在32位机的条件下一般都是4。而且当数组名作为函数参数时，在函数内部，形参也就是个指针，所以不再返回数组的大小； //1. sizeof基本用法 void test01(){ int a = 10; printf(\"len:%d\\n\", sizeof(a)); printf(\"len:%d\\n\", sizeof(int)); printf(\"len:%d\\n\", sizeof a); } //2. sizeof 结果类型 void test02(){ unsigned int a = 10; if (a - 11 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } int b = 5; if (sizeof(b) - 10 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } } //3. sizeof 碰到数组 void TestArray(int arr[]){ printf(\"TestArray arr size:%d\\n\",sizeof(arr)); } void test03(){ int arr[] = { 10, 20, 30, 40, 50 }; printf(\"array size: %d\\n\",sizeof(arr)); //数组名在某些情况下等价于指针 int* pArr = arr; printf(\"arr[2]:%d\\n\",pArr[2]); printf(\"array size: %d\\n\", sizeof(pArr)); //数组做函数函数参数，将退化为指针,在函数内部不再返回数组大小 TestArray(arr); } 总结l 数据类型本质是固定内存大小的别名，是个模具，C语言规定：通过数据类型定义变量； l 数据类型大小计算（sizeof）； l 可以给已存在的数据类型起别名typedef； l 数据类型的封装（void 万能类型）； ","date":"2023-12-31","objectID":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","series":null,"tags":["C"],"title":"数据类型","uri":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#数据类型"},{"categories":["C"],"content":" 数据类型 1.1、数据类型的基本概念 类型是对数据的抽象; 类型相同的数据具有相同的表示形式、存储格式以及相关操作; 程序中所有的数据都必定属于某种数据类型; 数据类型可以理解为创建变量的模具: *固定大小内存的别名*; 1.2、数据类型别名 typedef unsigned int u32; typedef struct _PERSON{ char name[64]; int age; }Person; void test(){ u32 val; //相当于 unsigned int val; Person person; //相当于 struct PERSON person; } 1.3、void数据类型void字面意思是”无类型”,void* 无类型指针，无类型指针可以指向任何类型的数据。 void定义变量是没有任何意义的，当你定义void a，编译器会报错。 void真正用在以下两个方面： 对函数返回的限定； Ø对函数参数的限定； //1. void修饰函数参数和函数返回 void test01(void){ printf(\"hello world\"); } //2. 不能定义void类型变量 void test02(){ void val; //报错 } //3. void* 可以指向任何类型的数据，被称为万能指针 void test03(){ int a = 10; void* p = NULL; p = \u0026a; printf(\"a:%d\\n\",*(int*)p); char c = 'a'; p = \u0026c; printf(\"c:%c\\n\",*(char*)p); } //4. void* 常用于数据类型的封装 void test04(){ //void * memcpy(void * _Dst, const void * _Src, size_t _Size); } 1.4、 sizeof操作符sizeof是c语言中的一个操作符，类似于++、--等等。sizeof能够告诉我们编译器为某一特定数据或者某一个类型的数据在内存中分配空间时分配的大小，大小以字节为单位。 基本语法： sizeof(变量); sizeof 变量； sizeof(类型); *sizeof 注意点：* sizeof返回的占用空间大小是为这个变量开辟的大小，而不只是它用到的空间。和现今住房的建筑面积和实用面积的概念差不多。所以对结构体用的时候，大多情况下就得考虑字节对齐的问题了； sizeof返回的数据结果类型是unsigned int； 要注意数组名和指针变量的区别。通常情况下，我们总觉得数组名和指针变量差不多，但是在用sizeof的时候差别很大，对数组名用sizeof返回的是整个数组的大小，而对指针变量进行操作的时候返回的则是指针变量本身所占得空间，在32位机的条件下一般都是4。而且当数组名作为函数参数时，在函数内部，形参也就是个指针，所以不再返回数组的大小； //1. sizeof基本用法 void test01(){ int a = 10; printf(\"len:%d\\n\", sizeof(a)); printf(\"len:%d\\n\", sizeof(int)); printf(\"len:%d\\n\", sizeof a); } //2. sizeof 结果类型 void test02(){ unsigned int a = 10; if (a - 11 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } int b = 5; if (sizeof(b) - 10 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } } //3. sizeof 碰到数组 void TestArray(int arr[]){ printf(\"TestArray arr size:%d\\n\",sizeof(arr)); } void test03(){ int arr[] = { 10, 20, 30, 40, 50 }; printf(\"array size: %d\\n\",sizeof(arr)); //数组名在某些情况下等价于指针 int* pArr = arr; printf(\"arr[2]:%d\\n\",pArr[2]); printf(\"array size: %d\\n\", sizeof(pArr)); //数组做函数函数参数，将退化为指针,在函数内部不再返回数组大小 TestArray(arr); } 总结l 数据类型本质是固定内存大小的别名，是个模具，C语言规定：通过数据类型定义变量； l 数据类型大小计算（sizeof）； l 可以给已存在的数据类型起别名typedef； l 数据类型的封装（void 万能类型）； ","date":"2023-12-31","objectID":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","series":null,"tags":["C"],"title":"数据类型","uri":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#11数据类型的基本概念"},{"categories":["C"],"content":" 数据类型 1.1、数据类型的基本概念 类型是对数据的抽象; 类型相同的数据具有相同的表示形式、存储格式以及相关操作; 程序中所有的数据都必定属于某种数据类型; 数据类型可以理解为创建变量的模具: *固定大小内存的别名*; 1.2、数据类型别名 typedef unsigned int u32; typedef struct _PERSON{ char name[64]; int age; }Person; void test(){ u32 val; //相当于 unsigned int val; Person person; //相当于 struct PERSON person; } 1.3、void数据类型void字面意思是”无类型”,void* 无类型指针，无类型指针可以指向任何类型的数据。 void定义变量是没有任何意义的，当你定义void a，编译器会报错。 void真正用在以下两个方面： 对函数返回的限定； Ø对函数参数的限定； //1. void修饰函数参数和函数返回 void test01(void){ printf(\"hello world\"); } //2. 不能定义void类型变量 void test02(){ void val; //报错 } //3. void* 可以指向任何类型的数据，被称为万能指针 void test03(){ int a = 10; void* p = NULL; p = \u0026a; printf(\"a:%d\\n\",*(int*)p); char c = 'a'; p = \u0026c; printf(\"c:%c\\n\",*(char*)p); } //4. void* 常用于数据类型的封装 void test04(){ //void * memcpy(void * _Dst, const void * _Src, size_t _Size); } 1.4、 sizeof操作符sizeof是c语言中的一个操作符，类似于++、--等等。sizeof能够告诉我们编译器为某一特定数据或者某一个类型的数据在内存中分配空间时分配的大小，大小以字节为单位。 基本语法： sizeof(变量); sizeof 变量； sizeof(类型); *sizeof 注意点：* sizeof返回的占用空间大小是为这个变量开辟的大小，而不只是它用到的空间。和现今住房的建筑面积和实用面积的概念差不多。所以对结构体用的时候，大多情况下就得考虑字节对齐的问题了； sizeof返回的数据结果类型是unsigned int； 要注意数组名和指针变量的区别。通常情况下，我们总觉得数组名和指针变量差不多，但是在用sizeof的时候差别很大，对数组名用sizeof返回的是整个数组的大小，而对指针变量进行操作的时候返回的则是指针变量本身所占得空间，在32位机的条件下一般都是4。而且当数组名作为函数参数时，在函数内部，形参也就是个指针，所以不再返回数组的大小； //1. sizeof基本用法 void test01(){ int a = 10; printf(\"len:%d\\n\", sizeof(a)); printf(\"len:%d\\n\", sizeof(int)); printf(\"len:%d\\n\", sizeof a); } //2. sizeof 结果类型 void test02(){ unsigned int a = 10; if (a - 11 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } int b = 5; if (sizeof(b) - 10 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } } //3. sizeof 碰到数组 void TestArray(int arr[]){ printf(\"TestArray arr size:%d\\n\",sizeof(arr)); } void test03(){ int arr[] = { 10, 20, 30, 40, 50 }; printf(\"array size: %d\\n\",sizeof(arr)); //数组名在某些情况下等价于指针 int* pArr = arr; printf(\"arr[2]:%d\\n\",pArr[2]); printf(\"array size: %d\\n\", sizeof(pArr)); //数组做函数函数参数，将退化为指针,在函数内部不再返回数组大小 TestArray(arr); } 总结l 数据类型本质是固定内存大小的别名，是个模具，C语言规定：通过数据类型定义变量； l 数据类型大小计算（sizeof）； l 可以给已存在的数据类型起别名typedef； l 数据类型的封装（void 万能类型）； ","date":"2023-12-31","objectID":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","series":null,"tags":["C"],"title":"数据类型","uri":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#12数据类型别名"},{"categories":["C"],"content":" 数据类型 1.1、数据类型的基本概念 类型是对数据的抽象; 类型相同的数据具有相同的表示形式、存储格式以及相关操作; 程序中所有的数据都必定属于某种数据类型; 数据类型可以理解为创建变量的模具: *固定大小内存的别名*; 1.2、数据类型别名 typedef unsigned int u32; typedef struct _PERSON{ char name[64]; int age; }Person; void test(){ u32 val; //相当于 unsigned int val; Person person; //相当于 struct PERSON person; } 1.3、void数据类型void字面意思是”无类型”,void* 无类型指针，无类型指针可以指向任何类型的数据。 void定义变量是没有任何意义的，当你定义void a，编译器会报错。 void真正用在以下两个方面： 对函数返回的限定； Ø对函数参数的限定； //1. void修饰函数参数和函数返回 void test01(void){ printf(\"hello world\"); } //2. 不能定义void类型变量 void test02(){ void val; //报错 } //3. void* 可以指向任何类型的数据，被称为万能指针 void test03(){ int a = 10; void* p = NULL; p = \u0026a; printf(\"a:%d\\n\",*(int*)p); char c = 'a'; p = \u0026c; printf(\"c:%c\\n\",*(char*)p); } //4. void* 常用于数据类型的封装 void test04(){ //void * memcpy(void * _Dst, const void * _Src, size_t _Size); } 1.4、 sizeof操作符sizeof是c语言中的一个操作符，类似于++、--等等。sizeof能够告诉我们编译器为某一特定数据或者某一个类型的数据在内存中分配空间时分配的大小，大小以字节为单位。 基本语法： sizeof(变量); sizeof 变量； sizeof(类型); *sizeof 注意点：* sizeof返回的占用空间大小是为这个变量开辟的大小，而不只是它用到的空间。和现今住房的建筑面积和实用面积的概念差不多。所以对结构体用的时候，大多情况下就得考虑字节对齐的问题了； sizeof返回的数据结果类型是unsigned int； 要注意数组名和指针变量的区别。通常情况下，我们总觉得数组名和指针变量差不多，但是在用sizeof的时候差别很大，对数组名用sizeof返回的是整个数组的大小，而对指针变量进行操作的时候返回的则是指针变量本身所占得空间，在32位机的条件下一般都是4。而且当数组名作为函数参数时，在函数内部，形参也就是个指针，所以不再返回数组的大小； //1. sizeof基本用法 void test01(){ int a = 10; printf(\"len:%d\\n\", sizeof(a)); printf(\"len:%d\\n\", sizeof(int)); printf(\"len:%d\\n\", sizeof a); } //2. sizeof 结果类型 void test02(){ unsigned int a = 10; if (a - 11 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } int b = 5; if (sizeof(b) - 10 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } } //3. sizeof 碰到数组 void TestArray(int arr[]){ printf(\"TestArray arr size:%d\\n\",sizeof(arr)); } void test03(){ int arr[] = { 10, 20, 30, 40, 50 }; printf(\"array size: %d\\n\",sizeof(arr)); //数组名在某些情况下等价于指针 int* pArr = arr; printf(\"arr[2]:%d\\n\",pArr[2]); printf(\"array size: %d\\n\", sizeof(pArr)); //数组做函数函数参数，将退化为指针,在函数内部不再返回数组大小 TestArray(arr); } 总结l 数据类型本质是固定内存大小的别名，是个模具，C语言规定：通过数据类型定义变量； l 数据类型大小计算（sizeof）； l 可以给已存在的数据类型起别名typedef； l 数据类型的封装（void 万能类型）； ","date":"2023-12-31","objectID":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","series":null,"tags":["C"],"title":"数据类型","uri":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#13void数据类型"},{"categories":["C"],"content":" 数据类型 1.1、数据类型的基本概念 类型是对数据的抽象; 类型相同的数据具有相同的表示形式、存储格式以及相关操作; 程序中所有的数据都必定属于某种数据类型; 数据类型可以理解为创建变量的模具: *固定大小内存的别名*; 1.2、数据类型别名 typedef unsigned int u32; typedef struct _PERSON{ char name[64]; int age; }Person; void test(){ u32 val; //相当于 unsigned int val; Person person; //相当于 struct PERSON person; } 1.3、void数据类型void字面意思是”无类型”,void* 无类型指针，无类型指针可以指向任何类型的数据。 void定义变量是没有任何意义的，当你定义void a，编译器会报错。 void真正用在以下两个方面： 对函数返回的限定； Ø对函数参数的限定； //1. void修饰函数参数和函数返回 void test01(void){ printf(\"hello world\"); } //2. 不能定义void类型变量 void test02(){ void val; //报错 } //3. void* 可以指向任何类型的数据，被称为万能指针 void test03(){ int a = 10; void* p = NULL; p = \u0026a; printf(\"a:%d\\n\",*(int*)p); char c = 'a'; p = \u0026c; printf(\"c:%c\\n\",*(char*)p); } //4. void* 常用于数据类型的封装 void test04(){ //void * memcpy(void * _Dst, const void * _Src, size_t _Size); } 1.4、 sizeof操作符sizeof是c语言中的一个操作符，类似于++、--等等。sizeof能够告诉我们编译器为某一特定数据或者某一个类型的数据在内存中分配空间时分配的大小，大小以字节为单位。 基本语法： sizeof(变量); sizeof 变量； sizeof(类型); *sizeof 注意点：* sizeof返回的占用空间大小是为这个变量开辟的大小，而不只是它用到的空间。和现今住房的建筑面积和实用面积的概念差不多。所以对结构体用的时候，大多情况下就得考虑字节对齐的问题了； sizeof返回的数据结果类型是unsigned int； 要注意数组名和指针变量的区别。通常情况下，我们总觉得数组名和指针变量差不多，但是在用sizeof的时候差别很大，对数组名用sizeof返回的是整个数组的大小，而对指针变量进行操作的时候返回的则是指针变量本身所占得空间，在32位机的条件下一般都是4。而且当数组名作为函数参数时，在函数内部，形参也就是个指针，所以不再返回数组的大小； //1. sizeof基本用法 void test01(){ int a = 10; printf(\"len:%d\\n\", sizeof(a)); printf(\"len:%d\\n\", sizeof(int)); printf(\"len:%d\\n\", sizeof a); } //2. sizeof 结果类型 void test02(){ unsigned int a = 10; if (a - 11 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } int b = 5; if (sizeof(b) - 10 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } } //3. sizeof 碰到数组 void TestArray(int arr[]){ printf(\"TestArray arr size:%d\\n\",sizeof(arr)); } void test03(){ int arr[] = { 10, 20, 30, 40, 50 }; printf(\"array size: %d\\n\",sizeof(arr)); //数组名在某些情况下等价于指针 int* pArr = arr; printf(\"arr[2]:%d\\n\",pArr[2]); printf(\"array size: %d\\n\", sizeof(pArr)); //数组做函数函数参数，将退化为指针,在函数内部不再返回数组大小 TestArray(arr); } 总结l 数据类型本质是固定内存大小的别名，是个模具，C语言规定：通过数据类型定义变量； l 数据类型大小计算（sizeof）； l 可以给已存在的数据类型起别名typedef； l 数据类型的封装（void 万能类型）； ","date":"2023-12-31","objectID":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","series":null,"tags":["C"],"title":"数据类型","uri":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#14-sizeof操作符"},{"categories":["C"],"content":" 数据类型 1.1、数据类型的基本概念 类型是对数据的抽象; 类型相同的数据具有相同的表示形式、存储格式以及相关操作; 程序中所有的数据都必定属于某种数据类型; 数据类型可以理解为创建变量的模具: *固定大小内存的别名*; 1.2、数据类型别名 typedef unsigned int u32; typedef struct _PERSON{ char name[64]; int age; }Person; void test(){ u32 val; //相当于 unsigned int val; Person person; //相当于 struct PERSON person; } 1.3、void数据类型void字面意思是”无类型”,void* 无类型指针，无类型指针可以指向任何类型的数据。 void定义变量是没有任何意义的，当你定义void a，编译器会报错。 void真正用在以下两个方面： 对函数返回的限定； Ø对函数参数的限定； //1. void修饰函数参数和函数返回 void test01(void){ printf(\"hello world\"); } //2. 不能定义void类型变量 void test02(){ void val; //报错 } //3. void* 可以指向任何类型的数据，被称为万能指针 void test03(){ int a = 10; void* p = NULL; p = \u0026a; printf(\"a:%d\\n\",*(int*)p); char c = 'a'; p = \u0026c; printf(\"c:%c\\n\",*(char*)p); } //4. void* 常用于数据类型的封装 void test04(){ //void * memcpy(void * _Dst, const void * _Src, size_t _Size); } 1.4、 sizeof操作符sizeof是c语言中的一个操作符，类似于++、--等等。sizeof能够告诉我们编译器为某一特定数据或者某一个类型的数据在内存中分配空间时分配的大小，大小以字节为单位。 基本语法： sizeof(变量); sizeof 变量； sizeof(类型); *sizeof 注意点：* sizeof返回的占用空间大小是为这个变量开辟的大小，而不只是它用到的空间。和现今住房的建筑面积和实用面积的概念差不多。所以对结构体用的时候，大多情况下就得考虑字节对齐的问题了； sizeof返回的数据结果类型是unsigned int； 要注意数组名和指针变量的区别。通常情况下，我们总觉得数组名和指针变量差不多，但是在用sizeof的时候差别很大，对数组名用sizeof返回的是整个数组的大小，而对指针变量进行操作的时候返回的则是指针变量本身所占得空间，在32位机的条件下一般都是4。而且当数组名作为函数参数时，在函数内部，形参也就是个指针，所以不再返回数组的大小； //1. sizeof基本用法 void test01(){ int a = 10; printf(\"len:%d\\n\", sizeof(a)); printf(\"len:%d\\n\", sizeof(int)); printf(\"len:%d\\n\", sizeof a); } //2. sizeof 结果类型 void test02(){ unsigned int a = 10; if (a - 11 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } int b = 5; if (sizeof(b) - 10 \u003c 0){ printf(\"结果小于0\\n\"); } else{ printf(\"结果大于0\\n\"); } } //3. sizeof 碰到数组 void TestArray(int arr[]){ printf(\"TestArray arr size:%d\\n\",sizeof(arr)); } void test03(){ int arr[] = { 10, 20, 30, 40, 50 }; printf(\"array size: %d\\n\",sizeof(arr)); //数组名在某些情况下等价于指针 int* pArr = arr; printf(\"arr[2]:%d\\n\",pArr[2]); printf(\"array size: %d\\n\", sizeof(pArr)); //数组做函数函数参数，将退化为指针,在函数内部不再返回数组大小 TestArray(arr); } 总结l 数据类型本质是固定内存大小的别名，是个模具，C语言规定：通过数据类型定义变量； l 数据类型大小计算（sizeof）； l 可以给已存在的数据类型起别名typedef； l 数据类型的封装（void 万能类型）； ","date":"2023-12-31","objectID":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","series":null,"tags":["C"],"title":"数据类型","uri":"/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#总结"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#函数"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#1-1-定义函数"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#1-2-函数调用"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#1-3-函数返回值"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#1-4-函数参数"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#1-5-函数声明"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#1-6-递归函数"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#2形参和实参"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#2-1形参形式参数"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#2-2--实参实际参数"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#2-3-形参和实参的关系"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#2-4-形参和实参匹配"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#3return和exit"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#3-1-return"},{"categories":["C"],"content":" 函数函数是编程中的一个基本概念，它是一段被命名的代码块，可以在程序中多次调用。函数允许将代码逻辑分成可重复使用的模块，从而提高代码的可读性、可维护性和重用性。以下是关于函数的详细描述： 1-1. 定义函数：函数通常由函数头和函数体组成。函数头包括函数的返回类型、函数名称和参数列表。函数体包含实际的代码逻辑。例如，以下是一个简单的函数定义： int add(int a, int b) { return a + b; } 1-2. 函数调用：函数调用是指在程序中使用函数。通过函数名称和实参（参数的实际值），可以调用函数并执行函数体中的代码。函数调用可以在程序的任何地方进行。例如： int sum = add(5, 3); // 调用 add 函数，传入参数 5 和 3 1-3. 函数返回值：函数可以返回一个值，这个值是通过 return 语句从函数体中返回的。返回值的类型需要与函数头中的返回类型匹配。如果函数不返回值，返回类型应该是 void。例如： int multiply(int x, int y) { return x * y; } void showMessage() { printf(\"Hello, world!\\n\"); } 1-4. 函数参数：函数可以接受零个或多个参数，参数是传递给函数的值。参数列表定义了函数的输入。在函数调用时，实参传递给参数。例如： double calculateAverage(double num1, double num2, double num3) { return (num1 + num2 + num3) / 3.0; } 1-5. 函数声明：在函数使用之前，需要提前声明函数。函数声明描述了函数的名称、返回类型和参数列表。函数声明可以放在函数使用之前的位置，或者放在头文件中。这样编译器就知道函数的存在和特征。例如： int add(int a, int b); // 函数声明 1-6. 递归函数：函数可以调用自身，这种称为递归。递归函数可以用于解决需要重复进行相同操作的问题。例如，计算阶乘的递归函数： int factorial(int n) { if (n == 0 || n == 1) { return 1; } else { return n * factorial(n - 1); } } 函数是将代码模块化、组织代码、提高可重用性和维护性的关键工具。通过函数，程序员可以将复杂的问题分解为小块，更好地管理代码。 2.形参和实参: 2-1.形参（形式参数）：形参是函数定义中声明的参数，用于接受函数调用时传递给函数的值。形参在函数定义中作为变量名出现，并指定了参数的数据类型。形参的作用范围仅限于函数体内部。函数的形参为函数提供了数据输入的方式。 例如，在下面的函数定义中，a 和 b 是形参： int add(int a, int b) { return a + b; } 2-2. 实参（实际参数）：实参是函数调用时传递给函数的值，用于提供函数所需的数据。实参可以是常量、变量、表达式等。当函数被调用时，实参的值被传递给函数的形参。实参与形参之间的数据类型和顺序必须匹配。 例如，在下面的函数调用中，5 和 3 是实参： int sum = add(5, 3); 2-3. 形参和实参的关系：当函数被调用时，实参的值被复制到函数的形参中，函数内部使用的是形参的值。形参在函数体中的操作不会影响实际传递的参数。实参和形参之间的连接是通过函数调用建立的，它们在内存中占用不同的位置。 2-4. 形参和实参匹配：- 数量必须匹配：函数调用时提供的实参数量必须与函数定义中的形参数量一致。 - 类型必须匹配：实参的数据类型必须与相应形参的数据类型匹配，或者能够隐式转换为匹配的数据类型。 - 顺序必须匹配：如果函数定义中有多个形参，实参的顺序必须与形参的顺序匹配。 总之，形参是函数定义中的参数，用于接收传递给函数的值，而实参是函数调用中的参数，提供给函数所需的数据。形参和实参之间的正确匹配是确保函数调用成功的关键。 3.return和exit: 3-1. return：return 是用于函数中的关键字，用于从函数中返回一个值，并将控制权返回给调用函数的地方。每个函数的返回类型需要在函数声明或定义中指定，而且函数中的 return 语句应该返回相应的值，与函数的返回类型相匹配。return 语句还可以提前退出函数的执行。 示例： int add(int a, int b) { return a + b; } int main() { int sum = add(5, 3); // 调用 add 函数并获取返回值 8 return 0; } 3-2. exit：exit 是一个库函数，用于终止整个程序的执行。它位于 stdlib.h 头文件中。当调用 exit 时，程序会立即退出，不再执行任何剩余的代码，且不会调用任何析构函数。你可以提供一个整数参数作为退出状态码，通常用于向操作系统报告程序退出的状态。 示例： #include #include int main() { printf(\"Before exit\\n\"); exit(1); // 终止程序，返回状态码 1 printf(\"After exit\\n\"); // 不会执行这行代码 return 0; } 总结： - return 用于函数中，返回函数的结果给调用者，继续执行调用者的代码。 - exit 用于整个程序，立即终止程序的执行，不再执行剩余的代码，通常用于表示程序的结束状态。 ","date":"2023-12-31","objectID":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/:0:1","series":null,"tags":["C"],"title":"低级函数","uri":"/%E4%BD%8E%E7%BA%A7%E5%87%BD%E6%95%B0/#3-2-exit"},{"categories":["C"],"content":" 1 、概述 1.1磁盘文件和设备文件 磁盘文件 指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。 设备文件 在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。 1.2 磁盘文件的分类计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。 从用户或者操作系统使用的角度（逻辑上）把文件分为： 文本文件：基于字符编码的文件 二进制文件：基于值编码的文件 1.3 文本文件和二进制文件 文本文件 基于字符编码，常见编码有ASCII、UNICODE等 一般可以使用文本编辑器直接打开 数5678的以ASCII存储形式(ASCII码)为：00110101 00110110 00110111 00111000 二进制文件 基于值编码,自己根据具体应用,指定某个值是什么意思 把内存中的数据按其在内存中的存储形式原样输出到磁盘上 数5678的存储形式(二进制码)为：00010110 00101110 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:1","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#1-概述"},{"categories":["C"],"content":" 1 、概述 1.1磁盘文件和设备文件 磁盘文件 指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。 设备文件 在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。 1.2 磁盘文件的分类计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。 从用户或者操作系统使用的角度（逻辑上）把文件分为： 文本文件：基于字符编码的文件 二进制文件：基于值编码的文件 1.3 文本文件和二进制文件 文本文件 基于字符编码，常见编码有ASCII、UNICODE等 一般可以使用文本编辑器直接打开 数5678的以ASCII存储形式(ASCII码)为：00110101 00110110 00110111 00111000 二进制文件 基于值编码,自己根据具体应用,指定某个值是什么意思 把内存中的数据按其在内存中的存储形式原样输出到磁盘上 数5678的存储形式(二进制码)为：00010110 00101110 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:1","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#11磁盘文件和设备文件"},{"categories":["C"],"content":" 1 、概述 1.1磁盘文件和设备文件 磁盘文件 指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。 设备文件 在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。 1.2 磁盘文件的分类计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。 从用户或者操作系统使用的角度（逻辑上）把文件分为： 文本文件：基于字符编码的文件 二进制文件：基于值编码的文件 1.3 文本文件和二进制文件 文本文件 基于字符编码，常见编码有ASCII、UNICODE等 一般可以使用文本编辑器直接打开 数5678的以ASCII存储形式(ASCII码)为：00110101 00110110 00110111 00111000 二进制文件 基于值编码,自己根据具体应用,指定某个值是什么意思 把内存中的数据按其在内存中的存储形式原样输出到磁盘上 数5678的存储形式(二进制码)为：00010110 00101110 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:1","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#12-磁盘文件的分类"},{"categories":["C"],"content":" 1 、概述 1.1磁盘文件和设备文件 磁盘文件 指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。 设备文件 在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。 1.2 磁盘文件的分类计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。 从用户或者操作系统使用的角度（逻辑上）把文件分为： 文本文件：基于字符编码的文件 二进制文件：基于值编码的文件 1.3 文本文件和二进制文件 文本文件 基于字符编码，常见编码有ASCII、UNICODE等 一般可以使用文本编辑器直接打开 数5678的以ASCII存储形式(ASCII码)为：00110101 00110110 00110111 00111000 二进制文件 基于值编码,自己根据具体应用,指定某个值是什么意思 把内存中的数据按其在内存中的存储形式原样输出到磁盘上 数5678的存储形式(二进制码)为：00010110 00101110 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:1","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#13-文本文件和二进制文件"},{"categories":["C"],"content":" 1 、概述 1.1磁盘文件和设备文件 磁盘文件 指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。 设备文件 在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。 1.2 磁盘文件的分类计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。 从用户或者操作系统使用的角度（逻辑上）把文件分为： 文本文件：基于字符编码的文件 二进制文件：基于值编码的文件 1.3 文本文件和二进制文件 文本文件 基于字符编码，常见编码有ASCII、UNICODE等 一般可以使用文本编辑器直接打开 数5678的以ASCII存储形式(ASCII码)为：00110101 00110110 00110111 00111000 二进制文件 基于值编码,自己根据具体应用,指定某个值是什么意思 把内存中的数据按其在内存中的存储形式原样输出到磁盘上 数5678的存储形式(二进制码)为：00010110 00101110 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:1","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#文本文件"},{"categories":["C"],"content":" 1 、概述 1.1磁盘文件和设备文件 磁盘文件 指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。 设备文件 在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。 1.2 磁盘文件的分类计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。 从用户或者操作系统使用的角度（逻辑上）把文件分为： 文本文件：基于字符编码的文件 二进制文件：基于值编码的文件 1.3 文本文件和二进制文件 文本文件 基于字符编码，常见编码有ASCII、UNICODE等 一般可以使用文本编辑器直接打开 数5678的以ASCII存储形式(ASCII码)为：00110101 00110110 00110111 00111000 二进制文件 基于值编码,自己根据具体应用,指定某个值是什么意思 把内存中的数据按其在内存中的存储形式原样输出到磁盘上 数5678的存储形式(二进制码)为：00010110 00101110 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:1","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#二进制文件"},{"categories":["C"],"content":" 2、 文件的打开和关闭 2.1 文件指针在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。 typedef struct { short level; //缓冲区\"满\"或者\"空\"的程度 unsigned flags; //文件状态标志 char fd; //文件描述符 unsigned char hold; //如无缓冲区不读取字符 short bsize; //缓冲区的大小 unsigned char *buffer;//数据缓冲区的位置 unsigned ar; //指针，当前的指向 unsigned istemp; //临时文件，指示器 short token; //用于有效性的检查 }FILE; FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。 声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 C语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用: stdin： 标准输入，默认为当前终端（键盘），我们使用的scanf、getchar函数默认从此终端获得数据。 stdout：标准输出，默认为当前终端（屏幕），我们使用的printf、puts函数默认输出信息到此终端。 stderr：标准出错，默认为当前终端（屏幕），我们使用的perror函数默认输出信息到此终端。 2.2 文件的打开任何文件使用之前必须打开： #include \u003cstdio.h\u003e FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的模式设置 返回值： 成功：文件指针 失败：NULL 第一个参数的几种形式: FILE *fp_passwd = NULL; //相对路径： //打开当前目录passdw文件：源文件(源程序)所在目录 FILE *fp_passwd = fopen(\"passwd.txt\", \"r\"); //打开当前目录(test)下passwd.txt文件 fp_passwd = fopen(\". / test / passwd.txt\", \"r\"); //打开当前目录上一级目录（相对当前目录）passwd.txt文件 fp_passwd = fopen(\".. / passwd.txt\", \"r\"); //绝对路径： //打开C盘test目录下一个叫passwd.txt文件 fp_passwd = fopen(\"c:/test/passwd.txt\",\"r\"); 第二个参数的几种形式(打开文件的方式)： 打开模式 含义 r或rb 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） w或wb 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a或ab 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件 r+或rb+ 以可读、可写的方式打开文件(不创建新文件) w+或wb+ 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a+或ab+ 以添加方式打开可读、可写的文件。若文件不存在则创建文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留。 注意： b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的 Unix和Linux下所有的文本文件行都是\\n结尾，而Windows所有的文本文件行都是\\r\\n结尾 在Windows平台下，以“文本”方式打开文件，不加b： 当读取文件的时候，系统会将所有的 “\\r\\n” 转换成 “\\n” 当写入文件的时候，系统会将 “\\n” 转换成 “\\r\\n” 写入 以\"二进制\"方式打开文件，则读写都不会进行这样的转换 在Unix/Linux平台下，“文本”与“二进制”模式没有区别，\"\\r\\n\" 作为两个字符原样输入输出 int main(void) { FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } return 0; } 2.3 文件的关闭任何文件在使用后应该关闭： 打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存 一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用fopen打开文件会失败 如果没有明确的调用fclose关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭。 #include \u003cstdio.h\u003e int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 FILE * fp = NULL; fp = fopen(\"abc.txt\", \"r\"); fclose(fp); ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:2","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#2-文件的打开和关闭"},{"categories":["C"],"content":" 2、 文件的打开和关闭 2.1 文件指针在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。 typedef struct { short level; //缓冲区\"满\"或者\"空\"的程度 unsigned flags; //文件状态标志 char fd; //文件描述符 unsigned char hold; //如无缓冲区不读取字符 short bsize; //缓冲区的大小 unsigned char *buffer;//数据缓冲区的位置 unsigned ar; //指针，当前的指向 unsigned istemp; //临时文件，指示器 short token; //用于有效性的检查 }FILE; FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。 声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 C语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用: stdin： 标准输入，默认为当前终端（键盘），我们使用的scanf、getchar函数默认从此终端获得数据。 stdout：标准输出，默认为当前终端（屏幕），我们使用的printf、puts函数默认输出信息到此终端。 stderr：标准出错，默认为当前终端（屏幕），我们使用的perror函数默认输出信息到此终端。 2.2 文件的打开任何文件使用之前必须打开： #include FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的模式设置 返回值： 成功：文件指针 失败：NULL 第一个参数的几种形式: FILE *fp_passwd = NULL; //相对路径： //打开当前目录passdw文件：源文件(源程序)所在目录 FILE *fp_passwd = fopen(\"passwd.txt\", \"r\"); //打开当前目录(test)下passwd.txt文件 fp_passwd = fopen(\". / test / passwd.txt\", \"r\"); //打开当前目录上一级目录（相对当前目录）passwd.txt文件 fp_passwd = fopen(\".. / passwd.txt\", \"r\"); //绝对路径： //打开C盘test目录下一个叫passwd.txt文件 fp_passwd = fopen(\"c:/test/passwd.txt\",\"r\"); 第二个参数的几种形式(打开文件的方式)： 打开模式 含义 r或rb 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） w或wb 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a或ab 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件 r+或rb+ 以可读、可写的方式打开文件(不创建新文件) w+或wb+ 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a+或ab+ 以添加方式打开可读、可写的文件。若文件不存在则创建文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留。 注意： b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的 Unix和Linux下所有的文本文件行都是\\n结尾，而Windows所有的文本文件行都是\\r\\n结尾 在Windows平台下，以“文本”方式打开文件，不加b： 当读取文件的时候，系统会将所有的 “\\r\\n” 转换成 “\\n” 当写入文件的时候，系统会将 “\\n” 转换成 “\\r\\n” 写入 以\"二进制\"方式打开文件，则读写都不会进行这样的转换 在Unix/Linux平台下，“文本”与“二进制”模式没有区别，\"\\r\\n\" 作为两个字符原样输入输出 int main(void) { FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } return 0; } 2.3 文件的关闭任何文件在使用后应该关闭： 打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存 一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用fopen打开文件会失败 如果没有明确的调用fclose关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭。 #include int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 FILE * fp = NULL; fp = fopen(\"abc.txt\", \"r\"); fclose(fp); ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:2","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#21-文件指针"},{"categories":["C"],"content":" 2、 文件的打开和关闭 2.1 文件指针在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。 typedef struct { short level; //缓冲区\"满\"或者\"空\"的程度 unsigned flags; //文件状态标志 char fd; //文件描述符 unsigned char hold; //如无缓冲区不读取字符 short bsize; //缓冲区的大小 unsigned char *buffer;//数据缓冲区的位置 unsigned ar; //指针，当前的指向 unsigned istemp; //临时文件，指示器 short token; //用于有效性的检查 }FILE; FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。 声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 C语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用: stdin： 标准输入，默认为当前终端（键盘），我们使用的scanf、getchar函数默认从此终端获得数据。 stdout：标准输出，默认为当前终端（屏幕），我们使用的printf、puts函数默认输出信息到此终端。 stderr：标准出错，默认为当前终端（屏幕），我们使用的perror函数默认输出信息到此终端。 2.2 文件的打开任何文件使用之前必须打开： #include FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的模式设置 返回值： 成功：文件指针 失败：NULL 第一个参数的几种形式: FILE *fp_passwd = NULL; //相对路径： //打开当前目录passdw文件：源文件(源程序)所在目录 FILE *fp_passwd = fopen(\"passwd.txt\", \"r\"); //打开当前目录(test)下passwd.txt文件 fp_passwd = fopen(\". / test / passwd.txt\", \"r\"); //打开当前目录上一级目录（相对当前目录）passwd.txt文件 fp_passwd = fopen(\".. / passwd.txt\", \"r\"); //绝对路径： //打开C盘test目录下一个叫passwd.txt文件 fp_passwd = fopen(\"c:/test/passwd.txt\",\"r\"); 第二个参数的几种形式(打开文件的方式)： 打开模式 含义 r或rb 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） w或wb 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a或ab 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件 r+或rb+ 以可读、可写的方式打开文件(不创建新文件) w+或wb+ 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a+或ab+ 以添加方式打开可读、可写的文件。若文件不存在则创建文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留。 注意： b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的 Unix和Linux下所有的文本文件行都是\\n结尾，而Windows所有的文本文件行都是\\r\\n结尾 在Windows平台下，以“文本”方式打开文件，不加b： 当读取文件的时候，系统会将所有的 “\\r\\n” 转换成 “\\n” 当写入文件的时候，系统会将 “\\n” 转换成 “\\r\\n” 写入 以\"二进制\"方式打开文件，则读写都不会进行这样的转换 在Unix/Linux平台下，“文本”与“二进制”模式没有区别，\"\\r\\n\" 作为两个字符原样输入输出 int main(void) { FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } return 0; } 2.3 文件的关闭任何文件在使用后应该关闭： 打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存 一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用fopen打开文件会失败 如果没有明确的调用fclose关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭。 #include int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 FILE * fp = NULL; fp = fopen(\"abc.txt\", \"r\"); fclose(fp); ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:2","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#22-文件的打开"},{"categories":["C"],"content":" 2、 文件的打开和关闭 2.1 文件指针在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。 typedef struct { short level; //缓冲区\"满\"或者\"空\"的程度 unsigned flags; //文件状态标志 char fd; //文件描述符 unsigned char hold; //如无缓冲区不读取字符 short bsize; //缓冲区的大小 unsigned char *buffer;//数据缓冲区的位置 unsigned ar; //指针，当前的指向 unsigned istemp; //临时文件，指示器 short token; //用于有效性的检查 }FILE; FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。 声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 C语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用: stdin： 标准输入，默认为当前终端（键盘），我们使用的scanf、getchar函数默认从此终端获得数据。 stdout：标准输出，默认为当前终端（屏幕），我们使用的printf、puts函数默认输出信息到此终端。 stderr：标准出错，默认为当前终端（屏幕），我们使用的perror函数默认输出信息到此终端。 2.2 文件的打开任何文件使用之前必须打开： #include FILE * fopen(const char * filename, const char * mode); 功能：打开文件 参数： filename：需要打开的文件名，根据需要加上路径 mode：打开文件的模式设置 返回值： 成功：文件指针 失败：NULL 第一个参数的几种形式: FILE *fp_passwd = NULL; //相对路径： //打开当前目录passdw文件：源文件(源程序)所在目录 FILE *fp_passwd = fopen(\"passwd.txt\", \"r\"); //打开当前目录(test)下passwd.txt文件 fp_passwd = fopen(\". / test / passwd.txt\", \"r\"); //打开当前目录上一级目录（相对当前目录）passwd.txt文件 fp_passwd = fopen(\".. / passwd.txt\", \"r\"); //绝对路径： //打开C盘test目录下一个叫passwd.txt文件 fp_passwd = fopen(\"c:/test/passwd.txt\",\"r\"); 第二个参数的几种形式(打开文件的方式)： 打开模式 含义 r或rb 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） w或wb 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a或ab 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件 r+或rb+ 以可读、可写的方式打开文件(不创建新文件) w+或wb+ 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a+或ab+ 以添加方式打开可读、可写的文件。若文件不存在则创建文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留。 注意： b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的 Unix和Linux下所有的文本文件行都是\\n结尾，而Windows所有的文本文件行都是\\r\\n结尾 在Windows平台下，以“文本”方式打开文件，不加b： 当读取文件的时候，系统会将所有的 “\\r\\n” 转换成 “\\n” 当写入文件的时候，系统会将 “\\n” 转换成 “\\r\\n” 写入 以\"二进制\"方式打开文件，则读写都不会进行这样的转换 在Unix/Linux平台下，“文本”与“二进制”模式没有区别，\"\\r\\n\" 作为两个字符原样输入输出 int main(void) { FILE *fp = NULL; // \"\\\\\"这样的路径形式，只能在windows使用 // \"/\"这样的路径形式，windows和linux平台下都可用，建议使用这种 // 路径可以是相对路径，也可是绝对路径 fp = fopen(\"../test\", \"w\"); //fp = fopen(\"..\\\\test\", \"w\"); if (fp == NULL) //返回空，说明打开失败 { //perror()是标准出错打印函数，能打印调用库函数出错原因 perror(\"open\"); return -1; } return 0; } 2.3 文件的关闭任何文件在使用后应该关闭： 打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存 一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用fopen打开文件会失败 如果没有明确的调用fclose关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭。 #include int fclose(FILE * stream); 功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。 参数： stream：文件指针 返回值： 成功：0 失败：-1 FILE * fp = NULL; fp = fopen(\"abc.txt\", \"r\"); fclose(fp); ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:2","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#23-文件的关闭"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include \u003cstdio.h\u003e int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include \u003cstdio.h\u003e int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include \u003cstdio.h\u003e int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include \u003cstdio.h\u003e int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include \u003cstdio.h\u003e char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include \u003cstdio.h\u003e int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include \u003cstdio.h\u003e int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include \u003cstdio.h\u003e size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include \u003cstdio.h\u003e size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include \u003cstdio.h\u003e int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#3-文件的顺序读写"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#31-按照字符读写文件fgetcfputc"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#311写文件"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#312文件结尾"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#313读文件"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#314拷贝文件"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#32按照行读写文件fgetsfputs"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#321写文件"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#322读文件"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#323强化四则运算"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#33按照格式化文件fprintffscanf"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#331写文件"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#332读文件"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#34按照块读写文件freadfwrite"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#341写文件"},{"categories":["C"],"content":" 3 、文件的顺序读写 3.1 按照字符读写文件fgetc、fputc 3.1.1写文件 #include int fputc(int ch, FILE * stream); 功能：将ch转换为unsigned char后写入stream指定的文件中 参数： ch：需要写入文件的字符 stream：文件指针 返回值： 成功：成功写入文件的字符 失败：返回-1 char buf[] = \"this is a test for fputc\"; int i = 0; int n = strlen(buf); for (i = 0; i \u003c n; i++) { //往文件fp写入字符buf[i] int ch = fputc(buf[i], fp); printf(\"ch = %c\\n\", ch); } 3.1.2文件结尾在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。 #define EOF (-1) 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。 #include int feof(FILE * stream); 功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。 参数： stream：文件指针 返回值： 非0值：已经到文件结尾 0：没有到文件结尾 3.1.3读文件 #include int fgetc(FILE * stream); 功能：从stream指定的文件中读取一个字符 参数： stream：文件指针 返回值： 成功：返回读取到的字符 失败：-1 char ch; #if 0 while ((ch = fgetc(fp)) != EOF) { printf(\"%c\", ch); } printf(\"\\n\"); #endif while (!feof(fp)) //文件没有结束，则执行循环 { ch = fgetc(fp); printf(\"%c\", ch); } printf(\"\\n\"); 3.1.4拷贝文件 3.2按照行读写文件fgets、fputs 3.2.1写文件 #include int fputs(const char * str, FILE * stream); 功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\\0' 不写入文件。 参数： str：字符串 stream：文件指针 返回值： 成功：0 失败：-1 char *buf[] = { \"123456\\n\", \"bbbbbbbbbb\\n\", \"ccccccccccc\\n\" }; int i = 0; int n = 3; for (i = 0; i \u003c n; i++) { int len = fputs(buf[i], fp); printf(\"len = %d\\n\", len); } 3.2.2读文件 #include char * fgets(char * str, int size, FILE * stream); 功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\\0' 作为字符串结束。 参数： str：字符串 size：指定最大读取字符串的长度（size - 1） stream：文件指针 返回值： 成功：成功读取的字符串 读到文件尾或出错： NULL char buf[100] = 0; while (!feof(fp)) //文件没有结束 { memset(buf, 0, sizeof(buf)); char *p = fgets(buf, sizeof(buf), fp); if (p != NULL) { printf(\"buf = %s\", buf); } } 3.2.3强化四则运算 3.3按照格式化文件fprintf、fscanf 3.3.1写文件 #include int fprintf(FILE * stream, const char * format, ...); 功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\\0' 为止。 参数： stream：已经打开的文件 format：字符串格式，用法和printf()一样 返回值： 成功：实际写入文件的字符个数 失败：-1 fprintf(fp, \"%d %d %d\\n\", 1, 2, 3); 3.3.2读文件 #include int fscanf(FILE * stream, const char * format, ...); 功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。 参数： stream：已经打开的文件 format：字符串格式，用法和scanf()一样 返回值： 成功：参数数目，成功转换的值的个数 失败： - 1 int a = 0; int b = 0; int c = 0; fscanf(fp, \"%d %d %d\\n\", \u0026a, \u0026b, \u0026c); printf(\"a = %d, b = %d, c = %d\\n\", a, b, c); 3.4按照块读写文件fread、fwrite 3.4.1写文件 #include size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式给文件写入内容 参数： ptr：准备写入文件数据的地址 size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小 nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功写入文件数据的块数目，此值和 nmemb 相等 失败：0 typedef struct Stu { char name[50]; int id; }Stu; Stu s[3]; int i = 0; for (i = 0; i \u003c 3; i++) { sprintf(s[i].name, \"stu%d%d%d\", i, i, i); s[i].id = i + 1; } int ret = fwrite(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); 3.4.2读文件 #include size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 功能：以数据块的方式从文件中读取内容 参数： ptr：存放读取出来数据的内存空间 size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小 nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb stream：已经打开的文件指针 返回值： 成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。 失败：0 fread 是 C 语言标准库中的一个函数，用于从文件中读取二进制数据。它的原型如下： cCopy code size_t fread(void *ptr, size_t size, size_t count, FILE *stream); 这个函数的作用是从指定的文件流 stream 中读取数据，将读取的数据存储到 ptr 指向的内存块中。它的参数含义如下： ptr：指向存储读取数据的内存块的指针。 size：每个数据项的字节数。 count：要读取的数据项的数量。 stream：文件流指针，指定要读取数据的文件。 fread 函数返回实际读取的数据项的数量，如果发生错误或文件结束，返回值可能小于 count。 下面是一些关于 fread 函数的详细说明： 数据读取：fread 从文件中读取数据，并存储到 ptr 指向的内存块中。它按照每个数据项的字节数和数量来读取数据。 文件指针位置：每次调用 fread 后，文件指针会向前移动，移动的字节数等于读取的字节数。这意味着多次调用 fread 会逐渐将文件指针移动到文件的末尾。 返回值：fread 返回实际读取的数据项的数量。如果返回值小于 count，可能是因为读取到文件末尾或发生了错误。 结构体读取：可以使用 fread 一次性读取整个结构体的内容。这对于从文件中读取二进制数据结构非常有用。 下面是一个简单的示例，演示如何使用 fread 从文件中读取整数数组： cCopy code#include int main() { FILE* fp = fopen(\"data.bin\", \"rb\"","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:3","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#342读文件"},{"categories":["C"],"content":" 4、文件的随机读写 4.1 fseekfseek 是 C 语言标准库中的一个函数，用于在文件流中移动文件指针的位置。这个函数允许你在文件中的任意位置进行读写操作。它的原型如下： cCopy code int fseek(FILE *stream, long offset, int whence); 这个函数的参数含义如下： stream：文件流指针，指定要操作的文件。 offset：移动的字节数，可以是正数、负数或零。 whence ：定位的方式，可以取以下值： SEEK_SET：从文件的开头开始计算偏移（offset）。 SEEK_CUR：从当前位置开始计算偏移。 SEEK_END：从文件的末尾开始计算偏移。 fseek 返回零表示成功，非零表示失败。失败可能是因为文件指针越界或发生了其他错误。 下面是一些关于 fseek 函数的详细说明： 文件指针位置：fseek 允许你在文件中移动文件指针的位置。通过设置 offset 和 whence 参数，你可以将文件指针移动到文件的任何位置。 文件末尾定位：如果你想将文件指针移动到文件的末尾，可以使用 fseek(fp, 0, SEEK_END);。这是一个常见的用法，特别是当你需要获取文件大小时。 文件指针越界：在使用 fseek 时，要注意不要将文件指针移动到文件末尾之后。这可能导致未定义的行为。 下面是一个简单的示例，演示如何使用 fseek 在文件中定位并读取数据： cCopy code#include \u003cstdio.h\u003e int main() { FILE* fp = fopen(\"data.txt\", \"r\"); if (fp == NULL) { perror(\"Error opening file\"); return 1; } // 将文件指针移动到文件的第 10 个字节处 if (fseek(fp, 10, SEEK_SET) != 0) { perror(\"Error seeking in file\"); fclose(fp); return 1; } // 读取并打印文件中的剩余内容 int ch; while ((ch = fgetc(fp)) != EOF) { putchar(ch); } fclose(fp); return 0; } 我们打开一个文本文件，将文件指针移动到文件的第 10 个字节处，然后读取并打印文件中的剩余内容。 #include \u003cstdio.h\u003e int fseek(FILE *stream, long offset, int whence); 功能：移动文件流（文件光标）的读写位置。 参数： stream：已经打开的文件指针 offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。 whence：其取值如下： SEEK_SET：从文件开头移动offset个字节 SEEK_CUR：从当前位置移动offset个字节 SEEK_END：从文件末尾移动offset个字节 返回值： 成功：0 失败：-1 #include \u003cstdio.h\u003e long ftell(FILE *stream); 功能：获取文件流（文件光标）的读写位置。 参数： stream：已经打开的文件指针 返回值： 成功：当前文件流（文件光标）的读写位置 失败：-1 #include \u003cstdio.h\u003e void rewind(FILE *stream); 功能：把文件流（文件光标）的读写位置移动到文件开头。 参数： stream：已经打开的文件指针 返回值： 无返回值 typedef struct Stu { char name[50]; int id; }Stu; //假如已经往文件写入3个结构体 //fwrite(s, sizeof(Stu), 3, fp); Stu s[3]; Stu tmp; int ret = 0; //文件光标读写位置从开头往右移动2个结构体的位置 fseek(fp, 2 * sizeof(Stu), SEEK_SET); //读第3个结构体 ret = fread(\u0026tmp, sizeof(Stu), 1, fp); if (ret == 1) { printf(\"[tmp]%s, %d\\n\", tmp.name, tmp.id); } //把文件光标移动到文件开头 //fseek(fp, 0, SEEK_SET); rewind(fp); ret = fread(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); int i = 0; for (i = 0; i \u003c 3; i++) { printf(\"s === %s, %d\\n\", s[i].name, s[i].id); } 4.2 ftellftell 是 C 语言标准库中的一个函数，用于获取文件指针的当前位置。这个函数返回当前文件指针相对于文件起始位置的字节数。 ftell 函数的原型如下： cCopy code long ftell(FILE *stream); 这个函数的参数是一个文件流指针 stream，指定要获取位置的文件。返回值是 long 类型，表示文件指针的当前位置。如果发生错误，ftell 返回 -1L。 以下是一些关于 ftell 函数的详细说明： 文件指针位置：ftell 用于获取文件指针的当前位置，返回值表示文件指针相对于文件起始位置的字节数。 long 类型：返回值的数据类型是 long，因为文件的大小可能大于 int 能够表示的范围。 fseek 和 ftell 的组合：通常，fseek 和 ftell 一起使用，用于定位和获取文件指针的位置。fseek 用于移动文件指针，而 ftell 用于获取当前位置。 下面是一个简单的示例，演示如何使用 ftell 函数获取文件指针的当前位置： cCopy code#include \u003cstdio.h\u003e int main() { FILE* fp = fopen(\"data.txt\", \"r\"); if (fp == NULL) { perror(\"Error opening file\"); return 1; } // 使用 ftell 获取当前文件指针位置 long position = ftell(fp); if (position == -1L) { perror(\"Error getting file position\"); fclose(fp); return 1; } printf(\"Current file position: %ld\\n\", position); fclose(fp); return 0; } 在这个例子中，我们打开一个文本文件，使用 ftell 获取文件指针的当前位置，然后打印该位置。请注意，ftell 返回的值在文件指针移动后仍然有效。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:4","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#4文件的随机读写"},{"categories":["C"],"content":" 4、文件的随机读写 4.1 fseekfseek 是 C 语言标准库中的一个函数，用于在文件流中移动文件指针的位置。这个函数允许你在文件中的任意位置进行读写操作。它的原型如下： cCopy code int fseek(FILE *stream, long offset, int whence); 这个函数的参数含义如下： stream：文件流指针，指定要操作的文件。 offset：移动的字节数，可以是正数、负数或零。 whence ：定位的方式，可以取以下值： SEEK_SET：从文件的开头开始计算偏移（offset）。 SEEK_CUR：从当前位置开始计算偏移。 SEEK_END：从文件的末尾开始计算偏移。 fseek 返回零表示成功，非零表示失败。失败可能是因为文件指针越界或发生了其他错误。 下面是一些关于 fseek 函数的详细说明： 文件指针位置：fseek 允许你在文件中移动文件指针的位置。通过设置 offset 和 whence 参数，你可以将文件指针移动到文件的任何位置。 文件末尾定位：如果你想将文件指针移动到文件的末尾，可以使用 fseek(fp, 0, SEEK_END);。这是一个常见的用法，特别是当你需要获取文件大小时。 文件指针越界：在使用 fseek 时，要注意不要将文件指针移动到文件末尾之后。这可能导致未定义的行为。 下面是一个简单的示例，演示如何使用 fseek 在文件中定位并读取数据： cCopy code#include int main() { FILE* fp = fopen(\"data.txt\", \"r\"); if (fp == NULL) { perror(\"Error opening file\"); return 1; } // 将文件指针移动到文件的第 10 个字节处 if (fseek(fp, 10, SEEK_SET) != 0) { perror(\"Error seeking in file\"); fclose(fp); return 1; } // 读取并打印文件中的剩余内容 int ch; while ((ch = fgetc(fp)) != EOF) { putchar(ch); } fclose(fp); return 0; } 我们打开一个文本文件，将文件指针移动到文件的第 10 个字节处，然后读取并打印文件中的剩余内容。 #include int fseek(FILE *stream, long offset, int whence); 功能：移动文件流（文件光标）的读写位置。 参数： stream：已经打开的文件指针 offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。 whence：其取值如下： SEEK_SET：从文件开头移动offset个字节 SEEK_CUR：从当前位置移动offset个字节 SEEK_END：从文件末尾移动offset个字节 返回值： 成功：0 失败：-1 #include long ftell(FILE *stream); 功能：获取文件流（文件光标）的读写位置。 参数： stream：已经打开的文件指针 返回值： 成功：当前文件流（文件光标）的读写位置 失败：-1 #include void rewind(FILE *stream); 功能：把文件流（文件光标）的读写位置移动到文件开头。 参数： stream：已经打开的文件指针 返回值： 无返回值 typedef struct Stu { char name[50]; int id; }Stu; //假如已经往文件写入3个结构体 //fwrite(s, sizeof(Stu), 3, fp); Stu s[3]; Stu tmp; int ret = 0; //文件光标读写位置从开头往右移动2个结构体的位置 fseek(fp, 2 * sizeof(Stu), SEEK_SET); //读第3个结构体 ret = fread(\u0026tmp, sizeof(Stu), 1, fp); if (ret == 1) { printf(\"[tmp]%s, %d\\n\", tmp.name, tmp.id); } //把文件光标移动到文件开头 //fseek(fp, 0, SEEK_SET); rewind(fp); ret = fread(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); int i = 0; for (i = 0; i \u003c 3; i++) { printf(\"s === %s, %d\\n\", s[i].name, s[i].id); } 4.2 ftellftell 是 C 语言标准库中的一个函数，用于获取文件指针的当前位置。这个函数返回当前文件指针相对于文件起始位置的字节数。 ftell 函数的原型如下： cCopy code long ftell(FILE *stream); 这个函数的参数是一个文件流指针 stream，指定要获取位置的文件。返回值是 long 类型，表示文件指针的当前位置。如果发生错误，ftell 返回 -1L。 以下是一些关于 ftell 函数的详细说明： 文件指针位置：ftell 用于获取文件指针的当前位置，返回值表示文件指针相对于文件起始位置的字节数。 long 类型：返回值的数据类型是 long，因为文件的大小可能大于 int 能够表示的范围。 fseek 和 ftell 的组合：通常，fseek 和 ftell 一起使用，用于定位和获取文件指针的位置。fseek 用于移动文件指针，而 ftell 用于获取当前位置。 下面是一个简单的示例，演示如何使用 ftell 函数获取文件指针的当前位置： cCopy code#include int main() { FILE* fp = fopen(\"data.txt\", \"r\"); if (fp == NULL) { perror(\"Error opening file\"); return 1; } // 使用 ftell 获取当前文件指针位置 long position = ftell(fp); if (position == -1L) { perror(\"Error getting file position\"); fclose(fp); return 1; } printf(\"Current file position: %ld\\n\", position); fclose(fp); return 0; } 在这个例子中，我们打开一个文本文件，使用 ftell 获取文件指针的当前位置，然后打印该位置。请注意，ftell 返回的值在文件指针移动后仍然有效。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:4","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#41-fseek"},{"categories":["C"],"content":" 4、文件的随机读写 4.1 fseekfseek 是 C 语言标准库中的一个函数，用于在文件流中移动文件指针的位置。这个函数允许你在文件中的任意位置进行读写操作。它的原型如下： cCopy code int fseek(FILE *stream, long offset, int whence); 这个函数的参数含义如下： stream：文件流指针，指定要操作的文件。 offset：移动的字节数，可以是正数、负数或零。 whence ：定位的方式，可以取以下值： SEEK_SET：从文件的开头开始计算偏移（offset）。 SEEK_CUR：从当前位置开始计算偏移。 SEEK_END：从文件的末尾开始计算偏移。 fseek 返回零表示成功，非零表示失败。失败可能是因为文件指针越界或发生了其他错误。 下面是一些关于 fseek 函数的详细说明： 文件指针位置：fseek 允许你在文件中移动文件指针的位置。通过设置 offset 和 whence 参数，你可以将文件指针移动到文件的任何位置。 文件末尾定位：如果你想将文件指针移动到文件的末尾，可以使用 fseek(fp, 0, SEEK_END);。这是一个常见的用法，特别是当你需要获取文件大小时。 文件指针越界：在使用 fseek 时，要注意不要将文件指针移动到文件末尾之后。这可能导致未定义的行为。 下面是一个简单的示例，演示如何使用 fseek 在文件中定位并读取数据： cCopy code#include int main() { FILE* fp = fopen(\"data.txt\", \"r\"); if (fp == NULL) { perror(\"Error opening file\"); return 1; } // 将文件指针移动到文件的第 10 个字节处 if (fseek(fp, 10, SEEK_SET) != 0) { perror(\"Error seeking in file\"); fclose(fp); return 1; } // 读取并打印文件中的剩余内容 int ch; while ((ch = fgetc(fp)) != EOF) { putchar(ch); } fclose(fp); return 0; } 我们打开一个文本文件，将文件指针移动到文件的第 10 个字节处，然后读取并打印文件中的剩余内容。 #include int fseek(FILE *stream, long offset, int whence); 功能：移动文件流（文件光标）的读写位置。 参数： stream：已经打开的文件指针 offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。 whence：其取值如下： SEEK_SET：从文件开头移动offset个字节 SEEK_CUR：从当前位置移动offset个字节 SEEK_END：从文件末尾移动offset个字节 返回值： 成功：0 失败：-1 #include long ftell(FILE *stream); 功能：获取文件流（文件光标）的读写位置。 参数： stream：已经打开的文件指针 返回值： 成功：当前文件流（文件光标）的读写位置 失败：-1 #include void rewind(FILE *stream); 功能：把文件流（文件光标）的读写位置移动到文件开头。 参数： stream：已经打开的文件指针 返回值： 无返回值 typedef struct Stu { char name[50]; int id; }Stu; //假如已经往文件写入3个结构体 //fwrite(s, sizeof(Stu), 3, fp); Stu s[3]; Stu tmp; int ret = 0; //文件光标读写位置从开头往右移动2个结构体的位置 fseek(fp, 2 * sizeof(Stu), SEEK_SET); //读第3个结构体 ret = fread(\u0026tmp, sizeof(Stu), 1, fp); if (ret == 1) { printf(\"[tmp]%s, %d\\n\", tmp.name, tmp.id); } //把文件光标移动到文件开头 //fseek(fp, 0, SEEK_SET); rewind(fp); ret = fread(s, sizeof(Stu), 3, fp); printf(\"ret = %d\\n\", ret); int i = 0; for (i = 0; i \u003c 3; i++) { printf(\"s === %s, %d\\n\", s[i].name, s[i].id); } 4.2 ftellftell 是 C 语言标准库中的一个函数，用于获取文件指针的当前位置。这个函数返回当前文件指针相对于文件起始位置的字节数。 ftell 函数的原型如下： cCopy code long ftell(FILE *stream); 这个函数的参数是一个文件流指针 stream，指定要获取位置的文件。返回值是 long 类型，表示文件指针的当前位置。如果发生错误，ftell 返回 -1L。 以下是一些关于 ftell 函数的详细说明： 文件指针位置：ftell 用于获取文件指针的当前位置，返回值表示文件指针相对于文件起始位置的字节数。 long 类型：返回值的数据类型是 long，因为文件的大小可能大于 int 能够表示的范围。 fseek 和 ftell 的组合：通常，fseek 和 ftell 一起使用，用于定位和获取文件指针的位置。fseek 用于移动文件指针，而 ftell 用于获取当前位置。 下面是一个简单的示例，演示如何使用 ftell 函数获取文件指针的当前位置： cCopy code#include int main() { FILE* fp = fopen(\"data.txt\", \"r\"); if (fp == NULL) { perror(\"Error opening file\"); return 1; } // 使用 ftell 获取当前文件指针位置 long position = ftell(fp); if (position == -1L) { perror(\"Error getting file position\"); fclose(fp); return 1; } printf(\"Current file position: %ld\\n\", position); fclose(fp); return 0; } 在这个例子中，我们打开一个文本文件，使用 ftell 获取文件指针的当前位置，然后打印该位置。请注意，ftell 返回的值在文件指针移动后仍然有效。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:4","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#42-ftell"},{"categories":["C"],"content":" 5、获取文件状态 5.1statstat 函数是 C 语言标准库中提供的一个用于获取文件或文件系统信息的函数。它可以获取指定文件的状态信息，并将这些信息存储在一个结构体中。在 POSIX 标准中，stat 函数的原型为： cCopy code int stat(const char *path, struct stat *buf); 其中，path 是文件路径的字符串，buf 是一个指向 struct stat 结构体的指针，用于存储文件状态信息。stat 函数的返回值为 0 表示成功，-1 表示失败。 以下是关于 stat 函数的详细说明： 结构体 struct stat： struct stat 结构体包含了文件的多种属性，例如文件大小、最后修改时间、权限等。 结构体定义在头文件 sys/stat.h 中。 文件路径 path： path 参数是一个表示文件路径的字符串。 该字符串可以是相对路径或绝对路径。 成功与失败： 如果函数调用成功，返回值为 0。 如果函数调用失败，返回值为 -1，并设置全局变量 errno 表示错误的类型。 文件状态信息： struct stat 结构体中的成员用于存储文件的各种信息，0例如文件大小、权限、最后访问时间等。 常用的结构体成员包括： st_size：文件大小（字节数）。 st_mode：文件类型和权限。 st_atime：最后访问时间。 st_mtime：最后修改时间。 st_ctime：最后状态改变时间。 文件类型和权限： 文件类型和权限信息存储在 st_mode 成员中。 通过宏定义进行解析，例如 S_ISREG(mode) 判断是否是普通文件，S_ISDIR(mode) 判断是否是目录等。 下面是一个简单的示例，演示如何使用 stat 函数获取文件信息： cCopy code#include \u003cstdio.h\u003e #include \u003csys/stat.h\u003e int main() { const char *filename = \"example.txt\"; struct stat file_info; if (stat(filename, \u0026file_info) == 0) { printf(\"File size: %ld bytes\\n\", file_info.st_size); printf(\"File permissions: %o\\n\", file_info.st_mode \u0026 0777); printf(\"Last access time: %ld\\n\", file_info.st_atime); } else { perror(\"Error getting file information\"); } return 0; } 在这个例子中，我们使用 stat 函数获取了一个文件的大小、权限和最后访问时间，并打印了这些信息。请注意，为了更好地理解文件权限，我们使用了 \u0026 0777 来提取权限的部分。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:5","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#5获取文件状态"},{"categories":["C"],"content":" 5、获取文件状态 5.1statstat 函数是 C 语言标准库中提供的一个用于获取文件或文件系统信息的函数。它可以获取指定文件的状态信息，并将这些信息存储在一个结构体中。在 POSIX 标准中，stat 函数的原型为： cCopy code int stat(const char *path, struct stat *buf); 其中，path 是文件路径的字符串，buf 是一个指向 struct stat 结构体的指针，用于存储文件状态信息。stat 函数的返回值为 0 表示成功，-1 表示失败。 以下是关于 stat 函数的详细说明： 结构体 struct stat： struct stat 结构体包含了文件的多种属性，例如文件大小、最后修改时间、权限等。 结构体定义在头文件 sys/stat.h 中。 文件路径 path： path 参数是一个表示文件路径的字符串。 该字符串可以是相对路径或绝对路径。 成功与失败： 如果函数调用成功，返回值为 0。 如果函数调用失败，返回值为 -1，并设置全局变量 errno 表示错误的类型。 文件状态信息： struct stat 结构体中的成员用于存储文件的各种信息，0例如文件大小、权限、最后访问时间等。 常用的结构体成员包括： st_size：文件大小（字节数）。 st_mode：文件类型和权限。 st_atime：最后访问时间。 st_mtime：最后修改时间。 st_ctime：最后状态改变时间。 文件类型和权限： 文件类型和权限信息存储在 st_mode 成员中。 通过宏定义进行解析，例如 S_ISREG(mode) 判断是否是普通文件，S_ISDIR(mode) 判断是否是目录等。 下面是一个简单的示例，演示如何使用 stat 函数获取文件信息： cCopy code#include #include int main() { const char *filename = \"example.txt\"; struct stat file_info; if (stat(filename, \u0026file_info) == 0) { printf(\"File size: %ld bytes\\n\", file_info.st_size); printf(\"File permissions: %o\\n\", file_info.st_mode \u0026 0777); printf(\"Last access time: %ld\\n\", file_info.st_atime); } else { perror(\"Error getting file information\"); } return 0; } 在这个例子中，我们使用 stat 函数获取了一个文件的大小、权限和最后访问时间，并打印了这些信息。请注意，为了更好地理解文件权限，我们使用了 \u0026 0777 来提取权限的部分。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:5","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#51stat"},{"categories":["C"],"content":" 6、删除和重命名文件remove 和 rename 是 C 语言标准库中用于文件操作的两个函数。 6.1 removeremove 函数用于删除指定的文件。其原型如下： cCopy code int remove(const char *filename); filename 参数是一个字符串，表示要删除的文件的路径。 返回值为 0 表示删除成功，-1 表示删除失败。在删除失败时，全局变量 errno 会被设置以指示具体的错误原因。 示例： cCopy code#include \u003cstdio.h\u003e int main() { const char *filename = \"example.txt\"; if (remove(filename) == 0) { printf(\"File '%s' deleted successfully.\\n\", filename); } else { perror(\"Error deleting file\"); } return 0; } 6.2 rename 函数rename 函数用于更改文件的名称或移动文件。其原型如下： cCopy code int rename(const char *old_filename, const char *new_filename); old_filename 参数是一个字符串，表示要更改的文件的路径。 new_filename 参数是一个字符串，表示文件的新路径或新名称。 返回值为 0 表示更名成功，-1 表示更名失败。在失败时，errno 会被设置以指示错误原因。 示例： cCopy code#include \u003cstdio.h\u003e int main() { const char *old_filename = \"old.txt\"; const char *new_filename = \"new.txt\"; if (rename(old_filename, new_filename) == 0) { printf(\"File '%s' renamed to '%s' successfully.\\n\", old_filename, new_filename); } else { perror(\"Error renaming file\"); } return 0; } 这两个函数在文件操作中很有用，remove 可用于删除文件，而 rename 可用于更改文件的名称或将文件移动到不同的位置。请注意，rename 函数也可以用于移动文件，通过将文件的新路径作为目标路径传递给 rename。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:6","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#6删除和重命名文件"},{"categories":["C"],"content":" 6、删除和重命名文件remove 和 rename 是 C 语言标准库中用于文件操作的两个函数。 6.1 removeremove 函数用于删除指定的文件。其原型如下： cCopy code int remove(const char *filename); filename 参数是一个字符串，表示要删除的文件的路径。 返回值为 0 表示删除成功，-1 表示删除失败。在删除失败时，全局变量 errno 会被设置以指示具体的错误原因。 示例： cCopy code#include int main() { const char *filename = \"example.txt\"; if (remove(filename) == 0) { printf(\"File '%s' deleted successfully.\\n\", filename); } else { perror(\"Error deleting file\"); } return 0; } 6.2 rename 函数rename 函数用于更改文件的名称或移动文件。其原型如下： cCopy code int rename(const char *old_filename, const char *new_filename); old_filename 参数是一个字符串，表示要更改的文件的路径。 new_filename 参数是一个字符串，表示文件的新路径或新名称。 返回值为 0 表示更名成功，-1 表示更名失败。在失败时，errno 会被设置以指示错误原因。 示例： cCopy code#include int main() { const char *old_filename = \"old.txt\"; const char *new_filename = \"new.txt\"; if (rename(old_filename, new_filename) == 0) { printf(\"File '%s' renamed to '%s' successfully.\\n\", old_filename, new_filename); } else { perror(\"Error renaming file\"); } return 0; } 这两个函数在文件操作中很有用，remove 可用于删除文件，而 rename 可用于更改文件的名称或将文件移动到不同的位置。请注意，rename 函数也可以用于移动文件，通过将文件的新路径作为目标路径传递给 rename。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:6","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#61-remove"},{"categories":["C"],"content":" 6、删除和重命名文件remove 和 rename 是 C 语言标准库中用于文件操作的两个函数。 6.1 removeremove 函数用于删除指定的文件。其原型如下： cCopy code int remove(const char *filename); filename 参数是一个字符串，表示要删除的文件的路径。 返回值为 0 表示删除成功，-1 表示删除失败。在删除失败时，全局变量 errno 会被设置以指示具体的错误原因。 示例： cCopy code#include int main() { const char *filename = \"example.txt\"; if (remove(filename) == 0) { printf(\"File '%s' deleted successfully.\\n\", filename); } else { perror(\"Error deleting file\"); } return 0; } 6.2 rename 函数rename 函数用于更改文件的名称或移动文件。其原型如下： cCopy code int rename(const char *old_filename, const char *new_filename); old_filename 参数是一个字符串，表示要更改的文件的路径。 new_filename 参数是一个字符串，表示文件的新路径或新名称。 返回值为 0 表示更名成功，-1 表示更名失败。在失败时，errno 会被设置以指示错误原因。 示例： cCopy code#include int main() { const char *old_filename = \"old.txt\"; const char *new_filename = \"new.txt\"; if (rename(old_filename, new_filename) == 0) { printf(\"File '%s' renamed to '%s' successfully.\\n\", old_filename, new_filename); } else { perror(\"Error renaming file\"); } return 0; } 这两个函数在文件操作中很有用，remove 可用于删除文件，而 rename 可用于更改文件的名称或将文件移动到不同的位置。请注意，rename 函数也可以用于移动文件，通过将文件的新路径作为目标路径传递给 rename。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:6","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#62-rename-函数"},{"categories":["C"],"content":" 7、文件缓冲区文件缓冲区是指对文件读写操作进行缓冲管理的一块内存区域。在 C 语言中，标准库提供了一套 I/O 缓冲机制，主要通过 FILE 结构体中的缓冲区来实现。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:7","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#7文件缓冲区"},{"categories":["C"],"content":" 文件缓冲类型 全缓冲（Fully Buffered）： 当文件大小超过一定阈值时，标准 I/O 库采用全缓冲，即在内存中为文件分配一个大的缓冲区，多次读写操作都在这个缓冲区中进行，减少了系统调用的次数，提高了性能。 FILE 结构体中的缓冲区通过 setvbuf 函数进行设置。 行缓冲（Line Buffered）： 当文件是一个终端设备（例如终端或控制台）时，标准 I/O 库采用行缓冲，即每次读写操作都以换行符为界进行缓冲，或者当缓冲区满时进行缓冲。 对于标准输入和标准输出，默认是行缓冲，但可以通过 setvbuf 函数进行更改。 无缓冲（Unbuffered）： 当文件是一个字符设备（例如终端）且是单字符 I/O 操作时，标准 I/O 库采用无缓冲。 无缓冲模式下，每个字符都立即进行 I/O 操作。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:8","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#文件缓冲类型"},{"categories":["C"],"content":" 问题与注意事项 文件关闭时刷新缓冲： 在关闭文件之前，标准 I/O 库会尝试刷新缓冲区，将缓冲区中的内容写入文件。 强制刷新缓冲： 使用 fflush 函数可以强制刷新文件缓冲区。 缓冲区溢出： 当进行写操作时，如果缓冲区满了，或者调用 fflush，或者文件关闭时，都会导致缓冲区被刷新。如果数据量过大，可能导致缓冲区溢出。 定向 I/O 函数： fseek, ftell, rewind 等定向 I/O 函数可能会影响缓冲区的状态。例如，使用 fseek 定位到文件中某个位置时，fflush 可能会被调用。 线程安全性： 默认情况下，标准 I/O 操作是不线程安全的。在多线程环境中，要注意使用 flockfile 和 funlockfile 来保护对同一文件流的并发访问。 强制关闭文件流： 使用 fclose 关闭文件时，系统会尝试刷新缓冲区。如果强制关闭程序（例如使用 exit 函数），则可能导致缓冲区未刷新。 总体而言，理解文件缓冲的工作机制并注意缓冲区的刷新是确保文件操作正确和高效的关键。根据应用的特定需求，可以通过 setvbuf 函数来调整文件缓冲类型。 ","date":"2023-12-31","objectID":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:9","series":null,"tags":["C"],"title":"文件操作","uri":"/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/#问题与注意事项"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include\u003cstdio.h\u003e #include\u003cstring.h\u003e //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include \u003cstdio.h\u003e //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include \u003cstdio.h\u003e struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include\u003cstdio.h\u003e #include\u003cstring.h\u003e //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include\u003cstdio.h\u003e //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include\u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include\u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include\u003cstdio.h\u003e #include \u003cstring.h\u003e //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#复合类型自定义类型"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#1结构体"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#11概述"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#12-结构体变量的定义和初始化"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#13-结构体成员的使用"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#14-结构体数组"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#15-结构体套结构体"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#16-结构体赋值"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#17-结构体和指针"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#171结构体指针"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#172结构体套指针"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#18-结构体做函数参数"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#181结构体普通变量做函数参数"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#182结构体指针变量做函数参数"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#183结构体数组名做函数参数"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#184const修饰结构体指针形参变量"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#2共用体联合"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#3枚举"},{"categories":["C"],"content":" 复合类型（自定义类型） 1、结构体 1.1概述数组：描述一组具有相同类型数据的有序集合，用于处理大量相同类型的数据运算。 有时我们需要将不同类型的数据组合成一个有机的整体，如：一个学生有学号/姓名/性别/年龄/地址等属性。显然单独定义以上变量比较繁琐，数据不便于管理。 Ｃ语言中给出了另一种构造数据类型——结构体。 1.2 结构体变量的定义和初始化定义结构体变量的方式： 先声明结构体类型再定义变量名 在声明类型的同时定义变量 直接定义结构体类型变量（无类型名） 结构体类型和结构体变量关系： l 结构体类型：指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元。 l 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间。 //结构体类型的定义 struct stu { char name[50]; int age; }; //先定义类型，再定义变量（常用） struct stu s1 = { \"mike\", 18 }; //定义类型同时定义变量 struct stu2 { char name[50]; int age; }s2 = { \"lily\", 22 }; struct { char name[50]; int age; }s3 = { \"yuri\", 25 }; 1.3 结构体成员的使用 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //如果是指针变量，通过-\u003e操作结构体成员 strcpy((\u0026s1)-\u003ename, \"test\"); (\u0026s1)-\u003eage = 22; printf(\"(\u0026s1)-\u003ename = %s, (\u0026s1)-\u003eage = %d\\n\", (\u0026s1)-\u003ename, (\u0026s1)-\u003eage); return 0; } 1.4 结构体数组 #include //统计学生成绩 struct stu { int num; char name[20]; char sex; float score; }; int main() { //定义一个含有5个元素的结构体数组并将其初始化 struct stu boy[5] = { { 101, \"Li ping\", 'M', 45 }, { 102, \"Zhang ping\", 'M', 62.5 }, { 103, \"He fang\", 'F', 92.5 }, { 104, \"Cheng ling\", 'F', 87 }, { 105, \"Wang ming\", 'M', 58 }}; int i = 0; int c = 0; float ave, s = 0; for (i = 0; i \u003c 5; i++) { s += boy[i].score; //计算总分 if (boy[i].score \u003c 60) { c += 1; //统计不及格人的分数 } } printf(\"s=%f\\n\", s);//打印总分数 ave = s / 5; //计算平均分数 printf(\"average=%f\\ncount=%d\\n\\n\", ave, c); //打印平均分与不及格人数 for (i = 0; i \u003c 5; i++) { printf(\" name=%s, score=%f\\n\", boy[i].name, boy[i].score); // printf(\" name=%s, score=%f\\n\", (boy+i)-\u003ename, (boy+i)-\u003escore); } return 0; } 1.5 结构体套结构体 #include struct person { char name[20]; char sex; }; struct stu { int id; struct person info; }; int main() { struct stu s[2] = { 1, \"lily\", 'F', 2, \"yuri\", 'M' }; int i = 0; for (i = 0; i \u003c 2; i++) { printf(\"id = %d\\tinfo.name=%s\\tinfo.sex=%c\\n\", s[i].id, s[i].info.name, s[i].info.sex); } return 0; } 1.6 结构体赋值 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1; //如果是普通变量，通过点运算符操作结构体成员 strcpy(s1.name, \"abc\"); s1.age = 18; printf(\"s1.name = %s, s1.age = %d\\n\", s1.name, s1.age); //相同类型的两个结构体变量，可以相互赋值 //把s1成员变量的值拷贝给s2成员变量的内存 //s1和s2只是成员变量的值一样而已，它们还是没有关系的两个变量 struct stu s2 = s1; //memcpy(\u0026s2, \u0026s1, sizeof(s1)); printf(\"s2.name = %s, s2.age = %d\\n\", s2.name, s2.age); return 0; } 1.7 结构体和指针 1.7.1结构体指针 #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu s1 = { \"lily\", 18 }; //如果是指针变量，通过-\u003e操作结构体成员 struct stu *p = \u0026s1; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); return 0; } #include #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); //如果是指针变量，通过-\u003e操作结构体成员 strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); free(p); p = NULL; return 0; } 1.7.2结构体套指针 #include #include #include //结构体类型的定义 struct stu { char *name; //一级指针 int age; }; int main() { struct stu *p = NULL; p = (struct stu *)malloc(sizeof(struct stu)); p-\u003ename = malloc(strlen(\"test\") + 1); strcpy(p-\u003ename, \"test\"); p-\u003eage = 22; printf(\"p-\u003ename = %s, p-\u003eage=%d\\n\", p-\u003ename, p-\u003eage); printf(\"(*p).name = %s, (*p).age=%d\\n\", (*p).name, (*p).age); if (p-\u003ename != NULL) { free(p-\u003ename); p-\u003ename = NULL; } if (p != NULL) { free(p); p = NULL; } return 0; } 1.8 结构体做函数参数 1.8.1结构体普通变量做函数参数 #include #include //结构体类型的定义 struct stu { char name[50]; int age; }; //函数参数为结构体普通变量 void set_stu(struct stu tmp) { strcpy(tmp.name, \"mike\"); tmp.age = 18; printf(\"tmp.name = %s, tmp.age = %d\\n\", tmp.name, tmp.age); } int main() { struct stu s = { 0 }; set_stu(s); //值传递 printf(\"","date":"2023-12-31","objectID":"/%E7%BB%93%E6%9E%84%E4%BD%93/:0:1","series":null,"tags":["C"],"title":"结构体","uri":"/%E7%BB%93%E6%9E%84%E4%BD%93/#4typedef命名"},{"categories":["C"],"content":"extern，静态函数，，内存操作函数（memset,memcpy） ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:0","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#"},{"categories":["C"],"content":" 1、概念 1.1局部变量 定义： 局部变量是在函数内部声明的变量，只在声明它的函数中可见。 生命周期： 局部变量的生命周期从声明开始，到函数执行结束。每次函数被调用时，都会创建新的局部变量。 示例： cCopy code#include \u003cstdio.h\u003e void exampleFunction() { int localVar = 42; // 局部变量 printf(\"Local Variable: %d\\n\", localVar); } int main() { exampleFunction(); // 下面的语句将会引发编译错误，因为 localVar 只在 exampleFunction 函数中可见 // printf(\"Trying to access local variable outside the function: %d\\n\", localVar); return 0; } 1.2静态局部变量 定义： 静态局部变量是在函数内部声明的，但使用 static 关键字修饰的变量。与普通局部变量不同，静态局部变量的生命周期在整个程序运行期间，而不是在函数执行期间。 生命周期： 静态局部变量的生命周期从程序开始运行到结束，但它仍然只在声明它的函数中可见。 示例： cCopy code#include \u003cstdio.h\u003e void exampleFunction() { static int staticLocalVar = 42; // 静态局部变量 printf(\"Static Local Variable: %d\\n\", staticLocalVar); // 修改静态局部变量的值，下次函数调用时保留修改后的值 staticLocalVar++; } int main() { exampleFunction(); exampleFunction(); exampleFunction(); return 0; } 1.3全局变量 定义： 全局变量是在函数外部声明的变量，它可以在整个程序中的任何位置访问。 生命周期： 全局变量的生命周期从程序开始运行到结束。 示例： cCopy code#include \u003cstdio.h\u003e int globalVar = 100; // 全局变量 void exampleFunction() { printf(\"Global Variable: %d\\n\", globalVar); } int main() { exampleFunction(); // 修改全局变量的值，其他函数调用时将反映修改后的值 globalVar = 200; exampleFunction(); return 0; } 1.4静态全局变量 定义： 静态全局变量是在文件的顶部声明的，使用 static 关键字修饰的全局变量。它在整个文件中可见，但对其他文件是不可见的。 生命周期： 静态全局变量的生命周期从程序开始运行到结束。 示例： cCopy code// 文件1.c #include \u003cstdio.h\u003e static int staticGlobalVar = 500; // 静态全局变量 void exampleFunction() { printf(\"Static Global Variable: %d\\n\", staticGlobalVar); } // 文件2.c #include \u003cstdio.h\u003e extern void exampleFunction(); // 外部声明，使得其他文件可以访问 exampleFunction int main() { exampleFunction(); return 0; } 这些变量的作用域和生命周期不同，选择使用哪种类型取决于程序的需求。要注意，全局变量和静态全局变量可能导致程序的可维护性降低，因为它们在整个程序中可见，可能被多个函数修改。因此，在使用全局变量时应当谨慎，优先考虑使用函数的参数传递和返回值传递数据。 1.5内存泄漏内存泄漏是指程序在运行时分配了一块内存，但在不再使用它时没有释放或回收这块内存的情况。内存泄漏可能导致程序使用的内存逐渐增加，最终耗尽系统的可用内存，导致程序崩溃或系统变得不稳定。内存泄漏是一种常见的程序错误，因此在编写代码时需要特别注意动态内存的管理。 以下是一个简单的例子，演示了内存泄漏的情况： cCopy code#include \u003cstdlib.h\u003e void memoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 不释放内存，导致内存泄漏 } int main() { memoryLeakExample(); // 主函数结束，程序退出，但动态分配的内存没有被释放 // 这会导致内存泄漏，因为无法再访问该内存并释放它 return 0; } 在这个例子中，memoryLeakExample 函数动态分配了一块整数大小的内存，但没有在函数结束时释放它。当程序运行时调用 memoryLeakExample 函数后，动态分配的内存就会变成不可访问，而系统无法再回收这块内存。这就是典型的内存泄漏情况。 为了避免内存泄漏，程序员通常应该确保在不再需要使用动态分配的内存时，通过调用 free 函数来释放它。修改上述代码如下： cCopy code#include \u003cstdlib.h\u003e void noMemoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 使用内存... // 释放内存 free(ptr); } int main() { noMemoryLeakExample(); // 内存在函数调用结束时得到释放，避免了内存泄漏 return 0; } 在这个修改后的例子中，动态分配的内存在函数结束时被正确释放，从而避免了内存泄漏。 ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:1","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#1概念"},{"categories":["C"],"content":" 1、概念 1.1局部变量 定义： 局部变量是在函数内部声明的变量，只在声明它的函数中可见。 生命周期： 局部变量的生命周期从声明开始，到函数执行结束。每次函数被调用时，都会创建新的局部变量。 示例： cCopy code#include void exampleFunction() { int localVar = 42; // 局部变量 printf(\"Local Variable: %d\\n\", localVar); } int main() { exampleFunction(); // 下面的语句将会引发编译错误，因为 localVar 只在 exampleFunction 函数中可见 // printf(\"Trying to access local variable outside the function: %d\\n\", localVar); return 0; } 1.2静态局部变量 定义： 静态局部变量是在函数内部声明的，但使用 static 关键字修饰的变量。与普通局部变量不同，静态局部变量的生命周期在整个程序运行期间，而不是在函数执行期间。 生命周期： 静态局部变量的生命周期从程序开始运行到结束，但它仍然只在声明它的函数中可见。 示例： cCopy code#include void exampleFunction() { static int staticLocalVar = 42; // 静态局部变量 printf(\"Static Local Variable: %d\\n\", staticLocalVar); // 修改静态局部变量的值，下次函数调用时保留修改后的值 staticLocalVar++; } int main() { exampleFunction(); exampleFunction(); exampleFunction(); return 0; } 1.3全局变量 定义： 全局变量是在函数外部声明的变量，它可以在整个程序中的任何位置访问。 生命周期： 全局变量的生命周期从程序开始运行到结束。 示例： cCopy code#include int globalVar = 100; // 全局变量 void exampleFunction() { printf(\"Global Variable: %d\\n\", globalVar); } int main() { exampleFunction(); // 修改全局变量的值，其他函数调用时将反映修改后的值 globalVar = 200; exampleFunction(); return 0; } 1.4静态全局变量 定义： 静态全局变量是在文件的顶部声明的，使用 static 关键字修饰的全局变量。它在整个文件中可见，但对其他文件是不可见的。 生命周期： 静态全局变量的生命周期从程序开始运行到结束。 示例： cCopy code// 文件1.c #include static int staticGlobalVar = 500; // 静态全局变量 void exampleFunction() { printf(\"Static Global Variable: %d\\n\", staticGlobalVar); } // 文件2.c #include extern void exampleFunction(); // 外部声明，使得其他文件可以访问 exampleFunction int main() { exampleFunction(); return 0; } 这些变量的作用域和生命周期不同，选择使用哪种类型取决于程序的需求。要注意，全局变量和静态全局变量可能导致程序的可维护性降低，因为它们在整个程序中可见，可能被多个函数修改。因此，在使用全局变量时应当谨慎，优先考虑使用函数的参数传递和返回值传递数据。 1.5内存泄漏内存泄漏是指程序在运行时分配了一块内存，但在不再使用它时没有释放或回收这块内存的情况。内存泄漏可能导致程序使用的内存逐渐增加，最终耗尽系统的可用内存，导致程序崩溃或系统变得不稳定。内存泄漏是一种常见的程序错误，因此在编写代码时需要特别注意动态内存的管理。 以下是一个简单的例子，演示了内存泄漏的情况： cCopy code#include void memoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 不释放内存，导致内存泄漏 } int main() { memoryLeakExample(); // 主函数结束，程序退出，但动态分配的内存没有被释放 // 这会导致内存泄漏，因为无法再访问该内存并释放它 return 0; } 在这个例子中，memoryLeakExample 函数动态分配了一块整数大小的内存，但没有在函数结束时释放它。当程序运行时调用 memoryLeakExample 函数后，动态分配的内存就会变成不可访问，而系统无法再回收这块内存。这就是典型的内存泄漏情况。 为了避免内存泄漏，程序员通常应该确保在不再需要使用动态分配的内存时，通过调用 free 函数来释放它。修改上述代码如下： cCopy code#include void noMemoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 使用内存... // 释放内存 free(ptr); } int main() { noMemoryLeakExample(); // 内存在函数调用结束时得到释放，避免了内存泄漏 return 0; } 在这个修改后的例子中，动态分配的内存在函数结束时被正确释放，从而避免了内存泄漏。 ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:1","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#11局部变量"},{"categories":["C"],"content":" 1、概念 1.1局部变量 定义： 局部变量是在函数内部声明的变量，只在声明它的函数中可见。 生命周期： 局部变量的生命周期从声明开始，到函数执行结束。每次函数被调用时，都会创建新的局部变量。 示例： cCopy code#include void exampleFunction() { int localVar = 42; // 局部变量 printf(\"Local Variable: %d\\n\", localVar); } int main() { exampleFunction(); // 下面的语句将会引发编译错误，因为 localVar 只在 exampleFunction 函数中可见 // printf(\"Trying to access local variable outside the function: %d\\n\", localVar); return 0; } 1.2静态局部变量 定义： 静态局部变量是在函数内部声明的，但使用 static 关键字修饰的变量。与普通局部变量不同，静态局部变量的生命周期在整个程序运行期间，而不是在函数执行期间。 生命周期： 静态局部变量的生命周期从程序开始运行到结束，但它仍然只在声明它的函数中可见。 示例： cCopy code#include void exampleFunction() { static int staticLocalVar = 42; // 静态局部变量 printf(\"Static Local Variable: %d\\n\", staticLocalVar); // 修改静态局部变量的值，下次函数调用时保留修改后的值 staticLocalVar++; } int main() { exampleFunction(); exampleFunction(); exampleFunction(); return 0; } 1.3全局变量 定义： 全局变量是在函数外部声明的变量，它可以在整个程序中的任何位置访问。 生命周期： 全局变量的生命周期从程序开始运行到结束。 示例： cCopy code#include int globalVar = 100; // 全局变量 void exampleFunction() { printf(\"Global Variable: %d\\n\", globalVar); } int main() { exampleFunction(); // 修改全局变量的值，其他函数调用时将反映修改后的值 globalVar = 200; exampleFunction(); return 0; } 1.4静态全局变量 定义： 静态全局变量是在文件的顶部声明的，使用 static 关键字修饰的全局变量。它在整个文件中可见，但对其他文件是不可见的。 生命周期： 静态全局变量的生命周期从程序开始运行到结束。 示例： cCopy code// 文件1.c #include static int staticGlobalVar = 500; // 静态全局变量 void exampleFunction() { printf(\"Static Global Variable: %d\\n\", staticGlobalVar); } // 文件2.c #include extern void exampleFunction(); // 外部声明，使得其他文件可以访问 exampleFunction int main() { exampleFunction(); return 0; } 这些变量的作用域和生命周期不同，选择使用哪种类型取决于程序的需求。要注意，全局变量和静态全局变量可能导致程序的可维护性降低，因为它们在整个程序中可见，可能被多个函数修改。因此，在使用全局变量时应当谨慎，优先考虑使用函数的参数传递和返回值传递数据。 1.5内存泄漏内存泄漏是指程序在运行时分配了一块内存，但在不再使用它时没有释放或回收这块内存的情况。内存泄漏可能导致程序使用的内存逐渐增加，最终耗尽系统的可用内存，导致程序崩溃或系统变得不稳定。内存泄漏是一种常见的程序错误，因此在编写代码时需要特别注意动态内存的管理。 以下是一个简单的例子，演示了内存泄漏的情况： cCopy code#include void memoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 不释放内存，导致内存泄漏 } int main() { memoryLeakExample(); // 主函数结束，程序退出，但动态分配的内存没有被释放 // 这会导致内存泄漏，因为无法再访问该内存并释放它 return 0; } 在这个例子中，memoryLeakExample 函数动态分配了一块整数大小的内存，但没有在函数结束时释放它。当程序运行时调用 memoryLeakExample 函数后，动态分配的内存就会变成不可访问，而系统无法再回收这块内存。这就是典型的内存泄漏情况。 为了避免内存泄漏，程序员通常应该确保在不再需要使用动态分配的内存时，通过调用 free 函数来释放它。修改上述代码如下： cCopy code#include void noMemoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 使用内存... // 释放内存 free(ptr); } int main() { noMemoryLeakExample(); // 内存在函数调用结束时得到释放，避免了内存泄漏 return 0; } 在这个修改后的例子中，动态分配的内存在函数结束时被正确释放，从而避免了内存泄漏。 ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:1","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#12静态局部变量"},{"categories":["C"],"content":" 1、概念 1.1局部变量 定义： 局部变量是在函数内部声明的变量，只在声明它的函数中可见。 生命周期： 局部变量的生命周期从声明开始，到函数执行结束。每次函数被调用时，都会创建新的局部变量。 示例： cCopy code#include void exampleFunction() { int localVar = 42; // 局部变量 printf(\"Local Variable: %d\\n\", localVar); } int main() { exampleFunction(); // 下面的语句将会引发编译错误，因为 localVar 只在 exampleFunction 函数中可见 // printf(\"Trying to access local variable outside the function: %d\\n\", localVar); return 0; } 1.2静态局部变量 定义： 静态局部变量是在函数内部声明的，但使用 static 关键字修饰的变量。与普通局部变量不同，静态局部变量的生命周期在整个程序运行期间，而不是在函数执行期间。 生命周期： 静态局部变量的生命周期从程序开始运行到结束，但它仍然只在声明它的函数中可见。 示例： cCopy code#include void exampleFunction() { static int staticLocalVar = 42; // 静态局部变量 printf(\"Static Local Variable: %d\\n\", staticLocalVar); // 修改静态局部变量的值，下次函数调用时保留修改后的值 staticLocalVar++; } int main() { exampleFunction(); exampleFunction(); exampleFunction(); return 0; } 1.3全局变量 定义： 全局变量是在函数外部声明的变量，它可以在整个程序中的任何位置访问。 生命周期： 全局变量的生命周期从程序开始运行到结束。 示例： cCopy code#include int globalVar = 100; // 全局变量 void exampleFunction() { printf(\"Global Variable: %d\\n\", globalVar); } int main() { exampleFunction(); // 修改全局变量的值，其他函数调用时将反映修改后的值 globalVar = 200; exampleFunction(); return 0; } 1.4静态全局变量 定义： 静态全局变量是在文件的顶部声明的，使用 static 关键字修饰的全局变量。它在整个文件中可见，但对其他文件是不可见的。 生命周期： 静态全局变量的生命周期从程序开始运行到结束。 示例： cCopy code// 文件1.c #include static int staticGlobalVar = 500; // 静态全局变量 void exampleFunction() { printf(\"Static Global Variable: %d\\n\", staticGlobalVar); } // 文件2.c #include extern void exampleFunction(); // 外部声明，使得其他文件可以访问 exampleFunction int main() { exampleFunction(); return 0; } 这些变量的作用域和生命周期不同，选择使用哪种类型取决于程序的需求。要注意，全局变量和静态全局变量可能导致程序的可维护性降低，因为它们在整个程序中可见，可能被多个函数修改。因此，在使用全局变量时应当谨慎，优先考虑使用函数的参数传递和返回值传递数据。 1.5内存泄漏内存泄漏是指程序在运行时分配了一块内存，但在不再使用它时没有释放或回收这块内存的情况。内存泄漏可能导致程序使用的内存逐渐增加，最终耗尽系统的可用内存，导致程序崩溃或系统变得不稳定。内存泄漏是一种常见的程序错误，因此在编写代码时需要特别注意动态内存的管理。 以下是一个简单的例子，演示了内存泄漏的情况： cCopy code#include void memoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 不释放内存，导致内存泄漏 } int main() { memoryLeakExample(); // 主函数结束，程序退出，但动态分配的内存没有被释放 // 这会导致内存泄漏，因为无法再访问该内存并释放它 return 0; } 在这个例子中，memoryLeakExample 函数动态分配了一块整数大小的内存，但没有在函数结束时释放它。当程序运行时调用 memoryLeakExample 函数后，动态分配的内存就会变成不可访问，而系统无法再回收这块内存。这就是典型的内存泄漏情况。 为了避免内存泄漏，程序员通常应该确保在不再需要使用动态分配的内存时，通过调用 free 函数来释放它。修改上述代码如下： cCopy code#include void noMemoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 使用内存... // 释放内存 free(ptr); } int main() { noMemoryLeakExample(); // 内存在函数调用结束时得到释放，避免了内存泄漏 return 0; } 在这个修改后的例子中，动态分配的内存在函数结束时被正确释放，从而避免了内存泄漏。 ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:1","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#13全局变量"},{"categories":["C"],"content":" 1、概念 1.1局部变量 定义： 局部变量是在函数内部声明的变量，只在声明它的函数中可见。 生命周期： 局部变量的生命周期从声明开始，到函数执行结束。每次函数被调用时，都会创建新的局部变量。 示例： cCopy code#include void exampleFunction() { int localVar = 42; // 局部变量 printf(\"Local Variable: %d\\n\", localVar); } int main() { exampleFunction(); // 下面的语句将会引发编译错误，因为 localVar 只在 exampleFunction 函数中可见 // printf(\"Trying to access local variable outside the function: %d\\n\", localVar); return 0; } 1.2静态局部变量 定义： 静态局部变量是在函数内部声明的，但使用 static 关键字修饰的变量。与普通局部变量不同，静态局部变量的生命周期在整个程序运行期间，而不是在函数执行期间。 生命周期： 静态局部变量的生命周期从程序开始运行到结束，但它仍然只在声明它的函数中可见。 示例： cCopy code#include void exampleFunction() { static int staticLocalVar = 42; // 静态局部变量 printf(\"Static Local Variable: %d\\n\", staticLocalVar); // 修改静态局部变量的值，下次函数调用时保留修改后的值 staticLocalVar++; } int main() { exampleFunction(); exampleFunction(); exampleFunction(); return 0; } 1.3全局变量 定义： 全局变量是在函数外部声明的变量，它可以在整个程序中的任何位置访问。 生命周期： 全局变量的生命周期从程序开始运行到结束。 示例： cCopy code#include int globalVar = 100; // 全局变量 void exampleFunction() { printf(\"Global Variable: %d\\n\", globalVar); } int main() { exampleFunction(); // 修改全局变量的值，其他函数调用时将反映修改后的值 globalVar = 200; exampleFunction(); return 0; } 1.4静态全局变量 定义： 静态全局变量是在文件的顶部声明的，使用 static 关键字修饰的全局变量。它在整个文件中可见，但对其他文件是不可见的。 生命周期： 静态全局变量的生命周期从程序开始运行到结束。 示例： cCopy code// 文件1.c #include static int staticGlobalVar = 500; // 静态全局变量 void exampleFunction() { printf(\"Static Global Variable: %d\\n\", staticGlobalVar); } // 文件2.c #include extern void exampleFunction(); // 外部声明，使得其他文件可以访问 exampleFunction int main() { exampleFunction(); return 0; } 这些变量的作用域和生命周期不同，选择使用哪种类型取决于程序的需求。要注意，全局变量和静态全局变量可能导致程序的可维护性降低，因为它们在整个程序中可见，可能被多个函数修改。因此，在使用全局变量时应当谨慎，优先考虑使用函数的参数传递和返回值传递数据。 1.5内存泄漏内存泄漏是指程序在运行时分配了一块内存，但在不再使用它时没有释放或回收这块内存的情况。内存泄漏可能导致程序使用的内存逐渐增加，最终耗尽系统的可用内存，导致程序崩溃或系统变得不稳定。内存泄漏是一种常见的程序错误，因此在编写代码时需要特别注意动态内存的管理。 以下是一个简单的例子，演示了内存泄漏的情况： cCopy code#include void memoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 不释放内存，导致内存泄漏 } int main() { memoryLeakExample(); // 主函数结束，程序退出，但动态分配的内存没有被释放 // 这会导致内存泄漏，因为无法再访问该内存并释放它 return 0; } 在这个例子中，memoryLeakExample 函数动态分配了一块整数大小的内存，但没有在函数结束时释放它。当程序运行时调用 memoryLeakExample 函数后，动态分配的内存就会变成不可访问，而系统无法再回收这块内存。这就是典型的内存泄漏情况。 为了避免内存泄漏，程序员通常应该确保在不再需要使用动态分配的内存时，通过调用 free 函数来释放它。修改上述代码如下： cCopy code#include void noMemoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 使用内存... // 释放内存 free(ptr); } int main() { noMemoryLeakExample(); // 内存在函数调用结束时得到释放，避免了内存泄漏 return 0; } 在这个修改后的例子中，动态分配的内存在函数结束时被正确释放，从而避免了内存泄漏。 ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:1","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#14静态全局变量"},{"categories":["C"],"content":" 1、概念 1.1局部变量 定义： 局部变量是在函数内部声明的变量，只在声明它的函数中可见。 生命周期： 局部变量的生命周期从声明开始，到函数执行结束。每次函数被调用时，都会创建新的局部变量。 示例： cCopy code#include void exampleFunction() { int localVar = 42; // 局部变量 printf(\"Local Variable: %d\\n\", localVar); } int main() { exampleFunction(); // 下面的语句将会引发编译错误，因为 localVar 只在 exampleFunction 函数中可见 // printf(\"Trying to access local variable outside the function: %d\\n\", localVar); return 0; } 1.2静态局部变量 定义： 静态局部变量是在函数内部声明的，但使用 static 关键字修饰的变量。与普通局部变量不同，静态局部变量的生命周期在整个程序运行期间，而不是在函数执行期间。 生命周期： 静态局部变量的生命周期从程序开始运行到结束，但它仍然只在声明它的函数中可见。 示例： cCopy code#include void exampleFunction() { static int staticLocalVar = 42; // 静态局部变量 printf(\"Static Local Variable: %d\\n\", staticLocalVar); // 修改静态局部变量的值，下次函数调用时保留修改后的值 staticLocalVar++; } int main() { exampleFunction(); exampleFunction(); exampleFunction(); return 0; } 1.3全局变量 定义： 全局变量是在函数外部声明的变量，它可以在整个程序中的任何位置访问。 生命周期： 全局变量的生命周期从程序开始运行到结束。 示例： cCopy code#include int globalVar = 100; // 全局变量 void exampleFunction() { printf(\"Global Variable: %d\\n\", globalVar); } int main() { exampleFunction(); // 修改全局变量的值，其他函数调用时将反映修改后的值 globalVar = 200; exampleFunction(); return 0; } 1.4静态全局变量 定义： 静态全局变量是在文件的顶部声明的，使用 static 关键字修饰的全局变量。它在整个文件中可见，但对其他文件是不可见的。 生命周期： 静态全局变量的生命周期从程序开始运行到结束。 示例： cCopy code// 文件1.c #include static int staticGlobalVar = 500; // 静态全局变量 void exampleFunction() { printf(\"Static Global Variable: %d\\n\", staticGlobalVar); } // 文件2.c #include extern void exampleFunction(); // 外部声明，使得其他文件可以访问 exampleFunction int main() { exampleFunction(); return 0; } 这些变量的作用域和生命周期不同，选择使用哪种类型取决于程序的需求。要注意，全局变量和静态全局变量可能导致程序的可维护性降低，因为它们在整个程序中可见，可能被多个函数修改。因此，在使用全局变量时应当谨慎，优先考虑使用函数的参数传递和返回值传递数据。 1.5内存泄漏内存泄漏是指程序在运行时分配了一块内存，但在不再使用它时没有释放或回收这块内存的情况。内存泄漏可能导致程序使用的内存逐渐增加，最终耗尽系统的可用内存，导致程序崩溃或系统变得不稳定。内存泄漏是一种常见的程序错误，因此在编写代码时需要特别注意动态内存的管理。 以下是一个简单的例子，演示了内存泄漏的情况： cCopy code#include void memoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 不释放内存，导致内存泄漏 } int main() { memoryLeakExample(); // 主函数结束，程序退出，但动态分配的内存没有被释放 // 这会导致内存泄漏，因为无法再访问该内存并释放它 return 0; } 在这个例子中，memoryLeakExample 函数动态分配了一块整数大小的内存，但没有在函数结束时释放它。当程序运行时调用 memoryLeakExample 函数后，动态分配的内存就会变成不可访问，而系统无法再回收这块内存。这就是典型的内存泄漏情况。 为了避免内存泄漏，程序员通常应该确保在不再需要使用动态分配的内存时，通过调用 free 函数来释放它。修改上述代码如下： cCopy code#include void noMemoryLeakExample() { // 分配一块内存 int *ptr = (int *)malloc(sizeof(int)); // 使用内存... // 释放内存 free(ptr); } int main() { noMemoryLeakExample(); // 内存在函数调用结束时得到释放，避免了内存泄漏 return 0; } 在这个修改后的例子中，动态分配的内存在函数结束时被正确释放，从而避免了内存泄漏。 ","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:1","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#15内存泄漏"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include \u003cstdio.h\u003e int globalVar = 42; // 全局变量的定义 // 文件2.c #include \u003cstdio.h\u003e extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include \u003cstdio.h\u003e static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include \u003cstdio.h\u003e #include \u003cstring.h\u003e int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include \u003cstdio.h\u003e int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#2内存操作函数"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include int globalVar = 42; // 全局变量的定义 // 文件2.c #include extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include #include int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include #include int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include #include int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include #include int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include #include int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include #include // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#21extern"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include int globalVar = 42; // 全局变量的定义 // 文件2.c #include extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include #include int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include #include int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include #include int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include #include int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include #include int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include #include // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#22静态函数"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include int globalVar = 42; // 全局变量的定义 // 文件2.c #include extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include #include int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include #include int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include #include int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include #include int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include #include int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include #include // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#23memset"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include int globalVar = 42; // 全局变量的定义 // 文件2.c #include extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include #include int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include #include int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include #include int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include #include int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include #include int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include #include // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#24memcpy"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include int globalVar = 42; // 全局变量的定义 // 文件2.c #include extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include #include int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include #include int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include #include int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include #include int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include #include int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include #include // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#25memcmp"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include int globalVar = 42; // 全局变量的定义 // 文件2.c #include extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include #include int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include #include int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include #include int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include #include int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include #include int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include #include // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#26malloc"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include int globalVar = 42; // 全局变量的定义 // 文件2.c #include extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include #include int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include #include int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include #include int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include #include int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include #include int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include #include // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#27返回变量的地址"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include int globalVar = 42; // 全局变量的定义 // 文件2.c #include extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include #include int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include #include int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include #include int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include #include int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include #include int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include #include // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#28返回堆区的地址"},{"categories":["C"],"content":" 2、内存操作函数 2.1externextern 是C语言中的一个关键字，用于声明一个变量或函数的外部链接性（external linkage）。当一个变量或函数被声明为 extern 时，它意味着该变量或函数的定义存在于其他文件中，而不是当前文件中。extern 的使用主要涉及到多个源文件的情况，其中一个文件可能需要访问另一个文件中定义的变量或函数。 cCopy code// 文件1.c #include int globalVar = 42; // 全局变量的定义 // 文件2.c #include extern int globalVar; // 外部声明，告知编译器 globalVar 是在其他文件中定义的 int main() { printf(\"Global Variable from another file: %d\\n\", globalVar); return 0; } 2.2静态函数在C语言中，函数默认情况下是具有文件作用域的，即只在定义它的文件中可见。因此，函数默认情况下就是静态的。当函数被声明为 static 时，它的链接性被限制为文件作用域，不可在其他文件中访问。静态函数对于将函数的作用域限制在当前文件中是很有用的，可以避免与其他文件中相同名称的函数发生冲突。 cCopy code// 文件1.c #include static void staticFunction() { printf(\"This is a static function.\\n\"); } // 文件2.c // 尝试在文件2.c中调用 staticFunction 会导致编译错误，因为它是文件1.c的局部函数 2.3memset 功能： 用指定的值填充一块内存。 原型： cCopy code void *memset(void *ptr, int value, size_t num); 示例： cCopy code#include #include int main() { char str[20]; // 使用memset将str数组的前10个字节填充为'A' memset(str, 'A', 10); printf(\"After memset: %s\\n\", str); return 0; } 2.4memcpy 功能： 从源内存地址复制一定数量的字节到目标内存地址。 原型： cCopy code void *memcpy(void *dest, const void *src, size_t num); 示例： cCopy code#include #include int main() { char src[] = \"Hello\"; char dest[20]; // 使用memcpy将src数组的内容复制到dest数组中 memcpy(dest, src, strlen(src) + 1); printf(\"After memcpy: %s\\n\", dest); return 0; } 2.5memcmp 功能： 比较两块内存区域的前 num 个字节。 原型： cCopy code int memcmp(const void *ptr1, const void *ptr2, size_t num); 示例： cCopy code#include #include int main() { char str1[] = \"abcd\"; char str2[] = \"abCd\"; // 使用memcmp比较两个字符串的前3个字节 int result = memcmp(str1, str2, 3); if (result == 0) { printf(\"The first 3 bytes are equal.\\n\"); } else { printf(\"The first 3 bytes are not equal.\\n\"); } return 0; } 2.6malloc 功能： 在堆上分配指定大小的内存块。 原型： cCopy code void *malloc(size_t size); 示例： cCopy code#include #include int main() { int *arr; // 使用malloc分配包含5个整数的内存块 arr = (int *)malloc(5 * sizeof(int)); if (arr != NULL) { for (int i = 0; i \u003c 5; ++i) { arr[i] = i * 2; printf(\"%d \", arr[i]); } // 释放动态分配的内存 free(arr); } else { printf(\"Memory allocation failed.\\n\"); } return 0; } 2.7返回变量的地址 这种情况通常发生在函数内部创建了一个局部变量，然后返回该变量的地址。要确保返回的地址在函数调用结束后仍然有效，可以使用动态内存分配或者将变量声明为静态变量。 下面是一个使用动态内存分配的例子： cCopy code#include #include int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建一个包含整数的数组，然后返回数组的首地址。在 main 函数中，调用了 createAndReturnArray 函数，并通过返回的地址访问了数组的元素。需要注意的是，在使用完动态分配的内存后，需要调用 free 函数释放该内存，以防止内存泄漏。 另外，如果变量是一个静态变量，它的地址可以直接返回，因为静态变量的生命周期跨越整个程序运行期间。 cCopy code#include int* getStaticVariable() { // 声明为静态变量 static int staticVar = 42; // 返回静态变量的地址 return \u0026staticVar; } int main() { // 获取静态变量的地址 int *ptr = getStaticVariable(); // 打印静态变量的值 printf(\"Static Variable: %d\\n\", *ptr); return 0; } 在这个例子中，getStaticVariable 函数返回了静态变量 staticVar 的地址，而 main 函数通过这个地址访问了静态变量的值。由于静态变量的生命周期跨越整个程序，返回其地址是安全的。 2.8返回堆区的地址 返回堆区的地址通常是通过动态内存分配函数（例如malloc、calloc等）创建的对象的地址。当函数中使用动态内存分配创建对象时，可以通过返回指向这个对象的指针来返回堆区的地址。 以下是一个简单的例子，演示如何在函数中动态分配内存，并返回分配的内存地址： cCopy code#include #include // 函数返回堆区分配的整数数组的地址 int* createAndReturnArray(int size) { // 使用动态内存分配创建整数数组 int *arr = (int *)malloc(size * sizeof(int)); // 将数组元素赋值 for (int i = 0; i \u003c size; ++i) { arr[i] = i * 2; } // 返回数组的首地址 return arr; } int main() { int size = 5; // 调用函数创建数组并获取数组的地址 int *resultArray = createAndReturnArray(size); // 打印数组元素 for (int i = 0; i \u003c size; ++i) { printf(\"%d \", resultArray[i]); } // 释放动态分配的内存 free(resultArray); return 0; } 在这个例子中，createAndReturnArray 函数创建了一个包含整数的数组，并返回了该数组的首地址。在 main 函数中，通过调用 createAndReturnArray 获取了数组的地址，并使用该地址访问了数组的元素。需要注意的是，调用者有责任在使用完动","date":"2023-12-31","objectID":"/%E5%86%85%E5%AD%98/:0:2","series":null,"tags":["C"],"title":"内存","uri":"/%E5%86%85%E5%AD%98/#29实参为一级指针的地址"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = \u0026num; // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = \u0026num; printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include \u003cstdio.h\u003e int main() { int num = 42; int *ptr1 = \u0026num; // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include \u003cstdio.h\u003e int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include \u003cstdio.h\u003e int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include \u003cstdio.h\u003e int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include \u003cstdio.h\u003e int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include \u003cstdio.h\u003e int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#指针"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#1概念"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#2"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#211多级指针"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#212指针运算"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#213指针数组"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#214指针作为函数的形参"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#215数组作为函数的形参"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#216指针作为函数的返回值"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#217指针与字符数组"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#218指针与字符串"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#219字符指针作为形参指针拼接字符串"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#221const修饰"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#222字符指针数组"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#223字符串指针数组作为main函数参数"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#224字符串处理拷贝连接"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#225字符串处理比较函数"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#231sprintf组包函数"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#232sscanf拆包函数"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#233strchr"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#234strstr"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#235strtok"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#236atoi"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#241字符反转"},{"categories":["C"],"content":" 指针 1、概念当谈到C语言时，指针是一个非常重要的概念。指针是一个变量，其值为内存地址，即某个数据存储位置的地址。通过使用指针，你可以直接访问和操作内存中的数据。 以下是关于指针的一些重要概念和语法： 声明指针： 你可以使用*来声明指针变量。例如： cCopy code int *ptr; // 声明一个整型指针 取地址操作符（\u0026）： 你可以使用\u0026操作符获取一个变量的地址。例如： cCopy codeint num = 42; int *ptr = # // ptr现在包含变量num的地址 指针的解引用操作符（*）： 通过使用*操作符，你可以访问指针所指向的内存地址处的值。例如： cCopy codeint num = 42; int *ptr = # printf(\"Value at the memory location pointed by ptr: %d\\n\", *ptr); 指针的算术操作： 指针可以进行算术操作，例如指针加法、减法等。这在数组和动态内存分配时很有用。 cCopy codeint numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 printf(\"Value at the first element: %d\\n\", *ptr); // 输出第一个元素的值 printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 输出第二个元素的值 空指针： 指针也可以具有空值，表示它不指向任何有效的内存地址。可以使用NULL宏来给指针赋空值。 cCopy code int *ptr = NULL; // 空指针 指针和函数： 在函数中，你可以使用指针来传递变量的地址，以便在函数内部修改变量的值。 cCopy codevoid increment(int *x) { (*x)++; // 通过指针增加变量的值 } int main() { int num = 10; increment(\u0026num); // 传递num的地址 printf(\"Incremented value: %d\\n\", num); return 0; } 2、 2.1.1多级指针 多级指针是指指针的指针，即一个指针变量存储的是另一个指针变量的地址。在C语言中，我们可以使用多级指针来处理更复杂的数据结构，如二维数组、链表等。多级指针的声明和使用可以通过多个星号来表示级数。 以下是一个简单的例子，说明了多级指针的概念： cCopy code#include int main() { int num = 42; int *ptr1 = # // 一级指针，指向整数num的地址 int **ptr2 = \u0026ptr1; // 二级指针，指向一级指针ptr1的地址 // 输出变量num的值及通过一级和二级指针访问num的值 printf(\"Value of num: %d\\n\", num); printf(\"Value through ptr1: %d\\n\", *ptr1); printf(\"Value through ptr2: %d\\n\", **ptr2); return 0; } 在这个例子中，ptr1是一个一级指针，指向整数变量num的地址。ptr2是一个二级指针，指向一级指针ptr1的地址。通过**ptr2，我们可以访问到num的值。 多级指针在处理多维数组、动态内存分配以及复杂的数据结构时非常有用。例如，如果有一个二维数组，可以使用二级指针来方便地访问数组的元素： cCopy code#include int main() { int rows = 3, cols = 4; // 分配二维数组的内存 int **matrix = (int **)malloc(rows * sizeof(int *)); for (int i = 0; i \u003c rows; ++i) { matrix[i] = (int *)malloc(cols * sizeof(int)); } // 初始化二维数组 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { matrix[i][j] = i * cols + j; } } // 使用二级指针访问二维数组的元素 for (int i = 0; i \u003c rows; ++i) { for (int j = 0; j \u003c cols; ++j) { printf(\"%d \", matrix[i][j]); } printf(\"\\n\"); } // 释放内存 for (int i = 0; i \u003c rows; ++i) { free(matrix[i]); } free(matrix); return 0; } 在这个例子中，matrix是一个二级指针，用于表示二维数组。通过使用二级指针，我们可以方便地进行动态内存分配和数组元素的访问。 2.1.2指针运算 指针运算是指对指针变量进行的一系列数学运算。主要的指针运算包括指针的加法、减法以及递增和递减运算。这些运算允许在内存中移动指针，对数组进行访问，以及在动态内存分配中进行操作。 以下是一些常见的指针运算及其示例： 指针的加法和减法： 可以对指针进行加法和减法运算，其中加法和减法的结果取决于指针指向的数据类型的大小。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的加法访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); printf(\"Value at the second element: %d\\n\", *(ptr + 1)); // 使用指针的减法访问数组元素 printf(\"Value at the last element: %d\\n\", *(ptr + 4)); return 0; } 指针的递增和递减： 使用++和--运算符对指针进行递增和递减操作。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 指向数组的第一个元素 // 使用指针的递增访问数组元素 printf(\"Value at the first element: %d\\n\", *ptr); ptr++; printf(\"Value after increment: %d\\n\", *ptr); // 使用指针的递减访问数组元素 ptr--; printf(\"Value after decrement: %d\\n\", *ptr); return 0; } 指针运算和数组： 指针运算与数组密切相关，因为数组名本身就是一个指向数组第一个元素的指针。 cCopy code#include int main() { int numbers[] = {1, 2, 3, 4, 5}; int *ptr = numbers; // 数组名是指向数组第一个元素的指针 // 使用数组名和指针进行访问数组元素 printf(\"Value at the first element: %d\\n\", numbers[0]); printf(\"Value at the second element using array name: %d\\n\", *(numbers + 1)); printf(\"Value at the third element using pointer: %d\\n\", *(ptr + 2)); return 0; } 2.1.3指针数组 指针数组是一个数组，其元素都是指针。每个元素指向一个特定类型的数据。指针数组在C语言中常用于存储字符串，也可以用于存储其他类型的指针。 以下是关于指针数组的解释和一个简单的例子： 指针数组的声明： 可以使用以下语法声明指针数组： cCopy code int *ptrArray[5]; // 声明一个包含5个指向整数的指针的数组 这表示 ptrArray 是一个包含5个元素的数组，每个元素都是指向整数的指针。 指针数组的初始化： 指针数组的元素可以初始化为指向相应类型的变量或动态分配的内存。 cCopy codeint num1 = 10, num2 = 20, num3 = 30; int *ptrArray[3] = {\u0026num1, \u0026num2, \u0026num3}; 这里，ptrArray 包含三个元素，每个元素都是指向整数的指针，分别指向 num1、num2 和 num3。 指针数组和字符串： 指针数组经常用于存储字符串。每个数组元素是一个指向字符串的指针。 cCopy code#include int main() { char *names[] = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}; for (int i = 0; i \u003c 4; ++i) { printf(\"Name %d: %s\\n\", i + 1, names[i]); } return 0; } 在","date":"2023-12-31","objectID":"/%E6%8C%87%E9%92%88/:0:1","series":null,"tags":["C"],"title":"指针","uri":"/%E6%8C%87%E9%92%88/#heading"},{"categories":["Spring"],"content":" 一、Spring简介 1.1 目前我们代码存在的问题 代码书写现状 耦合度偏高 解决方案 使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象 1.2 核心概念 ==IOC（Inversion of Control）控制反转== 使用对象时，由主动new产生对象转换为由==外部==提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。通俗的讲就是“==将new对象的权利交给Spring，我们从Spring中获取对象使用即可==” Spring技术对IoC思想进行了实现 Spring提供了一个容器，称为==IOC容器==，用来充当IoC思想中的“外部” IOC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为==Bean== ==DI（Dependency Injection）依赖注入== 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。 目标：充分解耦 使用IoC容器管理bean（IOC) 在IoC容器内将有依赖关系的bean进行关系绑定（DI） 最终效果 使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系 ","date":"2023-12-31","objectID":"/spring01/:1:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#一spring简介"},{"categories":["Spring"],"content":" 一、Spring简介 1.1 目前我们代码存在的问题 代码书写现状 耦合度偏高 解决方案 使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象 1.2 核心概念 ==IOC（Inversion of Control）控制反转== 使用对象时，由主动new产生对象转换为由==外部==提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。通俗的讲就是“==将new对象的权利交给Spring，我们从Spring中获取对象使用即可==” Spring技术对IoC思想进行了实现 Spring提供了一个容器，称为==IOC容器==，用来充当IoC思想中的“外部” IOC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为==Bean== ==DI（Dependency Injection）依赖注入== 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。 目标：充分解耦 使用IoC容器管理bean（IOC) 在IoC容器内将有依赖关系的bean进行关系绑定（DI） 最终效果 使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系 ","date":"2023-12-31","objectID":"/spring01/:1:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-目前我们代码存在的问题"},{"categories":["Spring"],"content":" 一、Spring简介 1.1 目前我们代码存在的问题 代码书写现状 耦合度偏高 解决方案 使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象 1.2 核心概念 ==IOC（Inversion of Control）控制反转== 使用对象时，由主动new产生对象转换为由==外部==提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。通俗的讲就是“==将new对象的权利交给Spring，我们从Spring中获取对象使用即可==” Spring技术对IoC思想进行了实现 Spring提供了一个容器，称为==IOC容器==，用来充当IoC思想中的“外部” IOC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为==Bean== ==DI（Dependency Injection）依赖注入== 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。 目标：充分解耦 使用IoC容器管理bean（IOC) 在IoC容器内将有依赖关系的bean进行关系绑定（DI） 最终效果 使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系 ","date":"2023-12-31","objectID":"/spring01/:1:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-核心概念"},{"categories":["Spring"],"content":" 二、IOC和DI入门案例【重点】","date":"2023-12-31","objectID":"/spring01/:2:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#二ioc和di入门案例重点"},{"categories":["Spring"],"content":" 1 IOC入门案例【重点】 问题导入\u003cbean\u003e标签中id属性和class属性的作用是什么？ 1.1 门案例思路分析 管理什么？(Service与Dao) 如何将被管理的对象告知IOC容器？(配置文件) 被管理的对象交给IOC容器，如何获取到IoC容器？(接口) IOC容器得到后，如何从容器中获取bean？(接口方法) 使用Spring导入哪些坐标？(pom.xml) 1.2 实现步骤 【第一步】导入Spring坐标 【第二步】定义Spring管理的类（接口） 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取bean对象 1.3 实现代码【第一步】导入Spring坐标 jdk8 \u003cdependencies\u003e \u003c!--导入spring的坐标spring-context，对应版本是5.2.10.RELEASE--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context\u003c/artifactId\u003e \u003cversion\u003e5.2.10.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e jdk17 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-test\u003c/artifactId\u003e \u003cversion\u003e5.3.10\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 【第二步】定义Spring管理的类（接口） BookDao接口和BookDaoImpl实现类 public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } BookService接口和BookServiceImpl实现类 public interface BookService { public void save(); } public class BookServiceImpl implements BookService { private BookDao bookDao = new BookDaoImpl(); public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 定义applicationContext.xml配置文件并配置BookServiceImpl \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!-- bean标签：表示配置bean id属性：表示给bean起名字 class属性：表示给bean定义类型 --\u003e \u003cbean id=\"bookService\" class=\"com.itghd.service.impl.BookServiceImpl\"\u003e\u003c/bean\u003e \u003c/beans\u003e ==注意事项：bean定义时id属性在同一个上下文中(IOC容器中)不能重复== 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取Bean对象 public class App { public static void main(String[] args) { //1.创建IoC容器对象，加载spring核心配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2 从IOC容器中获取Bean对象(BookService对象) BookService bookService= (BookService)ctx.getBean(\"bookService\"); //3 调用Bean对象(BookService对象)的方法 bookService.save(); } } 1.4 运行结果 ","date":"2023-12-31","objectID":"/spring01/:2:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-ioc入门案例重点"},{"categories":["Spring"],"content":" 1 IOC入门案例【重点】 问题导入标签中id属性和class属性的作用是什么？ 1.1 门案例思路分析 管理什么？(Service与Dao) 如何将被管理的对象告知IOC容器？(配置文件) 被管理的对象交给IOC容器，如何获取到IoC容器？(接口) IOC容器得到后，如何从容器中获取bean？(接口方法) 使用Spring导入哪些坐标？(pom.xml) 1.2 实现步骤 【第一步】导入Spring坐标 【第二步】定义Spring管理的类（接口） 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取bean对象 1.3 实现代码【第一步】导入Spring坐标 jdk8 org.springframework spring-context 5.2.10.RELEASE jdk17 org.springframework spring-test 5.3.10 test 【第二步】定义Spring管理的类（接口） BookDao接口和BookDaoImpl实现类 public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } BookService接口和BookServiceImpl实现类 public interface BookService { public void save(); } public class BookServiceImpl implements BookService { private BookDao bookDao = new BookDaoImpl(); public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 定义applicationContext.xml配置文件并配置BookServiceImpl \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ==注意事项：bean定义时id属性在同一个上下文中(IOC容器中)不能重复== 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取Bean对象 public class App { public static void main(String[] args) { //1.创建IoC容器对象，加载spring核心配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2 从IOC容器中获取Bean对象(BookService对象) BookService bookService= (BookService)ctx.getBean(\"bookService\"); //3 调用Bean对象(BookService对象)的方法 bookService.save(); } } 1.4 运行结果 ","date":"2023-12-31","objectID":"/spring01/:2:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入"},{"categories":["Spring"],"content":" 1 IOC入门案例【重点】 问题导入标签中id属性和class属性的作用是什么？ 1.1 门案例思路分析 管理什么？(Service与Dao) 如何将被管理的对象告知IOC容器？(配置文件) 被管理的对象交给IOC容器，如何获取到IoC容器？(接口) IOC容器得到后，如何从容器中获取bean？(接口方法) 使用Spring导入哪些坐标？(pom.xml) 1.2 实现步骤 【第一步】导入Spring坐标 【第二步】定义Spring管理的类（接口） 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取bean对象 1.3 实现代码【第一步】导入Spring坐标 jdk8 org.springframework spring-context 5.2.10.RELEASE jdk17 org.springframework spring-test 5.3.10 test 【第二步】定义Spring管理的类（接口） BookDao接口和BookDaoImpl实现类 public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } BookService接口和BookServiceImpl实现类 public interface BookService { public void save(); } public class BookServiceImpl implements BookService { private BookDao bookDao = new BookDaoImpl(); public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 定义applicationContext.xml配置文件并配置BookServiceImpl \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ==注意事项：bean定义时id属性在同一个上下文中(IOC容器中)不能重复== 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取Bean对象 public class App { public static void main(String[] args) { //1.创建IoC容器对象，加载spring核心配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2 从IOC容器中获取Bean对象(BookService对象) BookService bookService= (BookService)ctx.getBean(\"bookService\"); //3 调用Bean对象(BookService对象)的方法 bookService.save(); } } 1.4 运行结果 ","date":"2023-12-31","objectID":"/spring01/:2:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-门案例思路分析"},{"categories":["Spring"],"content":" 1 IOC入门案例【重点】 问题导入标签中id属性和class属性的作用是什么？ 1.1 门案例思路分析 管理什么？(Service与Dao) 如何将被管理的对象告知IOC容器？(配置文件) 被管理的对象交给IOC容器，如何获取到IoC容器？(接口) IOC容器得到后，如何从容器中获取bean？(接口方法) 使用Spring导入哪些坐标？(pom.xml) 1.2 实现步骤 【第一步】导入Spring坐标 【第二步】定义Spring管理的类（接口） 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取bean对象 1.3 实现代码【第一步】导入Spring坐标 jdk8 org.springframework spring-context 5.2.10.RELEASE jdk17 org.springframework spring-test 5.3.10 test 【第二步】定义Spring管理的类（接口） BookDao接口和BookDaoImpl实现类 public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } BookService接口和BookServiceImpl实现类 public interface BookService { public void save(); } public class BookServiceImpl implements BookService { private BookDao bookDao = new BookDaoImpl(); public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 定义applicationContext.xml配置文件并配置BookServiceImpl \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ==注意事项：bean定义时id属性在同一个上下文中(IOC容器中)不能重复== 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取Bean对象 public class App { public static void main(String[] args) { //1.创建IoC容器对象，加载spring核心配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2 从IOC容器中获取Bean对象(BookService对象) BookService bookService= (BookService)ctx.getBean(\"bookService\"); //3 调用Bean对象(BookService对象)的方法 bookService.save(); } } 1.4 运行结果 ","date":"2023-12-31","objectID":"/spring01/:2:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-实现步骤"},{"categories":["Spring"],"content":" 1 IOC入门案例【重点】 问题导入标签中id属性和class属性的作用是什么？ 1.1 门案例思路分析 管理什么？(Service与Dao) 如何将被管理的对象告知IOC容器？(配置文件) 被管理的对象交给IOC容器，如何获取到IoC容器？(接口) IOC容器得到后，如何从容器中获取bean？(接口方法) 使用Spring导入哪些坐标？(pom.xml) 1.2 实现步骤 【第一步】导入Spring坐标 【第二步】定义Spring管理的类（接口） 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取bean对象 1.3 实现代码【第一步】导入Spring坐标 jdk8 org.springframework spring-context 5.2.10.RELEASE jdk17 org.springframework spring-test 5.3.10 test 【第二步】定义Spring管理的类（接口） BookDao接口和BookDaoImpl实现类 public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } BookService接口和BookServiceImpl实现类 public interface BookService { public void save(); } public class BookServiceImpl implements BookService { private BookDao bookDao = new BookDaoImpl(); public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 定义applicationContext.xml配置文件并配置BookServiceImpl \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ==注意事项：bean定义时id属性在同一个上下文中(IOC容器中)不能重复== 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取Bean对象 public class App { public static void main(String[] args) { //1.创建IoC容器对象，加载spring核心配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2 从IOC容器中获取Bean对象(BookService对象) BookService bookService= (BookService)ctx.getBean(\"bookService\"); //3 调用Bean对象(BookService对象)的方法 bookService.save(); } } 1.4 运行结果 ","date":"2023-12-31","objectID":"/spring01/:2:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#13-实现代码"},{"categories":["Spring"],"content":" 1 IOC入门案例【重点】 问题导入标签中id属性和class属性的作用是什么？ 1.1 门案例思路分析 管理什么？(Service与Dao) 如何将被管理的对象告知IOC容器？(配置文件) 被管理的对象交给IOC容器，如何获取到IoC容器？(接口) IOC容器得到后，如何从容器中获取bean？(接口方法) 使用Spring导入哪些坐标？(pom.xml) 1.2 实现步骤 【第一步】导入Spring坐标 【第二步】定义Spring管理的类（接口） 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取bean对象 1.3 实现代码【第一步】导入Spring坐标 jdk8 org.springframework spring-context 5.2.10.RELEASE jdk17 org.springframework spring-test 5.3.10 test 【第二步】定义Spring管理的类（接口） BookDao接口和BookDaoImpl实现类 public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } BookService接口和BookServiceImpl实现类 public interface BookService { public void save(); } public class BookServiceImpl implements BookService { private BookDao bookDao = new BookDaoImpl(); public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 定义applicationContext.xml配置文件并配置BookServiceImpl \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ==注意事项：bean定义时id属性在同一个上下文中(IOC容器中)不能重复== 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取Bean对象 public class App { public static void main(String[] args) { //1.创建IoC容器对象，加载spring核心配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2 从IOC容器中获取Bean对象(BookService对象) BookService bookService= (BookService)ctx.getBean(\"bookService\"); //3 调用Bean对象(BookService对象)的方法 bookService.save(); } } 1.4 运行结果 ","date":"2023-12-31","objectID":"/spring01/:2:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#14-运行结果"},{"categories":["Spring"],"content":" 2 DI入门案例【重点】 问题导入\u003cproperty\u003e标签中name属性和ref属性的作用是什么？ 2.1 DI入门案例思路分析 基于IOC管理bean Service中使用new形式创建的Dao对象是否保留？(否) Service中需要的Dao对象如何进入到Service中？(提供方法) Service与Dao间的关系如何描述？(配置) 2.2 实现步骤 【第一步】删除使用new的形式创建对象的代码 【第二步】提供依赖对象对应的setter方法 【第三步】配置service与dao之间的关系 2.3 实现代码【第一步】删除使用new的形式创建对象的代码 public class BookServiceImpl implements BookService { private BookDao bookDao; //【第一步】删除使用new的形式创建对象的代码 public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第二步】提供依赖对象对应的setter方法 public class BookServiceImpl implements BookService { private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } //【第二步】提供依赖对象对应的setter方法 public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } } 【第三步】配置service与dao之间的关系 在applicationContext.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!-- bean标签：表示配置bean id属性：表示给bean起名字 class属性：表示给bean定义类型 --\u003e \u003cbean id=\"bookDao\" class=\"com.itghd.dao.impl.BookDaoImpl\"/\u003e \u003cbean id=\"bookService\" class=\"com.itghd.service.impl.BookServiceImpl\"\u003e \u003c!--配置server与dao的关系 property标签：表示配置当前bean的属性 name属性：表示配置哪一个具体的属性 ref属性：表示参照哪一个bean --\u003e \u003cproperty name=\"bookDao\" ref=\"bookDao\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 2.4 图解演示 ","date":"2023-12-31","objectID":"/spring01/:2:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-di入门案例重点"},{"categories":["Spring"],"content":" 2 DI入门案例【重点】 问题导入标签中name属性和ref属性的作用是什么？ 2.1 DI入门案例思路分析 基于IOC管理bean Service中使用new形式创建的Dao对象是否保留？(否) Service中需要的Dao对象如何进入到Service中？(提供方法) Service与Dao间的关系如何描述？(配置) 2.2 实现步骤 【第一步】删除使用new的形式创建对象的代码 【第二步】提供依赖对象对应的setter方法 【第三步】配置service与dao之间的关系 2.3 实现代码【第一步】删除使用new的形式创建对象的代码 public class BookServiceImpl implements BookService { private BookDao bookDao; //【第一步】删除使用new的形式创建对象的代码 public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第二步】提供依赖对象对应的setter方法 public class BookServiceImpl implements BookService { private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } //【第二步】提供依赖对象对应的setter方法 public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } } 【第三步】配置service与dao之间的关系 在applicationContext.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 2.4 图解演示 ","date":"2023-12-31","objectID":"/spring01/:2:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-1"},{"categories":["Spring"],"content":" 2 DI入门案例【重点】 问题导入标签中name属性和ref属性的作用是什么？ 2.1 DI入门案例思路分析 基于IOC管理bean Service中使用new形式创建的Dao对象是否保留？(否) Service中需要的Dao对象如何进入到Service中？(提供方法) Service与Dao间的关系如何描述？(配置) 2.2 实现步骤 【第一步】删除使用new的形式创建对象的代码 【第二步】提供依赖对象对应的setter方法 【第三步】配置service与dao之间的关系 2.3 实现代码【第一步】删除使用new的形式创建对象的代码 public class BookServiceImpl implements BookService { private BookDao bookDao; //【第一步】删除使用new的形式创建对象的代码 public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第二步】提供依赖对象对应的setter方法 public class BookServiceImpl implements BookService { private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } //【第二步】提供依赖对象对应的setter方法 public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } } 【第三步】配置service与dao之间的关系 在applicationContext.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 2.4 图解演示 ","date":"2023-12-31","objectID":"/spring01/:2:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-di入门案例思路分析"},{"categories":["Spring"],"content":" 2 DI入门案例【重点】 问题导入标签中name属性和ref属性的作用是什么？ 2.1 DI入门案例思路分析 基于IOC管理bean Service中使用new形式创建的Dao对象是否保留？(否) Service中需要的Dao对象如何进入到Service中？(提供方法) Service与Dao间的关系如何描述？(配置) 2.2 实现步骤 【第一步】删除使用new的形式创建对象的代码 【第二步】提供依赖对象对应的setter方法 【第三步】配置service与dao之间的关系 2.3 实现代码【第一步】删除使用new的形式创建对象的代码 public class BookServiceImpl implements BookService { private BookDao bookDao; //【第一步】删除使用new的形式创建对象的代码 public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第二步】提供依赖对象对应的setter方法 public class BookServiceImpl implements BookService { private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } //【第二步】提供依赖对象对应的setter方法 public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } } 【第三步】配置service与dao之间的关系 在applicationContext.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 2.4 图解演示 ","date":"2023-12-31","objectID":"/spring01/:2:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#22-实现步骤"},{"categories":["Spring"],"content":" 2 DI入门案例【重点】 问题导入标签中name属性和ref属性的作用是什么？ 2.1 DI入门案例思路分析 基于IOC管理bean Service中使用new形式创建的Dao对象是否保留？(否) Service中需要的Dao对象如何进入到Service中？(提供方法) Service与Dao间的关系如何描述？(配置) 2.2 实现步骤 【第一步】删除使用new的形式创建对象的代码 【第二步】提供依赖对象对应的setter方法 【第三步】配置service与dao之间的关系 2.3 实现代码【第一步】删除使用new的形式创建对象的代码 public class BookServiceImpl implements BookService { private BookDao bookDao; //【第一步】删除使用new的形式创建对象的代码 public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第二步】提供依赖对象对应的setter方法 public class BookServiceImpl implements BookService { private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } //【第二步】提供依赖对象对应的setter方法 public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } } 【第三步】配置service与dao之间的关系 在applicationContext.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 2.4 图解演示 ","date":"2023-12-31","objectID":"/spring01/:2:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#23-实现代码"},{"categories":["Spring"],"content":" 2 DI入门案例【重点】 问题导入标签中name属性和ref属性的作用是什么？ 2.1 DI入门案例思路分析 基于IOC管理bean Service中使用new形式创建的Dao对象是否保留？(否) Service中需要的Dao对象如何进入到Service中？(提供方法) Service与Dao间的关系如何描述？(配置) 2.2 实现步骤 【第一步】删除使用new的形式创建对象的代码 【第二步】提供依赖对象对应的setter方法 【第三步】配置service与dao之间的关系 2.3 实现代码【第一步】删除使用new的形式创建对象的代码 public class BookServiceImpl implements BookService { private BookDao bookDao; //【第一步】删除使用new的形式创建对象的代码 public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第二步】提供依赖对象对应的setter方法 public class BookServiceImpl implements BookService { private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } //【第二步】提供依赖对象对应的setter方法 public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } } 【第三步】配置service与dao之间的关系 在applicationContext.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 2.4 图解演示 ","date":"2023-12-31","objectID":"/spring01/:2:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#24-图解演示"},{"categories":["Spring"],"content":" 三、Bean的基础配置","date":"2023-12-31","objectID":"/spring01/:3:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#三bean的基础配置"},{"categories":["Spring"],"content":" 问题导入问题1：在\u003cbean\u003e标签上如何配置别名？ 问题2：Bean的默认作用范围是什么？如何修改？ ","date":"2023-12-31","objectID":"/spring01/:3:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-2"},{"categories":["Spring"],"content":" 1 Bean基础配置【重点】 配置说明 代码演示 见《IOC入门案例》applicationContext.xml配置 运行结果 见《IOC入门案例》运行结果 ","date":"2023-12-31","objectID":"/spring01/:3:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-bean基础配置重点"},{"categories":["Spring"],"content":" 1 Bean基础配置【重点】 配置说明 代码演示 见《IOC入门案例》applicationContext.xml配置 运行结果 见《IOC入门案例》运行结果 ","date":"2023-12-31","objectID":"/spring01/:3:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#配置说明"},{"categories":["Spring"],"content":" 1 Bean基础配置【重点】 配置说明 代码演示 见《IOC入门案例》applicationContext.xml配置 运行结果 见《IOC入门案例》运行结果 ","date":"2023-12-31","objectID":"/spring01/:3:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#代码演示"},{"categories":["Spring"],"content":" 1 Bean基础配置【重点】 配置说明 代码演示 见《IOC入门案例》applicationContext.xml配置 运行结果 见《IOC入门案例》运行结果 ","date":"2023-12-31","objectID":"/spring01/:3:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#运行结果"},{"categories":["Spring"],"content":" 2 Bean别名配置 配置说明 代码演示 打印结果 ","date":"2023-12-31","objectID":"/spring01/:3:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-bean别名配置"},{"categories":["Spring"],"content":" 2 Bean别名配置 配置说明 代码演示 打印结果 ","date":"2023-12-31","objectID":"/spring01/:3:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#配置说明-1"},{"categories":["Spring"],"content":" 2 Bean别名配置 配置说明 代码演示 打印结果 ","date":"2023-12-31","objectID":"/spring01/:3:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#代码演示-1"},{"categories":["Spring"],"content":" 2 Bean别名配置 配置说明 代码演示 打印结果 ","date":"2023-12-31","objectID":"/spring01/:3:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#打印结果"},{"categories":["Spring"],"content":" 3 Bean作用范围配置【重点】 配置说明 扩展：scope的取值不仅仅只有singleton和prototype，还有request、session、application、 websocket ，表示创建出的对象放置在web容器(tomcat)对应的位置。比如：request表示保存到request域中。 代码演示 打印结果 最后给大家说明一下：在我们的实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。 ","date":"2023-12-31","objectID":"/spring01/:3:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#3-bean作用范围配置重点"},{"categories":["Spring"],"content":" 3 Bean作用范围配置【重点】 配置说明 扩展：scope的取值不仅仅只有singleton和prototype，还有request、session、application、 websocket ，表示创建出的对象放置在web容器(tomcat)对应的位置。比如：request表示保存到request域中。 代码演示 打印结果 最后给大家说明一下：在我们的实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。 ","date":"2023-12-31","objectID":"/spring01/:3:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#配置说明-2"},{"categories":["Spring"],"content":" 3 Bean作用范围配置【重点】 配置说明 扩展：scope的取值不仅仅只有singleton和prototype，还有request、session、application、 websocket ，表示创建出的对象放置在web容器(tomcat)对应的位置。比如：request表示保存到request域中。 代码演示 打印结果 最后给大家说明一下：在我们的实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。 ","date":"2023-12-31","objectID":"/spring01/:3:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#代码演示-2"},{"categories":["Spring"],"content":" 3 Bean作用范围配置【重点】 配置说明 扩展：scope的取值不仅仅只有singleton和prototype，还有request、session、application、 websocket ，表示创建出的对象放置在web容器(tomcat)对应的位置。比如：request表示保存到request域中。 代码演示 打印结果 最后给大家说明一下：在我们的实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。 ","date":"2023-12-31","objectID":"/spring01/:3:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#打印结果-1"},{"categories":["Spring"],"content":" 四、Bean的实例化","date":"2023-12-31","objectID":"/spring01/:4:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#四bean的实例化"},{"categories":["Spring"],"content":" 问题导入Bean的实例化方式有几种？ ","date":"2023-12-31","objectID":"/spring01/:4:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-3"},{"categories":["Spring"],"content":" 1 Bean是如何创建的【理解】bean本质上就是对象，创建bean使用构造方法完成 ","date":"2023-12-31","objectID":"/spring01/:4:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-bean是如何创建的理解"},{"categories":["Spring"],"content":" 2 实例化Bean的三种方式 2.1 构造方法方式【重点】 BookDaoImpl实现类 public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor is running ....\"); } public void save() { System.out.println(\"book dao save ...\"); } } applicationContext.xml配置 \u003c!--方式一：构造方法实例化bean--\u003e \u003cbean id=\"bookDao\" class=\"com.itghd.dao.impl.BookDaoImpl\"/\u003e AppForInstanceBook测试类 public class AppForInstanceBook { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); } } 运行结果 ==注意：无参构造方法如果不存在，将抛出异常BeanCreationException== 2.2 静态工厂方式 OrderDao接口和OrderDaoImpl实现类 public interface OrderDao { public void save(); } public class OrderDaoImpl implements OrderDao { public void save() { System.out.println(\"order dao save ...\"); } } OrderDaoFatory工厂类 //静态工厂创建对象 public class OrderDaoFactory { public static OrderDao getOrderDao(){ System.out.println(\"factory setup....\"); return new OrderDaoImpl(); } } applicationContext.xml配置 \u003c!--方式二：使用静态工厂实例化bean--\u003e \u003cbean id=\"orderDao\" class=\"com.itghd.factory.OrderDaoFactory\" factory-method=\"getOrderDao\"/\u003e AppForInstanceOrder测试类 public class AppForInstanceOrder { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); OrderDao orderDao = (OrderDao) ctx.getBean(\"orderDao\"); orderDao.save(); } } 运行结果 2.3 实例工厂方式 UserDao接口和UserDaoImpl实现类 public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { public void save() { System.out.println(\"user dao save ...\"); } } UserDaoFactory工厂类 //实例工厂创建对象 public class UserDaoFactory { public UserDao getUserDao(){ return new UserDaoImpl(); } } applicationContext.xml配置 \u003c!--方式三：使用实例工厂实例化bean--\u003e \u003cbean id=\"userFactory\" class=\"com.itghd.factory.UserDaoFactory\"/\u003e \u003cbean id=\"userDao\" factory-method=\"getUserDao\" factory-bean=\"userFactory\"/\u003e AppForInstanceUser测试类 public class AppForInstanceUser { public static void main(String[] args) { // //创建实例工厂对象 // UserDaoFactory userDaoFactory = new UserDaoFactory(); // //通过实例工厂对象创建对象 // UserDao userDao = userDaoFactory.getUserDao(); // userDao.save(); ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) ctx.getBean(\"userDao\"); userDao.save(); } } 运行结果 2.4 实现FactoryBean\u003cT\u003e方式【扩展,了解】 定义UserDaoFactoryBean实现FactoryBean\u003cUserDao\u003e UserDaoFactoryBean中实例化什么类型的对象泛型就是该类型。 //FactoryBean创建对象 public class UserDaoFactoryBean implements FactoryBean\u003cUserDao\u003e { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } public Class\u003c?\u003e getObjectType() { return UserDao.class; } } applicationContext.xml配置 \u003c!--方式四：使用FactoryBean实例化bean--\u003e \u003cbean id=\"userDao\" class=\"com.itghd.factory.UserDaoFactoryBean\"/\u003e 使用之前的AppForInstanceUser测试类去运行看结果就行了。注意配置文件中id=“userDao\"是否重复。 ","date":"2023-12-31","objectID":"/spring01/:4:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-实例化bean的三种方式"},{"categories":["Spring"],"content":" 2 实例化Bean的三种方式 2.1 构造方法方式【重点】 BookDaoImpl实现类 public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor is running ....\"); } public void save() { System.out.println(\"book dao save ...\"); } } applicationContext.xml配置 AppForInstanceBook测试类 public class AppForInstanceBook { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); } } 运行结果 ==注意：无参构造方法如果不存在，将抛出异常BeanCreationException== 2.2 静态工厂方式 OrderDao接口和OrderDaoImpl实现类 public interface OrderDao { public void save(); } public class OrderDaoImpl implements OrderDao { public void save() { System.out.println(\"order dao save ...\"); } } OrderDaoFatory工厂类 //静态工厂创建对象 public class OrderDaoFactory { public static OrderDao getOrderDao(){ System.out.println(\"factory setup....\"); return new OrderDaoImpl(); } } applicationContext.xml配置 AppForInstanceOrder测试类 public class AppForInstanceOrder { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); OrderDao orderDao = (OrderDao) ctx.getBean(\"orderDao\"); orderDao.save(); } } 运行结果 2.3 实例工厂方式 UserDao接口和UserDaoImpl实现类 public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { public void save() { System.out.println(\"user dao save ...\"); } } UserDaoFactory工厂类 //实例工厂创建对象 public class UserDaoFactory { public UserDao getUserDao(){ return new UserDaoImpl(); } } applicationContext.xml配置 AppForInstanceUser测试类 public class AppForInstanceUser { public static void main(String[] args) { // //创建实例工厂对象 // UserDaoFactory userDaoFactory = new UserDaoFactory(); // //通过实例工厂对象创建对象 // UserDao userDao = userDaoFactory.getUserDao(); // userDao.save(); ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) ctx.getBean(\"userDao\"); userDao.save(); } } 运行结果 2.4 实现FactoryBean方式【扩展,了解】 定义UserDaoFactoryBean实现FactoryBean UserDaoFactoryBean中实例化什么类型的对象泛型就是该类型。 //FactoryBean创建对象 public class UserDaoFactoryBean implements FactoryBean { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } public Class\u003c?\u003e getObjectType() { return UserDao.class; } } applicationContext.xml配置 使用之前的AppForInstanceUser测试类去运行看结果就行了。注意配置文件中id=“userDao\"是否重复。 ","date":"2023-12-31","objectID":"/spring01/:4:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-构造方法方式重点"},{"categories":["Spring"],"content":" 2 实例化Bean的三种方式 2.1 构造方法方式【重点】 BookDaoImpl实现类 public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor is running ....\"); } public void save() { System.out.println(\"book dao save ...\"); } } applicationContext.xml配置 AppForInstanceBook测试类 public class AppForInstanceBook { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); } } 运行结果 ==注意：无参构造方法如果不存在，将抛出异常BeanCreationException== 2.2 静态工厂方式 OrderDao接口和OrderDaoImpl实现类 public interface OrderDao { public void save(); } public class OrderDaoImpl implements OrderDao { public void save() { System.out.println(\"order dao save ...\"); } } OrderDaoFatory工厂类 //静态工厂创建对象 public class OrderDaoFactory { public static OrderDao getOrderDao(){ System.out.println(\"factory setup....\"); return new OrderDaoImpl(); } } applicationContext.xml配置 AppForInstanceOrder测试类 public class AppForInstanceOrder { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); OrderDao orderDao = (OrderDao) ctx.getBean(\"orderDao\"); orderDao.save(); } } 运行结果 2.3 实例工厂方式 UserDao接口和UserDaoImpl实现类 public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { public void save() { System.out.println(\"user dao save ...\"); } } UserDaoFactory工厂类 //实例工厂创建对象 public class UserDaoFactory { public UserDao getUserDao(){ return new UserDaoImpl(); } } applicationContext.xml配置 AppForInstanceUser测试类 public class AppForInstanceUser { public static void main(String[] args) { // //创建实例工厂对象 // UserDaoFactory userDaoFactory = new UserDaoFactory(); // //通过实例工厂对象创建对象 // UserDao userDao = userDaoFactory.getUserDao(); // userDao.save(); ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) ctx.getBean(\"userDao\"); userDao.save(); } } 运行结果 2.4 实现FactoryBean方式【扩展,了解】 定义UserDaoFactoryBean实现FactoryBean UserDaoFactoryBean中实例化什么类型的对象泛型就是该类型。 //FactoryBean创建对象 public class UserDaoFactoryBean implements FactoryBean { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } public Class\u003c?\u003e getObjectType() { return UserDao.class; } } applicationContext.xml配置 使用之前的AppForInstanceUser测试类去运行看结果就行了。注意配置文件中id=“userDao\"是否重复。 ","date":"2023-12-31","objectID":"/spring01/:4:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#22-静态工厂方式"},{"categories":["Spring"],"content":" 2 实例化Bean的三种方式 2.1 构造方法方式【重点】 BookDaoImpl实现类 public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor is running ....\"); } public void save() { System.out.println(\"book dao save ...\"); } } applicationContext.xml配置 AppForInstanceBook测试类 public class AppForInstanceBook { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); } } 运行结果 ==注意：无参构造方法如果不存在，将抛出异常BeanCreationException== 2.2 静态工厂方式 OrderDao接口和OrderDaoImpl实现类 public interface OrderDao { public void save(); } public class OrderDaoImpl implements OrderDao { public void save() { System.out.println(\"order dao save ...\"); } } OrderDaoFatory工厂类 //静态工厂创建对象 public class OrderDaoFactory { public static OrderDao getOrderDao(){ System.out.println(\"factory setup....\"); return new OrderDaoImpl(); } } applicationContext.xml配置 AppForInstanceOrder测试类 public class AppForInstanceOrder { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); OrderDao orderDao = (OrderDao) ctx.getBean(\"orderDao\"); orderDao.save(); } } 运行结果 2.3 实例工厂方式 UserDao接口和UserDaoImpl实现类 public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { public void save() { System.out.println(\"user dao save ...\"); } } UserDaoFactory工厂类 //实例工厂创建对象 public class UserDaoFactory { public UserDao getUserDao(){ return new UserDaoImpl(); } } applicationContext.xml配置 AppForInstanceUser测试类 public class AppForInstanceUser { public static void main(String[] args) { // //创建实例工厂对象 // UserDaoFactory userDaoFactory = new UserDaoFactory(); // //通过实例工厂对象创建对象 // UserDao userDao = userDaoFactory.getUserDao(); // userDao.save(); ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) ctx.getBean(\"userDao\"); userDao.save(); } } 运行结果 2.4 实现FactoryBean方式【扩展,了解】 定义UserDaoFactoryBean实现FactoryBean UserDaoFactoryBean中实例化什么类型的对象泛型就是该类型。 //FactoryBean创建对象 public class UserDaoFactoryBean implements FactoryBean { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } public Class\u003c?\u003e getObjectType() { return UserDao.class; } } applicationContext.xml配置 使用之前的AppForInstanceUser测试类去运行看结果就行了。注意配置文件中id=“userDao\"是否重复。 ","date":"2023-12-31","objectID":"/spring01/:4:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#23-实例工厂方式"},{"categories":["Spring"],"content":" 2 实例化Bean的三种方式 2.1 构造方法方式【重点】 BookDaoImpl实现类 public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor is running ....\"); } public void save() { System.out.println(\"book dao save ...\"); } } applicationContext.xml配置 AppForInstanceBook测试类 public class AppForInstanceBook { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); } } 运行结果 ==注意：无参构造方法如果不存在，将抛出异常BeanCreationException== 2.2 静态工厂方式 OrderDao接口和OrderDaoImpl实现类 public interface OrderDao { public void save(); } public class OrderDaoImpl implements OrderDao { public void save() { System.out.println(\"order dao save ...\"); } } OrderDaoFatory工厂类 //静态工厂创建对象 public class OrderDaoFactory { public static OrderDao getOrderDao(){ System.out.println(\"factory setup....\"); return new OrderDaoImpl(); } } applicationContext.xml配置 AppForInstanceOrder测试类 public class AppForInstanceOrder { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); OrderDao orderDao = (OrderDao) ctx.getBean(\"orderDao\"); orderDao.save(); } } 运行结果 2.3 实例工厂方式 UserDao接口和UserDaoImpl实现类 public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { public void save() { System.out.println(\"user dao save ...\"); } } UserDaoFactory工厂类 //实例工厂创建对象 public class UserDaoFactory { public UserDao getUserDao(){ return new UserDaoImpl(); } } applicationContext.xml配置 AppForInstanceUser测试类 public class AppForInstanceUser { public static void main(String[] args) { // //创建实例工厂对象 // UserDaoFactory userDaoFactory = new UserDaoFactory(); // //通过实例工厂对象创建对象 // UserDao userDao = userDaoFactory.getUserDao(); // userDao.save(); ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) ctx.getBean(\"userDao\"); userDao.save(); } } 运行结果 2.4 实现FactoryBean方式【扩展,了解】 定义UserDaoFactoryBean实现FactoryBean UserDaoFactoryBean中实例化什么类型的对象泛型就是该类型。 //FactoryBean创建对象 public class UserDaoFactoryBean implements FactoryBean { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } public Class\u003c?\u003e getObjectType() { return UserDao.class; } } applicationContext.xml配置 使用之前的AppForInstanceUser测试类去运行看结果就行了。注意配置文件中id=“userDao\"是否重复。 ","date":"2023-12-31","objectID":"/spring01/:4:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#24-实现factorybeant方式扩展了解"},{"categories":["Spring"],"content":" 五、Bean的生命周期【了解】","date":"2023-12-31","objectID":"/spring01/:5:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#五bean的生命周期了解"},{"categories":["Spring"],"content":" 问题导入问题1：多例的Bean能够配置并执行销毁的方法？ 问题2：如何做才执行Bean销毁的方法？ ","date":"2023-12-31","objectID":"/spring01/:5:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-4"},{"categories":["Spring"],"content":" 1 生命周期相关概念介绍 生命周期：从创建到消亡的完整过程 bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做一些事情 ","date":"2023-12-31","objectID":"/spring01/:5:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-生命周期相关概念介绍"},{"categories":["Spring"],"content":" 2 代码演示 2.1 Bean生命周期控制 提供生命周期控制方法 public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } //表示bean初始化对应的操作 public void init(){ System.out.println(\"init...\"); } //表示bean销毁前对应的操作 public void destory(){ System.out.println(\"destory...\"); } } applicationContext.xml配置 \u003c!--init-method：设置bean初始化生命周期回调函数,此处填写init方法名--\u003e \u003c!--destroy-method：设置bean销毁生命周期回调函数，仅适用于单例对象，此处填写destory方法名--\u003e \u003cbean id=\"bookDao\" class=\"com.itghd.dao.impl.BookDaoImpl\" init-method=\"init\" destroy-method=\"destory\"/\u003e 测试类 public class AppForLifeCycle { public static void main( String[] args ) { //此处需要使用实现类类型，接口类型没有close方法 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); //关闭容器，执行销毁的方法 ctx.close(); } } 2.2 Bean生命周期控制 实现InitializingBean, DisposableBean接口 public class BookServiceImpl implements BookService, InitializingBean, DisposableBean { private BookDao bookDao; public void setBookDao(BookDao bookDao) { System.out.println(\"set .....\"); this.bookDao = bookDao; } public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } public void destroy() throws Exception { System.out.println(\"service destroy\"); } public void afterPropertiesSet() throws Exception { System.out.println(\"service init\"); } } 测试类代码同《3.2.1 Bean生命周期控制》中的测试代码 ","date":"2023-12-31","objectID":"/spring01/:5:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-代码演示"},{"categories":["Spring"],"content":" 2 代码演示 2.1 Bean生命周期控制 提供生命周期控制方法 public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } //表示bean初始化对应的操作 public void init(){ System.out.println(\"init...\"); } //表示bean销毁前对应的操作 public void destory(){ System.out.println(\"destory...\"); } } applicationContext.xml配置 测试类 public class AppForLifeCycle { public static void main( String[] args ) { //此处需要使用实现类类型，接口类型没有close方法 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); //关闭容器，执行销毁的方法 ctx.close(); } } 2.2 Bean生命周期控制 实现InitializingBean, DisposableBean接口 public class BookServiceImpl implements BookService, InitializingBean, DisposableBean { private BookDao bookDao; public void setBookDao(BookDao bookDao) { System.out.println(\"set .....\"); this.bookDao = bookDao; } public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } public void destroy() throws Exception { System.out.println(\"service destroy\"); } public void afterPropertiesSet() throws Exception { System.out.println(\"service init\"); } } 测试类代码同《3.2.1 Bean生命周期控制》中的测试代码 ","date":"2023-12-31","objectID":"/spring01/:5:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-bean生命周期控制"},{"categories":["Spring"],"content":" 2 代码演示 2.1 Bean生命周期控制 提供生命周期控制方法 public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } //表示bean初始化对应的操作 public void init(){ System.out.println(\"init...\"); } //表示bean销毁前对应的操作 public void destory(){ System.out.println(\"destory...\"); } } applicationContext.xml配置 测试类 public class AppForLifeCycle { public static void main( String[] args ) { //此处需要使用实现类类型，接口类型没有close方法 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); //关闭容器，执行销毁的方法 ctx.close(); } } 2.2 Bean生命周期控制 实现InitializingBean, DisposableBean接口 public class BookServiceImpl implements BookService, InitializingBean, DisposableBean { private BookDao bookDao; public void setBookDao(BookDao bookDao) { System.out.println(\"set .....\"); this.bookDao = bookDao; } public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } public void destroy() throws Exception { System.out.println(\"service destroy\"); } public void afterPropertiesSet() throws Exception { System.out.println(\"service init\"); } } 测试类代码同《3.2.1 Bean生命周期控制》中的测试代码 ","date":"2023-12-31","objectID":"/spring01/:5:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#22-bean生命周期控制"},{"categories":["Spring"],"content":" 3 Bean销毁时机 容器关闭前触发bean的销毁 关闭容器方式： 手工关闭容器 ConfigurableApplicationContext接口close()操作 注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机 ConfigurableApplicationContext接口registerShutdownHook()操作 public class AppForLifeCycle { public static void main( String[] args ) { //此处需要使用实现类类型，接口类型没有close方法 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); //注册关闭钩子函数，在虚拟机退出之前回调此函数，关闭容器 ctx.registerShutdownHook(); //关闭容器 //ctx.close(); } } ","date":"2023-12-31","objectID":"/spring01/:5:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#3-bean销毁时机"},{"categories":["Spring"],"content":" 六、依赖注入(DI配置)","date":"2023-12-31","objectID":"/spring01/:6:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#六依赖注入di配置"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-依赖注入方式重点"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-5"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-依赖注入的两种方式"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-setter方式注入"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-6"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#引用类型"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#简单类型"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#13-构造方式注入"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-7"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#引用类型-1"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#简单类型-1"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#参数适配了解"},{"categories":["Spring"],"content":" 1 依赖注入方式【重点】 问题导入依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2023-12-31","objectID":"/spring01/:6:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#14-依赖注入方式选择"},{"categories":["Spring"],"content":" 2 依赖自动装配【理解】 问题导入如何配置按照类型自动装配？ 2.1 自动装配概念 IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配方式 ==按类型（常用）== 按名称 按构造方法 不启用自动装配 2.2 自动装配类型 依赖自动装配 配置中使用bean标签autowire属性设置自动装配的类型 \u003cbean id=\"bookDao\" class=\"com.itghd.dao.impl.BookDaoImpl\"/\u003e \u003cbean id=\"bookService\" class=\"com.itghd.service.impl.BookServiceImpl\" autowire=\"byType\"/\u003e 依赖自动装配特征 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 ","date":"2023-12-31","objectID":"/spring01/:6:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-依赖自动装配理解"},{"categories":["Spring"],"content":" 2 依赖自动装配【理解】 问题导入如何配置按照类型自动装配？ 2.1 自动装配概念 IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配方式 ==按类型（常用）== 按名称 按构造方法 不启用自动装配 2.2 自动装配类型 依赖自动装配 配置中使用bean标签autowire属性设置自动装配的类型 依赖自动装配特征 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 ","date":"2023-12-31","objectID":"/spring01/:6:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-8"},{"categories":["Spring"],"content":" 2 依赖自动装配【理解】 问题导入如何配置按照类型自动装配？ 2.1 自动装配概念 IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配方式 ==按类型（常用）== 按名称 按构造方法 不启用自动装配 2.2 自动装配类型 依赖自动装配 配置中使用bean标签autowire属性设置自动装配的类型 依赖自动装配特征 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 ","date":"2023-12-31","objectID":"/spring01/:6:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-自动装配概念"},{"categories":["Spring"],"content":" 2 依赖自动装配【理解】 问题导入如何配置按照类型自动装配？ 2.1 自动装配概念 IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配方式 ==按类型（常用）== 按名称 按构造方法 不启用自动装配 2.2 自动装配类型 依赖自动装配 配置中使用bean标签autowire属性设置自动装配的类型 依赖自动装配特征 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 ","date":"2023-12-31","objectID":"/spring01/:6:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#22-自动装配类型"},{"categories":["Spring"],"content":" 2 依赖自动装配【理解】 问题导入如何配置按照类型自动装配？ 2.1 自动装配概念 IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配方式 ==按类型（常用）== 按名称 按构造方法 不启用自动装配 2.2 自动装配类型 依赖自动装配 配置中使用bean标签autowire属性设置自动装配的类型 依赖自动装配特征 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 ","date":"2023-12-31","objectID":"/spring01/:6:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#依赖自动装配"},{"categories":["Spring"],"content":" 2 依赖自动装配【理解】 问题导入如何配置按照类型自动装配？ 2.1 自动装配概念 IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配方式 ==按类型（常用）== 按名称 按构造方法 不启用自动装配 2.2 自动装配类型 依赖自动装配 配置中使用bean标签autowire属性设置自动装配的类型 依赖自动装配特征 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 ","date":"2023-12-31","objectID":"/spring01/:6:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#依赖自动装配特征"},{"categories":["Spring"],"content":" 3 集合注入 3.1 注入数组类型数据 \u003cproperty name=\"array\"\u003e \u003carray\u003e \u003cvalue\u003e100\u003c/value\u003e \u003cvalue\u003e200\u003c/value\u003e \u003cvalue\u003e300\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e 3.2 注入List类型数据 \u003cproperty name=\"list\"\u003e \u003clist\u003e \u003cvalue\u003eitcast\u003c/value\u003e \u003cvalue\u003eitghd\u003c/value\u003e \u003cvalue\u003eboxuegu\u003c/value\u003e \u003cvalue\u003echuanzhihui\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e 3.3 注入Set类型数据 \u003cproperty name=\"set\"\u003e \u003cset\u003e \u003cvalue\u003eitcast\u003c/value\u003e \u003cvalue\u003eitghd\u003c/value\u003e \u003cvalue\u003eboxuegu\u003c/value\u003e \u003cvalue\u003eboxuegu\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e 3.4 注入Map类型数据 \u003cproperty name=\"map\"\u003e \u003cmap\u003e \u003centry key=\"country\" value=\"china\"/\u003e \u003centry key=\"province\" value=\"henan\"/\u003e \u003centry key=\"city\" value=\"kaifeng\"/\u003e \u003c/map\u003e \u003c/property\u003e 3.5 注入Properties类型数据 \u003cproperty name=\"properties\"\u003e \u003cprops\u003e \u003cprop key=\"country\"\u003echina\u003c/prop\u003e \u003cprop key=\"province\"\u003ehenan\u003c/prop\u003e \u003cprop key=\"city\"\u003ekaifeng\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e 说明：property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写\u003carray\u003e、\u003clist\u003e、\u003cset\u003e、\u003cmap\u003e、\u003cprops\u003e标签 ","date":"2023-12-31","objectID":"/spring01/:6:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#3-集合注入"},{"categories":["Spring"],"content":" 3 集合注入 3.1 注入数组类型数据 100 200 300 3.2 注入List类型数据 itcast itghd boxuegu chuanzhihui 3.3 注入Set类型数据 itcast itghd boxuegu boxuegu 3.4 注入Map类型数据 3.5 注入Properties类型数据 china henan kaifeng 说明：property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写、、、、标签 ","date":"2023-12-31","objectID":"/spring01/:6:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#31-注入数组类型数据"},{"categories":["Spring"],"content":" 3 集合注入 3.1 注入数组类型数据 100 200 300 3.2 注入List类型数据 itcast itghd boxuegu chuanzhihui 3.3 注入Set类型数据 itcast itghd boxuegu boxuegu 3.4 注入Map类型数据 3.5 注入Properties类型数据 china henan kaifeng 说明：property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写、、、、标签 ","date":"2023-12-31","objectID":"/spring01/:6:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#32-注入list类型数据"},{"categories":["Spring"],"content":" 3 集合注入 3.1 注入数组类型数据 100 200 300 3.2 注入List类型数据 itcast itghd boxuegu chuanzhihui 3.3 注入Set类型数据 itcast itghd boxuegu boxuegu 3.4 注入Map类型数据 3.5 注入Properties类型数据 china henan kaifeng 说明：property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写、、、、标签 ","date":"2023-12-31","objectID":"/spring01/:6:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#33-注入set类型数据"},{"categories":["Spring"],"content":" 3 集合注入 3.1 注入数组类型数据 100 200 300 3.2 注入List类型数据 itcast itghd boxuegu chuanzhihui 3.3 注入Set类型数据 itcast itghd boxuegu boxuegu 3.4 注入Map类型数据 3.5 注入Properties类型数据 china henan kaifeng 说明：property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写、、、、标签 ","date":"2023-12-31","objectID":"/spring01/:6:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#34-注入map类型数据"},{"categories":["Spring"],"content":" 3 集合注入 3.1 注入数组类型数据 100 200 300 3.2 注入List类型数据 itcast itghd boxuegu chuanzhihui 3.3 注入Set类型数据 itcast itghd boxuegu boxuegu 3.4 注入Map类型数据 3.5 注入Properties类型数据 china henan kaifeng 说明：property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写、、、、标签 ","date":"2023-12-31","objectID":"/spring01/:6:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#35-注入properties类型数据"},{"categories":["Spring"],"content":" 四、第三方资源配置管理","date":"2023-12-31","objectID":"/spring01/:7:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#四第三方资源配置管理"},{"categories":["Spring"],"content":" 1 管理DataSource连接池对象 问题导入配置数据库连接参数时，注入驱动类名是用driverClassName还是driver？ 1.1 管理Druid连接池【重点】数据库准备 create database if not exists spring_db character set utf8; use spring_db; create table if not exists tbl_account( id int primary key auto_increment, name varchar(20), money double ); insert into tbl_account values(null,'Tom',1000); insert into tbl_account values(null,'Jerry',1000); 【第一步】添加Druid连接池依赖 jdk8 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e1.1.16\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e jdk17 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e1.2.6\u003c/version\u003e \u003c!-- 使用最新的 Druid 版本 --\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.27\u003c/version\u003e \u003c!-- 使用最新的 MySQL Connector 版本 --\u003e \u003c/dependency\u003e 注意：除了添加以上两个依赖之外，别忘了添加spring-context依赖。 【第二步】配置DruidDataSource连接池Bean对象 \u003cbean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/spring_db\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/bean\u003e 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } 1.2 管理c3p0连接池【第一步】添加c3p0连接池依赖 \u003cdependency\u003e \u003cgroupId\u003ec3p0\u003c/groupId\u003e \u003cartifactId\u003ec3p0\u003c/artifactId\u003e \u003cversion\u003e0.9.1.2\u003c/version\u003e \u003c/dependency\u003e 【第二步】配置c3p0连接池Bean对象 \u003cbean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring_db\"/\u003e \u003cproperty name=\"user\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003cproperty name=\"maxPoolSize\" value=\"1000\"/\u003e \u003c/bean\u003e 注意：同一个Spring容器中不能有两个id=“dataSource\"的连接池。 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } ","date":"2023-12-31","objectID":"/spring01/:7:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-管理datasource连接池对象"},{"categories":["Spring"],"content":" 1 管理DataSource连接池对象 问题导入配置数据库连接参数时，注入驱动类名是用driverClassName还是driver？ 1.1 管理Druid连接池【重点】数据库准备 create database if not exists spring_db character set utf8; use spring_db; create table if not exists tbl_account( id int primary key auto_increment, name varchar(20), money double ); insert into tbl_account values(null,'Tom',1000); insert into tbl_account values(null,'Jerry',1000); 【第一步】添加Druid连接池依赖 jdk8 com.alibaba druid 1.1.16 mysql mysql-connector-java 5.1.47 jdk17 com.alibaba druid 1.2.6 mysql mysql-connector-java 8.0.27 注意：除了添加以上两个依赖之外，别忘了添加spring-context依赖。 【第二步】配置DruidDataSource连接池Bean对象 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } 1.2 管理c3p0连接池【第一步】添加c3p0连接池依赖 c3p0 c3p0 0.9.1.2 【第二步】配置c3p0连接池Bean对象 注意：同一个Spring容器中不能有两个id=“dataSource\"的连接池。 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } ","date":"2023-12-31","objectID":"/spring01/:7:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-9"},{"categories":["Spring"],"content":" 1 管理DataSource连接池对象 问题导入配置数据库连接参数时，注入驱动类名是用driverClassName还是driver？ 1.1 管理Druid连接池【重点】数据库准备 create database if not exists spring_db character set utf8; use spring_db; create table if not exists tbl_account( id int primary key auto_increment, name varchar(20), money double ); insert into tbl_account values(null,'Tom',1000); insert into tbl_account values(null,'Jerry',1000); 【第一步】添加Druid连接池依赖 jdk8 com.alibaba druid 1.1.16 mysql mysql-connector-java 5.1.47 jdk17 com.alibaba druid 1.2.6 mysql mysql-connector-java 8.0.27 注意：除了添加以上两个依赖之外，别忘了添加spring-context依赖。 【第二步】配置DruidDataSource连接池Bean对象 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } 1.2 管理c3p0连接池【第一步】添加c3p0连接池依赖 c3p0 c3p0 0.9.1.2 【第二步】配置c3p0连接池Bean对象 注意：同一个Spring容器中不能有两个id=“dataSource\"的连接池。 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } ","date":"2023-12-31","objectID":"/spring01/:7:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-管理druid连接池重点"},{"categories":["Spring"],"content":" 1 管理DataSource连接池对象 问题导入配置数据库连接参数时，注入驱动类名是用driverClassName还是driver？ 1.1 管理Druid连接池【重点】数据库准备 create database if not exists spring_db character set utf8; use spring_db; create table if not exists tbl_account( id int primary key auto_increment, name varchar(20), money double ); insert into tbl_account values(null,'Tom',1000); insert into tbl_account values(null,'Jerry',1000); 【第一步】添加Druid连接池依赖 jdk8 com.alibaba druid 1.1.16 mysql mysql-connector-java 5.1.47 jdk17 com.alibaba druid 1.2.6 mysql mysql-connector-java 8.0.27 注意：除了添加以上两个依赖之外，别忘了添加spring-context依赖。 【第二步】配置DruidDataSource连接池Bean对象 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } 1.2 管理c3p0连接池【第一步】添加c3p0连接池依赖 c3p0 c3p0 0.9.1.2 【第二步】配置c3p0连接池Bean对象 注意：同一个Spring容器中不能有两个id=“dataSource\"的连接池。 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } ","date":"2023-12-31","objectID":"/spring01/:7:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-管理c3p0连接池"},{"categories":["Spring"],"content":" 2 加载properties属性文件【重点】 目的：将数据库的连接参数抽取到一个单独的文件中，与Spring配置文件解耦。 问题导入问题1：如何解决使用EL表达式读取属性文件中的值结果读取到了系统属性问题？ 问题2：加载properties文件写法标准写法该怎么写？ 2.1 基本用法【第一步】编写jdbc.properties属性文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db jdbc.username=root jdbc.password=root 【第二步】在applicationContext.xml中开启开启context命名空间，加载jdbc.properties属性文件 ==小技巧：如果同学们觉得上述复制粘贴方式不好改或者容易改错，其实idea是有提示功能的，注意不要选错就行了。有些版本的idea没有这个提示，那么就按照上面复制粘贴的方式改，改完之后可以做成live template模板，后期直接用。== \u003ccontext:property-placeholder location=\"jdbc.properties\"/\u003e 【第三步】在配置连接池Bean的地方使用EL表达式获取jdbc.properties属性文件中的值 \u003cbean class=\"com.alibaba.druid.pool.DruidDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"${jdbc.driver}\"/\u003e \u003cproperty name=\"url\" value=\"${jdbc.url}\"/\u003e \u003cproperty name=\"username\" value=\"${jdbc.username}\"/\u003e \u003cproperty name=\"password\" value=\"${jdbc.password}\"/\u003e \u003c/bean\u003e 配置完成之后，运行之前的获取Druid连接池代码，可以获取到连接池对象就表示配置成功。 2.2 配置不加载系统属性问题 如果属性文件中配置的不是jdbc.username，而是username=root666，那么使用${username}获取到的不是root666，而是计算机的名称。 原因 系统属性的优先级比我们属性文件中的高，替换了我们的username=root666。 解决 解决1：换一个名称，例如不叫username，叫jdbc.username。 解决2：使用system-properties-mode=“NEVER\"属性表示不使用系统属性。 \u003ccontext:property-placeholder location=\"jdbc.properties\" system-properties-mode=\"NEVER\"/\u003e 2.3 加载properties文件写法 不加载系统属性 \u003ccontext:property-placeholder location=\"jdbc.properties\" system-properties-mode=\"NEVER\"/\u003e 加载多个properties文件 \u003ccontext:property-placeholder location=\"jdbc.properties,msg.properties\"/\u003e 加载所有properties文件 \u003ccontext:property-placeholder location=\"*.properties\"/\u003e 加载properties文件**==标准格式==** \u003ccontext:property-placeholder location=\"classpath:*.properties\"/\u003e 加载properties文件标准格式 \u003ccontext:property-placeholder location=\"classpath*:*.properties\"/\u003e ","date":"2023-12-31","objectID":"/spring01/:7:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-加载properties属性文件重点"},{"categories":["Spring"],"content":" 2 加载properties属性文件【重点】 目的：将数据库的连接参数抽取到一个单独的文件中，与Spring配置文件解耦。 问题导入问题1：如何解决使用EL表达式读取属性文件中的值结果读取到了系统属性问题？ 问题2：加载properties文件写法标准写法该怎么写？ 2.1 基本用法【第一步】编写jdbc.properties属性文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db jdbc.username=root jdbc.password=root 【第二步】在applicationContext.xml中开启开启context命名空间，加载jdbc.properties属性文件 ==小技巧：如果同学们觉得上述复制粘贴方式不好改或者容易改错，其实idea是有提示功能的，注意不要选错就行了。有些版本的idea没有这个提示，那么就按照上面复制粘贴的方式改，改完之后可以做成live template模板，后期直接用。== 【第三步】在配置连接池Bean的地方使用EL表达式获取jdbc.properties属性文件中的值 配置完成之后，运行之前的获取Druid连接池代码，可以获取到连接池对象就表示配置成功。 2.2 配置不加载系统属性问题 如果属性文件中配置的不是jdbc.username，而是username=root666，那么使用${username}获取到的不是root666，而是计算机的名称。 原因 系统属性的优先级比我们属性文件中的高，替换了我们的username=root666。 解决 解决1：换一个名称，例如不叫username，叫jdbc.username。 解决2：使用system-properties-mode=“NEVER\"属性表示不使用系统属性。 2.3 加载properties文件写法 不加载系统属性 加载多个properties文件 加载所有properties文件 加载properties文件**==标准格式==** 加载properties文件标准格式 ","date":"2023-12-31","objectID":"/spring01/:7:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-10"},{"categories":["Spring"],"content":" 2 加载properties属性文件【重点】 目的：将数据库的连接参数抽取到一个单独的文件中，与Spring配置文件解耦。 问题导入问题1：如何解决使用EL表达式读取属性文件中的值结果读取到了系统属性问题？ 问题2：加载properties文件写法标准写法该怎么写？ 2.1 基本用法【第一步】编写jdbc.properties属性文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db jdbc.username=root jdbc.password=root 【第二步】在applicationContext.xml中开启开启context命名空间，加载jdbc.properties属性文件 ==小技巧：如果同学们觉得上述复制粘贴方式不好改或者容易改错，其实idea是有提示功能的，注意不要选错就行了。有些版本的idea没有这个提示，那么就按照上面复制粘贴的方式改，改完之后可以做成live template模板，后期直接用。== 【第三步】在配置连接池Bean的地方使用EL表达式获取jdbc.properties属性文件中的值 配置完成之后，运行之前的获取Druid连接池代码，可以获取到连接池对象就表示配置成功。 2.2 配置不加载系统属性问题 如果属性文件中配置的不是jdbc.username，而是username=root666，那么使用${username}获取到的不是root666，而是计算机的名称。 原因 系统属性的优先级比我们属性文件中的高，替换了我们的username=root666。 解决 解决1：换一个名称，例如不叫username，叫jdbc.username。 解决2：使用system-properties-mode=“NEVER\"属性表示不使用系统属性。 2.3 加载properties文件写法 不加载系统属性 加载多个properties文件 加载所有properties文件 加载properties文件**==标准格式==** 加载properties文件标准格式 ","date":"2023-12-31","objectID":"/spring01/:7:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-基本用法"},{"categories":["Spring"],"content":" 2 加载properties属性文件【重点】 目的：将数据库的连接参数抽取到一个单独的文件中，与Spring配置文件解耦。 问题导入问题1：如何解决使用EL表达式读取属性文件中的值结果读取到了系统属性问题？ 问题2：加载properties文件写法标准写法该怎么写？ 2.1 基本用法【第一步】编写jdbc.properties属性文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db jdbc.username=root jdbc.password=root 【第二步】在applicationContext.xml中开启开启context命名空间，加载jdbc.properties属性文件 ==小技巧：如果同学们觉得上述复制粘贴方式不好改或者容易改错，其实idea是有提示功能的，注意不要选错就行了。有些版本的idea没有这个提示，那么就按照上面复制粘贴的方式改，改完之后可以做成live template模板，后期直接用。== 【第三步】在配置连接池Bean的地方使用EL表达式获取jdbc.properties属性文件中的值 配置完成之后，运行之前的获取Druid连接池代码，可以获取到连接池对象就表示配置成功。 2.2 配置不加载系统属性问题 如果属性文件中配置的不是jdbc.username，而是username=root666，那么使用${username}获取到的不是root666，而是计算机的名称。 原因 系统属性的优先级比我们属性文件中的高，替换了我们的username=root666。 解决 解决1：换一个名称，例如不叫username，叫jdbc.username。 解决2：使用system-properties-mode=“NEVER\"属性表示不使用系统属性。 2.3 加载properties文件写法 不加载系统属性 加载多个properties文件 加载所有properties文件 加载properties文件**==标准格式==** 加载properties文件标准格式 ","date":"2023-12-31","objectID":"/spring01/:7:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#22-配置不加载系统属性"},{"categories":["Spring"],"content":" 2 加载properties属性文件【重点】 目的：将数据库的连接参数抽取到一个单独的文件中，与Spring配置文件解耦。 问题导入问题1：如何解决使用EL表达式读取属性文件中的值结果读取到了系统属性问题？ 问题2：加载properties文件写法标准写法该怎么写？ 2.1 基本用法【第一步】编写jdbc.properties属性文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db jdbc.username=root jdbc.password=root 【第二步】在applicationContext.xml中开启开启context命名空间，加载jdbc.properties属性文件 ==小技巧：如果同学们觉得上述复制粘贴方式不好改或者容易改错，其实idea是有提示功能的，注意不要选错就行了。有些版本的idea没有这个提示，那么就按照上面复制粘贴的方式改，改完之后可以做成live template模板，后期直接用。== 【第三步】在配置连接池Bean的地方使用EL表达式获取jdbc.properties属性文件中的值 配置完成之后，运行之前的获取Druid连接池代码，可以获取到连接池对象就表示配置成功。 2.2 配置不加载系统属性问题 如果属性文件中配置的不是jdbc.username，而是username=root666，那么使用${username}获取到的不是root666，而是计算机的名称。 原因 系统属性的优先级比我们属性文件中的高，替换了我们的username=root666。 解决 解决1：换一个名称，例如不叫username，叫jdbc.username。 解决2：使用system-properties-mode=“NEVER\"属性表示不使用系统属性。 2.3 加载properties文件写法 不加载系统属性 加载多个properties文件 加载所有properties文件 加载properties文件**==标准格式==** 加载properties文件标准格式 ","date":"2023-12-31","objectID":"/spring01/:7:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#23-加载properties文件写法"},{"categories":["Spring"],"content":" 五、Spring容器","date":"2023-12-31","objectID":"/spring01/:8:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#五spring容器"},{"categories":["Spring"],"content":" 1 Spring核心容器介绍 问题导入问题：按照Bean名称获取Bean有什么弊端，按照Bean类型获取Bean有什么弊端？ 1.1 创建容器 方式一：类路径加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 方式二：文件路径加载配置文件 ApplicationContext ctx = new FileSystemXmlApplicationContext(\"D:\\\\applicationContext.xml\"); 加载多个配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"bean1.xml\", \"bean2.xml\"); 1.2 获取bean对象 方式一：使用bean名称获取 弊端：需要自己强制类型转换 BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); ==方式二：使用bean名称获取并指定类型== 弊端：推荐使用 BookDao bookDao = ctx.getBean(\"bookDao\", BookDao.class); 方式三：使用bean类型获取 弊端：如果IOC容器中同类型的Bean对象有多个，此处获取会报错 BookDao bookDao = ctx.getBean(BookDao.class); 1.3 容器类层次结构 1.4 BeanFactory 类路径加载配置文件 Resource resources = new ClassPathResource(\"applicationContext.xml\"); BeanFactory bf = new XmlBeanFactory(resources); BookDao bookDao = bf.getBean(\"bookDao\", BookDao.class); bookDao.save(); BeanFactory创建完毕后，所有的Bean均为延迟加载，也就是说我们调用getBean()方法获取Bean对象时才创建Bean对象并返回给我们 ","date":"2023-12-31","objectID":"/spring01/:8:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-spring核心容器介绍"},{"categories":["Spring"],"content":" 1 Spring核心容器介绍 问题导入问题：按照Bean名称获取Bean有什么弊端，按照Bean类型获取Bean有什么弊端？ 1.1 创建容器 方式一：类路径加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 方式二：文件路径加载配置文件 ApplicationContext ctx = new FileSystemXmlApplicationContext(\"D:\\\\applicationContext.xml\"); 加载多个配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"bean1.xml\", \"bean2.xml\"); 1.2 获取bean对象 方式一：使用bean名称获取 弊端：需要自己强制类型转换 BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); ==方式二：使用bean名称获取并指定类型== 弊端：推荐使用 BookDao bookDao = ctx.getBean(\"bookDao\", BookDao.class); 方式三：使用bean类型获取 弊端：如果IOC容器中同类型的Bean对象有多个，此处获取会报错 BookDao bookDao = ctx.getBean(BookDao.class); 1.3 容器类层次结构 1.4 BeanFactory 类路径加载配置文件 Resource resources = new ClassPathResource(\"applicationContext.xml\"); BeanFactory bf = new XmlBeanFactory(resources); BookDao bookDao = bf.getBean(\"bookDao\", BookDao.class); bookDao.save(); BeanFactory创建完毕后，所有的Bean均为延迟加载，也就是说我们调用getBean()方法获取Bean对象时才创建Bean对象并返回给我们 ","date":"2023-12-31","objectID":"/spring01/:8:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-11"},{"categories":["Spring"],"content":" 1 Spring核心容器介绍 问题导入问题：按照Bean名称获取Bean有什么弊端，按照Bean类型获取Bean有什么弊端？ 1.1 创建容器 方式一：类路径加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 方式二：文件路径加载配置文件 ApplicationContext ctx = new FileSystemXmlApplicationContext(\"D:\\\\applicationContext.xml\"); 加载多个配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"bean1.xml\", \"bean2.xml\"); 1.2 获取bean对象 方式一：使用bean名称获取 弊端：需要自己强制类型转换 BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); ==方式二：使用bean名称获取并指定类型== 弊端：推荐使用 BookDao bookDao = ctx.getBean(\"bookDao\", BookDao.class); 方式三：使用bean类型获取 弊端：如果IOC容器中同类型的Bean对象有多个，此处获取会报错 BookDao bookDao = ctx.getBean(BookDao.class); 1.3 容器类层次结构 1.4 BeanFactory 类路径加载配置文件 Resource resources = new ClassPathResource(\"applicationContext.xml\"); BeanFactory bf = new XmlBeanFactory(resources); BookDao bookDao = bf.getBean(\"bookDao\", BookDao.class); bookDao.save(); BeanFactory创建完毕后，所有的Bean均为延迟加载，也就是说我们调用getBean()方法获取Bean对象时才创建Bean对象并返回给我们 ","date":"2023-12-31","objectID":"/spring01/:8:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-创建容器"},{"categories":["Spring"],"content":" 1 Spring核心容器介绍 问题导入问题：按照Bean名称获取Bean有什么弊端，按照Bean类型获取Bean有什么弊端？ 1.1 创建容器 方式一：类路径加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 方式二：文件路径加载配置文件 ApplicationContext ctx = new FileSystemXmlApplicationContext(\"D:\\\\applicationContext.xml\"); 加载多个配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"bean1.xml\", \"bean2.xml\"); 1.2 获取bean对象 方式一：使用bean名称获取 弊端：需要自己强制类型转换 BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); ==方式二：使用bean名称获取并指定类型== 弊端：推荐使用 BookDao bookDao = ctx.getBean(\"bookDao\", BookDao.class); 方式三：使用bean类型获取 弊端：如果IOC容器中同类型的Bean对象有多个，此处获取会报错 BookDao bookDao = ctx.getBean(BookDao.class); 1.3 容器类层次结构 1.4 BeanFactory 类路径加载配置文件 Resource resources = new ClassPathResource(\"applicationContext.xml\"); BeanFactory bf = new XmlBeanFactory(resources); BookDao bookDao = bf.getBean(\"bookDao\", BookDao.class); bookDao.save(); BeanFactory创建完毕后，所有的Bean均为延迟加载，也就是说我们调用getBean()方法获取Bean对象时才创建Bean对象并返回给我们 ","date":"2023-12-31","objectID":"/spring01/:8:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-获取bean对象"},{"categories":["Spring"],"content":" 1 Spring核心容器介绍 问题导入问题：按照Bean名称获取Bean有什么弊端，按照Bean类型获取Bean有什么弊端？ 1.1 创建容器 方式一：类路径加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 方式二：文件路径加载配置文件 ApplicationContext ctx = new FileSystemXmlApplicationContext(\"D:\\\\applicationContext.xml\"); 加载多个配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"bean1.xml\", \"bean2.xml\"); 1.2 获取bean对象 方式一：使用bean名称获取 弊端：需要自己强制类型转换 BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); ==方式二：使用bean名称获取并指定类型== 弊端：推荐使用 BookDao bookDao = ctx.getBean(\"bookDao\", BookDao.class); 方式三：使用bean类型获取 弊端：如果IOC容器中同类型的Bean对象有多个，此处获取会报错 BookDao bookDao = ctx.getBean(BookDao.class); 1.3 容器类层次结构 1.4 BeanFactory 类路径加载配置文件 Resource resources = new ClassPathResource(\"applicationContext.xml\"); BeanFactory bf = new XmlBeanFactory(resources); BookDao bookDao = bf.getBean(\"bookDao\", BookDao.class); bookDao.save(); BeanFactory创建完毕后，所有的Bean均为延迟加载，也就是说我们调用getBean()方法获取Bean对象时才创建Bean对象并返回给我们 ","date":"2023-12-31","objectID":"/spring01/:8:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#13-容器类层次结构"},{"categories":["Spring"],"content":" 1 Spring核心容器介绍 问题导入问题：按照Bean名称获取Bean有什么弊端，按照Bean类型获取Bean有什么弊端？ 1.1 创建容器 方式一：类路径加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 方式二：文件路径加载配置文件 ApplicationContext ctx = new FileSystemXmlApplicationContext(\"D:\\\\applicationContext.xml\"); 加载多个配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"bean1.xml\", \"bean2.xml\"); 1.2 获取bean对象 方式一：使用bean名称获取 弊端：需要自己强制类型转换 BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); ==方式二：使用bean名称获取并指定类型== 弊端：推荐使用 BookDao bookDao = ctx.getBean(\"bookDao\", BookDao.class); 方式三：使用bean类型获取 弊端：如果IOC容器中同类型的Bean对象有多个，此处获取会报错 BookDao bookDao = ctx.getBean(BookDao.class); 1.3 容器类层次结构 1.4 BeanFactory 类路径加载配置文件 Resource resources = new ClassPathResource(\"applicationContext.xml\"); BeanFactory bf = new XmlBeanFactory(resources); BookDao bookDao = bf.getBean(\"bookDao\", BookDao.class); bookDao.save(); BeanFactory创建完毕后，所有的Bean均为延迟加载，也就是说我们调用getBean()方法获取Bean对象时才创建Bean对象并返回给我们 ","date":"2023-12-31","objectID":"/spring01/:8:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#14-beanfactory"},{"categories":["Spring"],"content":" 2 Spring核心容器总结 2.1 容器相关 BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载 ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能 ApplicationContext接口常用初始化类 ==ClassPathXmlApplicationContext(常用)== FileSystemXmlApplicationContext 2.2 bean相关 2.3 依赖注入相关 ","date":"2023-12-31","objectID":"/spring01/:8:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-spring核心容器总结"},{"categories":["Spring"],"content":" 2 Spring核心容器总结 2.1 容器相关 BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载 ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能 ApplicationContext接口常用初始化类 ==ClassPathXmlApplicationContext(常用)== FileSystemXmlApplicationContext 2.2 bean相关 2.3 依赖注入相关 ","date":"2023-12-31","objectID":"/spring01/:8:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-容器相关"},{"categories":["Spring"],"content":" 2 Spring核心容器总结 2.1 容器相关 BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载 ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能 ApplicationContext接口常用初始化类 ==ClassPathXmlApplicationContext(常用)== FileSystemXmlApplicationContext 2.2 bean相关 2.3 依赖注入相关 ","date":"2023-12-31","objectID":"/spring01/:8:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#22-bean相关"},{"categories":["Spring"],"content":" 2 Spring核心容器总结 2.1 容器相关 BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载 ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能 ApplicationContext接口常用初始化类 ==ClassPathXmlApplicationContext(常用)== FileSystemXmlApplicationContext 2.2 bean相关 2.3 依赖注入相关 ","date":"2023-12-31","objectID":"/spring01/:8:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#23-依赖注入相关"},{"categories":["Spring"],"content":" 六、Spring注解开发","date":"2023-12-31","objectID":"/spring01/:9:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#六spring注解开发"},{"categories":["Spring"],"content":" 1 注解开发定义Bean对象【重点】 目的：xml配置Bean对象有些繁琐，使用注解简化Bean对象的定义 问题导入问题1：使用什么标签进行Spring注解包扫描？ 问题2：@Component注解和@Controller、@Service、@Repository三个衍生注解有什么区别？ 1.1 基本使用【第一步】在applicationContext.xml中开启Spring注解包扫描 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!--扫描com.itghd包及其子包下的类中注解--\u003e \u003ccontext:component-scan base-package=\"com.itghd\"/\u003e \u003c/beans\u003e 【第二步】在类上使用@Component注解定义Bean。 //@Component定义bean @Component(\"bookDao\") public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } @Component public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 补充说明：如果@Component注解没有使用参数指定Bean的名称，那么类名首字母小写就是Bean在IOC容器中的默认名称。例如：BookServiceImpl对象在IOC容器中的名称是bookServiceImpl。 【第三步】在测试类中获取Bean对象 public class AppForAnnotation { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } 注意：在测试类中不要调用bookService的save方法，因为还没有给BookServiceImpl中的bookDao赋值，调用bookService的save方法会出现空指针异常。 运行结果 1.2 @Component三个衍生注解 说明：加粗的注解为常用注解 Spring提供**@Component**注解的三个衍生注解 @Controller：用于表现层bean定义 @Service：用于业务层bean定义 @Repository：用于数据层bean定义 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { } @Service public class BookServiceImpl implements BookService { } ","date":"2023-12-31","objectID":"/spring01/:9:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-注解开发定义bean对象重点"},{"categories":["Spring"],"content":" 1 注解开发定义Bean对象【重点】 目的：xml配置Bean对象有些繁琐，使用注解简化Bean对象的定义 问题导入问题1：使用什么标签进行Spring注解包扫描？ 问题2：@Component注解和@Controller、@Service、@Repository三个衍生注解有什么区别？ 1.1 基本使用【第一步】在applicationContext.xml中开启Spring注解包扫描 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 【第二步】在类上使用@Component注解定义Bean。 //@Component定义bean @Component(\"bookDao\") public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } @Component public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 补充说明：如果@Component注解没有使用参数指定Bean的名称，那么类名首字母小写就是Bean在IOC容器中的默认名称。例如：BookServiceImpl对象在IOC容器中的名称是bookServiceImpl。 【第三步】在测试类中获取Bean对象 public class AppForAnnotation { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } 注意：在测试类中不要调用bookService的save方法，因为还没有给BookServiceImpl中的bookDao赋值，调用bookService的save方法会出现空指针异常。 运行结果 1.2 @Component三个衍生注解 说明：加粗的注解为常用注解 Spring提供**@Component**注解的三个衍生注解 @Controller：用于表现层bean定义 @Service：用于业务层bean定义 @Repository：用于数据层bean定义 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { } @Service public class BookServiceImpl implements BookService { } ","date":"2023-12-31","objectID":"/spring01/:9:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-12"},{"categories":["Spring"],"content":" 1 注解开发定义Bean对象【重点】 目的：xml配置Bean对象有些繁琐，使用注解简化Bean对象的定义 问题导入问题1：使用什么标签进行Spring注解包扫描？ 问题2：@Component注解和@Controller、@Service、@Repository三个衍生注解有什么区别？ 1.1 基本使用【第一步】在applicationContext.xml中开启Spring注解包扫描 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 【第二步】在类上使用@Component注解定义Bean。 //@Component定义bean @Component(\"bookDao\") public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } @Component public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 补充说明：如果@Component注解没有使用参数指定Bean的名称，那么类名首字母小写就是Bean在IOC容器中的默认名称。例如：BookServiceImpl对象在IOC容器中的名称是bookServiceImpl。 【第三步】在测试类中获取Bean对象 public class AppForAnnotation { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } 注意：在测试类中不要调用bookService的save方法，因为还没有给BookServiceImpl中的bookDao赋值，调用bookService的save方法会出现空指针异常。 运行结果 1.2 @Component三个衍生注解 说明：加粗的注解为常用注解 Spring提供**@Component**注解的三个衍生注解 @Controller：用于表现层bean定义 @Service：用于业务层bean定义 @Repository：用于数据层bean定义 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { } @Service public class BookServiceImpl implements BookService { } ","date":"2023-12-31","objectID":"/spring01/:9:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-基本使用"},{"categories":["Spring"],"content":" 1 注解开发定义Bean对象【重点】 目的：xml配置Bean对象有些繁琐，使用注解简化Bean对象的定义 问题导入问题1：使用什么标签进行Spring注解包扫描？ 问题2：@Component注解和@Controller、@Service、@Repository三个衍生注解有什么区别？ 1.1 基本使用【第一步】在applicationContext.xml中开启Spring注解包扫描 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 【第二步】在类上使用@Component注解定义Bean。 //@Component定义bean @Component(\"bookDao\") public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } @Component public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 补充说明：如果@Component注解没有使用参数指定Bean的名称，那么类名首字母小写就是Bean在IOC容器中的默认名称。例如：BookServiceImpl对象在IOC容器中的名称是bookServiceImpl。 【第三步】在测试类中获取Bean对象 public class AppForAnnotation { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } 注意：在测试类中不要调用bookService的save方法，因为还没有给BookServiceImpl中的bookDao赋值，调用bookService的save方法会出现空指针异常。 运行结果 1.2 @Component三个衍生注解 说明：加粗的注解为常用注解 Spring提供**@Component**注解的三个衍生注解 @Controller：用于表现层bean定义 @Service：用于业务层bean定义 @Repository：用于数据层bean定义 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { } @Service public class BookServiceImpl implements BookService { } ","date":"2023-12-31","objectID":"/spring01/:9:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-component三个衍生注解"},{"categories":["Spring"],"content":" 2 纯注解开发模式【重点】 问题导入问题1：配置类上使用什么注解表示该类是一个配置类？ 问题2：配置类上使用什么注解进行Spring注解包扫描？ 2.1 纯注解开发模式介绍 Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道 Java类代替Spring核心配置文件 @Configuration注解用于设定当前类为配置类 @ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式 @ComponentScan({com.itghd.service\",\"com.itghd.dao\"}) 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象 //加载配置文件初始化容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //加载配置类初始化容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); 2.2 代码演示【第一步】定义配置类代替配置文件 //声明当前类为Spring配置类 @Configuration //Spring注解扫描，相当于\u003ccontext:component-scan base-package=\"com.itghd\"/\u003e @ComponentScan(\"com.itghd\") //设置bean扫描路径，多个路径书写为字符串数组格式 //@ComponentScan({\"com.itghd.service\",\"com.itghd.dao\"}) public class SpringConfig { } 【第二步】在测试类中加载配置类，获取Bean对象并使用 public class AppForAnnotation { public static void main(String[] args) { //AnnotationConfigApplicationContext加载Spring配置类初始化Spring容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } ","date":"2023-12-31","objectID":"/spring01/:9:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-纯注解开发模式重点"},{"categories":["Spring"],"content":" 2 纯注解开发模式【重点】 问题导入问题1：配置类上使用什么注解表示该类是一个配置类？ 问题2：配置类上使用什么注解进行Spring注解包扫描？ 2.1 纯注解开发模式介绍 Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道 Java类代替Spring核心配置文件 @Configuration注解用于设定当前类为配置类 @ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式 @ComponentScan({com.itghd.service\",\"com.itghd.dao\"}) 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象 //加载配置文件初始化容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //加载配置类初始化容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); 2.2 代码演示【第一步】定义配置类代替配置文件 //声明当前类为Spring配置类 @Configuration //Spring注解扫描，相当于 @ComponentScan(\"com.itghd\") //设置bean扫描路径，多个路径书写为字符串数组格式 //@ComponentScan({\"com.itghd.service\",\"com.itghd.dao\"}) public class SpringConfig { } 【第二步】在测试类中加载配置类，获取Bean对象并使用 public class AppForAnnotation { public static void main(String[] args) { //AnnotationConfigApplicationContext加载Spring配置类初始化Spring容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } ","date":"2023-12-31","objectID":"/spring01/:9:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-13"},{"categories":["Spring"],"content":" 2 纯注解开发模式【重点】 问题导入问题1：配置类上使用什么注解表示该类是一个配置类？ 问题2：配置类上使用什么注解进行Spring注解包扫描？ 2.1 纯注解开发模式介绍 Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道 Java类代替Spring核心配置文件 @Configuration注解用于设定当前类为配置类 @ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式 @ComponentScan({com.itghd.service\",\"com.itghd.dao\"}) 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象 //加载配置文件初始化容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //加载配置类初始化容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); 2.2 代码演示【第一步】定义配置类代替配置文件 //声明当前类为Spring配置类 @Configuration //Spring注解扫描，相当于 @ComponentScan(\"com.itghd\") //设置bean扫描路径，多个路径书写为字符串数组格式 //@ComponentScan({\"com.itghd.service\",\"com.itghd.dao\"}) public class SpringConfig { } 【第二步】在测试类中加载配置类，获取Bean对象并使用 public class AppForAnnotation { public static void main(String[] args) { //AnnotationConfigApplicationContext加载Spring配置类初始化Spring容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } ","date":"2023-12-31","objectID":"/spring01/:9:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-纯注解开发模式介绍"},{"categories":["Spring"],"content":" 2 纯注解开发模式【重点】 问题导入问题1：配置类上使用什么注解表示该类是一个配置类？ 问题2：配置类上使用什么注解进行Spring注解包扫描？ 2.1 纯注解开发模式介绍 Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道 Java类代替Spring核心配置文件 @Configuration注解用于设定当前类为配置类 @ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式 @ComponentScan({com.itghd.service\",\"com.itghd.dao\"}) 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象 //加载配置文件初始化容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //加载配置类初始化容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); 2.2 代码演示【第一步】定义配置类代替配置文件 //声明当前类为Spring配置类 @Configuration //Spring注解扫描，相当于 @ComponentScan(\"com.itghd\") //设置bean扫描路径，多个路径书写为字符串数组格式 //@ComponentScan({\"com.itghd.service\",\"com.itghd.dao\"}) public class SpringConfig { } 【第二步】在测试类中加载配置类，获取Bean对象并使用 public class AppForAnnotation { public static void main(String[] args) { //AnnotationConfigApplicationContext加载Spring配置类初始化Spring容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } ","date":"2023-12-31","objectID":"/spring01/:9:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#22-代码演示"},{"categories":["Spring"],"content":" 3 注解开发Bean作用范围和生命周期管理 问题导入在类上使用什么注解定义Bean的作用范围？ 3.1 bean作用范围注解配置 使用@Scope定义bean作用范围 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { } 3.2 bean生命周期注解配置 使用@PostConstruct、@PreDestroy定义bean生命周期 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor ...\"); } @PostConstruct public void init(){ System.out.println(\"book init ...\"); } @PreDestroy public void destroy(){ System.out.println(\"book destory ...\"); } } ==注意：@PostConstruct和@PreDestroy注解是jdk中提供的注解，从jdk9开始，jdk中的javax.annotation包被移除了，也就是说这两个注解就用不了了，可以额外导入一下依赖解决这个问题。== \u003cdependency\u003e \u003cgroupId\u003ejavax.annotation\u003c/groupId\u003e \u003cartifactId\u003ejavax.annotation-api\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2023-12-31","objectID":"/spring01/:9:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#3-注解开发bean作用范围和生命周期管理"},{"categories":["Spring"],"content":" 3 注解开发Bean作用范围和生命周期管理 问题导入在类上使用什么注解定义Bean的作用范围？ 3.1 bean作用范围注解配置 使用@Scope定义bean作用范围 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { } 3.2 bean生命周期注解配置 使用@PostConstruct、@PreDestroy定义bean生命周期 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor ...\"); } @PostConstruct public void init(){ System.out.println(\"book init ...\"); } @PreDestroy public void destroy(){ System.out.println(\"book destory ...\"); } } ==注意：@PostConstruct和@PreDestroy注解是jdk中提供的注解，从jdk9开始，jdk中的javax.annotation包被移除了，也就是说这两个注解就用不了了，可以额外导入一下依赖解决这个问题。== javax.annotation javax.annotation-api 1.3.2 ","date":"2023-12-31","objectID":"/spring01/:9:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-14"},{"categories":["Spring"],"content":" 3 注解开发Bean作用范围和生命周期管理 问题导入在类上使用什么注解定义Bean的作用范围？ 3.1 bean作用范围注解配置 使用@Scope定义bean作用范围 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { } 3.2 bean生命周期注解配置 使用@PostConstruct、@PreDestroy定义bean生命周期 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor ...\"); } @PostConstruct public void init(){ System.out.println(\"book init ...\"); } @PreDestroy public void destroy(){ System.out.println(\"book destory ...\"); } } ==注意：@PostConstruct和@PreDestroy注解是jdk中提供的注解，从jdk9开始，jdk中的javax.annotation包被移除了，也就是说这两个注解就用不了了，可以额外导入一下依赖解决这个问题。== javax.annotation javax.annotation-api 1.3.2 ","date":"2023-12-31","objectID":"/spring01/:9:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#31-bean作用范围注解配置"},{"categories":["Spring"],"content":" 3 注解开发Bean作用范围和生命周期管理 问题导入在类上使用什么注解定义Bean的作用范围？ 3.1 bean作用范围注解配置 使用@Scope定义bean作用范围 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { } 3.2 bean生命周期注解配置 使用@PostConstruct、@PreDestroy定义bean生命周期 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor ...\"); } @PostConstruct public void init(){ System.out.println(\"book init ...\"); } @PreDestroy public void destroy(){ System.out.println(\"book destory ...\"); } } ==注意：@PostConstruct和@PreDestroy注解是jdk中提供的注解，从jdk9开始，jdk中的javax.annotation包被移除了，也就是说这两个注解就用不了了，可以额外导入一下依赖解决这个问题。== javax.annotation javax.annotation-api 1.3.2 ","date":"2023-12-31","objectID":"/spring01/:9:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#32-bean生命周期注解配置"},{"categories":["Spring"],"content":" 4 注解开发依赖注入【重点】 问题导入问题1：请描述@Autowired注解是如何进行自动装配的？ 问题2：请描述@Qualifier注解的作用 4.1 使用@Autowired注解开启自动装配模式（按类型） @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 说明：不管是使用配置文件还是配置类，都必须进行对应的Spring注解包扫描才可以使用。@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean有多个，那么默认按照变量名和Bean的名称匹配，建议使用@Qualifier注解指定要装配的bean名称 ==注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法。== 4.2 使用@Qualifier注解指定要装配的bean名称 目的：解决IOC容器中同类型Bean有多个装配哪一个的问题 @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired //@Qualifier：自动装配bean时按bean名称装配 @Qualifier(\"bookDao\") private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } ==注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用== 4.3 使用@Value实现简单类型注入 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { //@Value：注入简单类型（无需提供set方法） @Value(\"${name}\") private String name; public void save() { System.out.println(\"book dao save ...\" + name); } } 以上@Value注解中使用${name}从属性文件中读取name值，那么就需要在配置类或者配置文件中加载属性文件。 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource加载properties配置文件 @PropertySource({\"classpath:jdbc.properties\"}) //{}可以省略不写 public class SpringConfig { } ==注意：@PropertySource()中加载多文件请使用数组格式配置，不允许使用通配符*== ","date":"2023-12-31","objectID":"/spring01/:9:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#4-注解开发依赖注入重点"},{"categories":["Spring"],"content":" 4 注解开发依赖注入【重点】 问题导入问题1：请描述@Autowired注解是如何进行自动装配的？ 问题2：请描述@Qualifier注解的作用 4.1 使用@Autowired注解开启自动装配模式（按类型） @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 说明：不管是使用配置文件还是配置类，都必须进行对应的Spring注解包扫描才可以使用。@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean有多个，那么默认按照变量名和Bean的名称匹配，建议使用@Qualifier注解指定要装配的bean名称 ==注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法。== 4.2 使用@Qualifier注解指定要装配的bean名称 目的：解决IOC容器中同类型Bean有多个装配哪一个的问题 @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired //@Qualifier：自动装配bean时按bean名称装配 @Qualifier(\"bookDao\") private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } ==注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用== 4.3 使用@Value实现简单类型注入 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { //@Value：注入简单类型（无需提供set方法） @Value(\"${name}\") private String name; public void save() { System.out.println(\"book dao save ...\" + name); } } 以上@Value注解中使用${name}从属性文件中读取name值，那么就需要在配置类或者配置文件中加载属性文件。 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource加载properties配置文件 @PropertySource({\"classpath:jdbc.properties\"}) //{}可以省略不写 public class SpringConfig { } ==注意：@PropertySource()中加载多文件请使用数组格式配置，不允许使用通配符*== ","date":"2023-12-31","objectID":"/spring01/:9:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-15"},{"categories":["Spring"],"content":" 4 注解开发依赖注入【重点】 问题导入问题1：请描述@Autowired注解是如何进行自动装配的？ 问题2：请描述@Qualifier注解的作用 4.1 使用@Autowired注解开启自动装配模式（按类型） @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 说明：不管是使用配置文件还是配置类，都必须进行对应的Spring注解包扫描才可以使用。@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean有多个，那么默认按照变量名和Bean的名称匹配，建议使用@Qualifier注解指定要装配的bean名称 ==注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法。== 4.2 使用@Qualifier注解指定要装配的bean名称 目的：解决IOC容器中同类型Bean有多个装配哪一个的问题 @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired //@Qualifier：自动装配bean时按bean名称装配 @Qualifier(\"bookDao\") private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } ==注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用== 4.3 使用@Value实现简单类型注入 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { //@Value：注入简单类型（无需提供set方法） @Value(\"${name}\") private String name; public void save() { System.out.println(\"book dao save ...\" + name); } } 以上@Value注解中使用${name}从属性文件中读取name值，那么就需要在配置类或者配置文件中加载属性文件。 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource加载properties配置文件 @PropertySource({\"classpath:jdbc.properties\"}) //{}可以省略不写 public class SpringConfig { } ==注意：@PropertySource()中加载多文件请使用数组格式配置，不允许使用通配符*== ","date":"2023-12-31","objectID":"/spring01/:9:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#41-使用autowired注解开启自动装配模式按类型"},{"categories":["Spring"],"content":" 4 注解开发依赖注入【重点】 问题导入问题1：请描述@Autowired注解是如何进行自动装配的？ 问题2：请描述@Qualifier注解的作用 4.1 使用@Autowired注解开启自动装配模式（按类型） @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 说明：不管是使用配置文件还是配置类，都必须进行对应的Spring注解包扫描才可以使用。@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean有多个，那么默认按照变量名和Bean的名称匹配，建议使用@Qualifier注解指定要装配的bean名称 ==注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法。== 4.2 使用@Qualifier注解指定要装配的bean名称 目的：解决IOC容器中同类型Bean有多个装配哪一个的问题 @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired //@Qualifier：自动装配bean时按bean名称装配 @Qualifier(\"bookDao\") private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } ==注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用== 4.3 使用@Value实现简单类型注入 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { //@Value：注入简单类型（无需提供set方法） @Value(\"${name}\") private String name; public void save() { System.out.println(\"book dao save ...\" + name); } } 以上@Value注解中使用${name}从属性文件中读取name值，那么就需要在配置类或者配置文件中加载属性文件。 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource加载properties配置文件 @PropertySource({\"classpath:jdbc.properties\"}) //{}可以省略不写 public class SpringConfig { } ==注意：@PropertySource()中加载多文件请使用数组格式配置，不允许使用通配符*== ","date":"2023-12-31","objectID":"/spring01/:9:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#42-使用qualifier注解指定要装配的bean名称"},{"categories":["Spring"],"content":" 4 注解开发依赖注入【重点】 问题导入问题1：请描述@Autowired注解是如何进行自动装配的？ 问题2：请描述@Qualifier注解的作用 4.1 使用@Autowired注解开启自动装配模式（按类型） @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 说明：不管是使用配置文件还是配置类，都必须进行对应的Spring注解包扫描才可以使用。@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean有多个，那么默认按照变量名和Bean的名称匹配，建议使用@Qualifier注解指定要装配的bean名称 ==注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法。== 4.2 使用@Qualifier注解指定要装配的bean名称 目的：解决IOC容器中同类型Bean有多个装配哪一个的问题 @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired //@Qualifier：自动装配bean时按bean名称装配 @Qualifier(\"bookDao\") private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } ==注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用== 4.3 使用@Value实现简单类型注入 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { //@Value：注入简单类型（无需提供set方法） @Value(\"${name}\") private String name; public void save() { System.out.println(\"book dao save ...\" + name); } } 以上@Value注解中使用${name}从属性文件中读取name值，那么就需要在配置类或者配置文件中加载属性文件。 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource加载properties配置文件 @PropertySource({\"classpath:jdbc.properties\"}) //{}可以省略不写 public class SpringConfig { } ==注意：@PropertySource()中加载多文件请使用数组格式配置，不允许使用通配符*== ","date":"2023-12-31","objectID":"/spring01/:9:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#43-使用value实现简单类型注入"},{"categories":["Spring"],"content":" 5 注解开发管理第三方Bean【重点】 问题导入导入自己定义的配置类有几种方式？ 【第一步】单独定义配置类 public class JdbcConfig { //@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring_db\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; } } 【第二步】将独立的配置类加入核心配置 方式1：@Import注解导入式 @Configuration @ComponentScan(\"com.itghd\") //@Import:导入配置信息 @Import({JdbcConfig.class}) public class SpringConfig { } 方式2：@ComponentScan扫描式 @Configuration @ComponentScan({\"com.itghd.config\",\"com.itghd.service\",\"com.itghd.dao\"}) //只要com.itghd.config包扫到了就行，三个包可以合并写成com.itghd public class SpringConfig { } ","date":"2023-12-31","objectID":"/spring01/:9:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#5-注解开发管理第三方bean重点"},{"categories":["Spring"],"content":" 5 注解开发管理第三方Bean【重点】 问题导入导入自己定义的配置类有几种方式？ 【第一步】单独定义配置类 public class JdbcConfig { //@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring_db\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; } } 【第二步】将独立的配置类加入核心配置 方式1：@Import注解导入式 @Configuration @ComponentScan(\"com.itghd\") //@Import:导入配置信息 @Import({JdbcConfig.class}) public class SpringConfig { } 方式2：@ComponentScan扫描式 @Configuration @ComponentScan({\"com.itghd.config\",\"com.itghd.service\",\"com.itghd.dao\"}) //只要com.itghd.config包扫到了就行，三个包可以合并写成com.itghd public class SpringConfig { } ","date":"2023-12-31","objectID":"/spring01/:9:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-16"},{"categories":["Spring"],"content":" 5 注解开发管理第三方Bean【重点】 问题导入导入自己定义的配置类有几种方式？ 【第一步】单独定义配置类 public class JdbcConfig { //@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring_db\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; } } 【第二步】将独立的配置类加入核心配置 方式1：@Import注解导入式 @Configuration @ComponentScan(\"com.itghd\") //@Import:导入配置信息 @Import({JdbcConfig.class}) public class SpringConfig { } 方式2：@ComponentScan扫描式 @Configuration @ComponentScan({\"com.itghd.config\",\"com.itghd.service\",\"com.itghd.dao\"}) //只要com.itghd.config包扫到了就行，三个包可以合并写成com.itghd public class SpringConfig { } ","date":"2023-12-31","objectID":"/spring01/:9:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第一步单独定义配置类"},{"categories":["Spring"],"content":" 5 注解开发管理第三方Bean【重点】 问题导入导入自己定义的配置类有几种方式？ 【第一步】单独定义配置类 public class JdbcConfig { //@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring_db\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; } } 【第二步】将独立的配置类加入核心配置 方式1：@Import注解导入式 @Configuration @ComponentScan(\"com.itghd\") //@Import:导入配置信息 @Import({JdbcConfig.class}) public class SpringConfig { } 方式2：@ComponentScan扫描式 @Configuration @ComponentScan({\"com.itghd.config\",\"com.itghd.service\",\"com.itghd.dao\"}) //只要com.itghd.config包扫到了就行，三个包可以合并写成com.itghd public class SpringConfig { } ","date":"2023-12-31","objectID":"/spring01/:9:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第二步将独立的配置类加入核心配置"},{"categories":["Spring"],"content":" 5 注解开发管理第三方Bean【重点】 问题导入导入自己定义的配置类有几种方式？ 【第一步】单独定义配置类 public class JdbcConfig { //@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring_db\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; } } 【第二步】将独立的配置类加入核心配置 方式1：@Import注解导入式 @Configuration @ComponentScan(\"com.itghd\") //@Import:导入配置信息 @Import({JdbcConfig.class}) public class SpringConfig { } 方式2：@ComponentScan扫描式 @Configuration @ComponentScan({\"com.itghd.config\",\"com.itghd.service\",\"com.itghd.dao\"}) //只要com.itghd.config包扫到了就行，三个包可以合并写成com.itghd public class SpringConfig { } ","date":"2023-12-31","objectID":"/spring01/:9:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#方式1import注解导入式"},{"categories":["Spring"],"content":" 5 注解开发管理第三方Bean【重点】 问题导入导入自己定义的配置类有几种方式？ 【第一步】单独定义配置类 public class JdbcConfig { //@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring_db\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; } } 【第二步】将独立的配置类加入核心配置 方式1：@Import注解导入式 @Configuration @ComponentScan(\"com.itghd\") //@Import:导入配置信息 @Import({JdbcConfig.class}) public class SpringConfig { } 方式2：@ComponentScan扫描式 @Configuration @ComponentScan({\"com.itghd.config\",\"com.itghd.service\",\"com.itghd.dao\"}) //只要com.itghd.config包扫到了就行，三个包可以合并写成com.itghd public class SpringConfig { } ","date":"2023-12-31","objectID":"/spring01/:9:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#方式2componentscan扫描式"},{"categories":["Spring"],"content":" 6 注解开发为第三方Bean注入资源【重点】 问题导入配置类中如何注入简单类型数据，如何注入引用类型数据？ 6.1 简单类型依赖注入 public class JdbcConfig { //1.定义一个方法获得要管理的对象 @Value(\"com.mysql.jdbc.Driver\") private String driver; @Value(\"jdbc:mysql://localhost:3306/spring_db\") private String url; @Value(\"root\") private String userName; @Value(\"root\") private String password; //2.@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 说明：如果@Value()中使用了EL表达式读取properties属性文件中的内容，那么就需要加载properties属性文件。 6.2 引用类型依赖注入 //Spring会自动从IOC容器中找到BookDao对象赋值给参数bookDao变量，如果没有就会报错。 @Bean public DataSource dataSource(BookDao bookDao){ System.out.println(bookDao); DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } 说明：引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象 ","date":"2023-12-31","objectID":"/spring01/:9:6","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#6-注解开发为第三方bean注入资源重点"},{"categories":["Spring"],"content":" 6 注解开发为第三方Bean注入资源【重点】 问题导入配置类中如何注入简单类型数据，如何注入引用类型数据？ 6.1 简单类型依赖注入 public class JdbcConfig { //1.定义一个方法获得要管理的对象 @Value(\"com.mysql.jdbc.Driver\") private String driver; @Value(\"jdbc:mysql://localhost:3306/spring_db\") private String url; @Value(\"root\") private String userName; @Value(\"root\") private String password; //2.@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 说明：如果@Value()中使用了EL表达式读取properties属性文件中的内容，那么就需要加载properties属性文件。 6.2 引用类型依赖注入 //Spring会自动从IOC容器中找到BookDao对象赋值给参数bookDao变量，如果没有就会报错。 @Bean public DataSource dataSource(BookDao bookDao){ System.out.println(bookDao); DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } 说明：引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象 ","date":"2023-12-31","objectID":"/spring01/:9:6","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-17"},{"categories":["Spring"],"content":" 6 注解开发为第三方Bean注入资源【重点】 问题导入配置类中如何注入简单类型数据，如何注入引用类型数据？ 6.1 简单类型依赖注入 public class JdbcConfig { //1.定义一个方法获得要管理的对象 @Value(\"com.mysql.jdbc.Driver\") private String driver; @Value(\"jdbc:mysql://localhost:3306/spring_db\") private String url; @Value(\"root\") private String userName; @Value(\"root\") private String password; //2.@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 说明：如果@Value()中使用了EL表达式读取properties属性文件中的内容，那么就需要加载properties属性文件。 6.2 引用类型依赖注入 //Spring会自动从IOC容器中找到BookDao对象赋值给参数bookDao变量，如果没有就会报错。 @Bean public DataSource dataSource(BookDao bookDao){ System.out.println(bookDao); DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } 说明：引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象 ","date":"2023-12-31","objectID":"/spring01/:9:6","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#61-简单类型依赖注入"},{"categories":["Spring"],"content":" 6 注解开发为第三方Bean注入资源【重点】 问题导入配置类中如何注入简单类型数据，如何注入引用类型数据？ 6.1 简单类型依赖注入 public class JdbcConfig { //1.定义一个方法获得要管理的对象 @Value(\"com.mysql.jdbc.Driver\") private String driver; @Value(\"jdbc:mysql://localhost:3306/spring_db\") private String url; @Value(\"root\") private String userName; @Value(\"root\") private String password; //2.@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 说明：如果@Value()中使用了EL表达式读取properties属性文件中的内容，那么就需要加载properties属性文件。 6.2 引用类型依赖注入 //Spring会自动从IOC容器中找到BookDao对象赋值给参数bookDao变量，如果没有就会报错。 @Bean public DataSource dataSource(BookDao bookDao){ System.out.println(bookDao); DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } 说明：引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象 ","date":"2023-12-31","objectID":"/spring01/:9:6","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#62-引用类型依赖注入"},{"categories":["Spring"],"content":" 7 注解开发总结 ","date":"2023-12-31","objectID":"/spring01/:9:7","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#7-注解开发总结"},{"categories":["Spring"],"content":" 七、Spring整合其他技术【重点】","date":"2023-12-31","objectID":"/spring01/:10:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#七spring整合其他技术重点"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List\u003cAccount\u003e findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List\u003cAccount\u003e findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List\u003cAccount\u003e findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) \u003c!-- Spring JDBC --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.10\u003c/version\u003e \u003c/dependency\u003e \u003c!-- MyBatis Spring --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.7\u003c/version\u003e \u003c/dependency\u003e 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-spring整合mybatis重点"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-思路分析"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-18"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#111-mybatis程序核心对象分析"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#112-整合mybatis"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-代码实现"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-19"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#前置工作"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第一步导入spring整合mybatis依赖java17"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第二步创建jdbcconfig配置datasource数据源"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第三步创建mybatisconfig整合mybatis"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第四步创建springconfig主配置类进行包扫描和加载其他配置类"},{"categories":["Spring"],"content":" 1 Spring整合mybatis【重点】 1.1 思路分析 问题导入mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖(JAVA17) org.springframework spring-jdbc 5.3.10 org.mybatis mybatis-spring 2.0.7 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itghd.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itghd.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itghd\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2023-12-31","objectID":"/spring01/:10:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第五步定义测试类进行测试"},{"categories":["Spring"],"content":" 2 Spring整合Junit单元测试【重点】 问题导入Spring整合Junit的两个注解作用分别是什么？ 【第一步】导入整合的依赖坐标spring-testjdk8 \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c!--spring整合junit--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-test\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e jdk17 \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c!-- Spring 整合 JUnit 5 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-test\u003c/artifactId\u003e \u003cversion\u003e5.3.10\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 【第二步】使用Spring整合Junit专用的类加载器 【第三步】加载配置文件或者配置类 //【第二步】使用Spring整合Junit专用的类加载器 @RunWith(SpringJUnit4ClassRunner.class) //【第三步】加载配置文件或者配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) //加载配置类 //@ContextConfiguration(locations={\"classpath:applicationContext.xml\"})//加载配置文件 public class AccountServiceTest { //支持自动装配注入bean @Autowired private AccountService accountService; @Test public void testFindById(){ System.out.println(accountService.findById(1)); } @Test public void testFindAll(){ System.out.println(accountService.findAll()); } } ","date":"2023-12-31","objectID":"/spring01/:10:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-spring整合junit单元测试重点"},{"categories":["Spring"],"content":" 2 Spring整合Junit单元测试【重点】 问题导入Spring整合Junit的两个注解作用分别是什么？ 【第一步】导入整合的依赖坐标spring-testjdk8 junit junit 4.12 org.springframework spring-test 5.1.9.RELEASE jdk17 org.junit.jupiter junit-jupiter-engine 5.8.1 test org.springframework spring-test 5.3.10 test 【第二步】使用Spring整合Junit专用的类加载器 【第三步】加载配置文件或者配置类 //【第二步】使用Spring整合Junit专用的类加载器 @RunWith(SpringJUnit4ClassRunner.class) //【第三步】加载配置文件或者配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) //加载配置类 //@ContextConfiguration(locations={\"classpath:applicationContext.xml\"})//加载配置文件 public class AccountServiceTest { //支持自动装配注入bean @Autowired private AccountService accountService; @Test public void testFindById(){ System.out.println(accountService.findById(1)); } @Test public void testFindAll(){ System.out.println(accountService.findAll()); } } ","date":"2023-12-31","objectID":"/spring01/:10:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-20"},{"categories":["Spring"],"content":" 2 Spring整合Junit单元测试【重点】 问题导入Spring整合Junit的两个注解作用分别是什么？ 【第一步】导入整合的依赖坐标spring-testjdk8 junit junit 4.12 org.springframework spring-test 5.1.9.RELEASE jdk17 org.junit.jupiter junit-jupiter-engine 5.8.1 test org.springframework spring-test 5.3.10 test 【第二步】使用Spring整合Junit专用的类加载器 【第三步】加载配置文件或者配置类 //【第二步】使用Spring整合Junit专用的类加载器 @RunWith(SpringJUnit4ClassRunner.class) //【第三步】加载配置文件或者配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) //加载配置类 //@ContextConfiguration(locations={\"classpath:applicationContext.xml\"})//加载配置文件 public class AccountServiceTest { //支持自动装配注入bean @Autowired private AccountService accountService; @Test public void testFindById(){ System.out.println(accountService.findById(1)); } @Test public void testFindAll(){ System.out.println(accountService.findAll()); } } ","date":"2023-12-31","objectID":"/spring01/:10:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第一步导入整合的依赖坐标spring-test"},{"categories":["Spring"],"content":" 2 Spring整合Junit单元测试【重点】 问题导入Spring整合Junit的两个注解作用分别是什么？ 【第一步】导入整合的依赖坐标spring-testjdk8 junit junit 4.12 org.springframework spring-test 5.1.9.RELEASE jdk17 org.junit.jupiter junit-jupiter-engine 5.8.1 test org.springframework spring-test 5.3.10 test 【第二步】使用Spring整合Junit专用的类加载器 【第三步】加载配置文件或者配置类 //【第二步】使用Spring整合Junit专用的类加载器 @RunWith(SpringJUnit4ClassRunner.class) //【第三步】加载配置文件或者配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) //加载配置类 //@ContextConfiguration(locations={\"classpath:applicationContext.xml\"})//加载配置文件 public class AccountServiceTest { //支持自动装配注入bean @Autowired private AccountService accountService; @Test public void testFindById(){ System.out.println(accountService.findById(1)); } @Test public void testFindAll(){ System.out.println(accountService.findAll()); } } ","date":"2023-12-31","objectID":"/spring01/:10:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第二步使用spring整合junit专用的类加载器"},{"categories":["Spring"],"content":" 2 Spring整合Junit单元测试【重点】 问题导入Spring整合Junit的两个注解作用分别是什么？ 【第一步】导入整合的依赖坐标spring-testjdk8 junit junit 4.12 org.springframework spring-test 5.1.9.RELEASE jdk17 org.junit.jupiter junit-jupiter-engine 5.8.1 test org.springframework spring-test 5.3.10 test 【第二步】使用Spring整合Junit专用的类加载器 【第三步】加载配置文件或者配置类 //【第二步】使用Spring整合Junit专用的类加载器 @RunWith(SpringJUnit4ClassRunner.class) //【第三步】加载配置文件或者配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) //加载配置类 //@ContextConfiguration(locations={\"classpath:applicationContext.xml\"})//加载配置文件 public class AccountServiceTest { //支持自动装配注入bean @Autowired private AccountService accountService; @Test public void testFindById(){ System.out.println(accountService.findById(1)); } @Test public void testFindAll(){ System.out.println(accountService.findAll()); } } ","date":"2023-12-31","objectID":"/spring01/:10:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第三步加载配置文件或者配置类"},{"categories":["Spring"],"content":" 八、AOP","date":"2023-12-31","objectID":"/spring01/:11:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#八aop"},{"categories":["Spring"],"content":" 1 AOP简介 问题导入问题1：AOP的作用是什么？ 问题2：连接点和切入点有什么区别，二者谁的范围大？ 问题3：请描述什么是切面？ 1.1 AOP简介和作用【理解】 AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP(Object Oriented Programming)面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强。简单的说就是在不改变方法源代码的基础上对方法进行功能增强。 Spring理念：无入侵式/无侵入式 1.2 AOP中的核心概念【理解】 连接点（JoinPoint）：正在执行的方法，例如：update()、delete()、select()等都是连接点。 切入点（Pointcut）：进行功能增强了的方法，例如:update()、delete()方法，select()方法没有被增强所以不是切入点，但是是连接点。 在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法 匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法 通知（Advice）：在切入点前后执行的操作，也就是增强的共性功能 在SpringAOP中，功能最终以方法的形式呈现 通知类：通知方法所在的类叫做通知类 切面（Aspect）：描述通知与切入点的对应关系，也就是哪些通知方法对应哪些切入点方法。 ","date":"2023-12-31","objectID":"/spring01/:11:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-aop简介"},{"categories":["Spring"],"content":" 1 AOP简介 问题导入问题1：AOP的作用是什么？ 问题2：连接点和切入点有什么区别，二者谁的范围大？ 问题3：请描述什么是切面？ 1.1 AOP简介和作用【理解】 AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP(Object Oriented Programming)面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强。简单的说就是在不改变方法源代码的基础上对方法进行功能增强。 Spring理念：无入侵式/无侵入式 1.2 AOP中的核心概念【理解】 连接点（JoinPoint）：正在执行的方法，例如：update()、delete()、select()等都是连接点。 切入点（Pointcut）：进行功能增强了的方法，例如:update()、delete()方法，select()方法没有被增强所以不是切入点，但是是连接点。 在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法 匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法 通知（Advice）：在切入点前后执行的操作，也就是增强的共性功能 在SpringAOP中，功能最终以方法的形式呈现 通知类：通知方法所在的类叫做通知类 切面（Aspect）：描述通知与切入点的对应关系，也就是哪些通知方法对应哪些切入点方法。 ","date":"2023-12-31","objectID":"/spring01/:11:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-21"},{"categories":["Spring"],"content":" 1 AOP简介 问题导入问题1：AOP的作用是什么？ 问题2：连接点和切入点有什么区别，二者谁的范围大？ 问题3：请描述什么是切面？ 1.1 AOP简介和作用【理解】 AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP(Object Oriented Programming)面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强。简单的说就是在不改变方法源代码的基础上对方法进行功能增强。 Spring理念：无入侵式/无侵入式 1.2 AOP中的核心概念【理解】 连接点（JoinPoint）：正在执行的方法，例如：update()、delete()、select()等都是连接点。 切入点（Pointcut）：进行功能增强了的方法，例如:update()、delete()方法，select()方法没有被增强所以不是切入点，但是是连接点。 在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法 匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法 通知（Advice）：在切入点前后执行的操作，也就是增强的共性功能 在SpringAOP中，功能最终以方法的形式呈现 通知类：通知方法所在的类叫做通知类 切面（Aspect）：描述通知与切入点的对应关系，也就是哪些通知方法对应哪些切入点方法。 ","date":"2023-12-31","objectID":"/spring01/:11:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-aop简介和作用理解"},{"categories":["Spring"],"content":" 1 AOP简介 问题导入问题1：AOP的作用是什么？ 问题2：连接点和切入点有什么区别，二者谁的范围大？ 问题3：请描述什么是切面？ 1.1 AOP简介和作用【理解】 AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构 OOP(Object Oriented Programming)面向对象编程 作用：在不惊动原始设计的基础上为其进行功能增强。简单的说就是在不改变方法源代码的基础上对方法进行功能增强。 Spring理念：无入侵式/无侵入式 1.2 AOP中的核心概念【理解】 连接点（JoinPoint）：正在执行的方法，例如：update()、delete()、select()等都是连接点。 切入点（Pointcut）：进行功能增强了的方法，例如:update()、delete()方法，select()方法没有被增强所以不是切入点，但是是连接点。 在SpringAOP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法 一个具体方法：com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法 匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法 通知（Advice）：在切入点前后执行的操作，也就是增强的共性功能 在SpringAOP中，功能最终以方法的形式呈现 通知类：通知方法所在的类叫做通知类 切面（Aspect）：描述通知与切入点的对应关系，也就是哪些通知方法对应哪些切入点方法。 ","date":"2023-12-31","objectID":"/spring01/:11:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-aop中的核心概念理解"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 \u003cdependencies\u003e \u003c!--spring核心依赖，会将spring-aop传递进来--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context\u003c/artifactId\u003e \u003cversion\u003e5.2.10.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!--切入点表达式依赖，目的是找到切入点方法，也就是找到要增强的方法--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e jdk17 \u003cdependencies\u003e \u003c!-- Spring Framework --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context\u003c/artifactId\u003e \u003cversion\u003e5.3.10\u003c/version\u003e \u003c/dependency\u003e \u003c!-- AspectJ Weaver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.7\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-aop入门案例重点"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 org.springframework spring-context 5.2.10.RELEASE org.aspectj aspectjweaver 1.9.4 jdk17 org.springframework spring-context 5.3.10 org.aspectj aspectjweaver 1.9.7 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-22"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 org.springframework spring-context 5.2.10.RELEASE org.aspectj aspectjweaver 1.9.4 jdk17 org.springframework spring-context 5.3.10 org.aspectj aspectjweaver 1.9.7 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-aop入门案例思路分析"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 org.springframework spring-context 5.2.10.RELEASE org.aspectj aspectjweaver 1.9.4 jdk17 org.springframework spring-context 5.3.10 org.aspectj aspectjweaver 1.9.7 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#22-aop入门案例实现"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 org.springframework spring-context 5.2.10.RELEASE org.aspectj aspectjweaver 1.9.4 jdk17 org.springframework spring-context 5.3.10 org.aspectj aspectjweaver 1.9.7 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第一步导入aop相关坐标"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 org.springframework spring-context 5.2.10.RELEASE org.aspectj aspectjweaver 1.9.4 jdk17 org.springframework spring-context 5.3.10 org.aspectj aspectjweaver 1.9.7 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第二步定义dao接口与实现类"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 org.springframework spring-context 5.2.10.RELEASE org.aspectj aspectjweaver 1.9.4 jdk17 org.springframework spring-context 5.3.10 org.aspectj aspectjweaver 1.9.7 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第三步定义通知类制作通知方法"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 org.springframework spring-context 5.2.10.RELEASE org.aspectj aspectjweaver 1.9.4 jdk17 org.springframework spring-context 5.3.10 org.aspectj aspectjweaver 1.9.7 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第四步定义切入点表达式配置切面绑定切入点与通知关系"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 org.springframework spring-context 5.2.10.RELEASE org.aspectj aspectjweaver 1.9.4 jdk17 org.springframework spring-context 5.3.10 org.aspectj aspectjweaver 1.9.7 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第五步在配置类中进行spring注解包扫描和开启aop功能"},{"categories":["Spring"],"content":" 2 AOP入门案例【重点】 问题导入问题1：在通知方法中如何定义切入点表达式？ 问题2：如何配置切面？ 问题3：在配置类上如何开启AOP注解功能？ 2.1 AOP入门案例思路分析 案例设定：测定接口执行效率 简化设定：在接口执行前输出当前系统时间 开发模式：XML or ==注解== 思路分析： 导入坐标（pom.xml） 制作连接点方法（原始操作，dao接口与实现类） 制作共性功能（通知类与通知） 定义切入点 绑定切入点与通知关系（切面） 2.2 AOP入门案例实现 【第一步】导入aop相关坐标jdk8 org.springframework spring-context 5.2.10.RELEASE org.aspectj aspectjweaver 1.9.4 jdk17 org.springframework spring-context 5.3.10 org.aspectj aspectjweaver 1.9.7 【第二步】定义dao接口与实现类 public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\"book dao save ...\"); } public void update(){ System.out.println(\"book dao update ...\"); } } 【第三步】定义通知类，制作通知方法 //通知类必须配置成Spring管理的bean @Component public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } 【第四步】定义切入点表达式、配置切面(绑定切入点与通知关系) //通知类必须配置成Spring管理的bean @Component //设置当前类为切面类类 @Aspect public class MyAdvice { //设置切入点，@Pointcut注解要求配置在方法上方 @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\") private void pt(){} //设置在切入点pt()的前面运行当前操作(前置通知) @Before(\"pt()\") public void method(){ System.out.println(System.currentTimeMillis()); } } 【第五步】在配置类中进行Spring注解包扫描和开启AOP功能 @Configuration @ComponentScan(\"com.itheima\") //开启注解开发AOP功能 @EnableAspectJAutoProxy public class SpringConfig { } 测试类和运行结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } ","date":"2023-12-31","objectID":"/spring01/:11:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#测试类和运行结果"},{"categories":["Spring"],"content":" 3 AOP工作流程【理解】 问题导入什么是目标对象？什么是代理对象？ 3.1 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建原始对象 匹配成功，创建原始对象（目标对象）的代理对象 获取bean执行方法 获取的bean是原始对象时，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作 3.2 AOP核心概念目标对象（Target）：被代理的对象，也叫原始对象，该对象中的方法没有任何功能增强。 代理对象（Proxy）：代理后生成的对象，由Spring帮我们创建代理对象。 3.3 在测试类中验证代理对象 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); //打印对象的类名 System.out.println(bookDao.getClass()); } } ","date":"2023-12-31","objectID":"/spring01/:11:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#3-aop工作流程理解"},{"categories":["Spring"],"content":" 3 AOP工作流程【理解】 问题导入什么是目标对象？什么是代理对象？ 3.1 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建原始对象 匹配成功，创建原始对象（目标对象）的代理对象 获取bean执行方法 获取的bean是原始对象时，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作 3.2 AOP核心概念目标对象（Target）：被代理的对象，也叫原始对象，该对象中的方法没有任何功能增强。 代理对象（Proxy）：代理后生成的对象，由Spring帮我们创建代理对象。 3.3 在测试类中验证代理对象 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); //打印对象的类名 System.out.println(bookDao.getClass()); } } ","date":"2023-12-31","objectID":"/spring01/:11:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-23"},{"categories":["Spring"],"content":" 3 AOP工作流程【理解】 问题导入什么是目标对象？什么是代理对象？ 3.1 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建原始对象 匹配成功，创建原始对象（目标对象）的代理对象 获取bean执行方法 获取的bean是原始对象时，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作 3.2 AOP核心概念目标对象（Target）：被代理的对象，也叫原始对象，该对象中的方法没有任何功能增强。 代理对象（Proxy）：代理后生成的对象，由Spring帮我们创建代理对象。 3.3 在测试类中验证代理对象 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); //打印对象的类名 System.out.println(bookDao.getClass()); } } ","date":"2023-12-31","objectID":"/spring01/:11:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#31-aop工作流程"},{"categories":["Spring"],"content":" 3 AOP工作流程【理解】 问题导入什么是目标对象？什么是代理对象？ 3.1 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建原始对象 匹配成功，创建原始对象（目标对象）的代理对象 获取bean执行方法 获取的bean是原始对象时，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作 3.2 AOP核心概念目标对象（Target）：被代理的对象，也叫原始对象，该对象中的方法没有任何功能增强。 代理对象（Proxy）：代理后生成的对象，由Spring帮我们创建代理对象。 3.3 在测试类中验证代理对象 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); //打印对象的类名 System.out.println(bookDao.getClass()); } } ","date":"2023-12-31","objectID":"/spring01/:11:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#32-aop核心概念"},{"categories":["Spring"],"content":" 3 AOP工作流程【理解】 问题导入什么是目标对象？什么是代理对象？ 3.1 AOP工作流程 Spring容器启动 读取所有切面配置中的切入点 初始化bean，判定bean对应的类中的方法是否匹配到任意切入点 匹配失败，创建原始对象 匹配成功，创建原始对象（目标对象）的代理对象 获取bean执行方法 获取的bean是原始对象时，调用方法并执行，完成操作 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作 3.2 AOP核心概念目标对象（Target）：被代理的对象，也叫原始对象，该对象中的方法没有任何功能增强。 代理对象（Proxy）：代理后生成的对象，由Spring帮我们创建代理对象。 3.3 在测试类中验证代理对象 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); //打印对象的类名 System.out.println(bookDao.getClass()); } } ","date":"2023-12-31","objectID":"/spring01/:11:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#33-在测试类中验证代理对象"},{"categories":["Spring"],"content":" 4 AOP切入点表达式 问题导入在切入点表达式中如何简化包名和参数类型书写？ 4.1 语法格式 切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方式 描述方式一：执行com.itheima.dao包下的BookDao接口中的无参数update方法 execution(void com.itheima.dao.BookDao.update()) 描述方式二：执行com.itheima.dao.impl包下的BookDaoImpl类中的无参数update方法 execution(void com.itheima.dao.impl.BookDaoImpl.update()) 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名） execution(public User com.itheima.service.UserService.findById(int)) 动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值：写返回值类型 包名：多级包使用点连接 类/接口名： 方法名： 参数：直接写参数的类型，多个类型用逗号隔开 异常名：方法定义中抛出指定异常，可以省略 4.2 通配符 目的：可以使用通配符描述切入点，快速描述。 ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法 execution（public * com.itheima.*.UserService.find*(*)) .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法 execution（public User com..UserService.findById(..)) +：专用于匹配子类类型 execution(* *..*Service+.*(..)) 4.3 书写技巧 所有代码按照标准规范开发，否则以下技巧全部失效 描述切入点通**==常描述接口==**，而不描述实现类 访问控制修饰符针对接口开发均采用public描述（==可省略访问控制修饰符描述==） 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述 ==包名==书写==尽量不使用..匹配==，效率过低，常用*做单个包描述匹配，或精准匹配 ==接口名/类名==书写名称与模块相关的==采用*匹配==，例如UserService书写成*Service，绑定业务层接口名 ==方法名==书写以==动词==进行==精准匹配==，名词采用匹配，例如getById书写成getBy,selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常**==不使用异常==作为==匹配==**规则 ","date":"2023-12-31","objectID":"/spring01/:11:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#4-aop切入点表达式"},{"categories":["Spring"],"content":" 4 AOP切入点表达式 问题导入在切入点表达式中如何简化包名和参数类型书写？ 4.1 语法格式 切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方式 描述方式一：执行com.itheima.dao包下的BookDao接口中的无参数update方法 execution(void com.itheima.dao.BookDao.update()) 描述方式二：执行com.itheima.dao.impl包下的BookDaoImpl类中的无参数update方法 execution(void com.itheima.dao.impl.BookDaoImpl.update()) 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名） execution(public User com.itheima.service.UserService.findById(int)) 动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值：写返回值类型 包名：多级包使用点连接 类/接口名： 方法名： 参数：直接写参数的类型，多个类型用逗号隔开 异常名：方法定义中抛出指定异常，可以省略 4.2 通配符 目的：可以使用通配符描述切入点，快速描述。 ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法 execution（public * com.itheima.*.UserService.find*(*)) .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法 execution（public User com..UserService.findById(..)) +：专用于匹配子类类型 execution(* *..*Service+.*(..)) 4.3 书写技巧 所有代码按照标准规范开发，否则以下技巧全部失效 描述切入点通**==常描述接口==**，而不描述实现类 访问控制修饰符针对接口开发均采用public描述（==可省略访问控制修饰符描述==） 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述 ==包名==书写==尽量不使用..匹配==，效率过低，常用*做单个包描述匹配，或精准匹配 ==接口名/类名==书写名称与模块相关的==采用*匹配==，例如UserService书写成*Service，绑定业务层接口名 ==方法名==书写以==动词==进行==精准匹配==，名词采用匹配，例如getById书写成getBy,selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常**==不使用异常==作为==匹配==**规则 ","date":"2023-12-31","objectID":"/spring01/:11:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-24"},{"categories":["Spring"],"content":" 4 AOP切入点表达式 问题导入在切入点表达式中如何简化包名和参数类型书写？ 4.1 语法格式 切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方式 描述方式一：执行com.itheima.dao包下的BookDao接口中的无参数update方法 execution(void com.itheima.dao.BookDao.update()) 描述方式二：执行com.itheima.dao.impl包下的BookDaoImpl类中的无参数update方法 execution(void com.itheima.dao.impl.BookDaoImpl.update()) 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名） execution(public User com.itheima.service.UserService.findById(int)) 动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值：写返回值类型 包名：多级包使用点连接 类/接口名： 方法名： 参数：直接写参数的类型，多个类型用逗号隔开 异常名：方法定义中抛出指定异常，可以省略 4.2 通配符 目的：可以使用通配符描述切入点，快速描述。 ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法 execution（public * com.itheima.*.UserService.find*(*)) .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法 execution（public User com..UserService.findById(..)) +：专用于匹配子类类型 execution(* *..*Service+.*(..)) 4.3 书写技巧 所有代码按照标准规范开发，否则以下技巧全部失效 描述切入点通**==常描述接口==**，而不描述实现类 访问控制修饰符针对接口开发均采用public描述（==可省略访问控制修饰符描述==） 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述 ==包名==书写==尽量不使用..匹配==，效率过低，常用*做单个包描述匹配，或精准匹配 ==接口名/类名==书写名称与模块相关的==采用*匹配==，例如UserService书写成*Service，绑定业务层接口名 ==方法名==书写以==动词==进行==精准匹配==，名词采用匹配，例如getById书写成getBy,selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常**==不使用异常==作为==匹配==**规则 ","date":"2023-12-31","objectID":"/spring01/:11:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#41-语法格式"},{"categories":["Spring"],"content":" 4 AOP切入点表达式 问题导入在切入点表达式中如何简化包名和参数类型书写？ 4.1 语法格式 切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方式 描述方式一：执行com.itheima.dao包下的BookDao接口中的无参数update方法 execution(void com.itheima.dao.BookDao.update()) 描述方式二：执行com.itheima.dao.impl包下的BookDaoImpl类中的无参数update方法 execution(void com.itheima.dao.impl.BookDaoImpl.update()) 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名） execution(public User com.itheima.service.UserService.findById(int)) 动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值：写返回值类型 包名：多级包使用点连接 类/接口名： 方法名： 参数：直接写参数的类型，多个类型用逗号隔开 异常名：方法定义中抛出指定异常，可以省略 4.2 通配符 目的：可以使用通配符描述切入点，快速描述。 ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法 execution（public * com.itheima.*.UserService.find*(*)) .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法 execution（public User com..UserService.findById(..)) +：专用于匹配子类类型 execution(* *..*Service+.*(..)) 4.3 书写技巧 所有代码按照标准规范开发，否则以下技巧全部失效 描述切入点通**==常描述接口==**，而不描述实现类 访问控制修饰符针对接口开发均采用public描述（==可省略访问控制修饰符描述==） 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述 ==包名==书写==尽量不使用..匹配==，效率过低，常用*做单个包描述匹配，或精准匹配 ==接口名/类名==书写名称与模块相关的==采用*匹配==，例如UserService书写成*Service，绑定业务层接口名 ==方法名==书写以==动词==进行==精准匹配==，名词采用匹配，例如getById书写成getBy,selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常**==不使用异常==作为==匹配==**规则 ","date":"2023-12-31","objectID":"/spring01/:11:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#42-通配符"},{"categories":["Spring"],"content":" 4 AOP切入点表达式 问题导入在切入点表达式中如何简化包名和参数类型书写？ 4.1 语法格式 切入点：要进行增强的方法 切入点表达式：要进行增强的方法的描述方式 描述方式一：执行com.itheima.dao包下的BookDao接口中的无参数update方法 execution(void com.itheima.dao.BookDao.update()) 描述方式二：执行com.itheima.dao.impl包下的BookDaoImpl类中的无参数update方法 execution(void com.itheima.dao.impl.BookDaoImpl.update()) 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名） execution(public User com.itheima.service.UserService.findById(int)) 动作关键字：描述切入点的行为动作，例如execution表示执行到指定切入点 访问修饰符：public，private等，可以省略 返回值：写返回值类型 包名：多级包使用点连接 类/接口名： 方法名： 参数：直接写参数的类型，多个类型用逗号隔开 异常名：方法定义中抛出指定异常，可以省略 4.2 通配符 目的：可以使用通配符描述切入点，快速描述。 ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现 匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法 execution（public * com.itheima.*.UserService.find*(*)) .. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写 匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法 execution（public User com..UserService.findById(..)) +：专用于匹配子类类型 execution(* *..*Service+.*(..)) 4.3 书写技巧 所有代码按照标准规范开发，否则以下技巧全部失效 描述切入点通**==常描述接口==**，而不描述实现类 访问控制修饰符针对接口开发均采用public描述（==可省略访问控制修饰符描述==） 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述 ==包名==书写==尽量不使用..匹配==，效率过低，常用*做单个包描述匹配，或精准匹配 ==接口名/类名==书写名称与模块相关的==采用*匹配==，例如UserService书写成*Service，绑定业务层接口名 ==方法名==书写以==动词==进行==精准匹配==，名词采用匹配，例如getById书写成getBy,selectAll书写成selectAll 参数规则较为复杂，根据业务方法灵活调整 通常**==不使用异常==作为==匹配==**规则 ","date":"2023-12-31","objectID":"/spring01/:11:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#43-书写技巧"},{"categories":["Spring"],"content":" 5 AOP通知类型【重点】 问题导入请描述一下如何定义环绕通知方法？ 5.1 AOP通知分类 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。 **==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。 5.2 AOP通知详解 5.2.1 前置通知 名称：@Before 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 范例： @Before(\"pt()\") public void before() { System.out.println(\"before advice ...\"); } 5.2.2 后置通知 名称：@After 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行 范例： @After(\"pt()\") public void after() { System.out.println(\"after advice ...\"); } 5.2.3 返回后通知 名称：@AfterReturning（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行 范例： @AfterReturning(\"pt()\") public void afterReturning() { System.out.println(\"afterReturning advice ...\"); } 5.2.4 抛出异常后通知 名称：@AfterThrowing（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行 范例： @AfterThrowing(\"pt()\") public void afterThrowing() { System.out.println(\"afterThrowing advice ...\"); } 5.2.5 环绕通知 名称：@Around（重点，常用） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行 范例：： @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"around before advice ...\"); Object ret = pjp.proceed(); System.out.println(\"around after advice ...\"); return ret; } ==环绕通知注意事项== 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。 ","date":"2023-12-31","objectID":"/spring01/:11:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#5-aop通知类型重点"},{"categories":["Spring"],"content":" 5 AOP通知类型【重点】 问题导入请描述一下如何定义环绕通知方法？ 5.1 AOP通知分类 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。 **==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。 5.2 AOP通知详解 5.2.1 前置通知 名称：@Before 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 范例： @Before(\"pt()\") public void before() { System.out.println(\"before advice ...\"); } 5.2.2 后置通知 名称：@After 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行 范例： @After(\"pt()\") public void after() { System.out.println(\"after advice ...\"); } 5.2.3 返回后通知 名称：@AfterReturning（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行 范例： @AfterReturning(\"pt()\") public void afterReturning() { System.out.println(\"afterReturning advice ...\"); } 5.2.4 抛出异常后通知 名称：@AfterThrowing（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行 范例： @AfterThrowing(\"pt()\") public void afterThrowing() { System.out.println(\"afterThrowing advice ...\"); } 5.2.5 环绕通知 名称：@Around（重点，常用） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行 范例：： @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"around before advice ...\"); Object ret = pjp.proceed(); System.out.println(\"around after advice ...\"); return ret; } ==环绕通知注意事项== 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。 ","date":"2023-12-31","objectID":"/spring01/:11:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-25"},{"categories":["Spring"],"content":" 5 AOP通知类型【重点】 问题导入请描述一下如何定义环绕通知方法？ 5.1 AOP通知分类 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。 **==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。 5.2 AOP通知详解 5.2.1 前置通知 名称：@Before 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 范例： @Before(\"pt()\") public void before() { System.out.println(\"before advice ...\"); } 5.2.2 后置通知 名称：@After 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行 范例： @After(\"pt()\") public void after() { System.out.println(\"after advice ...\"); } 5.2.3 返回后通知 名称：@AfterReturning（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行 范例： @AfterReturning(\"pt()\") public void afterReturning() { System.out.println(\"afterReturning advice ...\"); } 5.2.4 抛出异常后通知 名称：@AfterThrowing（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行 范例： @AfterThrowing(\"pt()\") public void afterThrowing() { System.out.println(\"afterThrowing advice ...\"); } 5.2.5 环绕通知 名称：@Around（重点，常用） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行 范例：： @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"around before advice ...\"); Object ret = pjp.proceed(); System.out.println(\"around after advice ...\"); return ret; } ==环绕通知注意事项== 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。 ","date":"2023-12-31","objectID":"/spring01/:11:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#51-aop通知分类"},{"categories":["Spring"],"content":" 5 AOP通知类型【重点】 问题导入请描述一下如何定义环绕通知方法？ 5.1 AOP通知分类 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。 **==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。 5.2 AOP通知详解 5.2.1 前置通知 名称：@Before 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 范例： @Before(\"pt()\") public void before() { System.out.println(\"before advice ...\"); } 5.2.2 后置通知 名称：@After 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行 范例： @After(\"pt()\") public void after() { System.out.println(\"after advice ...\"); } 5.2.3 返回后通知 名称：@AfterReturning（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行 范例： @AfterReturning(\"pt()\") public void afterReturning() { System.out.println(\"afterReturning advice ...\"); } 5.2.4 抛出异常后通知 名称：@AfterThrowing（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行 范例： @AfterThrowing(\"pt()\") public void afterThrowing() { System.out.println(\"afterThrowing advice ...\"); } 5.2.5 环绕通知 名称：@Around（重点，常用） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行 范例：： @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"around before advice ...\"); Object ret = pjp.proceed(); System.out.println(\"around after advice ...\"); return ret; } ==环绕通知注意事项== 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。 ","date":"2023-12-31","objectID":"/spring01/:11:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#52-aop通知详解"},{"categories":["Spring"],"content":" 5 AOP通知类型【重点】 问题导入请描述一下如何定义环绕通知方法？ 5.1 AOP通知分类 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。 **==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。 5.2 AOP通知详解 5.2.1 前置通知 名称：@Before 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 范例： @Before(\"pt()\") public void before() { System.out.println(\"before advice ...\"); } 5.2.2 后置通知 名称：@After 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行 范例： @After(\"pt()\") public void after() { System.out.println(\"after advice ...\"); } 5.2.3 返回后通知 名称：@AfterReturning（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行 范例： @AfterReturning(\"pt()\") public void afterReturning() { System.out.println(\"afterReturning advice ...\"); } 5.2.4 抛出异常后通知 名称：@AfterThrowing（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行 范例： @AfterThrowing(\"pt()\") public void afterThrowing() { System.out.println(\"afterThrowing advice ...\"); } 5.2.5 环绕通知 名称：@Around（重点，常用） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行 范例：： @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"around before advice ...\"); Object ret = pjp.proceed(); System.out.println(\"around after advice ...\"); return ret; } ==环绕通知注意事项== 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。 ","date":"2023-12-31","objectID":"/spring01/:11:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#521-前置通知"},{"categories":["Spring"],"content":" 5 AOP通知类型【重点】 问题导入请描述一下如何定义环绕通知方法？ 5.1 AOP通知分类 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。 **==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。 5.2 AOP通知详解 5.2.1 前置通知 名称：@Before 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 范例： @Before(\"pt()\") public void before() { System.out.println(\"before advice ...\"); } 5.2.2 后置通知 名称：@After 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行 范例： @After(\"pt()\") public void after() { System.out.println(\"after advice ...\"); } 5.2.3 返回后通知 名称：@AfterReturning（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行 范例： @AfterReturning(\"pt()\") public void afterReturning() { System.out.println(\"afterReturning advice ...\"); } 5.2.4 抛出异常后通知 名称：@AfterThrowing（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行 范例： @AfterThrowing(\"pt()\") public void afterThrowing() { System.out.println(\"afterThrowing advice ...\"); } 5.2.5 环绕通知 名称：@Around（重点，常用） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行 范例：： @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"around before advice ...\"); Object ret = pjp.proceed(); System.out.println(\"around after advice ...\"); return ret; } ==环绕通知注意事项== 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。 ","date":"2023-12-31","objectID":"/spring01/:11:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#522-后置通知"},{"categories":["Spring"],"content":" 5 AOP通知类型【重点】 问题导入请描述一下如何定义环绕通知方法？ 5.1 AOP通知分类 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。 **==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。 5.2 AOP通知详解 5.2.1 前置通知 名称：@Before 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 范例： @Before(\"pt()\") public void before() { System.out.println(\"before advice ...\"); } 5.2.2 后置通知 名称：@After 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行 范例： @After(\"pt()\") public void after() { System.out.println(\"after advice ...\"); } 5.2.3 返回后通知 名称：@AfterReturning（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行 范例： @AfterReturning(\"pt()\") public void afterReturning() { System.out.println(\"afterReturning advice ...\"); } 5.2.4 抛出异常后通知 名称：@AfterThrowing（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行 范例： @AfterThrowing(\"pt()\") public void afterThrowing() { System.out.println(\"afterThrowing advice ...\"); } 5.2.5 环绕通知 名称：@Around（重点，常用） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行 范例：： @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"around before advice ...\"); Object ret = pjp.proceed(); System.out.println(\"around after advice ...\"); return ret; } ==环绕通知注意事项== 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。 ","date":"2023-12-31","objectID":"/spring01/:11:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#523-返回后通知"},{"categories":["Spring"],"content":" 5 AOP通知类型【重点】 问题导入请描述一下如何定义环绕通知方法？ 5.1 AOP通知分类 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。 **==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。 5.2 AOP通知详解 5.2.1 前置通知 名称：@Before 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 范例： @Before(\"pt()\") public void before() { System.out.println(\"before advice ...\"); } 5.2.2 后置通知 名称：@After 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行 范例： @After(\"pt()\") public void after() { System.out.println(\"after advice ...\"); } 5.2.3 返回后通知 名称：@AfterReturning（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行 范例： @AfterReturning(\"pt()\") public void afterReturning() { System.out.println(\"afterReturning advice ...\"); } 5.2.4 抛出异常后通知 名称：@AfterThrowing（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行 范例： @AfterThrowing(\"pt()\") public void afterThrowing() { System.out.println(\"afterThrowing advice ...\"); } 5.2.5 环绕通知 名称：@Around（重点，常用） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行 范例：： @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"around before advice ...\"); Object ret = pjp.proceed(); System.out.println(\"around after advice ...\"); return ret; } ==环绕通知注意事项== 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。 ","date":"2023-12-31","objectID":"/spring01/:11:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#524-抛出异常后通知"},{"categories":["Spring"],"content":" 5 AOP通知类型【重点】 问题导入请描述一下如何定义环绕通知方法？ 5.1 AOP通知分类 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置 AOP通知共分为5种类型 前置通知：在切入点方法执行之前执行 后置通知：在切入点方法执行之后执行，无论切入点方法内部是否出现异常，后置通知都会执行。 **==环绕通知(重点)：==**手动调用切入点方法并对其进行增强的通知方式。 返回后通知(了解)：在切入点方法执行之后执行，如果切入点方法内部出现异常将不会执行。 抛出异常后通知(了解)：在切入点方法执行之后执行，只有当切入点方法内部出现异常之后才执行。 5.2 AOP通知详解 5.2.1 前置通知 名称：@Before 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行 范例： @Before(\"pt()\") public void before() { System.out.println(\"before advice ...\"); } 5.2.2 后置通知 名称：@After 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行 范例： @After(\"pt()\") public void after() { System.out.println(\"after advice ...\"); } 5.2.3 返回后通知 名称：@AfterReturning（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行 范例： @AfterReturning(\"pt()\") public void afterReturning() { System.out.println(\"afterReturning advice ...\"); } 5.2.4 抛出异常后通知 名称：@AfterThrowing（了解） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行 范例： @AfterThrowing(\"pt()\") public void afterThrowing() { System.out.println(\"afterThrowing advice ...\"); } 5.2.5 环绕通知 名称：@Around（重点，常用） 类型：==方法注解== 位置：通知方法定义上方 作用：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行 范例：： @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\"around before advice ...\"); Object ret = pjp.proceed(); System.out.println(\"around after advice ...\"); return ret; } ==环绕通知注意事项== 环绕通知方法形参必须是ProceedingJoinPoint，表示正在执行的连接点，使用该对象的proceed()方法表示对原始对象方法进行调用，返回值为原始对象方法的返回值。 环绕通知方法的返回值建议写成Object类型，用于将原始对象方法的返回值进行返回，哪里使用代理对象就返回到哪里。 ","date":"2023-12-31","objectID":"/spring01/:11:5","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#525-环绕通知"},{"categories":["Spring"],"content":" 九、AOP案例","date":"2023-12-31","objectID":"/spring01/:12:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#九aop案例"},{"categories":["Spring"],"content":" 1 案例-测量业务层接口万次执行效率 问题导入能不能描述一下环绕通知里面的实现步骤？ 1.1 需求和分析需求：任意业务层接口执行均可显示其执行效率（执行时长） 分析： ​ ①：业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率 ​ ②：通知类型选择前后均可以增强的类型——环绕通知 1.2 代码实现 【前置工作】环境准备 Spring整合mybatis对spring_db数据库中的Account进行CRUD操作 Spring整合Junit测试CRUD是否OK。 在pom.xml中添加aspectjweaver切入点表达式依赖 … … 【第一步】编写通知类 @Component @Aspect public class ProjectAdvice { //匹配业务层的所有方法 @Pointcut(\"execution(* com.itheima.service.*Service.*(..))\") private void servicePt(){} //设置环绕通知，在原始操作的运行前后记录执行时间 @Around(\"ProjectAdvice.servicePt()\") //本类类名可以省略不写 public void runSpeed(ProceedingJoinPoint pjp) throws Throwable { //获取执行的签名对象 Signature signature = pjp.getSignature(); //获取接口/类全限定名 String className = signature.getDeclaringTypeName(); //获取方法名 String methodName = signature.getName(); //记录开始时间 long start = System.currentTimeMillis(); //执行万次操作 for (int i = 0; i \u003c 10000; i++) { pjp.proceed(); } //记录结束时间 long end = System.currentTimeMillis(); //打印执行结果 System.out.println(\"万次执行：\"+ className+\".\"+methodName+\"----\u003e\" +(end-start) + \"ms\"); } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) @EnableAspectJAutoProxy //开启AOP注解功能 public class SpringConfig { } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTestCase { @Autowired private AccountService accountService; @Test public void testFindById(){ Account account = accountService.findById(2); } @Test public void testFindAll(){ List\u003cAccount\u003e list = accountService.findAll(); } } ","date":"2023-12-31","objectID":"/spring01/:12:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-案例-测量业务层接口万次执行效率"},{"categories":["Spring"],"content":" 1 案例-测量业务层接口万次执行效率 问题导入能不能描述一下环绕通知里面的实现步骤？ 1.1 需求和分析需求：任意业务层接口执行均可显示其执行效率（执行时长） 分析： ​ ①：业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率 ​ ②：通知类型选择前后均可以增强的类型——环绕通知 1.2 代码实现 【前置工作】环境准备 Spring整合mybatis对spring_db数据库中的Account进行CRUD操作 Spring整合Junit测试CRUD是否OK。 在pom.xml中添加aspectjweaver切入点表达式依赖 … … 【第一步】编写通知类 @Component @Aspect public class ProjectAdvice { //匹配业务层的所有方法 @Pointcut(\"execution(* com.itheima.service.*Service.*(..))\") private void servicePt(){} //设置环绕通知，在原始操作的运行前后记录执行时间 @Around(\"ProjectAdvice.servicePt()\") //本类类名可以省略不写 public void runSpeed(ProceedingJoinPoint pjp) throws Throwable { //获取执行的签名对象 Signature signature = pjp.getSignature(); //获取接口/类全限定名 String className = signature.getDeclaringTypeName(); //获取方法名 String methodName = signature.getName(); //记录开始时间 long start = System.currentTimeMillis(); //执行万次操作 for (int i = 0; i \u003c 10000; i++) { pjp.proceed(); } //记录结束时间 long end = System.currentTimeMillis(); //打印执行结果 System.out.println(\"万次执行：\"+ className+\".\"+methodName+\"----\u003e\" +(end-start) + \"ms\"); } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) @EnableAspectJAutoProxy //开启AOP注解功能 public class SpringConfig { } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTestCase { @Autowired private AccountService accountService; @Test public void testFindById(){ Account account = accountService.findById(2); } @Test public void testFindAll(){ List list = accountService.findAll(); } } ","date":"2023-12-31","objectID":"/spring01/:12:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-26"},{"categories":["Spring"],"content":" 1 案例-测量业务层接口万次执行效率 问题导入能不能描述一下环绕通知里面的实现步骤？ 1.1 需求和分析需求：任意业务层接口执行均可显示其执行效率（执行时长） 分析： ​ ①：业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率 ​ ②：通知类型选择前后均可以增强的类型——环绕通知 1.2 代码实现 【前置工作】环境准备 Spring整合mybatis对spring_db数据库中的Account进行CRUD操作 Spring整合Junit测试CRUD是否OK。 在pom.xml中添加aspectjweaver切入点表达式依赖 … … 【第一步】编写通知类 @Component @Aspect public class ProjectAdvice { //匹配业务层的所有方法 @Pointcut(\"execution(* com.itheima.service.*Service.*(..))\") private void servicePt(){} //设置环绕通知，在原始操作的运行前后记录执行时间 @Around(\"ProjectAdvice.servicePt()\") //本类类名可以省略不写 public void runSpeed(ProceedingJoinPoint pjp) throws Throwable { //获取执行的签名对象 Signature signature = pjp.getSignature(); //获取接口/类全限定名 String className = signature.getDeclaringTypeName(); //获取方法名 String methodName = signature.getName(); //记录开始时间 long start = System.currentTimeMillis(); //执行万次操作 for (int i = 0; i \u003c 10000; i++) { pjp.proceed(); } //记录结束时间 long end = System.currentTimeMillis(); //打印执行结果 System.out.println(\"万次执行：\"+ className+\".\"+methodName+\"----\u003e\" +(end-start) + \"ms\"); } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) @EnableAspectJAutoProxy //开启AOP注解功能 public class SpringConfig { } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTestCase { @Autowired private AccountService accountService; @Test public void testFindById(){ Account account = accountService.findById(2); } @Test public void testFindAll(){ List list = accountService.findAll(); } } ","date":"2023-12-31","objectID":"/spring01/:12:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-需求和分析"},{"categories":["Spring"],"content":" 1 案例-测量业务层接口万次执行效率 问题导入能不能描述一下环绕通知里面的实现步骤？ 1.1 需求和分析需求：任意业务层接口执行均可显示其执行效率（执行时长） 分析： ​ ①：业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率 ​ ②：通知类型选择前后均可以增强的类型——环绕通知 1.2 代码实现 【前置工作】环境准备 Spring整合mybatis对spring_db数据库中的Account进行CRUD操作 Spring整合Junit测试CRUD是否OK。 在pom.xml中添加aspectjweaver切入点表达式依赖 … … 【第一步】编写通知类 @Component @Aspect public class ProjectAdvice { //匹配业务层的所有方法 @Pointcut(\"execution(* com.itheima.service.*Service.*(..))\") private void servicePt(){} //设置环绕通知，在原始操作的运行前后记录执行时间 @Around(\"ProjectAdvice.servicePt()\") //本类类名可以省略不写 public void runSpeed(ProceedingJoinPoint pjp) throws Throwable { //获取执行的签名对象 Signature signature = pjp.getSignature(); //获取接口/类全限定名 String className = signature.getDeclaringTypeName(); //获取方法名 String methodName = signature.getName(); //记录开始时间 long start = System.currentTimeMillis(); //执行万次操作 for (int i = 0; i \u003c 10000; i++) { pjp.proceed(); } //记录结束时间 long end = System.currentTimeMillis(); //打印执行结果 System.out.println(\"万次执行：\"+ className+\".\"+methodName+\"----\u003e\" +(end-start) + \"ms\"); } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) @EnableAspectJAutoProxy //开启AOP注解功能 public class SpringConfig { } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTestCase { @Autowired private AccountService accountService; @Test public void testFindById(){ Account account = accountService.findById(2); } @Test public void testFindAll(){ List list = accountService.findAll(); } } ","date":"2023-12-31","objectID":"/spring01/:12:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-代码实现-1"},{"categories":["Spring"],"content":" 1 案例-测量业务层接口万次执行效率 问题导入能不能描述一下环绕通知里面的实现步骤？ 1.1 需求和分析需求：任意业务层接口执行均可显示其执行效率（执行时长） 分析： ​ ①：业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率 ​ ②：通知类型选择前后均可以增强的类型——环绕通知 1.2 代码实现 【前置工作】环境准备 Spring整合mybatis对spring_db数据库中的Account进行CRUD操作 Spring整合Junit测试CRUD是否OK。 在pom.xml中添加aspectjweaver切入点表达式依赖 … … 【第一步】编写通知类 @Component @Aspect public class ProjectAdvice { //匹配业务层的所有方法 @Pointcut(\"execution(* com.itheima.service.*Service.*(..))\") private void servicePt(){} //设置环绕通知，在原始操作的运行前后记录执行时间 @Around(\"ProjectAdvice.servicePt()\") //本类类名可以省略不写 public void runSpeed(ProceedingJoinPoint pjp) throws Throwable { //获取执行的签名对象 Signature signature = pjp.getSignature(); //获取接口/类全限定名 String className = signature.getDeclaringTypeName(); //获取方法名 String methodName = signature.getName(); //记录开始时间 long start = System.currentTimeMillis(); //执行万次操作 for (int i = 0; i \u003c 10000; i++) { pjp.proceed(); } //记录结束时间 long end = System.currentTimeMillis(); //打印执行结果 System.out.println(\"万次执行：\"+ className+\".\"+methodName+\"----\u003e\" +(end-start) + \"ms\"); } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) @EnableAspectJAutoProxy //开启AOP注解功能 public class SpringConfig { } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTestCase { @Autowired private AccountService accountService; @Test public void testFindById(){ Account account = accountService.findById(2); } @Test public void testFindAll(){ List list = accountService.findAll(); } } ","date":"2023-12-31","objectID":"/spring01/:12:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#前置工作环境准备"},{"categories":["Spring"],"content":" 1 案例-测量业务层接口万次执行效率 问题导入能不能描述一下环绕通知里面的实现步骤？ 1.1 需求和分析需求：任意业务层接口执行均可显示其执行效率（执行时长） 分析： ​ ①：业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率 ​ ②：通知类型选择前后均可以增强的类型——环绕通知 1.2 代码实现 【前置工作】环境准备 Spring整合mybatis对spring_db数据库中的Account进行CRUD操作 Spring整合Junit测试CRUD是否OK。 在pom.xml中添加aspectjweaver切入点表达式依赖 … … 【第一步】编写通知类 @Component @Aspect public class ProjectAdvice { //匹配业务层的所有方法 @Pointcut(\"execution(* com.itheima.service.*Service.*(..))\") private void servicePt(){} //设置环绕通知，在原始操作的运行前后记录执行时间 @Around(\"ProjectAdvice.servicePt()\") //本类类名可以省略不写 public void runSpeed(ProceedingJoinPoint pjp) throws Throwable { //获取执行的签名对象 Signature signature = pjp.getSignature(); //获取接口/类全限定名 String className = signature.getDeclaringTypeName(); //获取方法名 String methodName = signature.getName(); //记录开始时间 long start = System.currentTimeMillis(); //执行万次操作 for (int i = 0; i \u003c 10000; i++) { pjp.proceed(); } //记录结束时间 long end = System.currentTimeMillis(); //打印执行结果 System.out.println(\"万次执行：\"+ className+\".\"+methodName+\"----\u003e\" +(end-start) + \"ms\"); } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) @EnableAspectJAutoProxy //开启AOP注解功能 public class SpringConfig { } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTestCase { @Autowired private AccountService accountService; @Test public void testFindById(){ Account account = accountService.findById(2); } @Test public void testFindAll(){ List list = accountService.findAll(); } } ","date":"2023-12-31","objectID":"/spring01/:12:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第一步编写通知类"},{"categories":["Spring"],"content":" 1 案例-测量业务层接口万次执行效率 问题导入能不能描述一下环绕通知里面的实现步骤？ 1.1 需求和分析需求：任意业务层接口执行均可显示其执行效率（执行时长） 分析： ​ ①：业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率 ​ ②：通知类型选择前后均可以增强的类型——环绕通知 1.2 代码实现 【前置工作】环境准备 Spring整合mybatis对spring_db数据库中的Account进行CRUD操作 Spring整合Junit测试CRUD是否OK。 在pom.xml中添加aspectjweaver切入点表达式依赖 … … 【第一步】编写通知类 @Component @Aspect public class ProjectAdvice { //匹配业务层的所有方法 @Pointcut(\"execution(* com.itheima.service.*Service.*(..))\") private void servicePt(){} //设置环绕通知，在原始操作的运行前后记录执行时间 @Around(\"ProjectAdvice.servicePt()\") //本类类名可以省略不写 public void runSpeed(ProceedingJoinPoint pjp) throws Throwable { //获取执行的签名对象 Signature signature = pjp.getSignature(); //获取接口/类全限定名 String className = signature.getDeclaringTypeName(); //获取方法名 String methodName = signature.getName(); //记录开始时间 long start = System.currentTimeMillis(); //执行万次操作 for (int i = 0; i \u003c 10000; i++) { pjp.proceed(); } //记录结束时间 long end = System.currentTimeMillis(); //打印执行结果 System.out.println(\"万次执行：\"+ className+\".\"+methodName+\"----\u003e\" +(end-start) + \"ms\"); } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) @EnableAspectJAutoProxy //开启AOP注解功能 public class SpringConfig { } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTestCase { @Autowired private AccountService accountService; @Test public void testFindById(){ Account account = accountService.findById(2); } @Test public void testFindAll(){ List list = accountService.findAll(); } } ","date":"2023-12-31","objectID":"/spring01/:12:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第二步在springconfig配置类上开启aop注解功能"},{"categories":["Spring"],"content":" 1 案例-测量业务层接口万次执行效率 问题导入能不能描述一下环绕通知里面的实现步骤？ 1.1 需求和分析需求：任意业务层接口执行均可显示其执行效率（执行时长） 分析： ​ ①：业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率 ​ ②：通知类型选择前后均可以增强的类型——环绕通知 1.2 代码实现 【前置工作】环境准备 Spring整合mybatis对spring_db数据库中的Account进行CRUD操作 Spring整合Junit测试CRUD是否OK。 在pom.xml中添加aspectjweaver切入点表达式依赖 … … 【第一步】编写通知类 @Component @Aspect public class ProjectAdvice { //匹配业务层的所有方法 @Pointcut(\"execution(* com.itheima.service.*Service.*(..))\") private void servicePt(){} //设置环绕通知，在原始操作的运行前后记录执行时间 @Around(\"ProjectAdvice.servicePt()\") //本类类名可以省略不写 public void runSpeed(ProceedingJoinPoint pjp) throws Throwable { //获取执行的签名对象 Signature signature = pjp.getSignature(); //获取接口/类全限定名 String className = signature.getDeclaringTypeName(); //获取方法名 String methodName = signature.getName(); //记录开始时间 long start = System.currentTimeMillis(); //执行万次操作 for (int i = 0; i \u003c 10000; i++) { pjp.proceed(); } //记录结束时间 long end = System.currentTimeMillis(); //打印执行结果 System.out.println(\"万次执行：\"+ className+\".\"+methodName+\"----\u003e\" +(end-start) + \"ms\"); } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) @EnableAspectJAutoProxy //开启AOP注解功能 public class SpringConfig { } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTestCase { @Autowired private AccountService accountService; @Test public void testFindById(){ Account account = accountService.findById(2); } @Test public void testFindAll(){ List list = accountService.findAll(); } } ","date":"2023-12-31","objectID":"/spring01/:12:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第三步运行测试类查看结果"},{"categories":["Spring"],"content":" 2 AOP切入点数据获取 问题导入在环绕通知中可以获取到哪些数据？ 2.1 获取参数 说明：在前置通知和环绕通知中都可以获取到连接点方法的参数们 JoinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数 @Before(\"pt()\") public void before(JoinPoint jp) { Object[] args = jp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); } ProccedJointPoint是JoinPoint的子类 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); Object ret = pjp.proceed(); return ret; } 2.2 获取返回值 说明：在返回后通知和环绕通知中都可以获取到连接点方法的返回值 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterReturning(value = \"pt()\",returning = \"ret\") public void afterReturning(String ret) { //变量名要和returning=\"ret\"的属性值一致 System.out.println(\"afterReturning advice ...\"+ret); } 环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { // 手动调用连接点方法，返回值就是连接点方法的返回值 Object ret = pjp.proceed(); return ret; } 2.3 获取异常 说明：在抛出异常后通知和环绕通知中都可以获取到连接点方法中出现的异常 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterThrowing(value = \"pt()\",throwing = \"t\") public void afterThrowing(Throwable t) {//变量名要和throwing = \"t\"的属性值一致 System.out.println(\"afterThrowing advice ...\"+ t); } 抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) { Object ret = null; //此处需要try...catch处理，catch中捕获到的异常就是连接点方法中抛出的异常 try { ret = pjp.proceed(); } catch (Throwable t) { t.printStackTrace(); } return ret; } ","date":"2023-12-31","objectID":"/spring01/:12:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-aop切入点数据获取"},{"categories":["Spring"],"content":" 2 AOP切入点数据获取 问题导入在环绕通知中可以获取到哪些数据？ 2.1 获取参数 说明：在前置通知和环绕通知中都可以获取到连接点方法的参数们 JoinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数 @Before(\"pt()\") public void before(JoinPoint jp) { Object[] args = jp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); } ProccedJointPoint是JoinPoint的子类 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); Object ret = pjp.proceed(); return ret; } 2.2 获取返回值 说明：在返回后通知和环绕通知中都可以获取到连接点方法的返回值 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterReturning(value = \"pt()\",returning = \"ret\") public void afterReturning(String ret) { //变量名要和returning=\"ret\"的属性值一致 System.out.println(\"afterReturning advice ...\"+ret); } 环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { // 手动调用连接点方法，返回值就是连接点方法的返回值 Object ret = pjp.proceed(); return ret; } 2.3 获取异常 说明：在抛出异常后通知和环绕通知中都可以获取到连接点方法中出现的异常 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterThrowing(value = \"pt()\",throwing = \"t\") public void afterThrowing(Throwable t) {//变量名要和throwing = \"t\"的属性值一致 System.out.println(\"afterThrowing advice ...\"+ t); } 抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) { Object ret = null; //此处需要try...catch处理，catch中捕获到的异常就是连接点方法中抛出的异常 try { ret = pjp.proceed(); } catch (Throwable t) { t.printStackTrace(); } return ret; } ","date":"2023-12-31","objectID":"/spring01/:12:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-27"},{"categories":["Spring"],"content":" 2 AOP切入点数据获取 问题导入在环绕通知中可以获取到哪些数据？ 2.1 获取参数 说明：在前置通知和环绕通知中都可以获取到连接点方法的参数们 JoinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数 @Before(\"pt()\") public void before(JoinPoint jp) { Object[] args = jp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); } ProccedJointPoint是JoinPoint的子类 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); Object ret = pjp.proceed(); return ret; } 2.2 获取返回值 说明：在返回后通知和环绕通知中都可以获取到连接点方法的返回值 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterReturning(value = \"pt()\",returning = \"ret\") public void afterReturning(String ret) { //变量名要和returning=\"ret\"的属性值一致 System.out.println(\"afterReturning advice ...\"+ret); } 环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { // 手动调用连接点方法，返回值就是连接点方法的返回值 Object ret = pjp.proceed(); return ret; } 2.3 获取异常 说明：在抛出异常后通知和环绕通知中都可以获取到连接点方法中出现的异常 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterThrowing(value = \"pt()\",throwing = \"t\") public void afterThrowing(Throwable t) {//变量名要和throwing = \"t\"的属性值一致 System.out.println(\"afterThrowing advice ...\"+ t); } 抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) { Object ret = null; //此处需要try...catch处理，catch中捕获到的异常就是连接点方法中抛出的异常 try { ret = pjp.proceed(); } catch (Throwable t) { t.printStackTrace(); } return ret; } ","date":"2023-12-31","objectID":"/spring01/:12:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-获取参数"},{"categories":["Spring"],"content":" 2 AOP切入点数据获取 问题导入在环绕通知中可以获取到哪些数据？ 2.1 获取参数 说明：在前置通知和环绕通知中都可以获取到连接点方法的参数们 JoinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数 @Before(\"pt()\") public void before(JoinPoint jp) { Object[] args = jp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); } ProccedJointPoint是JoinPoint的子类 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); Object ret = pjp.proceed(); return ret; } 2.2 获取返回值 说明：在返回后通知和环绕通知中都可以获取到连接点方法的返回值 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterReturning(value = \"pt()\",returning = \"ret\") public void afterReturning(String ret) { //变量名要和returning=\"ret\"的属性值一致 System.out.println(\"afterReturning advice ...\"+ret); } 环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { // 手动调用连接点方法，返回值就是连接点方法的返回值 Object ret = pjp.proceed(); return ret; } 2.3 获取异常 说明：在抛出异常后通知和环绕通知中都可以获取到连接点方法中出现的异常 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterThrowing(value = \"pt()\",throwing = \"t\") public void afterThrowing(Throwable t) {//变量名要和throwing = \"t\"的属性值一致 System.out.println(\"afterThrowing advice ...\"+ t); } 抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) { Object ret = null; //此处需要try...catch处理，catch中捕获到的异常就是连接点方法中抛出的异常 try { ret = pjp.proceed(); } catch (Throwable t) { t.printStackTrace(); } return ret; } ","date":"2023-12-31","objectID":"/spring01/:12:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#22-获取返回值"},{"categories":["Spring"],"content":" 2 AOP切入点数据获取 问题导入在环绕通知中可以获取到哪些数据？ 2.1 获取参数 说明：在前置通知和环绕通知中都可以获取到连接点方法的参数们 JoinPoint对象描述了连接点方法的运行状态，可以获取到原始方法的调用参数 @Before(\"pt()\") public void before(JoinPoint jp) { Object[] args = jp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); } ProccedJointPoint是JoinPoint的子类 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); //获取连接点方法的参数们 System.out.println(Arrays.toString(args)); Object ret = pjp.proceed(); return ret; } 2.2 获取返回值 说明：在返回后通知和环绕通知中都可以获取到连接点方法的返回值 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterReturning(value = \"pt()\",returning = \"ret\") public void afterReturning(String ret) { //变量名要和returning=\"ret\"的属性值一致 System.out.println(\"afterReturning advice ...\"+ret); } 环绕通知中可以手工书写对原始方法的调用，得到的结果即为原始方法的返回值 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { // 手动调用连接点方法，返回值就是连接点方法的返回值 Object ret = pjp.proceed(); return ret; } 2.3 获取异常 说明：在抛出异常后通知和环绕通知中都可以获取到连接点方法中出现的异常 抛出异常后通知可以获取切入点方法中出现的异常信息，使用形参可以接收对应的异常对象 @AfterThrowing(value = \"pt()\",throwing = \"t\") public void afterThrowing(Throwable t) {//变量名要和throwing = \"t\"的属性值一致 System.out.println(\"afterThrowing advice ...\"+ t); } 抛出异常后通知可以获取切入点方法运行的异常信息，使用形参可以接收运行时抛出的异常对象 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) { Object ret = null; //此处需要try...catch处理，catch中捕获到的异常就是连接点方法中抛出的异常 try { ret = pjp.proceed(); } catch (Throwable t) { t.printStackTrace(); } return ret; } ","date":"2023-12-31","objectID":"/spring01/:12:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#23-获取异常"},{"categories":["Spring"],"content":" 3 案例-百度网盘密码数据兼容处理 问题导入请说出我们该使用什么类型的通知来完成这个需求？ 3.1 需求和分析需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理 分析： ①：在业务方法执行之前对所有的输入参数进行格式处理——trim() ②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用 3.2 代码实现 【前置工作】环境准备 //-------------service层代码----------------------- public interface ResourcesService { public boolean openURL(String url ,String password); } @Service public class ResourcesServiceImpl implements ResourcesService { @Autowired private ResourcesDao resourcesDao; public boolean openURL(String url, String password) { return resourcesDao.readResources(url,password); } } //-------------dao层代码----------------------- public interface ResourcesDao { boolean readResources(String url, String password); } @Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { System.out.println(password.length()); //模拟校验 return password.equals(\"root\"); } } 【第一步】编写通知类 @Component @Aspect public class DataAdvice { @Pointcut(\"execution(boolean com.itheima.service.*Service.*(*,*))\") private void servicePt(){} @Around(\"DataAdvice.servicePt()\") public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); for (int i = 0; i \u003c args.length; i++) { //判断参数是不是字符串 if(args[i].getClass().equals(String.class)){ args[i] = args[i].toString().trim(); } } Object ret = pjp.proceed(args); return ret; } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @EnableAspectJAutoProxy public class SpringConfig { } 【第三步】运行测试类，查看结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); ResourcesService resourcesService = ctx.getBean(ResourcesService.class); boolean flag = resourcesService.openURL(\"http://pan.baidu.com/haha\", \"root \"); System.out.println(flag); } } ","date":"2023-12-31","objectID":"/spring01/:12:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#3-案例-百度网盘密码数据兼容处理"},{"categories":["Spring"],"content":" 3 案例-百度网盘密码数据兼容处理 问题导入请说出我们该使用什么类型的通知来完成这个需求？ 3.1 需求和分析需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理 分析： ①：在业务方法执行之前对所有的输入参数进行格式处理——trim() ②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用 3.2 代码实现 【前置工作】环境准备 //-------------service层代码----------------------- public interface ResourcesService { public boolean openURL(String url ,String password); } @Service public class ResourcesServiceImpl implements ResourcesService { @Autowired private ResourcesDao resourcesDao; public boolean openURL(String url, String password) { return resourcesDao.readResources(url,password); } } //-------------dao层代码----------------------- public interface ResourcesDao { boolean readResources(String url, String password); } @Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { System.out.println(password.length()); //模拟校验 return password.equals(\"root\"); } } 【第一步】编写通知类 @Component @Aspect public class DataAdvice { @Pointcut(\"execution(boolean com.itheima.service.*Service.*(*,*))\") private void servicePt(){} @Around(\"DataAdvice.servicePt()\") public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); for (int i = 0; i \u003c args.length; i++) { //判断参数是不是字符串 if(args[i].getClass().equals(String.class)){ args[i] = args[i].toString().trim(); } } Object ret = pjp.proceed(args); return ret; } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @EnableAspectJAutoProxy public class SpringConfig { } 【第三步】运行测试类，查看结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); ResourcesService resourcesService = ctx.getBean(ResourcesService.class); boolean flag = resourcesService.openURL(\"http://pan.baidu.com/haha\", \"root \"); System.out.println(flag); } } ","date":"2023-12-31","objectID":"/spring01/:12:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-28"},{"categories":["Spring"],"content":" 3 案例-百度网盘密码数据兼容处理 问题导入请说出我们该使用什么类型的通知来完成这个需求？ 3.1 需求和分析需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理 分析： ①：在业务方法执行之前对所有的输入参数进行格式处理——trim() ②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用 3.2 代码实现 【前置工作】环境准备 //-------------service层代码----------------------- public interface ResourcesService { public boolean openURL(String url ,String password); } @Service public class ResourcesServiceImpl implements ResourcesService { @Autowired private ResourcesDao resourcesDao; public boolean openURL(String url, String password) { return resourcesDao.readResources(url,password); } } //-------------dao层代码----------------------- public interface ResourcesDao { boolean readResources(String url, String password); } @Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { System.out.println(password.length()); //模拟校验 return password.equals(\"root\"); } } 【第一步】编写通知类 @Component @Aspect public class DataAdvice { @Pointcut(\"execution(boolean com.itheima.service.*Service.*(*,*))\") private void servicePt(){} @Around(\"DataAdvice.servicePt()\") public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); for (int i = 0; i \u003c args.length; i++) { //判断参数是不是字符串 if(args[i].getClass().equals(String.class)){ args[i] = args[i].toString().trim(); } } Object ret = pjp.proceed(args); return ret; } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @EnableAspectJAutoProxy public class SpringConfig { } 【第三步】运行测试类，查看结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); ResourcesService resourcesService = ctx.getBean(ResourcesService.class); boolean flag = resourcesService.openURL(\"http://pan.baidu.com/haha\", \"root \"); System.out.println(flag); } } ","date":"2023-12-31","objectID":"/spring01/:12:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#31-需求和分析"},{"categories":["Spring"],"content":" 3 案例-百度网盘密码数据兼容处理 问题导入请说出我们该使用什么类型的通知来完成这个需求？ 3.1 需求和分析需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理 分析： ①：在业务方法执行之前对所有的输入参数进行格式处理——trim() ②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用 3.2 代码实现 【前置工作】环境准备 //-------------service层代码----------------------- public interface ResourcesService { public boolean openURL(String url ,String password); } @Service public class ResourcesServiceImpl implements ResourcesService { @Autowired private ResourcesDao resourcesDao; public boolean openURL(String url, String password) { return resourcesDao.readResources(url,password); } } //-------------dao层代码----------------------- public interface ResourcesDao { boolean readResources(String url, String password); } @Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { System.out.println(password.length()); //模拟校验 return password.equals(\"root\"); } } 【第一步】编写通知类 @Component @Aspect public class DataAdvice { @Pointcut(\"execution(boolean com.itheima.service.*Service.*(*,*))\") private void servicePt(){} @Around(\"DataAdvice.servicePt()\") public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); for (int i = 0; i \u003c args.length; i++) { //判断参数是不是字符串 if(args[i].getClass().equals(String.class)){ args[i] = args[i].toString().trim(); } } Object ret = pjp.proceed(args); return ret; } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @EnableAspectJAutoProxy public class SpringConfig { } 【第三步】运行测试类，查看结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); ResourcesService resourcesService = ctx.getBean(ResourcesService.class); boolean flag = resourcesService.openURL(\"http://pan.baidu.com/haha\", \"root \"); System.out.println(flag); } } ","date":"2023-12-31","objectID":"/spring01/:12:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#32-代码实现"},{"categories":["Spring"],"content":" 3 案例-百度网盘密码数据兼容处理 问题导入请说出我们该使用什么类型的通知来完成这个需求？ 3.1 需求和分析需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理 分析： ①：在业务方法执行之前对所有的输入参数进行格式处理——trim() ②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用 3.2 代码实现 【前置工作】环境准备 //-------------service层代码----------------------- public interface ResourcesService { public boolean openURL(String url ,String password); } @Service public class ResourcesServiceImpl implements ResourcesService { @Autowired private ResourcesDao resourcesDao; public boolean openURL(String url, String password) { return resourcesDao.readResources(url,password); } } //-------------dao层代码----------------------- public interface ResourcesDao { boolean readResources(String url, String password); } @Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { System.out.println(password.length()); //模拟校验 return password.equals(\"root\"); } } 【第一步】编写通知类 @Component @Aspect public class DataAdvice { @Pointcut(\"execution(boolean com.itheima.service.*Service.*(*,*))\") private void servicePt(){} @Around(\"DataAdvice.servicePt()\") public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); for (int i = 0; i \u003c args.length; i++) { //判断参数是不是字符串 if(args[i].getClass().equals(String.class)){ args[i] = args[i].toString().trim(); } } Object ret = pjp.proceed(args); return ret; } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @EnableAspectJAutoProxy public class SpringConfig { } 【第三步】运行测试类，查看结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); ResourcesService resourcesService = ctx.getBean(ResourcesService.class); boolean flag = resourcesService.openURL(\"http://pan.baidu.com/haha\", \"root \"); System.out.println(flag); } } ","date":"2023-12-31","objectID":"/spring01/:12:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#前置工作环境准备-1"},{"categories":["Spring"],"content":" 3 案例-百度网盘密码数据兼容处理 问题导入请说出我们该使用什么类型的通知来完成这个需求？ 3.1 需求和分析需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理 分析： ①：在业务方法执行之前对所有的输入参数进行格式处理——trim() ②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用 3.2 代码实现 【前置工作】环境准备 //-------------service层代码----------------------- public interface ResourcesService { public boolean openURL(String url ,String password); } @Service public class ResourcesServiceImpl implements ResourcesService { @Autowired private ResourcesDao resourcesDao; public boolean openURL(String url, String password) { return resourcesDao.readResources(url,password); } } //-------------dao层代码----------------------- public interface ResourcesDao { boolean readResources(String url, String password); } @Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { System.out.println(password.length()); //模拟校验 return password.equals(\"root\"); } } 【第一步】编写通知类 @Component @Aspect public class DataAdvice { @Pointcut(\"execution(boolean com.itheima.service.*Service.*(*,*))\") private void servicePt(){} @Around(\"DataAdvice.servicePt()\") public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); for (int i = 0; i \u003c args.length; i++) { //判断参数是不是字符串 if(args[i].getClass().equals(String.class)){ args[i] = args[i].toString().trim(); } } Object ret = pjp.proceed(args); return ret; } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @EnableAspectJAutoProxy public class SpringConfig { } 【第三步】运行测试类，查看结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); ResourcesService resourcesService = ctx.getBean(ResourcesService.class); boolean flag = resourcesService.openURL(\"http://pan.baidu.com/haha\", \"root \"); System.out.println(flag); } } ","date":"2023-12-31","objectID":"/spring01/:12:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第一步编写通知类-1"},{"categories":["Spring"],"content":" 3 案例-百度网盘密码数据兼容处理 问题导入请说出我们该使用什么类型的通知来完成这个需求？ 3.1 需求和分析需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理 分析： ①：在业务方法执行之前对所有的输入参数进行格式处理——trim() ②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用 3.2 代码实现 【前置工作】环境准备 //-------------service层代码----------------------- public interface ResourcesService { public boolean openURL(String url ,String password); } @Service public class ResourcesServiceImpl implements ResourcesService { @Autowired private ResourcesDao resourcesDao; public boolean openURL(String url, String password) { return resourcesDao.readResources(url,password); } } //-------------dao层代码----------------------- public interface ResourcesDao { boolean readResources(String url, String password); } @Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { System.out.println(password.length()); //模拟校验 return password.equals(\"root\"); } } 【第一步】编写通知类 @Component @Aspect public class DataAdvice { @Pointcut(\"execution(boolean com.itheima.service.*Service.*(*,*))\") private void servicePt(){} @Around(\"DataAdvice.servicePt()\") public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); for (int i = 0; i \u003c args.length; i++) { //判断参数是不是字符串 if(args[i].getClass().equals(String.class)){ args[i] = args[i].toString().trim(); } } Object ret = pjp.proceed(args); return ret; } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @EnableAspectJAutoProxy public class SpringConfig { } 【第三步】运行测试类，查看结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); ResourcesService resourcesService = ctx.getBean(ResourcesService.class); boolean flag = resourcesService.openURL(\"http://pan.baidu.com/haha\", \"root \"); System.out.println(flag); } } ","date":"2023-12-31","objectID":"/spring01/:12:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第二步在springconfig配置类上开启aop注解功能-1"},{"categories":["Spring"],"content":" 3 案例-百度网盘密码数据兼容处理 问题导入请说出我们该使用什么类型的通知来完成这个需求？ 3.1 需求和分析需求：对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理 分析： ①：在业务方法执行之前对所有的输入参数进行格式处理——trim() ②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用 3.2 代码实现 【前置工作】环境准备 //-------------service层代码----------------------- public interface ResourcesService { public boolean openURL(String url ,String password); } @Service public class ResourcesServiceImpl implements ResourcesService { @Autowired private ResourcesDao resourcesDao; public boolean openURL(String url, String password) { return resourcesDao.readResources(url,password); } } //-------------dao层代码----------------------- public interface ResourcesDao { boolean readResources(String url, String password); } @Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { System.out.println(password.length()); //模拟校验 return password.equals(\"root\"); } } 【第一步】编写通知类 @Component @Aspect public class DataAdvice { @Pointcut(\"execution(boolean com.itheima.service.*Service.*(*,*))\") private void servicePt(){} @Around(\"DataAdvice.servicePt()\") public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); for (int i = 0; i \u003c args.length; i++) { //判断参数是不是字符串 if(args[i].getClass().equals(String.class)){ args[i] = args[i].toString().trim(); } } Object ret = pjp.proceed(args); return ret; } } 【第二步】在SpringConfig配置类上开启AOP注解功能 @Configuration @ComponentScan(\"com.itheima\") @EnableAspectJAutoProxy public class SpringConfig { } 【第三步】运行测试类，查看结果 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); ResourcesService resourcesService = ctx.getBean(ResourcesService.class); boolean flag = resourcesService.openURL(\"http://pan.baidu.com/haha\", \"root \"); System.out.println(flag); } } ","date":"2023-12-31","objectID":"/spring01/:12:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第三步运行测试类查看结果-1"},{"categories":["Spring"],"content":" 4 AOP开发总结 4.1 AOP的核心概念 概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式 作用：在不惊动原始设计的基础上为方法进行功能增强 核心概念 代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的 连接点（JoinPoint）： 在SpringAOP中，理解为任意方法的执行 切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述 通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法 切面（Aspect）：描述通知与切入点的对应关系 目标对象（Target）：被代理的原始对象成为目标对象 4.2 切入点表达式语法 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名（参数）异常名) execution(* com.itheima.service.Service.(..)) 切入点表达式描述通配符： 作用：用于快速描述，范围描述 *：匹配任意符号（常用） .. ：匹配多个连续的任意符号（常用） +：匹配子类类型 切入点表达式书写技巧 1.按标准规范开发 2.查询操作的返回值建议使用*匹配 3.减少使用..的形式描述包 4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service 5.方法名书写保留动词，例如get，使用*表示名词，例如getById匹配描述为getBy* 6.参数根据实际情况灵活调整 4.3 五种通知类型 前置通知 后置通知 环绕通知（重点） 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用 环绕通知可以隔离原始方法的调用执行 环绕通知返回值设置为Object类型 环绕通知中可以对原始方法调用过程中出现的异常进行处理 返回后通知 抛出异常后通知 ","date":"2023-12-31","objectID":"/spring01/:12:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#4-aop开发总结"},{"categories":["Spring"],"content":" 4 AOP开发总结 4.1 AOP的核心概念 概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式 作用：在不惊动原始设计的基础上为方法进行功能增强 核心概念 代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的 连接点（JoinPoint）： 在SpringAOP中，理解为任意方法的执行 切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述 通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法 切面（Aspect）：描述通知与切入点的对应关系 目标对象（Target）：被代理的原始对象成为目标对象 4.2 切入点表达式语法 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名（参数）异常名) execution(* com.itheima.service.Service.(..)) 切入点表达式描述通配符： 作用：用于快速描述，范围描述 *：匹配任意符号（常用） .. ：匹配多个连续的任意符号（常用） +：匹配子类类型 切入点表达式书写技巧 1.按标准规范开发 2.查询操作的返回值建议使用*匹配 3.减少使用..的形式描述包 4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service 5.方法名书写保留动词，例如get，使用*表示名词，例如getById匹配描述为getBy* 6.参数根据实际情况灵活调整 4.3 五种通知类型 前置通知 后置通知 环绕通知（重点） 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用 环绕通知可以隔离原始方法的调用执行 环绕通知返回值设置为Object类型 环绕通知中可以对原始方法调用过程中出现的异常进行处理 返回后通知 抛出异常后通知 ","date":"2023-12-31","objectID":"/spring01/:12:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#41-aop的核心概念"},{"categories":["Spring"],"content":" 4 AOP开发总结 4.1 AOP的核心概念 概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式 作用：在不惊动原始设计的基础上为方法进行功能增强 核心概念 代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的 连接点（JoinPoint）： 在SpringAOP中，理解为任意方法的执行 切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述 通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法 切面（Aspect）：描述通知与切入点的对应关系 目标对象（Target）：被代理的原始对象成为目标对象 4.2 切入点表达式语法 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名（参数）异常名) execution(* com.itheima.service.Service.(..)) 切入点表达式描述通配符： 作用：用于快速描述，范围描述 *：匹配任意符号（常用） .. ：匹配多个连续的任意符号（常用） +：匹配子类类型 切入点表达式书写技巧 1.按标准规范开发 2.查询操作的返回值建议使用*匹配 3.减少使用..的形式描述包 4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service 5.方法名书写保留动词，例如get，使用*表示名词，例如getById匹配描述为getBy* 6.参数根据实际情况灵活调整 4.3 五种通知类型 前置通知 后置通知 环绕通知（重点） 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用 环绕通知可以隔离原始方法的调用执行 环绕通知返回值设置为Object类型 环绕通知中可以对原始方法调用过程中出现的异常进行处理 返回后通知 抛出异常后通知 ","date":"2023-12-31","objectID":"/spring01/:12:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#42-切入点表达式语法"},{"categories":["Spring"],"content":" 4 AOP开发总结 4.1 AOP的核心概念 概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式 作用：在不惊动原始设计的基础上为方法进行功能增强 核心概念 代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的 连接点（JoinPoint）： 在SpringAOP中，理解为任意方法的执行 切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述 通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法 切面（Aspect）：描述通知与切入点的对应关系 目标对象（Target）：被代理的原始对象成为目标对象 4.2 切入点表达式语法 切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名（参数）异常名) execution(* com.itheima.service.Service.(..)) 切入点表达式描述通配符： 作用：用于快速描述，范围描述 *：匹配任意符号（常用） .. ：匹配多个连续的任意符号（常用） +：匹配子类类型 切入点表达式书写技巧 1.按标准规范开发 2.查询操作的返回值建议使用*匹配 3.减少使用..的形式描述包 4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service 5.方法名书写保留动词，例如get，使用*表示名词，例如getById匹配描述为getBy* 6.参数根据实际情况灵活调整 4.3 五种通知类型 前置通知 后置通知 环绕通知（重点） 环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用 环绕通知可以隔离原始方法的调用执行 环绕通知返回值设置为Object类型 环绕通知中可以对原始方法调用过程中出现的异常进行处理 返回后通知 抛出异常后通知 ","date":"2023-12-31","objectID":"/spring01/:12:4","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#43-五种通知类型"},{"categories":["Spring"],"content":" 十、Spring事务管理","date":"2023-12-31","objectID":"/spring01/:13:0","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#十spring事务管理"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#1-spring事务简介重点"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-29"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#11-spring事务作用"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#12-需求和分析"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#13-代码实现"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#前置工作环境准备-2"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第一步在业务层接口上添加spring事务管理"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第二步设置事务管理器将事务管理器添加到ioc容器中"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第三步开启注解式事务驱动"},{"categories":["Spring"],"content":" 1 Spring事务简介【重点】 问题导入Spring提供的事务管理是数据层的事务还是业务层的事务? 1.1 Spring事务作用 事务作用：在数据层保障一系列的数据库操作同成功同失败 Spring事务作用：在数据层或**==业务层==**保障一系列的数据库操作同成功同失败 1.2 需求和分析 需求：实现任意两个账户间转账操作 需求微缩：A账户减钱，B账户加钱 分析： ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作 结果分析： ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败 1.3 代码实现 【前置工作】环境准备 Spring整合Mybatis相关代码(依赖、JdbcConfig、MybatisConfig、SpringConfig)省略。 public interface AccountDao { @Update(\"update tbl_account set money = money + #{money} where name = #{name}\") void inMoney(@Param(\"name\") String name, @Param(\"money\") Double money); @Update(\"update tbl_account set money = money - #{money} where name = #{name}\") void outMoney(@Param(\"name\") String name, @Param(\"money\") Double money); } public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } 【第一步】在业务层接口上添加Spring事务管理 public interface AccountService { //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } 注意事项 Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合 注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务 【第二步】设置事务管理器(将事务管理器添加到IOC容器中) 说明：可以在JdbcConfig中配置事务管理器 //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager dtm = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } 注意事项 事务管理器要根据实现技术进行选择 MyBatis框架使用的是JDBC事务 【第三步】开启注解式事务驱动 @Configuration @ComponentScan(\"com.itheima\") @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } 【第四步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",100D); } } ","date":"2023-12-31","objectID":"/spring01/:13:1","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第四步运行测试类查看结果"},{"categories":["Spring"],"content":" 2 Spring事务角色【理解】 问题导入什么是事务管理员，什么是事务协调员？ 2.1 Spring事务角色 事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法 事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法 ","date":"2023-12-31","objectID":"/spring01/:13:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#2-spring事务角色理解"},{"categories":["Spring"],"content":" 2 Spring事务角色【理解】 问题导入什么是事务管理员，什么是事务协调员？ 2.1 Spring事务角色 事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法 事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法 ","date":"2023-12-31","objectID":"/spring01/:13:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-30"},{"categories":["Spring"],"content":" 2 Spring事务角色【理解】 问题导入什么是事务管理员，什么是事务协调员？ 2.1 Spring事务角色 事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法 事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法 ","date":"2023-12-31","objectID":"/spring01/:13:2","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#21-spring事务角色"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#3-spring事务相关配置"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#问题导入-31"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#31-事务配置"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#32-案例转账业务追加日志"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#需求和分析"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#准备工作环境整备"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第一步在accountserviceimpl中调用logservice中添加日志的方法"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第二步在logservice的log方法上设置事务的传播行为"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#第三步运行测试类查看结果-2"},{"categories":["Spring"],"content":" 3 Spring事务相关配置 问题导入什么样的异常，Spring事务默认是不进行回滚的？ 3.1 事务配置 说明：对于RuntimeException类型异常或者Error错误，Spring事务能够进行回滚操作。但是对于编译器异常，Spring事务是不进行回滚的，所以需要使用rollbackFor来设置要回滚的异常。 3.2 案例：转账业务追加日志 需求和分析 需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕 需求微缩：A账户减钱，B账户加钱，数据库记录日志 分析： ①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能 实现效果预期： 无论转账操作是否成功，均进行转账操作的日志留痕 存在的问题： 日志的记录与转账操作隶属同一个事务，同成功同失败 实现效果预期改进： 无论转账操作是否成功，日志必须保留 事务传播行为：事务协调员对事务管理员所携带事务的处理态度 【准备工作】环境整备 USE spring_db; CREATE TABLE tbl_log( id INT PRIMARY KEY AUTO_INCREMENT, info VARCHAR(255), createDate DATE ); public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\"转账操作由\"+out+\"到\"+in+\",金额：\"+money); } } public interface LogDao { @Insert(\"insert into tbl_log (info,createDate) values(#{info},now())\") void log(String info); } 【第一步】在AccountServiceImpl中调用logService中添加日志的方法 @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } 【第二步】在LogService的log()方法上设置事务的传播行为 public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) //设置事物回滚异常 @Transactional(rollbackFor={IOException.class}) void log(String out, String in, Double money); } 【第三步】运行测试类，查看结果 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\"Tom\",\"Jerry\",50D); } } 3.3 事务传播行为 ","date":"2023-12-31","objectID":"/spring01/:13:3","series":null,"tags":["Spring"],"title":"Spring01","uri":"/spring01/#33-事务传播行为"},{"categories":["Mybatis"],"content":" 4.2 多表模型一对一操作 一对一模型： 人和身份证，一个人只有一个身份证 步骤： 在Card类要有person属性，得到数据好封装。 返回结果集天然不带有封装类的关系。我们要重新声明结果集。 测试。 代码实现 步骤一: sql语句准备 create database db2; use db2; CREATE TABLE person( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT ); INSERT INTO person VALUES (NULL,'张三',23); INSERT INTO person VALUES (NULL,'李四',24); INSERT INTO person VALUES (NULL,'王五',25); CREATE TABLE card( id INT PRIMARY KEY AUTO_INCREMENT, number VARCHAR(30), pid INT, CONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id) ); INSERT INTO card VALUES (NULL,'12345',1); INSERT INTO card VALUES (NULL,'23456',2); INSERT INTO card VALUES (NULL,'34567',3); 相关实体类： public class Person { private int id; private String name; private int age; //getter \u0026 setter略 } public class Card { private int id; private String number; private int pid; private Person p; //getter \u0026 setter略 } //一对一查询 select * from card c,person p where c.pid = p.id 实体关联属性 配置结果集 测试 步骤二:配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.it ghd.table01.OneToOneMapper\"\u003e \u003c!--配置字段和实体对象属性的映射关系--\u003e \u003cresultMap id=\"oneToOne\" type=\"card\"\u003e \u003c!-- column 数据库列名 property 对象属性名 --\u003e \u003cid column=\"cid\" property=\"id\" /\u003e \u003cresult column=\"number\" property=\"number\" /\u003e \u003c!-- association：配置被包含对象的映射关系 property：被包含对象的变量名 javaType：被包含对象的数据类型 --\u003e \u003cassociation property=\"p\" javaType=\"person\"\u003e \u003cid column=\"pid\" property=\"id\" /\u003e \u003cresult column=\"name\" property=\"name\" /\u003e \u003cresult column=\"age\" property=\"age\" /\u003e \u003c/association\u003e \u003c/resultMap\u003e \u003cselect id=\"selectAll\" resultMap=\"oneToOne\"\u003e SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id \u003c/select\u003e \u003c/mapper\u003e ​ 步骤三：测试类 @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取OneToOneMapper接口的实现类对象 OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class); //5.调用实现类的方法，接收结果 List\u003cCard\u003e list = mapper.selectAll(); //6.处理结果 for (Card c : list) { System.out.println(c); } //7.释放资源 sqlSession.close(); is.close(); } 一对一配置总结: ：配置字段和对象属性的映射关系标签。 id 属性：唯一标识 type 属性：实体对象类型 ：配置主键映射关系标签。 ：配置非主键映射关系标签。 column 属性：表中字段名称 (有别名就是别名的名字) property 属性： 实体对象变量名称 ：配置被包含对象的映射关系标签。 property 属性：被包含对象的变量名 javaType 属性：被包含对象的数据类型 ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:1:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#42-多表模型一对一操作"},{"categories":["Mybatis"],"content":" 4.3 多表模型一对多操作 一对多模型： 一对多模型：班级和学生，一个班级可以有多个学生。 ![image-20210330154023544](D:\\Wechat\\WeChat Files\\wxid_d97ib7s1lsxa22\\FileStorage\\File\\2023-09\\img\\image-20210330154023544.png) 准备资料和步骤： 数据创建两张表：student classes 。创建两个bean实体类。 在班级表中设置学生列表属性。 映射配置文件配置结果集。 测试。 代码实现 sql语句准备 CREATE TABLE classes( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO classes VALUES (NULL,' 一班'); INSERT INTO classes VALUES (NULL,' 二班'); CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), age INT, cid INT, CONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id) ); INSERT INTO student VALUES (NULL,'张三',23,1); INSERT INTO student VALUES (NULL,'李四',24,1); INSERT INTO student VALUES (NULL,'王五',25,2); INSERT INTO student VALUES (NULL,'赵六',26,2); --1对多查询方法 SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid 创建bean文件。 //班级 public class Classes { private Integer id; private String name; private List\u003cStudent\u003e students; //getter/setter略 } //学生 public class Student { private Integer id; private String name; private Integer age; private Integer cid; //getter/setter略 } 创建一个一对多mapper文件，创建一个同名mapper.xml映射文件。 public interface OneToManyMapper { //查询全部 public abstract List\u003cClasses\u003e selectAll(); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.itgaohe.mapper.ClassesMapper\"\u003e \u003cresultMap id=\"oneToMany\" type=\"com.itgaohe.pojo.Classes\"\u003e \u003cid property=\"id\" column=\"cid\"/\u003e \u003cresult property=\"name\" column=\"cname\"/\u003e \u003c!-- collection :集合映射标签 property：实体类中属性名 ofType：集合属性的每一个元素的类型 --\u003e \u003ccollection property=\"students\" ofType=\"com.itgaohe.pojo.Student\"\u003e \u003cid property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"age\" column=\"sage\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e \u003cselect id=\"selectAll\" resultMap=\"oneToMany\"\u003e SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid \u003c/select\u003e \u003c/mapper\u003e 在主配置文件中进行别名、mapper配置。 ![image-20210329153710595](D:\\Wechat\\WeChat Files\\wxid_d97ib7s1lsxa22\\FileStorage\\File\\2023-09\\img\\image-20210329153710595.png) 测试类 @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取OneToManyMapper接口的实现类对象 OneToManyMapper mapper = sqlSession.getMapper(OneToManyMapper.class); //5.调用实现类的方法，接收结果 List\u003cClasses\u003e classes = mapper.selectAll(); //6.处理结果 for (Classes cls : classes) { System.out.println(cls.getId() + \",\" + cls.getName()); List\u003cStudent\u003e students = cls.getStudents(); for (Student student : students) { System.out.println(\"\\t\" + student); } } //7.释放资源 sqlSession.close(); is.close(); } 运行结果： 运行结果为如下： 1，高合一班 Student{sid=1,name='zhangsna',age=15} Student{sid=3,name='赵四',age=34} Student{sid=5,name='小二',age=23} Student{sid=7,name='小七',age=32} 2，高合二班 Student{sid=2,name='王五',age=32} Student{sid=4,name='张三',age=43} Student{sid=6,name='周七2',age=37} 3.一对多配置文件总结： \u003cresultMap\u003e：配置字段和对象属性的映射关系标签。 id 属性：唯一标识 type 属性：实体对象类型 \u003cid\u003e：配置主键映射关系标签。 \u003cresult\u003e：配置非主键映射关系标签。 column 属性：表中字段名称 property 属性： 实体对象变量名称 \u003ccollection\u003e：配置被包含集合对象的映射关系标签。 property 属性：被包含集合对象的变量名 ofType 属性：集合中保存的对象数据类型 tips: 常见问题：属性值问题 数据库名称、bean、映射配置名称在拷贝代码的时候容易不一致 ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:2:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#43-多表模型一对多操作"},{"categories":["Mybatis"],"content":" 4.4 多表模型多对多操作 多对多模型：学生和课程，一个学生可以选择多门课程、一个课程也可以被多个学生所选择。 ![image-20210330160220739](D:\\Wechat\\WeChat Files\\wxid_d97ib7s1lsxa22\\FileStorage\\File\\2023-09\\img\\image-20210330160220739.png) 准备资料和步骤： 数据创建三张表：student\\course\\stu_cr。 创建两个bean文件。 创建一个一对多mapper文件，创建一个同名mapper.xml映射文件。 在主配置文件中进行别名、mapper配置。 开始编写mapper代码及相关功能功能。测试。 代码实现 步骤一: sql语句准备 CREATE TABLE course( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO course VALUES (NULL,'语文'); INSERT INTO course VALUES (NULL,'数学'); CREATE TABLE stu_cr( id INT PRIMARY KEY AUTO_INCREMENT, sid INT, cid INT, CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id) ); INSERT INTO stu_cr VALUES (NULL,1,1); INSERT INTO stu_cr VALUES (NULL,1,2); INSERT INTO stu_cr VALUES (NULL,2,1); INSERT INTO stu_cr VALUES (NULL,2,2); SELECT s.id sid,s.`NAME` sname,c.`NAME` cname FROM student s,stu_cr cr,course c WHERE s.`id` = cr.sid AND cr.cid = c.id 接口方法 步骤二:配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.itgaohe.mapper.StudentMapper\"\u003e \u003cresultMap id=\"manyToMany\" type=\"com.itgaohe.pojo.Student\"\u003e \u003cid column=\"sid\" property=\"id\"/\u003e \u003cresult column=\"sname\" property=\"name\"/\u003e \u003cresult column=\"sage\" property=\"age\"/\u003e \u003ccollection property=\"courses\" ofType=\"com.itgaohe.pojo.Course\"\u003e \u003cid column=\"cid\" property=\"id\"/\u003e \u003cresult column=\"cname\" property=\"name\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e \u003c!-- public List\u003cStudentMapper\u003e selectAll();--\u003e \u003cselect id=\"selectAll\" resultMap=\"manyToMany\"\u003e SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id \u003c/select\u003e \u003c/mapper\u003e 步骤三：测试类 @Test public void selectAll() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取ManyToManyMapper接口的实现类对象 ManyToManyMapper mapper = sqlSession.getMapper(ManyToManyMapper.class); //5.调用实现类的方法，接收结果 List\u003cStudent\u003e students = mapper.selectAll(); //6.处理结果 for (Student student : students) { System.out.println(student.getId() + \",\" + student.getName() + \",\" + student.getAge()); List\u003cCourse\u003e courses = student.getCourses(); for (Course cours : courses) { System.out.println(\"\\t\" + cours); } } //7.释放资源 sqlSession.close(); is.close(); } 运行效果： ![image-20210329212531848](D:\\Wechat\\WeChat Files\\wxid_d97ib7s1lsxa22\\FileStorage\\File\\2023-09\\img\\image-20210329212531848.png) 3.多对多配置文件总结： \u003cresultMap\u003e：配置字段和对象属性的映射关系标签。 id 属性：唯一标识 type 属性：实体对象类型 \u003cid\u003e：配置主键映射关系标签。 \u003cresult\u003e：配置非主键映射关系标签。 column 属性：表中字段名称 property 属性： 实体对象变量名称 \u003ccollection\u003e：配置被包含集合对象的映射关系标签。 property 属性：被包含集合对象的变量名 ofType 属性：集合中保存的对象数据类型 ​ ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:3:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#44-多表模型多对多操作"},{"categories":["Mybatis"],"content":" 4.5 多表模型操作总结 \u003cresultMap\u003e：配置字段和对象属性的映射关系标签。 id 属性：唯一标识 type 属性：实体对象类型 \u003cid\u003e：配置主键映射关系标签。 \u003cresult\u003e：配置非主键映射关系标签。 column 属性：表中字段名称 property 属性： 实体对象变量名称 \u003cassociation\u003e：配置被包含对象的映射关系标签。 property 属性：被包含对象的变量名 javaType 属性：被包含对象的数据类型 \u003ccollection\u003e：配置被包含集合对象的映射关系标签。 property 属性：被包含集合对象的变量名 ofType 属性：集合中保存的对象数据类型 ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:4:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#45-多表模型操作总结"},{"categories":["Mybatis"],"content":" 注解开发略。 注解实现crud。 /*查询*/ @Select(\"select * from student where id = #{id} or name = #{name}\") List\u003cStudent\u003e findbyId(@Param(\"id\") Integer id, @Param(\"name\")String name); /*新增*/ @Options(useGeneratedKeys = true,keyColumn = \"id\" ,keyProperty = \"id\") @Insert(\"insert into student (id,name,age,cid) values(null,#{name},#{age},#{cid})\") void add(Student student); /*修改*/ @Update(\"update student set name = #{name},age= #{age},cid = #{cid} where id = #{id}\") void update(Student student); /*删除*/ @Delete(\"delete from student where id = #{id}\") void delete(Integer id); 注解实现1对1。 @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"number\",column = \"number\"), @Result( property = \"p\", javaType = Person.class, column = \"pid\", one = @One(select = \"com.itgaohe.mapper.PersonMapper.findById\") ) }) @Select(\"select * from card where id = #{id}\") public Card findById(Integer id); @Select(\"select * from person where id = #{id}\") public Person findById(Integer id); 注解实现1对多。 @Results({ @Result(property = \"id\",column = \"id\"), @Result(property = \"name\",column = \"name\"), @Result( property = \"students\",/*实体对象属性名*/ javaType = List.class,/*查询结果封装类型*/ column = \"id\",/*查询参数*/ many = @Many(select = \"com.itgaohe.mapper.StudentMapper.findByCourseId\") ) }) @Select(\"select * from course\") public List\u003cCourse\u003e findById(Integer id); @Select(\"SELECT s.id,s.name,s.age,s.cid FROM student s,stu_cr cr \" + \"WHERE cr.cid = #{id} \" + \"AND cr.sid = s.id\") List\u003cStudent\u003e findByCourseId(Integer id); ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:0:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#注解开发略"},{"categories":["Mybatis"],"content":" 分页查询","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:0:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#分页查询"},{"categories":["Mybatis"],"content":" 三. 分页插件以前我们都是findAll()查询。 问题：数据量一旦大了，查询效率会非常慢。页面展示渲染更需要大量时间。 所以在企业应用中展示条形数据，几乎都是分页。 ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:0:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#三-分页插件"},{"categories":["Mybatis"],"content":" 3.1 分页插件介绍 分页可以将很多条结果进行分页显示。 如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。 需要明确当前是第几页，这一页中显示多少条结果。 MyBatis分页插件总结 在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。 PageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。 ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:1:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#31-分页插件介绍"},{"categories":["Mybatis"],"content":" 3.2 分页插件的使用MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： 导入与PageHelper的jar包 在mybatis核心配置文件中配置PageHelper插件 测试分页数据获取 代码演示： ①导入与PageHelper的jar包 \u003c!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.github.pagehelper\u003c/groupId\u003e \u003cartifactId\u003epagehelper\u003c/artifactId\u003e \u003cversion\u003e5.2.0\u003c/version\u003e \u003c/dependency\u003e ②在mybatis核心配置文件中配置PageHelper插件 \u003c!-- 注意：分页助手的插件 配置在通用mapper之前 --\u003e \u003cplugins\u003e \u003c!-- 分页助手的插件 --\u003e \u003cplugin interceptor=\"com.github.pagehelper.PageInterceptor\"\u003e \u003c/plugin\u003e \u003c/plugins\u003e ③测试分页数据获取 @Test public void testPageHelper(){ //设置分页参数 PageHelper.startPage(1,2); List\u003cUser\u003e select = userMapper2.select(null); for(User user : select){ System.out.println(user); } } ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:2:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#32-分页插件的使用"},{"categories":["Mybatis"],"content":" 3.3 分页插件的参数获取获得分页相关的其他参数： //其他分页的数据 PageInfo\u003cUser\u003e pageInfo = new PageInfo\u003cUser\u003e(select); System.out.println(\"总条数：\"+pageInfo.getTotal()); System.out.println(\"总页数：\"+pageInfo.getPages()); System.out.println(\"当前页：\"+pageInfo.getPageNum()); System.out.println(\"每页显示长度：\"+pageInfo.getPageSize()); System.out.println(\"是否第一页：\"+pageInfo.isIsFirstPage()); System.out.println(\"是否最后一页：\"+pageInfo.isIsLastPage()); 3.2-3.3演示： @Test public void selectPaging() throws Exception{ //1.加载核心配置文件 InputStream is = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); //2.获取SqlSession工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); //3.通过工厂对象获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(true); //4.获取StudentMapper接口的实现类对象 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); //通过分页助手来实现分页功能 // 第一页：显示3条数据 // PageHelper.startPage(1,3); // 第三页：显示3条数据 PageHelper.startPage(3,3); //5.调用实现类的方法，接收结果 List\u003cStudent\u003e list = mapper.selectAll(); //6.处理结果 for (Student student : list) { System.out.println(student); } // //获取分页相关参数 PageInfo\u003cStudent\u003e info = new PageInfo\u003c\u003e(list); System.out.println(\"总条数：\" + info.getTotal()); System.out.println(\"总页数：\" + info.getPages()); System.out.println(\"当前页：\" + info.getPageNum()); System.out.println(\"每页显示条数：\" + info.getPageSize()); System.out.println(\"上一页：\" + info.getPrePage()); System.out.println(\"下一页：\" + info.getNextPage()); System.out.println(\"是否是第一页：\" + info.isIsFirstPage()); System.out.println(\"是否是最后一页：\" + info.isIsLastPage()); //7.释放资源 sqlSession.close(); is.close(); } 演示效果； ![image-20210329140304948](D:\\Wechat\\WeChat Files\\wxid_d97ib7s1lsxa22\\FileStorage\\File\\2023-09\\img\\image-20210329140304948.png) ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:3:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#33-分页插件的参数获取"},{"categories":["Mybatis"],"content":" 3.4 分页插件知识小结​ 分页：可以将很多条结果进行分页显示。 分页插件 jar 包： pagehelper-5.1.10.jar jsqlparser-3.1.jar ：集成插件标签。 分页助手相关 API ​ 1.PageHelper：分页助手功能类。 startPage()：设置分页参数 PageInfo：分页相关参数功能类。 getTotal()：获取总条数 getPages()：获取总页数 getPageNum()：获取当前页 getPageSize()：获取每页显示条数 getPrePage()：获取上一页 getNextPage()：获取下一页 isIsFirstPage()：获取是否是第一页 isIsLastPage()：获取是否是最后一页 ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:4:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#34--分页插件知识小结"},{"categories":["Mybatis"],"content":" 二级缓存一级缓存: ​ 一级缓存基于sqlSession默认开启,在操作数据库时需要构造SqlSession对象，在对象中有一个HashMap用于存储缓存数据。不同的SqlSession之间的缓存数据区域是互相不影响的。 如果SqlSession执行了DML操作（增删改），并且提交到数据库，MyBatis则会清空SqlSession中的一级缓存，这样做的目的是为了保证缓存中存储的是最新的信息，避免出现脏读现象。 sqlSession关闭。 二级缓存 mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 手动开启 面向所有的sqlSession 性能提升（弊大于利） 的区别 二级缓存需要手动打开 打开总开关： 在核心配置文件SqlMapConfig.xml中加入 \u003c !–注意顺序–\u003e \u003c setting name=“cacheEnabled” value=“true”/\u003e @Test public void findAll() { SqlSession sqlSession = MybatisUtils.getSqlSession(); StuMapper mapper = sqlSession.getMapper(StuMapper.class); long start = System.currentTimeMillis(); List\u003cStu\u003e all = mapper.findAll(); long end = System.currentTimeMillis(); System.out.println(\"执行效率：\"+(end-start));//time=2000 long start2 = System.currentTimeMillis(); List\u003cStu\u003e all2 = mapper.findAll(); long end2 = System.currentTimeMillis(); System.out.println(\"执行效率2：\"+(end2-start2));//time=0 sqlSession.close(); } ","date":"2023-12-31","objectID":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/:0:0","series":null,"tags":["Mybatis"],"title":"Mybatis的多表模型","uri":"/mybatis%E7%9A%84%E5%A4%9A%E8%A1%A8%E6%A8%A1%E5%9E%8B/#二级缓存"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include \u003cstring.h\u003e int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include \u003cstring.h\u003e int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include \u003cstring.h\u003e int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include \u003cstring.h\u003e int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include \u003cstring.h\u003e int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include \u003cstdio.h\u003e int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include \u003cstdio.h\u003e int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include \u003cstdio.h\u003e int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include \u003cstdio.h\u003e int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#1-1定义和声明"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#1-2初始化"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#1-3字符串表示"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#1-4访问和操作"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2字符串函数"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2-1strlen计算字符串长度"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2-2strcpy复制字符串"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2-3strcat拼接字符串"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2-4-strcmp比较字符串"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2-5-strstr在字符串中查找子字符串"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2-6-fgets从文件流中读取一行"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2-7-puts输出字符串到控制台"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2-8-fputs将字符串写入文件流"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#2-9-scanf从标准输入读取格式化数据"},{"categories":["C"],"content":"字符数组是 C 语言中的一种数据类型，用于存储一系列字符。字符数组可以用来表示字符串或任何以 null 终止的字符序列。以下是关于字符数组的详细描述： 1-1.定义和声明：字符数组是一个连续的内存块，用于存储字符。它可以通过以下方式定义和声明： char myArray[10]; // 定义一个可以存储 10 个字符的字符数组 这里的 myArray 是字符数组的名称，char 是元素的数据类型，10 是数组的大小。 1-2.初始化：字符数组可以在声明时进行初始化，也可以在后续的代码中逐个字符赋值。例如： char message[20] = \"Hello, world!\"; // 初始化字符数组 或者： char name[10]; name[0] = 'J'; name[1] = 'o'; name[2] = 'h'; // ... 1-3.字符串表示：字符数组常常用来表示字符串。字符串是以 null 终止的字符序列，即以 '\\0'（空字符）作为结束标志。例如： char greeting[] = \"Hello\"; // 自动添加 '\\0' 终止符 1-4.访问和操作：字符数组中的每个字符都有一个对应的索引，从 0 开始。你可以使用索引来访问和修改字符数组中的元素。例如： char word[] = \"apple\"; char firstLetter = word[0]; // 获取第一个字符 'a' word[2] = 'r'; // 修改第三个字符为 'r' 2.字符串函数：C 语言提供了一些处理字符数组和字符串的库函数，例如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（拼接字符串）等。 2-1.strlen（计算字符串长度）：- 功能：返回给定字符串的字符个数（不包括结尾的 null 终止字符）。 - 示例： #include int main() { char str[] = \"Hello, world!\"; int length = strlen(str); // 返回 13 return 0; } 2-2.strcpy（复制字符串）：- 功能：将一个字符串复制到另一个字符串。 - 示例： #include int main() { char source[] = \"Hello\"; char destination[10]; strcpy(destination, source); // 复制 \"Hello\" 到 destination return 0; } 2-3.strcat（拼接字符串）：- 功能：将一个字符串追加到另一个字符串的末尾。 - 示例： #include int main() { char str1[20] = \"Hello, \"; char str2[] = \"world!\"; strcat(str1, str2); // 将 \"world!\" 拼接到 str1 后面 return 0; } 2-4. strcmp（比较字符串）：- 功能：比较两个字符串的大小。 - 示例： #include int main() { char str1[] = \"apple\"; char str2[] = \"banana\"; int result = strcmp(str1, str2); // 返回负值，表示 str1 \u003c str2 return 0; } 2-5. strstr（在字符串中查找子字符串）：- 功能：在一个字符串中查找第一次出现的子字符串。 - 示例： #include int main() { char text[] = \"This is a test.\"; char *substring = strstr(text, \"is\"); // 返回 \"is is a test.\" return 0; } 2-6. fgets（从文件流中读取一行）：- 功能：从文件流中读取一行字符串，包括换行符，并将其存储到指定的字符数组中。 - 语法：char *fgets(char *str, int num, FILE *stream); - 示例： #include int main() { char buffer[100]; FILE *file = fopen(\"input.txt\", \"r\"); // 假设存在 input.txt 文件 if (file != NULL) { fgets(buffer, sizeof(buffer), file); // 从文件中读取一行到 buffer printf(\"Read from file: %s\", buffer); fclose(file); } return 0; } 2-7. puts（输出字符串到控制台）：- 功能：将字符串输出到控制台，并自动添加换行符。 - 语法：int puts(const char *str); - 示例： #include int main() { char message[] = \"Hello, world!\"; puts(message); // 输出 \"Hello, world!\" 并换行 return 0; } 2-8. fputs（将字符串写入文件流）：- 功能：将字符串写入指定的文件流，不会自动添加换行符。 - 语法：int fputs(const char *str, FILE *stream); - 示例： #include int main() { char text[] = \"This is some text.\"; FILE *file = fopen(\"output.txt\", \"w\"); // 创建或覆盖 output.txt 文件 if (file != NULL) { fputs(text, file); // 将字符串写入文件 fclose(file); } return 0; } 2-9. scanf（从标准输入读取格式化数据）：- 功能：从标准输入读取格式化数据，并将其存储到指定的变量中。 - 语法：int scanf(const char *format, ...); - 示例： #include int main() { char name[50]; int age; printf(\"Enter your name and age: \"); scanf(\"%s %d\", name, \u0026age); // 读取字符串和整数 printf(\"Name: %s, Age: %d\\n\", name, age); return 0; } 3.注意事项：- 字符数组的大小应该足够容纳存储的字符，否则可能会导致内存溢出。 - 字符数组在声明时要留出一个额外的位置来存储终止字符 '\\0'。 - 字符数组可以用于存储 ASCII 字符、特殊字符、数字等各种字符。 总之，字符数组是在 C 语言中用于存储字符序列的一种基本数据结构，通常用于表示字符串和处理文本数据。 ","date":"2023-12-31","objectID":"/%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C"],"title":"数组","uri":"/%E6%95%B0%E7%BB%84/#3注意事项"},{"categories":["Web"],"content":"Apache Maven 是一个项目管理和构建工具，它基于项目对象模型(POM)的概念 通过一小段描述信息来管理项目的构建、报告和文档 官网：http://maven.apache.org/ ","date":"2023-12-31","objectID":"/maven/:0:0","series":null,"tags":["Web"],"title":"Maven","uri":"/maven/#"},{"categories":["Web"],"content":" 1.1Maven安装配置 解压 apache-maven-3.6.1.rar 既安装完成 配置环境变量 MAVEN_HOME 为安装路径的bin目录 配置本地仓库：修改 conf/settings.xml 中的 为一个指定目录 配置阿里云私服：修改 conf/settings.xml 中的 标签，为其添加如下子标签： \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e\u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e ","date":"2023-12-31","objectID":"/maven/:0:1","series":null,"tags":["Web"],"title":"Maven","uri":"/maven/#11maven安装配置"},{"categories":["Web"],"content":" 1.2Maven的基本使用 1.2.1Maven的常用命令 compile :编译 clean:清理 test:测试 package:打包 install:安装 1.2.2Maven生命周期 Maven构建项目生命周期描述的是一次构建过程经历经历了多少个事件 Maven对项目构建的生命周期划分为3套 clean:清理工作 default:核心工作，例如编译，测试，打包，安装等 site:产生报告，发布站点等 同一生命周期内，执行后边的命令，前边的所有命令会自动执行 ","date":"2023-12-31","objectID":"/maven/:0:2","series":null,"tags":["Web"],"title":"Maven","uri":"/maven/#12maven的基本使用"},{"categories":["Web"],"content":" 1.2Maven的基本使用 1.2.1Maven的常用命令 compile :编译 clean:清理 test:测试 package:打包 install:安装 1.2.2Maven生命周期 Maven构建项目生命周期描述的是一次构建过程经历经历了多少个事件 Maven对项目构建的生命周期划分为3套 clean:清理工作 default:核心工作，例如编译，测试，打包，安装等 site:产生报告，发布站点等 同一生命周期内，执行后边的命令，前边的所有命令会自动执行 ","date":"2023-12-31","objectID":"/maven/:0:2","series":null,"tags":["Web"],"title":"Maven","uri":"/maven/#121maven的常用命令"},{"categories":["Web"],"content":" 1.2Maven的基本使用 1.2.1Maven的常用命令 compile :编译 clean:清理 test:测试 package:打包 install:安装 1.2.2Maven生命周期 Maven构建项目生命周期描述的是一次构建过程经历经历了多少个事件 Maven对项目构建的生命周期划分为3套 clean:清理工作 default:核心工作，例如编译，测试，打包，安装等 site:产生报告，发布站点等 同一生命周期内，执行后边的命令，前边的所有命令会自动执行 ","date":"2023-12-31","objectID":"/maven/:0:2","series":null,"tags":["Web"],"title":"Maven","uri":"/maven/#122maven生命周期"},{"categories":["Web"],"content":" 1，会话跟踪技术的概述对于会话跟踪这四个词，我们需要拆开来进行解释，首先要理解什么是会话，然后再去理解什么是会话跟踪: 会话:用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含==多次==请求和响应。 从浏览器发出请求到服务端响应数据给前端之后，一次会话(在浏览器和服务器之间)就被建立了 会话被建立后，如果浏览器或服务端都没有被关闭，则会话就会持续建立着 浏览器和服务器就可以继续使用该会话进行请求发送和响应，上述的整个过程就被称之为==会话==。 用实际场景来理解下会话，比如在我们访问京东的时候，当打开浏览器进入京东首页后，浏览器和京东的服务器之间就建立了一次会话，后面的搜索商品,查看商品的详情,加入购物车等都是在这一次会话中完成。 会话跟踪:一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间==共享数据==。 服务器会收到多个请求，这多个请求可能来自多个浏览器，如上图中的6个请求来自3个浏览器 服务器需要用来识别请求是否来自同一个浏览器 服务器用来识别浏览器的过程，这个过程就是==会话跟踪== 服务器识别浏览器后就可以在同一个会话中多次请求之间来共享数据 那么我们又有一个问题需要思考，一个会话中的多次请求为什么要共享数据呢?有了这个数据共享功能后能实现哪些功能呢? 购物车: 加入购物车和去购物车结算是两次请求，但是后面这次请求要想展示前一次请求所添加的商品，就需要用到数据共享。 页面展示用户登录信息:很多网站，登录后访问多个功能发送多次请求后，浏览器上都会有当前登录用户的信息[用户名]，比如百度、京东、码云等。 网站登录页面的记住我功能:当用户登录成功后，勾选记住我按钮后下次再登录的时候，网站就会自动填充用户名和密码，简化用户的登录操作，多次登录就会有多次请求，他们之间也涉及到共享数据 登录页面的验证码功能:生成验证码和输入验证码点击注册这也是两次请求，这两次请求的数据之间要进行对比，相同则允许注册，不同则拒绝注册，该功能的实现也需要在同一次会话中共享数据。 通过这几个例子的讲解，相信大家对会话追踪技术已经有了一定的理解，该技术在实际开发中也非常重要。那么接下来我们就需要去学习下会话跟踪技术，在学习这些技术之前，我们需要思考:为什么现在浏览器和服务器不支持数据共享呢? 浏览器和服务器之间使用的是HTTP请求来进行数据传输 HTTP协议是==无状态==的，每次浏览器向服务器请求时，服务器都会将该请求视为==新的==请求 HTTP协议设计成无状态的目的是让每次请求之间相互独立，互不影响 请求与请求之间独立后，就无法实现多次请求之间的数据共享 分析完具体的原因后，那么该如何实现会话跟踪技术呢? 具体的实现方式有: (1)客户端会话跟踪技术：==Cookie== (2)服务端会话跟踪技术：==Session== 这两个技术都可以实现会话跟踪，它们之间最大的区别:==Cookie是存储在浏览器端而Session是存储在服务器端== 具体的学习思路为: CooKie的基本使用、原理、使用细节 Session的基本使用、原理、使用细节 Cookie和Session的综合案例 小结 在这节中，我们主要介绍了下什么是会话和会话跟踪技术，需要注意的是: HTTP协议是无状态的，靠HTTP协议是无法实现会话跟踪 想要实现会话跟踪，就需要用到Cookie和Session 这个Cookie和Session具体该如何使用，接下来就先从Cookie来学起。 ","date":"2023-12-31","objectID":"/cookie-json/:1:0","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#1会话跟踪技术的概述"},{"categories":["Web"],"content":" 2，Cookie学习Cookie，我们主要解决下面几个问题: 什么是Cookie? Cookie如何来使用? Cookie是如何实现的? Cookie的使用注意事项有哪些? ","date":"2023-12-31","objectID":"/cookie-json/:2:0","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#2cookie"},{"categories":["Web"],"content":" 2.1 Cookie的基本使用1.概念 ==Cookie==：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问。 2.Cookie的工作流程 服务端提供了两个Servlet，分别是ServletA和ServletB 浏览器发送HTTP请求1给服务端，服务端ServletA接收请求并进行业务处理 服务端ServletA在处理的过程中可以创建一个Cookie对象并将name=zs的数据存入Cookie 服务端ServletA在响应数据的时候，会把Cookie对象响应给浏览器 浏览器接收到响应数据，会把Cookie对象中的数据存储在浏览器内存中，此时浏览器和服务端就==建立了一次会话== ==在同一次会话==中浏览器再次发送HTTP请求2给服务端ServletB，浏览器会携带Cookie对象中的所有数据 ServletB接收到请求和数据后，就可以获取到存储在Cookie对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享 3.Cookie的基本使用 对于Cookie的使用，我们更关注的应该是后台代码如何操作Cookie，对于Cookie的操作主要分两大类，本别是==发送Cookie==和==获取Cookie==,对于上面这两块内容，分别该如何实现呢? 3.1 发送Cookie 创建Cookie对象，并设置数据 Cookie cookie = new Cookie(\"key\",\"value\"); 发送Cookie到客户端：使用==response==对象 response.addCookie(cookie); 介绍完发送Cookie对应的步骤后，接下面通过一个案例来完成Cookie的发送，具体实现步骤为: 需求:在Servlet中生成Cookie对象并存入数据，然后将数据发送给浏览器 1.创建Maven项目,项目名称为cookie-demo，并在pom.xml添加依赖 2.编写Servlet类，名称为AServlet 3.在AServlet中创建Cookie对象，存入数据，发送给前端 4.启动测试，在浏览器查看Cookie对象中的值 (1)创建Maven项目cookie-demo，并在pom.xml添加依赖 \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003c!--servlet--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c!--jsp--\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet.jsp\u003c/groupId\u003e \u003cartifactId\u003ejsp-api\u003c/artifactId\u003e \u003cversion\u003e2.2\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c!--jstl--\u003e \u003cdependency\u003e \u003cgroupId\u003ejstl\u003c/groupId\u003e \u003cartifactId\u003ejstl\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003etaglibs\u003c/groupId\u003e \u003cartifactId\u003estandard\u003c/artifactId\u003e \u003cversion\u003e1.1.2\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.tomcat.maven\u003c/groupId\u003e \u003cartifactId\u003etomcat7-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.2\u003c/version\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e (2)编写Servlet类，名称为AServlet @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (3)在Servlet中创建Cookie对象，存入数据，发送给前端 @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie //1. 创建Cookie对象 Cookie cookie = new Cookie(\"username\",\"zs\"); //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } （4）启动测试，在浏览器查看Cookie对象中的值 访问http://localhost:8080/cookie-demo/aServlet chrome浏览器查看Cookie的值，有两种方式,分布式: 方式一: 方式二:选中打开开发者工具或者 使用快捷键F12 或者 Ctrl+Shift+I 3.2 获取Cookie 获取客户端携带的所有Cookie，使用==request==对象 Cookie[] cookies = request.getCookies(); 遍历数组，获取每一个Cookie对象：for 使用Cookie对象方法获取数据 cookie.getName(); cookie.getValue(); 介绍完获取Cookie对应的步骤后，接下面再通过一个案例来完成Cookie的获取，具体实现步骤为: 需求:在Servlet中获取前一个案例存入在Cookie对象中的数据 1.编写一个新Servlet类，名称为BServlet 2.在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值 3.启动测试，在控制台打印出获取的值 (1)编写一个新Servlet类，名称为BServlet @WebServlet(\"/bServlet\") public class BServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } （2）在BServlet中使用request对象获取Cookie数组，遍历数组，从数据中获取指定名称对应的值 @WebServlet(\"/bServlet\") public class BServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取Cookie //1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); //2. 遍历数组 for (Cookie cookie : cookies) { //3. 获取数据 String name = coo","date":"2023-12-31","objectID":"/cookie-json/:2:1","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#21-cookie的基本使用"},{"categories":["Web"],"content":" 2.2 Cookie的原理分析对于Cookie的实现原理是基于HTTP协议的,其中设计到HTTP协议中的两个请求头信息: 响应头:set-cookie 请求头: cookie 前面的案例中已经能够实现，AServlet给前端发送Cookie,BServlet从request中获取Cookie的功能 对于AServlet响应数据的时候，Tomcat服务器都是基于HTTP协议来响应数据 当Tomcat发现后端要返回的是一个Cookie对象之后，Tomcat就会在响应头中添加一行数据==Set-Cookie:username=zs== 浏览器获取到响应结果后，从响应头中就可以获取到Set-Cookie对应值username=zs,并将数据存储在浏览器的内存中 浏览器再次发送请求给BServlet的时候，浏览器会自动在请求头中添加==Cookie: username=zs==发送给服务端BServlet Request对象会把请求头中cookie对应的值封装成一个个Cookie对象，最终形成一个数组 BServlet通过Request对象获取到Cookie[]后，就可以从中获取自己需要的数据 接下来，使用刚才的案例，把上述结论验证下: (1)访问AServlet对应的地址http://localhost:8080/cookie-demo/aServlet 使用Chrom浏览器打开开发者工具(F12或Crtl+Shift+I)进行查看==响应头==中的数据 （2）访问BServlet对应的地址`http://localhost:8080/cookie-demo/bServlet 使用Chrom浏览器打开开发者工具(F12或Crtl+Shift+I)进行查看==请求头==中的数据 ","date":"2023-12-31","objectID":"/cookie-json/:2:2","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#22-cookie的原理分析"},{"categories":["Web"],"content":" 2.3 Cookie的使用细节在这节我们主要讲解两个知识，第一个是Cookie的存活时间，第二个是Cookie如何存储中文，首先来学习下Cookie的存活时间。 2.3.1 Cookie的存活时间前面让大家思考过一个问题: (1)浏览器发送请求给AServlet,AServlet会响应一个存有usernanme=zs的Cookie对象给浏览器 (2)浏览器接收到响应数据将cookie存入到浏览器内存中 (3)当浏览器再次发送请求给BServlet,BServlet就可以使用Request对象获取到Cookie数据 (4)在发送请求到BServlet之前，如果把浏览器关闭再打开进行访问，BServlet能否获取到Cookie数据? ==注意：浏览器关闭再打开不是指打开一个新的选显卡，而且必须是先关闭再打开，顺序不能变。== 针对上面这个问题，通过演示，会发现，BServlet中无法再获取到Cookie数据，这是为什么呢? 默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁 这个结论就印证了上面的演示效果，但是如果使用这种默认情况下的Cookie,有些需求就无法实现，比如: 上面这个网站的登录页面上有一个记住我的功能，这个功能大家都比较熟悉 第一次输入用户名和密码并勾选记住我然后进行登录 下次再登陆的时候，用户名和密码就会被自动填充，不需要再重新输入登录 比如记住我这个功能需要记住用户名和密码一个星期，那么使用默认情况下的Cookie就会出现问题 因为默认情况，浏览器一关，Cookie就会从浏览器内存中删除，对于记住我功能就无法实现 所以我们现在就遇到一个难题是如何将Cookie持久化存储? Cookie其实已经为我们提供好了对应的API来完成这件事，这个API就是==setMaxAge==, 设置Cookie存活时间 setMaxAge(int seconds) 参数值为: 1.正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除 2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁 3.零：删除对应Cookie 接下来，咱们就在AServlet中去设置Cookie的存活时间。 @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie //1. 创建Cookie对象 Cookie cookie = new Cookie(\"username\",\"zs\"); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //易阅读，需程序计算 //cookie.setMaxAge(604800); //不易阅读(可以使用注解弥补)，程序少进行一次计算 //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 修改完代码后，启动测试，访问http://localhost:8080/cookie-demo/aServlet 访问一个AServlet后，把浏览器关闭重启后，再去访问http://localhost:8080/cookie-demo/bServet,能在控制台打印出username:zs,说明Cookie没有随着浏览器关闭而被销毁 通过浏览器查看Cookie的内容，会发现Cookie的相关信息 2.3.2 Cookie存储中文首先，先来演示一个效果，将之前username=zs的值改成username=张三，把汉字张三存入到Cookie中，看是什么效果: @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie String value = \"张三\"; Cookie cookie = new Cookie(\"username\",value); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动访问测试，访问http://localhost:8080/cookie-demo/aServlet会发现浏览器会提示错误信息 通过上面的案例演示，我们得到一个结论: Cookie不能直接存储中文 Cookie不能存储中文，但是如果有这方面的需求，这个时候该如何解决呢? 这个时候，我们可以使用之前学过的一个知识点叫URL编码，所以如果需要存储中文，就需要进行转码，具体的实现思路为: 1.在AServlet中对中文进行URL编码，采用URLEncoder.encode()，将编码后的值存入Cookie中 2.在BServlet中获取Cookie中的值,获取的值为URL编码后的值 3.将获取的值在进行URL解码,采用URLDecoder.decode()，就可以获取到对应的中文值 (1)在AServlet中对中文进行URL编码 @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie String value = \"张三\"; //对中文进行URL编码 value = URLEncoder.encode(value, \"UTF-8\"); System.out.println(\"存储数据：\"+value); //将编码后的值存入Cookie中 Cookie cookie = new Cookie(\"username\",value); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (2)在BServlet中获取值，并对值进行解码 @WebServlet(\"/bServlet\") public class BServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取Cookie //1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); //2. 遍历数组 for (Cookie cookie : cookies) { //3. 获取数据 String name = cookie.getName(); if(\"username\".equals(name)){ String value = cookie.getValue();//获取的是URL编码后的值 %E5%BC%A0%E4%B8%89 //URL解码 value = URLDecoder.decode(value,\"UTF-8\"); System.out.println(name+\":\"+value);//value解码后为 张三 break; } } } @Override protected void doPost(","date":"2023-12-31","objectID":"/cookie-json/:2:3","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#23-cookie的使用细节"},{"categories":["Web"],"content":" 2.3 Cookie的使用细节在这节我们主要讲解两个知识，第一个是Cookie的存活时间，第二个是Cookie如何存储中文，首先来学习下Cookie的存活时间。 2.3.1 Cookie的存活时间前面让大家思考过一个问题: (1)浏览器发送请求给AServlet,AServlet会响应一个存有usernanme=zs的Cookie对象给浏览器 (2)浏览器接收到响应数据将cookie存入到浏览器内存中 (3)当浏览器再次发送请求给BServlet,BServlet就可以使用Request对象获取到Cookie数据 (4)在发送请求到BServlet之前，如果把浏览器关闭再打开进行访问，BServlet能否获取到Cookie数据? ==注意：浏览器关闭再打开不是指打开一个新的选显卡，而且必须是先关闭再打开，顺序不能变。== 针对上面这个问题，通过演示，会发现，BServlet中无法再获取到Cookie数据，这是为什么呢? 默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁 这个结论就印证了上面的演示效果，但是如果使用这种默认情况下的Cookie,有些需求就无法实现，比如: 上面这个网站的登录页面上有一个记住我的功能，这个功能大家都比较熟悉 第一次输入用户名和密码并勾选记住我然后进行登录 下次再登陆的时候，用户名和密码就会被自动填充，不需要再重新输入登录 比如记住我这个功能需要记住用户名和密码一个星期，那么使用默认情况下的Cookie就会出现问题 因为默认情况，浏览器一关，Cookie就会从浏览器内存中删除，对于记住我功能就无法实现 所以我们现在就遇到一个难题是如何将Cookie持久化存储? Cookie其实已经为我们提供好了对应的API来完成这件事，这个API就是==setMaxAge==, 设置Cookie存活时间 setMaxAge(int seconds) 参数值为: 1.正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除 2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁 3.零：删除对应Cookie 接下来，咱们就在AServlet中去设置Cookie的存活时间。 @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie //1. 创建Cookie对象 Cookie cookie = new Cookie(\"username\",\"zs\"); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //易阅读，需程序计算 //cookie.setMaxAge(604800); //不易阅读(可以使用注解弥补)，程序少进行一次计算 //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 修改完代码后，启动测试，访问http://localhost:8080/cookie-demo/aServlet 访问一个AServlet后，把浏览器关闭重启后，再去访问http://localhost:8080/cookie-demo/bServet,能在控制台打印出username:zs,说明Cookie没有随着浏览器关闭而被销毁 通过浏览器查看Cookie的内容，会发现Cookie的相关信息 2.3.2 Cookie存储中文首先，先来演示一个效果，将之前username=zs的值改成username=张三，把汉字张三存入到Cookie中，看是什么效果: @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie String value = \"张三\"; Cookie cookie = new Cookie(\"username\",value); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动访问测试，访问http://localhost:8080/cookie-demo/aServlet会发现浏览器会提示错误信息 通过上面的案例演示，我们得到一个结论: Cookie不能直接存储中文 Cookie不能存储中文，但是如果有这方面的需求，这个时候该如何解决呢? 这个时候，我们可以使用之前学过的一个知识点叫URL编码，所以如果需要存储中文，就需要进行转码，具体的实现思路为: 1.在AServlet中对中文进行URL编码，采用URLEncoder.encode()，将编码后的值存入Cookie中 2.在BServlet中获取Cookie中的值,获取的值为URL编码后的值 3.将获取的值在进行URL解码,采用URLDecoder.decode()，就可以获取到对应的中文值 (1)在AServlet中对中文进行URL编码 @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie String value = \"张三\"; //对中文进行URL编码 value = URLEncoder.encode(value, \"UTF-8\"); System.out.println(\"存储数据：\"+value); //将编码后的值存入Cookie中 Cookie cookie = new Cookie(\"username\",value); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (2)在BServlet中获取值，并对值进行解码 @WebServlet(\"/bServlet\") public class BServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取Cookie //1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); //2. 遍历数组 for (Cookie cookie : cookies) { //3. 获取数据 String name = cookie.getName(); if(\"username\".equals(name)){ String value = cookie.getValue();//获取的是URL编码后的值 %E5%BC%A0%E4%B8%89 //URL解码 value = URLDecoder.decode(value,\"UTF-8\"); System.out.println(name+\":\"+value);//value解码后为 张三 break; } } } @Override protected void doPost(","date":"2023-12-31","objectID":"/cookie-json/:2:3","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#231-cookie的存活时间"},{"categories":["Web"],"content":" 2.3 Cookie的使用细节在这节我们主要讲解两个知识，第一个是Cookie的存活时间，第二个是Cookie如何存储中文，首先来学习下Cookie的存活时间。 2.3.1 Cookie的存活时间前面让大家思考过一个问题: (1)浏览器发送请求给AServlet,AServlet会响应一个存有usernanme=zs的Cookie对象给浏览器 (2)浏览器接收到响应数据将cookie存入到浏览器内存中 (3)当浏览器再次发送请求给BServlet,BServlet就可以使用Request对象获取到Cookie数据 (4)在发送请求到BServlet之前，如果把浏览器关闭再打开进行访问，BServlet能否获取到Cookie数据? ==注意：浏览器关闭再打开不是指打开一个新的选显卡，而且必须是先关闭再打开，顺序不能变。== 针对上面这个问题，通过演示，会发现，BServlet中无法再获取到Cookie数据，这是为什么呢? 默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁 这个结论就印证了上面的演示效果，但是如果使用这种默认情况下的Cookie,有些需求就无法实现，比如: 上面这个网站的登录页面上有一个记住我的功能，这个功能大家都比较熟悉 第一次输入用户名和密码并勾选记住我然后进行登录 下次再登陆的时候，用户名和密码就会被自动填充，不需要再重新输入登录 比如记住我这个功能需要记住用户名和密码一个星期，那么使用默认情况下的Cookie就会出现问题 因为默认情况，浏览器一关，Cookie就会从浏览器内存中删除，对于记住我功能就无法实现 所以我们现在就遇到一个难题是如何将Cookie持久化存储? Cookie其实已经为我们提供好了对应的API来完成这件事，这个API就是==setMaxAge==, 设置Cookie存活时间 setMaxAge(int seconds) 参数值为: 1.正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除 2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁 3.零：删除对应Cookie 接下来，咱们就在AServlet中去设置Cookie的存活时间。 @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie //1. 创建Cookie对象 Cookie cookie = new Cookie(\"username\",\"zs\"); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //易阅读，需程序计算 //cookie.setMaxAge(604800); //不易阅读(可以使用注解弥补)，程序少进行一次计算 //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 修改完代码后，启动测试，访问http://localhost:8080/cookie-demo/aServlet 访问一个AServlet后，把浏览器关闭重启后，再去访问http://localhost:8080/cookie-demo/bServet,能在控制台打印出username:zs,说明Cookie没有随着浏览器关闭而被销毁 通过浏览器查看Cookie的内容，会发现Cookie的相关信息 2.3.2 Cookie存储中文首先，先来演示一个效果，将之前username=zs的值改成username=张三，把汉字张三存入到Cookie中，看是什么效果: @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie String value = \"张三\"; Cookie cookie = new Cookie(\"username\",value); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动访问测试，访问http://localhost:8080/cookie-demo/aServlet会发现浏览器会提示错误信息 通过上面的案例演示，我们得到一个结论: Cookie不能直接存储中文 Cookie不能存储中文，但是如果有这方面的需求，这个时候该如何解决呢? 这个时候，我们可以使用之前学过的一个知识点叫URL编码，所以如果需要存储中文，就需要进行转码，具体的实现思路为: 1.在AServlet中对中文进行URL编码，采用URLEncoder.encode()，将编码后的值存入Cookie中 2.在BServlet中获取Cookie中的值,获取的值为URL编码后的值 3.将获取的值在进行URL解码,采用URLDecoder.decode()，就可以获取到对应的中文值 (1)在AServlet中对中文进行URL编码 @WebServlet(\"/aServlet\") public class AServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //发送Cookie String value = \"张三\"; //对中文进行URL编码 value = URLEncoder.encode(value, \"UTF-8\"); System.out.println(\"存储数据：\"+value); //将编码后的值存入Cookie中 Cookie cookie = new Cookie(\"username\",value); //设置存活时间 ，1周 7天 cookie.setMaxAge(60*60*24*7); //2. 发送Cookie，response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (2)在BServlet中获取值，并对值进行解码 @WebServlet(\"/bServlet\") public class BServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取Cookie //1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); //2. 遍历数组 for (Cookie cookie : cookies) { //3. 获取数据 String name = cookie.getName(); if(\"username\".equals(name)){ String value = cookie.getValue();//获取的是URL编码后的值 %E5%BC%A0%E4%B8%89 //URL解码 value = URLDecoder.decode(value,\"UTF-8\"); System.out.println(name+\":\"+value);//value解码后为 张三 break; } } } @Override protected void doPost(","date":"2023-12-31","objectID":"/cookie-json/:2:3","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#232-cookie存储中文"},{"categories":["Web"],"content":" 3，SessionCookie已经能完成一次会话多次请求之间的数据共享，之前我们还提到过Session也可以实现，那么: 什么是Session? Session如何来使用? Session是如何实现的? Session的使用注意事项有哪些? ","date":"2023-12-31","objectID":"/cookie-json/:3:0","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#3session"},{"categories":["Web"],"content":" 3.1 Session的基本使用1.概念 ==Session==：服务端会话跟踪技术：将数据保存到服务端。 Session是存储在服务端而Cookie是存储在客户端 存储在客户端的数据容易被窃取和截获，存在很多不安全的因素 存储在服务端的数据相比于客户端来说就更安全 2.Session的工作流程 在服务端的AServlet获取一个Session对象，把数据存入其中 在服务端的BServlet获取到相同的Session对象，从中取出数据 就可以实现一次会话中多次请求之间的数据共享了 现在最大的问题是如何保证AServlet和BServlet使用的是同一个Session对象(在原理分析会讲解)? 3.Session的基本使用 在JavaEE中提供了HttpSession接口，来实现一次会话的多次请求之间数据共享功能。 具体的使用步骤为: 获取Session对象,使用的是request对象 HttpSession session = request.getSession(); Session对象提供的功能: 存储数据到 session 域中 void setAttribute(String name, Object o) 根据 key，获取值 Object getAttribute(String name) 根据 key，删除该键值对 void removeAttribute(String name) 介绍完Session相关的API后，接下来通过一个案例来完成对Session的使用，具体实现步骤为: 需求:在一个Servlet中往Session中存入数据，在另一个Servlet中获取Session中存入的数据 1.创建名为SessionDemo1的Servlet类 2.创建名为SessionDemo2的Servlet类 3.在SessionDemo1的方法中:获取Session对象、存储数据 4.在SessionDemo2的方法中:获取Session对象、获取数据 5.启动测试 (1)创建名为SessionDemo1的Servlet类 @WebServlet(\"/demo1\") public class SessionDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (2)创建名为SessionDemo2的Servlet类 @WebServlet(\"/demo2\") public class SessionDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (3)SessionDemo1:获取Session对象、存储数据 @WebServlet(\"/demo1\") public class SessionDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //存储到Session中 //1. 获取Session对象 HttpSession session = request.getSession(); //2. 存储数据 session.setAttribute(\"username\",\"zs\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (4)SessionDemo2:获取Session对象、获取数据 @WebServlet(\"/demo2\") public class SessionDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); //2. 获取数据 Object username = session.getAttribute(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (5)启动测试， 先访问http://localhost:8080/cookie-demo/demo1,将数据存入Session 在访问http://localhost:8080/cookie-demo/demo2,从Session中获取数据 查看控制台 通过案例的效果，能看到Session是能够在一次会话中两次请求之间共享数据。 小结 至此Session的基本使用就已经完成了，重点要掌握的是: Session的获取 HttpSession session = request.getSession(); Session常用方法的使用 void setAttribute(000String name, Object o) Object getAttribute(String name) **注意:**Session中可以存储的是一个Object类型的数据，也就是说Session中可以存储任意数据类型。 介绍完Session的基本使用之后，那么Session的底层到底是如何实现一次会话两次请求之间的数据共享呢? ","date":"2023-12-31","objectID":"/cookie-json/:3:1","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#31-session的基本使用"},{"categories":["Web"],"content":" 3.2 Session的原理分析 Session是基于Cookie实现的 这句话其实不太能详细的说明Session的底层实现，接下来，咱们一步步来分析下Session的具体实现原理: (1)前提条件 Session要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取Session的对象是同一个。 那么它们是一个对象么？要验证这个结论也很简单，只需要在上面案例中的两个Servlet中分别打印下Session对象 SessionDemo1 @WebServlet(\"/demo1\") public class SessionDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //存储到Session中 //1. 获取Session对象 HttpSession session = request.getSession(); System.out.println(session); //2. 存储数据 session.setAttribute(\"username\",\"zs\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } SessionDemo2 @WebServlet(\"/demo2\") public class SessionDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); System.out.println(session); //2. 获取数据 Object username = session.getAttribute(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动测试，分别访问 http://localhost:8080/cookie-demo/demo1 http://localhost:8080/cookie-demo/demo2 通过打印可以得到如下结论: 两个Servlet类中获取的Session对象是同一个 把demo1和demo2请求刷新多次，控制台最终打印的结果都是同一个 那么问题又来了，如果新开一个浏览器，访问demo1或者demo2,打印在控制台的Session还是同一个对象么? ==注意:在一台电脑上演示的时候，如果是相同的浏览器必须要把浏览器全部关掉重新打开，才算新开的一个浏览器。== 当然也可以使用不同的浏览器进行测试，就不需要把之前的浏览器全部关闭。 测试的结果：如果是不同浏览器或者重新打开浏览器后，打印的Session就不一样了。 所以Session实现的也是一次会话中的多次请求之间的数据共享。 那么最主要的问题就来了，Session是如何保证在一次会话中获取的Session对象是同一个呢? (1)demo1在第一次获取session对象的时候，session对象会有一个唯一的标识，假如是id:10 (2)demo1在session中存入其他数据并处理完成所有业务后，需要通过Tomcat服务器响应结果给浏览器 (3)Tomcat服务器发现业务处理中使用了session对象，就会把session的唯一标识id:10当做一个cookie，添加Set-Cookie:JESSIONID=10到响应头中，并响应给浏览器 (4)浏览器接收到响应结果后，会把响应头中的coookie数据存储到浏览器的内存中 (5)浏览器在同一会话中访问demo2的时候，会把cookie中的数据按照cookie: JESSIONID=10的格式添加到请求头中并发送给服务器Tomcat (6)demo2获取到请求后，从请求头中就读取cookie中的JSESSIONID值为10，然后就会到服务器内存中寻找id:10的session对象，如果找到了，就直接返回该对象，如果没有则新创建一个session对象 (7)关闭打开浏览器后，因为浏览器的cookie已被销毁，所以就没有JESSIONID的数据，服务端获取到的session就是一个全新的session对象 至此，Session是基于Cookie来实现的这就话，我们就解释完了，接下来通过实例来演示下: (1)使用chrome浏览器访问http://localhost:8080/cookie-demo/demo1,打开开发者模式(F12或Ctrl+Shift+I),查看==响应头(Response Headers)==数据: (2)使用chrome浏览器再次访问http://localhost:8080/cookie-demo/demo2，查看==请求头(Request Headers)==数据: 小结 介绍完Session的原理，我们只需要记住 Session是基于Cookie来实现的 ","date":"2023-12-31","objectID":"/cookie-json/:3:2","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#32-session的原理分析"},{"categories":["Web"],"content":" 3.3 Session的使用细节这节我们会主要讲解两个知识，第一个是Session的钝化和活化，第二个是Session的销毁，首先来学习什么是Session的钝化和活化？ 3.3.1 Session钝化与活化首先需要大家思考的问题是: 服务器重启后，Session中的数据是否还在? 要想回答这个问题，我们可以先看下下面这幅图， (1)服务器端AServlet和BServlet共用的session对象应该是存储在服务器的内存中 (2)服务器重新启动后，内存中的数据应该是已经被释放，对象也应该都销毁了 所以session数据应该也已经不存在了。但是如果session不存在会引发什么问题呢? 举个例子说明下， (1)用户把需要购买的商品添加到购物车，因为要实现同一个会话多次请求数据共享，所以假设把数据存入Session对象中 (2)用户正要付钱的时候接到一个电话，付钱的动作就搁浅了 (3)正在用户打电话的时候，购物网站因为某些原因需要重启 (4)重启后session数据被销毁，购物车中的商品信息也就会随之而消失 (5)用户想再次发起支付，就会出为问题 所以说对于session的数据，我们应该做到就算服务器重启了，也应该能把数据保存下来才对。 分析了这么多，那么Tomcat服务器在重启的时候，session数据到底会不会保存以及是如何保存的，我们可以通过实际案例来演示下: ==注意:这里所说的关闭和启动应该要确保是正常的关闭和启动。== 那如何才是正常关闭Tomcat服务器呢? 需要使用命令行的方式来启动和停止Tomcat服务器: ==启动==:进入到项目pom.xml所在目录，执行tomcat7:run ==停止==:在启动的命令行界面，输入ctrl+c 有了上述两个正常启动和关闭的方式后，接下来的测试流程是: (1)先启动Tomcat服务器 (2)访问http://localhost:8080/cookie-demo/demo1将数据存入session中 (3)正确停止Tomcat服务器 (4)再次重新启动Tomcat服务器 (5)访问http://localhost:8080/cookie-demo/demo2 查看是否能获取到session中的数据 经过测试，会发现只要服务器是正常关闭和启动，session中的数据是可以被保存下来的。 那么Tomcat服务器到底是如何做到的呢? 具体的原因就是:Session的钝化和活化: 钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中 钝化的数据路径为:项目目录\\target\\tomcat\\work\\Tomcat\\localhost\\项目名称\\SESSIONS.ser 活化：再次启动服务器后，从文件中加载数据到Session中 数据加载到Session中后，路径中的SESSIONS.ser文件会被删除掉 对于上述的整个过程，大家只需要了解下即可。因为所有的过程都是Tomcat自己完成的，不需要我们参与。 小结 Session的钝化和活化介绍完后，需要我们注意的是: session数据存储在服务端，服务器重启后，session数据会被保存 浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的session数据也是一个新的对象 session的数据要想共享，浏览器不能关闭，所以session数据不能长期保存数据 cookie是存储在客户端，是可以长期保存 3.3.2 Session销毁session的销毁会有两种方式: 默认情况下，无操作，30分钟自动销毁 对于这个失效时间，是可以通过配置进行修改的 在项目的web.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"\u003e \u003csession-config\u003e \u003csession-timeout\u003e100\u003c/session-timeout\u003e \u003c/session-config\u003e \u003c/web-app\u003e 如果没有配置，默认是30分钟，默认值是在Tomcat的web.xml配置文件中写死的 调用Session对象的invalidate()进行销毁 在SessionDemo2类中添加session销毁的方法 @WebServlet(\"/demo2\") public class SessionDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); System.out.println(session); // 销毁 session.invalidate(); //2. 获取数据 Object username = session.getAttribute(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动访问测试，先访问demo1将数据存入到session，再次访问demo2从session中获取数据 该销毁方法一般会在用户退出的时候，需要将session销毁掉。 Cookie和Session小结 Cookie 和 Session 都是来完成一次会话内多次请求间==数据共享==的。 所需两个对象放在一块，就需要思考: Cookie和Session的区别是什么? Cookie和Session的应用场景分别是什么? 区别: 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端 安全性：Cookie不安全，Session安全 数据大小：Cookie最大3KB，Session无大小限制 存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟 服务器性能：Cookie不占服务器资源，Session占用服务器资源 应用场景: 购物车:使用Cookie来存储 以登录用户的名称展示:使用Session来存储 记住我功能:使用Cookie来存储 验证码:使用session来存储 结论 Cookie是用来保证用户在未登录情况下的身份识别 Session是用来保存用户登录后的数据 介绍完Cookie和Session以后，具体用哪个还是需要根据具体的业务进行具体分析。 ","date":"2023-12-31","objectID":"/cookie-json/:3:3","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#33-session的使用细节"},{"categories":["Web"],"content":" 3.3 Session的使用细节这节我们会主要讲解两个知识，第一个是Session的钝化和活化，第二个是Session的销毁，首先来学习什么是Session的钝化和活化？ 3.3.1 Session钝化与活化首先需要大家思考的问题是: 服务器重启后，Session中的数据是否还在? 要想回答这个问题，我们可以先看下下面这幅图， (1)服务器端AServlet和BServlet共用的session对象应该是存储在服务器的内存中 (2)服务器重新启动后，内存中的数据应该是已经被释放，对象也应该都销毁了 所以session数据应该也已经不存在了。但是如果session不存在会引发什么问题呢? 举个例子说明下， (1)用户把需要购买的商品添加到购物车，因为要实现同一个会话多次请求数据共享，所以假设把数据存入Session对象中 (2)用户正要付钱的时候接到一个电话，付钱的动作就搁浅了 (3)正在用户打电话的时候，购物网站因为某些原因需要重启 (4)重启后session数据被销毁，购物车中的商品信息也就会随之而消失 (5)用户想再次发起支付，就会出为问题 所以说对于session的数据，我们应该做到就算服务器重启了，也应该能把数据保存下来才对。 分析了这么多，那么Tomcat服务器在重启的时候，session数据到底会不会保存以及是如何保存的，我们可以通过实际案例来演示下: ==注意:这里所说的关闭和启动应该要确保是正常的关闭和启动。== 那如何才是正常关闭Tomcat服务器呢? 需要使用命令行的方式来启动和停止Tomcat服务器: ==启动==:进入到项目pom.xml所在目录，执行tomcat7:run ==停止==:在启动的命令行界面，输入ctrl+c 有了上述两个正常启动和关闭的方式后，接下来的测试流程是: (1)先启动Tomcat服务器 (2)访问http://localhost:8080/cookie-demo/demo1将数据存入session中 (3)正确停止Tomcat服务器 (4)再次重新启动Tomcat服务器 (5)访问http://localhost:8080/cookie-demo/demo2 查看是否能获取到session中的数据 经过测试，会发现只要服务器是正常关闭和启动，session中的数据是可以被保存下来的。 那么Tomcat服务器到底是如何做到的呢? 具体的原因就是:Session的钝化和活化: 钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中 钝化的数据路径为:项目目录\\target\\tomcat\\work\\Tomcat\\localhost\\项目名称\\SESSIONS.ser 活化：再次启动服务器后，从文件中加载数据到Session中 数据加载到Session中后，路径中的SESSIONS.ser文件会被删除掉 对于上述的整个过程，大家只需要了解下即可。因为所有的过程都是Tomcat自己完成的，不需要我们参与。 小结 Session的钝化和活化介绍完后，需要我们注意的是: session数据存储在服务端，服务器重启后，session数据会被保存 浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的session数据也是一个新的对象 session的数据要想共享，浏览器不能关闭，所以session数据不能长期保存数据 cookie是存储在客户端，是可以长期保存 3.3.2 Session销毁session的销毁会有两种方式: 默认情况下，无操作，30分钟自动销毁 对于这个失效时间，是可以通过配置进行修改的 在项目的web.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 100 如果没有配置，默认是30分钟，默认值是在Tomcat的web.xml配置文件中写死的 调用Session对象的invalidate()进行销毁 在SessionDemo2类中添加session销毁的方法 @WebServlet(\"/demo2\") public class SessionDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); System.out.println(session); // 销毁 session.invalidate(); //2. 获取数据 Object username = session.getAttribute(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动访问测试，先访问demo1将数据存入到session，再次访问demo2从session中获取数据 该销毁方法一般会在用户退出的时候，需要将session销毁掉。 Cookie和Session小结 Cookie 和 Session 都是来完成一次会话内多次请求间==数据共享==的。 所需两个对象放在一块，就需要思考: Cookie和Session的区别是什么? Cookie和Session的应用场景分别是什么? 区别: 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端 安全性：Cookie不安全，Session安全 数据大小：Cookie最大3KB，Session无大小限制 存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟 服务器性能：Cookie不占服务器资源，Session占用服务器资源 应用场景: 购物车:使用Cookie来存储 以登录用户的名称展示:使用Session来存储 记住我功能:使用Cookie来存储 验证码:使用session来存储 结论 Cookie是用来保证用户在未登录情况下的身份识别 Session是用来保存用户登录后的数据 介绍完Cookie和Session以后，具体用哪个还是需要根据具体的业务进行具体分析。 ","date":"2023-12-31","objectID":"/cookie-json/:3:3","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#331-session钝化与活化"},{"categories":["Web"],"content":" 3.3 Session的使用细节这节我们会主要讲解两个知识，第一个是Session的钝化和活化，第二个是Session的销毁，首先来学习什么是Session的钝化和活化？ 3.3.1 Session钝化与活化首先需要大家思考的问题是: 服务器重启后，Session中的数据是否还在? 要想回答这个问题，我们可以先看下下面这幅图， (1)服务器端AServlet和BServlet共用的session对象应该是存储在服务器的内存中 (2)服务器重新启动后，内存中的数据应该是已经被释放，对象也应该都销毁了 所以session数据应该也已经不存在了。但是如果session不存在会引发什么问题呢? 举个例子说明下， (1)用户把需要购买的商品添加到购物车，因为要实现同一个会话多次请求数据共享，所以假设把数据存入Session对象中 (2)用户正要付钱的时候接到一个电话，付钱的动作就搁浅了 (3)正在用户打电话的时候，购物网站因为某些原因需要重启 (4)重启后session数据被销毁，购物车中的商品信息也就会随之而消失 (5)用户想再次发起支付，就会出为问题 所以说对于session的数据，我们应该做到就算服务器重启了，也应该能把数据保存下来才对。 分析了这么多，那么Tomcat服务器在重启的时候，session数据到底会不会保存以及是如何保存的，我们可以通过实际案例来演示下: ==注意:这里所说的关闭和启动应该要确保是正常的关闭和启动。== 那如何才是正常关闭Tomcat服务器呢? 需要使用命令行的方式来启动和停止Tomcat服务器: ==启动==:进入到项目pom.xml所在目录，执行tomcat7:run ==停止==:在启动的命令行界面，输入ctrl+c 有了上述两个正常启动和关闭的方式后，接下来的测试流程是: (1)先启动Tomcat服务器 (2)访问http://localhost:8080/cookie-demo/demo1将数据存入session中 (3)正确停止Tomcat服务器 (4)再次重新启动Tomcat服务器 (5)访问http://localhost:8080/cookie-demo/demo2 查看是否能获取到session中的数据 经过测试，会发现只要服务器是正常关闭和启动，session中的数据是可以被保存下来的。 那么Tomcat服务器到底是如何做到的呢? 具体的原因就是:Session的钝化和活化: 钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中 钝化的数据路径为:项目目录\\target\\tomcat\\work\\Tomcat\\localhost\\项目名称\\SESSIONS.ser 活化：再次启动服务器后，从文件中加载数据到Session中 数据加载到Session中后，路径中的SESSIONS.ser文件会被删除掉 对于上述的整个过程，大家只需要了解下即可。因为所有的过程都是Tomcat自己完成的，不需要我们参与。 小结 Session的钝化和活化介绍完后，需要我们注意的是: session数据存储在服务端，服务器重启后，session数据会被保存 浏览器被关闭启动后，重新建立的连接就已经是一个全新的会话，获取的session数据也是一个新的对象 session的数据要想共享，浏览器不能关闭，所以session数据不能长期保存数据 cookie是存储在客户端，是可以长期保存 3.3.2 Session销毁session的销毁会有两种方式: 默认情况下，无操作，30分钟自动销毁 对于这个失效时间，是可以通过配置进行修改的 在项目的web.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 100 如果没有配置，默认是30分钟，默认值是在Tomcat的web.xml配置文件中写死的 调用Session对象的invalidate()进行销毁 在SessionDemo2类中添加session销毁的方法 @WebServlet(\"/demo2\") public class SessionDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取数据，从session中 //1. 获取Session对象 HttpSession session = request.getSession(); System.out.println(session); // 销毁 session.invalidate(); //2. 获取数据 Object username = session.getAttribute(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动访问测试，先访问demo1将数据存入到session，再次访问demo2从session中获取数据 该销毁方法一般会在用户退出的时候，需要将session销毁掉。 Cookie和Session小结 Cookie 和 Session 都是来完成一次会话内多次请求间==数据共享==的。 所需两个对象放在一块，就需要思考: Cookie和Session的区别是什么? Cookie和Session的应用场景分别是什么? 区别: 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端 安全性：Cookie不安全，Session安全 数据大小：Cookie最大3KB，Session无大小限制 存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟 服务器性能：Cookie不占服务器资源，Session占用服务器资源 应用场景: 购物车:使用Cookie来存储 以登录用户的名称展示:使用Session来存储 记住我功能:使用Cookie来存储 验证码:使用session来存储 结论 Cookie是用来保证用户在未登录情况下的身份识别 Session是用来保存用户登录后的数据 介绍完Cookie和Session以后，具体用哪个还是需要根据具体的业务进行具体分析。 ","date":"2023-12-31","objectID":"/cookie-json/:3:3","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#332-session销毁"},{"categories":["Web"],"content":" 4，用户登录注册案例","date":"2023-12-31","objectID":"/cookie-json/:4:0","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#4用户登录注册案例"},{"categories":["Web"],"content":" 4.1 需求分析需求说明： 完成用户登录功能，如果用户勾选“记住用户” ，则下次访问登录页面==自动==填充用户名密码 完成注册功能，并实现==验证码==功能 ","date":"2023-12-31","objectID":"/cookie-json/:4:1","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#41-需求分析"},{"categories":["Web"],"content":" 4.2 用户登录功能 需求: 用户登录成功后，跳转到列表页面，并在页面上展示当前登录的用户名称 用户登录失败后，跳转回登录页面，并在页面上展示对应的错误信息 实现流程分析 (1)前端通过表单发送请求和数据给Web层的LoginServlet (2)在LoginServlet中接收请求和数据[用户名和密码] (3)LoginServlet接收到请求和数据后，调用Service层完成根据用户名和密码查询用户对象 (4)在Service层需要编写UserService类，在类中实现login方法，方法中调用Dao层的UserMapper (5)在UserMapper接口中，声明一个根据用户名和密码查询用户信息的方法 (6)Dao层把数据查询出来以后，将返回数据封装到User对象，将对象交给Service层 (7)Service层将数据返回给Web层 (8)Web层获取到User对象后，判断User对象，如果为Null,则将错误信息响应给登录页面，如果不为Null，则跳转到列表页面，并把当前登录用户的信息存入Session携带到列表页面。 具体实现 (1)完成Dao层的代码编写 (1.1)将04-资料\\1. 登录注册案例\\2. MyBatis环境\\UserMapper.java放到com.itheima.mapper`包下: public interface UserMapper { /** * 根据用户名和密码查询用户对象 * @param username * @param password * @return */ @Select(\"select * from tb_user where username = #{username} and password = #{password}\") User select(@Param(\"username\") String username,@Param(\"password\") String password); /** * 根据用户名查询用户对象 * @param username * @return */ @Select(\"select * from tb_user where username = #{username}\") User selectByUsername(String username); /** * 添加用户 * @param user */ @Insert(\"insert into tb_user values(null,#{username},#{password})\") void add(User user); } (1.2)将04-资料\\1. 登录注册案例\\2. MyBatis环境\\User.java放到com.itheima.pojo包下: public class User { private Integer id; private String username; private String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } (1.3)将04-资料\\1. 登录注册案例\\2. MyBatis环境\\UserMapper.xml放入到resources/com/itheima/mapper`目录下: \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.itheima.mapper.UserMapper\"\u003e \u003c/mapper\u003e (2)完成Service层的代码编写 (2.1)在com.itheima.service包下，创建UserService类 public class UserService { //1.使用工具类获取SqlSessionFactory SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory(); /** * 登录方法 * @param username * @param password * @return */ public User login(String username,String password){ //2. 获取SqlSession SqlSession sqlSession = factory.openSession(); //3. 获取UserMapper UserMapper mapper = sqlSession.getMapper(UserMapper.class); //4. 调用方法 User user = mapper.select(username, password); //释放资源 sqlSession.close(); return user; } } (3)完成页面和Web层的代码编写 (3.1)将04-资料\\1. 登录注册案例\\1. 静态页面拷贝到项目的webapp目录下: (3.2)将login.html内容修改成login.jsp \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elogin\u003c/title\u003e \u003clink href=\"css/login.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"loginDiv\" style=\"height: 350px\"\u003e \u003cform action=\"/brand-demo/loginServlet\" method=\"post\" id=\"form\"\u003e \u003ch1 id=\"loginMsg\"\u003eLOGIN IN\u003c/h1\u003e \u003cdiv id=\"errorMsg\"\u003e用户名或密码不正确\u003c/div\u003e \u003cp\u003eUsername:\u003cinput id=\"username\" name=\"username\" type=\"text\"\u003e\u003c/p\u003e \u003cp\u003ePassword:\u003cinput id=\"password\" name=\"password\" type=\"password\"\u003e\u003c/p\u003e \u003cp\u003eRemember:\u003cinput id=\"remember\" name=\"remember\" type=\"checkbox\"\u003e\u003c/p\u003e \u003cdiv id=\"subDiv\"\u003e \u003cinput type=\"submit\" class=\"button\" value=\"login up\"\u003e \u003cinput type=\"reset\" class=\"button\" value=\"reset\"\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp; \u003ca href=\"register.html\"\u003e没有账号？\u003c/a\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e (3.3)创建LoginServlet类 @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { private UserService service = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 获取用户名和密码 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); //2. 调用service查询 User user = service.login(username, password); //3. 判断 if(user != null){ //登录成功，跳转到查询所有的BrandServlet //将登陆成功后","date":"2023-12-31","objectID":"/cookie-json/:4:2","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#42-用户登录功能"},{"categories":["Web"],"content":" 4.3 记住我-设置Cookie 需求: 如果用户勾选“记住用户” ，则下次访问登陆页面自动填充用户名密码。这样可以提升用户的体验。 对应上面这个需求，最大的问题就是: 如何自动填充用户名和密码? 实现流程分析 因为记住我功能要实现的效果是，就算用户把浏览器关闭过几天再来访问也能自动填充，所以需要将登陆信息存入一个可以长久保存，并且能够在浏览器关闭重新启动后依然有效的地方，就是我们前面讲的==Cookie==,所以: 将用户名和密码写入==Cookie==中，并且持久化存储Cookie,下次访问浏览器会自动携带Cookie 在页面获取Cookie数据后，设置到用户名和密码框中 何时写入Cookie? 用户必须登陆成功后才需要写 用户必须在登录页面勾选了记住我的复选框 (1)前端需要在发送请求和数据的时候，多携带一个用户是否勾选Remember的数据 (2)LoginServlet获取到数据后，调用Service完成用户名和密码的判定 (3)登录成功，并且用户在前端勾选了记住我，需要往Cookie中写入用户名和密码的数据，并设置Cookie存活时间 (4)设置成功后，将数据响应给前端 具体实现 (1)在login.jsp为复选框设置值 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elogin\u003c/title\u003e \u003clink href=\"css/login.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"loginDiv\" style=\"height: 350px\"\u003e \u003cform action=\"/brand-demo/loginServlet\" method=\"post\" id=\"form\"\u003e \u003ch1 id=\"loginMsg\"\u003eLOGIN IN\u003c/h1\u003e \u003cdiv id=\"errorMsg\"\u003e${login_msg}\u003c/div\u003e \u003cp\u003eUsername:\u003cinput id=\"username\" name=\"username\" type=\"text\"\u003e\u003c/p\u003e \u003cp\u003ePassword:\u003cinput id=\"password\" name=\"password\" type=\"password\"\u003e\u003c/p\u003e \u003cp\u003eRemember:\u003cinput id=\"remember\" name=\"remember\" value=\"1\" type=\"checkbox\"\u003e\u003c/p\u003e \u003cdiv id=\"subDiv\"\u003e \u003cinput type=\"submit\" class=\"button\" value=\"login up\"\u003e \u003cinput type=\"reset\" class=\"button\" value=\"reset\"\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp; \u003ca href=\"register.html\"\u003e没有账号？\u003c/a\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e (2)在LoginServlet获取复选框的值并在登录成功后进行设置Cookie @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { private UserService service = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 获取用户名和密码 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); //获取复选框数据 String remember = request.getParameter(\"remember\"); //2. 调用service查询 User user = service.login(username, password); //3. 判断 if(user != null){ //登录成功，跳转到查询所有的BrandServlet //判断用户是否勾选记住我，字符串写前面是为了避免出现空指针异常 if(\"1\".equals(remember)){ //勾选了，发送Cookie //1. 创建Cookie对象 Cookie c_username = new Cookie(\"username\",username); Cookie c_password = new Cookie(\"password\",password); // 设置Cookie的存活时间 c_username.setMaxAge( 60 * 60 * 24 * 7); c_password.setMaxAge( 60 * 60 * 24 * 7); //2. 发送 response.addCookie(c_username); response.addCookie(c_password); } //将登陆成功后的user对象，存储到session HttpSession session = request.getSession(); session.setAttribute(\"user\",user); String contextPath = request.getContextPath(); response.sendRedirect(contextPath+\"/selectAllServlet\"); }else { // 登录失败, // 存储错误信息到request request.setAttribute(\"login_msg\",\"用户名或密码错误\"); // 跳转到login.jsp request.getRequestDispatcher(\"/login.jsp\").forward(request,response); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (3)启动访问测试， 只有当前用户名和密码输入正确，并且勾选了Remeber的复选框，在响应头中才可以看得cookie的相关数据 ","date":"2023-12-31","objectID":"/cookie-json/:4:3","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#43-记住我-设置cookie"},{"categories":["Web"],"content":" 4.4 记住我-获取Cookie 需求 登录成功并勾选了Remeber后，后端返回给前端的Cookie数据就已经存储好了，接下来就需要在页面获取Cookie中的数据，并把数据设置到登录页面的用户名和密码框中。 如何在页面直接获取Cookie中的值呢? 实现流程分析 在页面可以使用EL表达式，${cookie.==key==.value} key:指的是存储在cookie中的键名称 (1)在login.jsp用户名的表单输入框使用value值给表单元素添加默认值，value可以使用${cookie.username.value} (2)在login.jsp密码的表单输入框使用value值给表单元素添加默认值，value可以使用${cookie.password.value} 具体实现 (1)修改login.jsp页面 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elogin\u003c/title\u003e \u003clink href=\"css/login.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"loginDiv\" style=\"height: 350px\"\u003e \u003cform action=\"/brand-demo/loginServlet\" method=\"post\" id=\"form\"\u003e \u003ch1 id=\"loginMsg\"\u003eLOGIN IN\u003c/h1\u003e \u003cdiv id=\"errorMsg\"\u003e${login_msg}\u003c/div\u003e \u003cp\u003eUsername:\u003cinput id=\"username\" name=\"username\" value=\"${cookie.username.value}\" type=\"text\"\u003e\u003c/p\u003e \u003cp\u003ePassword:\u003cinput id=\"password\" name=\"password\" value=\"${cookie.password.value}\" type=\"password\"\u003e\u003c/p\u003e \u003cp\u003eRemember:\u003cinput id=\"remember\" name=\"remember\" value=\"1\" type=\"checkbox\"\u003e\u003c/p\u003e \u003cdiv id=\"subDiv\"\u003e \u003cinput type=\"submit\" class=\"button\" value=\"login up\"\u003e \u003cinput type=\"reset\" class=\"button\" value=\"reset\"\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp; \u003ca href=\"register.html\"\u003e没有账号？\u003c/a\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 访问测试，重新访问登录页面，就可以看得用户和密码已经被填充。 ","date":"2023-12-31","objectID":"/cookie-json/:4:4","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#44-记住我-获取cookie"},{"categories":["Web"],"content":" 4.5 用户注册功能 需求 注册功能：保存用户信息到数据库 验证码功能 展示验证码：展示验证码图片，并可以点击切换 校验验证码：验证码填写不正确，则注册失败 实现流程分析 (1)前端通过表单发送请求和数据给Web层的RegisterServlet (2)在RegisterServlet中接收请求和数据[用户名和密码] (3)RegisterServlet接收到请求和数据后，调用Service层完成用户信息的保存 (4)在Service层需要编写UserService类，在类中实现register方法，需要判断用户是否已经存在，如果不存在，则完成用户数据的保存 (5)在UserMapper接口中，声明两个方法，一个是根据用户名查询用户信息方法，另一个是保存用户信息方法 (6)在UserService类中保存成功则返回true，失败则返回false,将数据返回给Web层 (7)Web层获取到结果后，如果返回的是true,则提示注册成功，并转发到登录页面，如果返回false则提示用户名已存在并转发到注册页面 具体实现 (1)Dao层代码参考资料中的内容完成 (2)编写Service层代码 public class UserService { //1.使用工具类获取SqlSessionFactory SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory(); /** * 注册方法 * @return */ public boolean register(User user){ //2. 获取SqlSession SqlSession sqlSession = factory.openSession(); //3. 获取UserMapper UserMapper mapper = sqlSession.getMapper(UserMapper.class); //4. 判断用户名是否存在 User u = mapper.selectByUsername(user.getUsername()); if(u == null){ // 用户名不存在，注册 mapper.add(user); sqlSession.commit(); } sqlSession.close(); return u == null; } } (3)完成页面和Web层的代码编写 (3.1)将register.html内容修改成register.jsp \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e欢迎注册\u003c/title\u003e \u003clink href=\"css/register.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"form-div\"\u003e \u003cdiv class=\"reg-content\"\u003e \u003ch1\u003e欢迎注册\u003c/h1\u003e \u003cspan\u003e已有帐号？\u003c/span\u003e \u003ca href=\"login.html\"\u003e登录\u003c/a\u003e \u003c/div\u003e \u003cform id=\"reg-form\" action=\"/brand-demo/registerServlet\" method=\"post\"\u003e \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e用户名\u003c/td\u003e \u003ctd class=\"inputs\"\u003e \u003cinput name=\"username\" type=\"text\" id=\"username\"\u003e \u003cbr\u003e \u003cspan id=\"username_err\" class=\"err_msg\" style=\"display:none\"\u003e用户名不太受欢迎\u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e密码\u003c/td\u003e \u003ctd class=\"inputs\"\u003e \u003cinput name=\"password\" type=\"password\" id=\"password\"\u003e \u003cbr\u003e \u003cspan id=\"password_err\" class=\"err_msg\" style=\"display: none\"\u003e密码格式有误\u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e验证码\u003c/td\u003e \u003ctd class=\"inputs\"\u003e \u003cinput name=\"checkCode\" type=\"text\" id=\"checkCode\"\u003e \u003cimg src=\"imgs/a.jpg\"\u003e \u003ca href=\"#\" id=\"changeImg\" \u003e看不清？\u003c/a\u003e \u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003cdiv class=\"buttons\"\u003e \u003cinput value=\"注 册\" type=\"submit\" id=\"reg_btn\"\u003e \u003c/div\u003e \u003cbr class=\"clear\"\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e (3.2)编写RegisterServlet @WebServlet(\"/registerServlet\") public class RegisterServlet extends HttpServlet { private UserService service = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 获取用户名和密码数据 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); User user = new User(); user.setUsername(username); user.setPassword(password); //2. 调用service 注册 boolean flag = service.register(user); //3. 判断注册成功与否 if(flag){ //注册功能，跳转登陆页面 request.setAttribute(\"register_msg\",\"注册成功，请登录\"); request.getRequestDispatcher(\"/login.jsp\").forward(request,response); }else { //注册失败，跳转到注册页面 request.setAttribute(\"register_msg\",\"用户名已存在\"); request.getRequestDispatcher(\"/register.jsp\").forward(request,response); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (3.3)需要在页面上展示后台返回的错误信息，需要修改register.jsp 修改前:\u003cspan id=\"username_err\" class=\"err_msg\" style=\"display:none\"\u003e用户名不太受欢迎\u003c/span\u003e 修改后:\u003cspan id=\"username_err\" class=\"err_msg\"\u003e${register_msg}\u003c/span\u003e (3.4)如果注册成功，需要把成功信息展示在登录页面，所以也需要修改login.jsp 修改前:\u003cdiv id=\"errorMsg\"\u003e${login_msg}\u003c/div\u003e 修改后:\u003cdiv id=\"errorMsg\"\u003e${login_msg} ${register_msg}\u003c/div\u003e (3.5)修改login.jsp，将注册跳转地址修改为register.jsp 修改前：\u003ca href=\"register.html\"\u003e没有账号？\u003c/a\u003e 修改后: \u003ca href=\"register.jsp\"\u003e没有账号？\u003c/a\u003e (3.6)启动测试， 如果是注册的用户信息已经存在: 如果注册的用户信息不存在，注册成功: ","date":"2023-12-31","objectID":"/cookie-json/:4:5","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#45-用户注册功能"},{"categories":["Web"],"content":" 4.6 验证码-展示 需求分析 展示验证码：展示验证码图片，并可以点击切换 验证码的生成是通过工具类来实现的，具体的工具类参考 04-资料\\1. 登录注册案例\\CheckCodeUtil.java 在该工具类中编写main方法进行测试: public static void main(String[] args) throws IOException { //生成验证码的图片位置 OutputStream fos = new FileOutputStream(\"d://a.jpg\"); //checkCode为最终验证码的数据 String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, fos, 4); System.out.println(checkCode); } 生成完验证码以后，我们就可以知晓: 验证码就是使用Java代码生成的一张图片 验证码的作用:防止机器自动注册，攻击服务器 实现流程分析 (1)前端发送请求给CheckCodeServlet (2)CheckCodeServlet接收到请求后，生成验证码图片，将图片用Reponse对象的输出流写回到前端 思考:如何将图片写回到前端浏览器呢? (1)Java中已经有工具类生成验证码图片，测试类中只是把图片生成到磁盘上 (2)生成磁盘的过程中使用的是OutputStream流，如何把这个图片生成在页面呢? (3)前面在将Reponse对象的时候，它有一个方法可以获取其字节输出流，getOutputStream() (4)综上所述，我们可以把写往磁盘的流对象更好成Response的字节流，即可完成图片响应给前端 具体实现 (1)修改Register.jsp页面，将验证码的图片从后台获取 \u003ctr\u003e \u003ctd\u003e验证码\u003c/td\u003e \u003ctd class=\"inputs\"\u003e \u003cinput name=\"checkCode\" type=\"text\" id=\"checkCode\"\u003e \u003cimg id=\"checkCodeImg\" src=\"/brand-demo/checkCodeServlet\"\u003e \u003ca href=\"#\" id=\"changeImg\" \u003e看不清？\u003c/a\u003e \u003c/td\u003e \u003c/tr\u003e \u003cscript\u003e document.getElementById(\"changeImg\").onclick = function () { //路径后面添加时间戳的目的是避免浏览器进行缓存静态资源 document.getElementById(\"checkCodeImg\").src = \"/brand-demo/checkCodeServlet?\"+new Date().getMilliseconds(); } \u003c/script\u003e (2)编写CheckCodeServlet类，用来接收请求生成验证码 @WebServlet(\"/checkCodeServlet\") public class CheckCodeServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 生成验证码 ServletOutputStream os = response.getOutputStream(); String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } ","date":"2023-12-31","objectID":"/cookie-json/:4:6","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#46-验证码-展示"},{"categories":["Web"],"content":" 4.7验证码-校验 需求 判断程序生成的验证码 和 用户输入的验证码 是否一样，如果不一样，则阻止注册 验证码图片访问和提交注册表单是==两次==请求，所以要将程序生成的验证码存入Session中 思考:为什么要把验证码数据存入到Session中呢? 生成验证码和校验验证码是两次请求，此处就需要在一个会话的两次请求之间共享数据 验证码属于安全数据类的，所以我们选中Session来存储验证码数据。 实现流程分析 (1)在CheckCodeServlet中生成验证码的时候，将验证码数据存入Session对象 (2)前端将验证码和注册数据提交到后台，交给RegisterServlet类 (3)RegisterServlet类接收到请求和数据后，其中就有验证码，和Session中的验证码进行对比 (4)如果一致，则完成注册，如果不一致，则提示错误信息 具体实现 (1)修改CheckCodeServlet类，将验证码存入Session对象 @WebServlet(\"/checkCodeServlet\") public class CheckCodeServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 生成验证码 ServletOutputStream os = response.getOutputStream(); String checkCode = CheckCodeUtil.outputVerifyImage(100, 50, os, 4); // 存入Session HttpSession session = request.getSession(); session.setAttribute(\"checkCodeGen\",checkCode); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (2)在RegisterServlet中，获取页面的和session对象中的验证码，进行对比 package com.itheima.web; import com.itheima.pojo.User; import com.itheima.service.UserService; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.*; import java.io.IOException; @WebServlet(\"/registerServlet\") public class RegisterServlet extends HttpServlet { private UserService service = new UserService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 获取用户名和密码数据 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); User user = new User(); user.setUsername(username); user.setPassword(password); // 获取用户输入的验证码 String checkCode = request.getParameter(\"checkCode\"); // 程序生成的验证码，从Session获取 HttpSession session = request.getSession(); String checkCodeGen = (String) session.getAttribute(\"checkCodeGen\"); // 比对 if(!checkCodeGen.equalsIgnoreCase(checkCode)){ request.setAttribute(\"register_msg\",\"验证码错误\"); request.getRequestDispatcher(\"/register.jsp\").forward(request,response); // 不允许注册 return; } //2. 调用service 注册 boolean flag = service.register(user); //3. 判断注册成功与否 if(flag){ //注册功能，跳转登陆页面 request.setAttribute(\"register_msg\",\"注册成功，请登录\"); request.getRequestDispatcher(\"/login.jsp\").forward(request,response); }else { //注册失败，跳转到注册页面 request.setAttribute(\"register_msg\",\"用户名已存在\"); request.getRequestDispatcher(\"/register.jsp\").forward(request,response); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } ","date":"2023-12-31","objectID":"/cookie-json/:4:7","series":null,"tags":["Web"],"title":"Cookie JSON","uri":"/cookie-json/#47验证码-校验"},{"categories":["Web"],"content":" Filter\u0026Listener\u0026Ajax","date":"2023-12-31","objectID":"/filter-listener-ajax/:1:0","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#filterlistenerajax"},{"categories":["Web"],"content":" 1，Filter","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:0","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#1filter"},{"categories":["Web"],"content":" 1.1 Filter概述Filter 表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。Servlet 我们之前都已经学习过了，Filter和Listener 我们今天都会进行学习。 过滤器可以把对资源的请求==拦截==下来，从而实现一些特殊的功能。 如下图所示，浏览器可以访问服务器上的所有的资源（servlet、jsp、html等） 而在访问到这些资源之前可以使过滤器拦截来下，也就是说在访问资源之前会先经过 Filter，如下图 拦截器拦截到后可以做什么功能呢？ ==过滤器一般完成一些通用的操作。==比如每个资源都要写一些代码完成某个功能，我们总不能在每个资源中写这样的代码吧，而此时我们可以将这些代码写在过滤器中，因为请求每一个资源都要经过过滤器。 我们之前做的品牌数据管理的案例中就已经做了登陆的功能，而如果我们不登录能不能访问到数据呢？我们可以在浏览器直接访问首页 ，可以看到 查询所有 的超链接 当我点击该按钮，居然可以看到品牌的数据 这显然和我们的要求不符。我们希望实现的效果是用户如果登陆过了就跳转到品牌数据展示的页面；如果没有登陆就跳转到登陆页面让用户进行登陆，要实现这个效果需要在每一个资源中都写上这段逻辑，而像这种通用的操作，我们就可以放在过滤器中进行实现。这个就是==权限控制==，以后我们还会进行细粒度权限控制。过滤器还可以做 统一编码处理、 敏感字符处理 等等… ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:1","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#11--filter概述"},{"categories":["Web"],"content":" 1.2 Filter快速入门 1.2.1 开发步骤进行 Filter 开发分成以下三步实现 定义类，实现 Filter接口，并重写其所有方法 配置Filter拦截资源的路径：在类上定义 @WebFilter 注解。而注解的 value 属性值 /* 表示拦截所有的资源 在doFilter方法中输出一句话，并放行 上述代码中的 chain.doFilter(request,response); 就是放行，也就是让其访问本该访问的资源。 1.2.2 代码演示创建一个项目，项目下有一个 hello.jsp 页面，项目结构如下： pom.xml 配置文件内容如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003efilter-demo\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003ewar\u003c/packaging\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.tomcat.maven\u003c/groupId\u003e \u003cartifactId\u003etomcat7-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.2\u003c/version\u003e \u003cconfiguration\u003e \u003cport\u003e80\u003c/port\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e hello.jsp 页面内容如下： \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003ehello JSP~\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 我们现在在浏览器输入 http://localhost/filter-demo/hello.jsp 访问 hello.jsp 页面，这里是可以访问到 hello.jsp 页面内容的。 接下来编写过滤器。过滤器是 Web 三大组件之一，所以我们将 filter 创建在 com.itheima.web.filter 包下，起名为 FilterDemo @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 重启启动服务器，再次重新访问 hello.jsp 页面，这次发现页面没有任何效果，但是在 idea 的控制台可以看到如下内容 上述效果说明 FilterDemo 这个过滤器的 doFilter() 方法执行了，但是为什么在浏览器上看不到 hello.jsp 页面的内容呢？这是因为在 doFilter() 方法中添加放行的方法才能访问到 hello.jsp 页面。那就在 doFilter() 方法中添加放行的代码 //放行 chain.doFilter(request,response); 再次重启服务器并访问 hello.jsp 页面，发现这次就可以在浏览器上看到页面效果。 FilterDemo 过滤器完整代码如下： @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"1.FilterDemo...\"); //放行 chain.doFilter(request,response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#12--filter快速入门"},{"categories":["Web"],"content":" 1.2 Filter快速入门 1.2.1 开发步骤进行 Filter 开发分成以下三步实现 定义类，实现 Filter接口，并重写其所有方法 配置Filter拦截资源的路径：在类上定义 @WebFilter 注解。而注解的 value 属性值 /* 表示拦截所有的资源 在doFilter方法中输出一句话，并放行 上述代码中的 chain.doFilter(request,response); 就是放行，也就是让其访问本该访问的资源。 1.2.2 代码演示创建一个项目，项目下有一个 hello.jsp 页面，项目结构如下： pom.xml 配置文件内容如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 4.0.0 org.example filter-demo 1.0-SNAPSHOT war 8 8 javax.servlet javax.servlet-api 3.1.0 provided org.apache.tomcat.maven tomcat7-maven-plugin 2.2 80 hello.jsp 页面内容如下： \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e Title hello JSP~ 我们现在在浏览器输入 http://localhost/filter-demo/hello.jsp 访问 hello.jsp 页面，这里是可以访问到 hello.jsp 页面内容的。 接下来编写过滤器。过滤器是 Web 三大组件之一，所以我们将 filter 创建在 com.itheima.web.filter 包下，起名为 FilterDemo @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 重启启动服务器，再次重新访问 hello.jsp 页面，这次发现页面没有任何效果，但是在 idea 的控制台可以看到如下内容 上述效果说明 FilterDemo 这个过滤器的 doFilter() 方法执行了，但是为什么在浏览器上看不到 hello.jsp 页面的内容呢？这是因为在 doFilter() 方法中添加放行的方法才能访问到 hello.jsp 页面。那就在 doFilter() 方法中添加放行的代码 //放行 chain.doFilter(request,response); 再次重启服务器并访问 hello.jsp 页面，发现这次就可以在浏览器上看到页面效果。 FilterDemo 过滤器完整代码如下： @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"1.FilterDemo...\"); //放行 chain.doFilter(request,response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#121--开发步骤"},{"categories":["Web"],"content":" 1.2 Filter快速入门 1.2.1 开发步骤进行 Filter 开发分成以下三步实现 定义类，实现 Filter接口，并重写其所有方法 配置Filter拦截资源的路径：在类上定义 @WebFilter 注解。而注解的 value 属性值 /* 表示拦截所有的资源 在doFilter方法中输出一句话，并放行 上述代码中的 chain.doFilter(request,response); 就是放行，也就是让其访问本该访问的资源。 1.2.2 代码演示创建一个项目，项目下有一个 hello.jsp 页面，项目结构如下： pom.xml 配置文件内容如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 4.0.0 org.example filter-demo 1.0-SNAPSHOT war 8 8 javax.servlet javax.servlet-api 3.1.0 provided org.apache.tomcat.maven tomcat7-maven-plugin 2.2 80 hello.jsp 页面内容如下： \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e Title hello JSP~ 我们现在在浏览器输入 http://localhost/filter-demo/hello.jsp 访问 hello.jsp 页面，这里是可以访问到 hello.jsp 页面内容的。 接下来编写过滤器。过滤器是 Web 三大组件之一，所以我们将 filter 创建在 com.itheima.web.filter 包下，起名为 FilterDemo @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 重启启动服务器，再次重新访问 hello.jsp 页面，这次发现页面没有任何效果，但是在 idea 的控制台可以看到如下内容 上述效果说明 FilterDemo 这个过滤器的 doFilter() 方法执行了，但是为什么在浏览器上看不到 hello.jsp 页面的内容呢？这是因为在 doFilter() 方法中添加放行的方法才能访问到 hello.jsp 页面。那就在 doFilter() 方法中添加放行的代码 //放行 chain.doFilter(request,response); 再次重启服务器并访问 hello.jsp 页面，发现这次就可以在浏览器上看到页面效果。 FilterDemo 过滤器完整代码如下： @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\"1.FilterDemo...\"); //放行 chain.doFilter(request,response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#122--代码演示"},{"categories":["Web"],"content":" 1.3 Filter执行流程 如上图是使用过滤器的流程，我们通过以下问题来研究过滤器的执行流程： 放行后访问对应资源，资源访问完成后，还会回到Filter中吗？ 从上图就可以看出肯定 ==会== 回到Filter中 如果回到Filter中，是重头执行还是执行放行后的逻辑呢？ 如果是重头执行的话，就意味着 放行前逻辑 会被执行两次，肯定不会这样设计了；所以访问完资源后，会回到 放行后逻辑，执行该部分代码。 通过上述的说明，我们就可以总结Filter的执行流程如下： 接下来我们通过代码验证一下，在 doFilter() 方法前后都加上输出语句，如下 同时在 hello.jsp 页面加上输出语句，如下 执行访问该资源打印的顺序是按照我们标记的标号进行打印的话，说明我们上边总结出来的流程是没有问题的。启动服务器访问 hello.jsp 页面，在控制台打印的内容如下： 以后我们可以将对请求进行处理的代码放在放行之前进行处理，而如果请求完资源后还要对响应的数据进行处理时可以在放行后进行逻辑处理。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#13--filter执行流程"},{"categories":["Web"],"content":" 1.4 Filter拦截路径配置拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 @WebFilter 注解进行配置。如：@WebFilter(\"拦截路径\") 拦截路径有如下四种配置方式： 拦截具体的资源：/index.jsp：只有访问index.jsp时才会被拦截 目录拦截：/user/*：访问/user下的所有资源，都会被拦截 后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截 拦截所有：/*：访问所有资源，都会被拦截 通过上面拦截路径的学习，大家会发现拦截路径的配置方式和 Servlet 的请求资源路径配置方式一样，但是表示的含义不同。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:4","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#14--filter拦截路径配置"},{"categories":["Web"],"content":" 1.5 过滤器链 1.5.1 概述过滤器链是指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。 如下图就是一个过滤器链，我们学习过滤器链主要是学习过滤器链执行的流程 上图中的过滤器链执行是按照以下流程执行： 执行 Filter1 的放行前逻辑代码 执行 Filter1 的放行代码 执行 Filter2 的放行前逻辑代码 执行 Filter2 的放行代码 访问到资源 执行 Filter2 的放行后逻辑代码 执行 Filter1 的放行后逻辑代码 以上流程串起来就像一条链子，故称之为过滤器链。 1.5.2 代码演示 编写第一个过滤器 FilterDemo ，配置成拦截所有资源 @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //1. 放行前，对 request数据进行处理 System.out.println(\"1.FilterDemo...\"); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(\"3.FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 编写第二个过滤器 FilterDemo2 ，配置炒年糕拦截所有资源 @WebFilter(\"/*\") public class FilterDemo2 implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //1. 放行前，对 request数据进行处理 System.out.println(\"2.FilterDemo...\"); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(\"4.FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 修改 hello.jsp 页面中脚本的输出语句 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003ehello JSP~\u003c/h1\u003e \u003c% System.out.println(\"3.hello jsp\"); %\u003e \u003c/body\u003e \u003c/html\u003e 启动服务器，在浏览器输入 http://localhost/filter-demo/hello.jsp 进行测试，在控制台打印内容如下 从结果可以看到确实是按照我们之前说的执行流程进行执行的。 1.5.3 问题上面代码中为什么是先执行 FilterDemo ，后执行 FilterDemo2 呢？ 我们现在使用的是注解配置Filter，而这种配置方式的优先级是按照过滤器类名(字符串)的自然排序。 比如有如下两个名称的过滤器 ： BFilterDemo 和 AFilterDemo 。那一定是 AFilterDemo 过滤器先执行。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:5","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#15--过滤器链"},{"categories":["Web"],"content":" 1.5 过滤器链 1.5.1 概述过滤器链是指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。 如下图就是一个过滤器链，我们学习过滤器链主要是学习过滤器链执行的流程 上图中的过滤器链执行是按照以下流程执行： 执行 Filter1 的放行前逻辑代码 执行 Filter1 的放行代码 执行 Filter2 的放行前逻辑代码 执行 Filter2 的放行代码 访问到资源 执行 Filter2 的放行后逻辑代码 执行 Filter1 的放行后逻辑代码 以上流程串起来就像一条链子，故称之为过滤器链。 1.5.2 代码演示 编写第一个过滤器 FilterDemo ，配置成拦截所有资源 @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //1. 放行前，对 request数据进行处理 System.out.println(\"1.FilterDemo...\"); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(\"3.FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 编写第二个过滤器 FilterDemo2 ，配置炒年糕拦截所有资源 @WebFilter(\"/*\") public class FilterDemo2 implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //1. 放行前，对 request数据进行处理 System.out.println(\"2.FilterDemo...\"); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(\"4.FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 修改 hello.jsp 页面中脚本的输出语句 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e Title hello JSP~ \u003c% System.out.println(\"3.hello jsp\"); %\u003e 启动服务器，在浏览器输入 http://localhost/filter-demo/hello.jsp 进行测试，在控制台打印内容如下 从结果可以看到确实是按照我们之前说的执行流程进行执行的。 1.5.3 问题上面代码中为什么是先执行 FilterDemo ，后执行 FilterDemo2 呢？ 我们现在使用的是注解配置Filter，而这种配置方式的优先级是按照过滤器类名(字符串)的自然排序。 比如有如下两个名称的过滤器 ： BFilterDemo 和 AFilterDemo 。那一定是 AFilterDemo 过滤器先执行。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:5","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#151--概述"},{"categories":["Web"],"content":" 1.5 过滤器链 1.5.1 概述过滤器链是指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。 如下图就是一个过滤器链，我们学习过滤器链主要是学习过滤器链执行的流程 上图中的过滤器链执行是按照以下流程执行： 执行 Filter1 的放行前逻辑代码 执行 Filter1 的放行代码 执行 Filter2 的放行前逻辑代码 执行 Filter2 的放行代码 访问到资源 执行 Filter2 的放行后逻辑代码 执行 Filter1 的放行后逻辑代码 以上流程串起来就像一条链子，故称之为过滤器链。 1.5.2 代码演示 编写第一个过滤器 FilterDemo ，配置成拦截所有资源 @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //1. 放行前，对 request数据进行处理 System.out.println(\"1.FilterDemo...\"); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(\"3.FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 编写第二个过滤器 FilterDemo2 ，配置炒年糕拦截所有资源 @WebFilter(\"/*\") public class FilterDemo2 implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //1. 放行前，对 request数据进行处理 System.out.println(\"2.FilterDemo...\"); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(\"4.FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 修改 hello.jsp 页面中脚本的输出语句 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e Title hello JSP~ \u003c% System.out.println(\"3.hello jsp\"); %\u003e 启动服务器，在浏览器输入 http://localhost/filter-demo/hello.jsp 进行测试，在控制台打印内容如下 从结果可以看到确实是按照我们之前说的执行流程进行执行的。 1.5.3 问题上面代码中为什么是先执行 FilterDemo ，后执行 FilterDemo2 呢？ 我们现在使用的是注解配置Filter，而这种配置方式的优先级是按照过滤器类名(字符串)的自然排序。 比如有如下两个名称的过滤器 ： BFilterDemo 和 AFilterDemo 。那一定是 AFilterDemo 过滤器先执行。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:5","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#152--代码演示"},{"categories":["Web"],"content":" 1.5 过滤器链 1.5.1 概述过滤器链是指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。 如下图就是一个过滤器链，我们学习过滤器链主要是学习过滤器链执行的流程 上图中的过滤器链执行是按照以下流程执行： 执行 Filter1 的放行前逻辑代码 执行 Filter1 的放行代码 执行 Filter2 的放行前逻辑代码 执行 Filter2 的放行代码 访问到资源 执行 Filter2 的放行后逻辑代码 执行 Filter1 的放行后逻辑代码 以上流程串起来就像一条链子，故称之为过滤器链。 1.5.2 代码演示 编写第一个过滤器 FilterDemo ，配置成拦截所有资源 @WebFilter(\"/*\") public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //1. 放行前，对 request数据进行处理 System.out.println(\"1.FilterDemo...\"); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(\"3.FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 编写第二个过滤器 FilterDemo2 ，配置炒年糕拦截所有资源 @WebFilter(\"/*\") public class FilterDemo2 implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //1. 放行前，对 request数据进行处理 System.out.println(\"2.FilterDemo...\"); //放行 chain.doFilter(request,response); //2. 放行后，对Response 数据进行处理 System.out.println(\"4.FilterDemo...\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { } } 修改 hello.jsp 页面中脚本的输出语句 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e Title hello JSP~ \u003c% System.out.println(\"3.hello jsp\"); %\u003e 启动服务器，在浏览器输入 http://localhost/filter-demo/hello.jsp 进行测试，在控制台打印内容如下 从结果可以看到确实是按照我们之前说的执行流程进行执行的。 1.5.3 问题上面代码中为什么是先执行 FilterDemo ，后执行 FilterDemo2 呢？ 我们现在使用的是注解配置Filter，而这种配置方式的优先级是按照过滤器类名(字符串)的自然排序。 比如有如下两个名称的过滤器 ： BFilterDemo 和 AFilterDemo 。那一定是 AFilterDemo 过滤器先执行。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:5","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#153--问题"},{"categories":["Web"],"content":" 1.6 案例 1.6.1 需求访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.2 编写逻辑代码在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.3 测试并抛出问题在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } 1.6.3.5 过滤器完整代码 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:6","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#16--案例"},{"categories":["Web"],"content":" 1.6 案例 1.6.1 需求访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.2 编写逻辑代码在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.3 测试并抛出问题在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } 1.6.3.5 过滤器完整代码 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:6","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#161--需求"},{"categories":["Web"],"content":" 1.6 案例 1.6.1 需求访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.2 编写逻辑代码在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.3 测试并抛出问题在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } 1.6.3.5 过滤器完整代码 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:6","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#162--分析"},{"categories":["Web"],"content":" 1.6 案例 1.6.1 需求访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.2 编写逻辑代码在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.3 测试并抛出问题在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } 1.6.3.5 过滤器完整代码 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:6","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#163--代码实现"},{"categories":["Web"],"content":" 1.6 案例 1.6.1 需求访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.2 编写逻辑代码在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.3 测试并抛出问题在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } 1.6.3.5 过滤器完整代码 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:6","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#1631--创建filter"},{"categories":["Web"],"content":" 1.6 案例 1.6.1 需求访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.2 编写逻辑代码在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.3 测试并抛出问题在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } 1.6.3.5 过滤器完整代码 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:6","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#1632--编写逻辑代码"},{"categories":["Web"],"content":" 1.6 案例 1.6.1 需求访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.2 编写逻辑代码在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.3 测试并抛出问题在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } 1.6.3.5 过滤器完整代码 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:6","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#1633--测试并抛出问题"},{"categories":["Web"],"content":" 1.6 案例 1.6.1 需求访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.2 编写逻辑代码在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.3 测试并抛出问题在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } 1.6.3.5 过滤器完整代码 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:6","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#1634--问题分析及解决"},{"categories":["Web"],"content":" 1.6 案例 1.6.1 需求访问服务器资源时，需要先进行登录验证，如果没有登录，则自动跳转到登录页面 1.6.2 分析我们要实现该功能是在每一个资源里加入登陆状态校验的代码吗？显然是不需要的，只需要写一个 Filter ，在该过滤器中进行登陆状态校验即可。而在该 Filter 中逻辑如下： 1.6.3 代码实现 1.6.3.1 创建Filter在 brand-demo 工程创建 com.itheima.web.filter 包，在该下创建名为 LoginFilter 的过滤器 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.2 编写逻辑代码在 doFilter() 方法中编写登陆状态校验的逻辑代码。 我们首先需要从 session 对象中获取用户信息，但是 ServletRequest 类型的 requset 对象没有获取 session 对象的方法，所以此时需要将 request对象强转成 HttpServletRequest 对象。 HttpServletRequest req = (HttpServletRequest) request; 然后完成以下逻辑 获取Session对象 从Session对象中获取名为 user 的数据 判断获取到的数据是否是 null 如果不是，说明已经登陆，放行 如果是，说明尚未登陆，将提示信息存储到域对象中并跳转到登陆页面 代码如下： @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } 1.6.3.3 测试并抛出问题在浏览器上输入 http://localhost:8080/brand-demo/ ，可以看到如下页面效果 从上面效果可以看出没有登陆确实是跳转到登陆页面了，但是登陆页面为什么展示成这种效果了呢？ 1.6.3.4 问题分析及解决因为登陆页面需要 css/login.css 这个文件进行样式的渲染，下图是登陆页面引入的css文件图解 而在请求这个css资源时被过滤器拦截，就相当于没有加载到样式文件导致的。解决这个问题，只需要对所以的登陆相关的资源进行放行即可。还有一种情况就是当我没有用户信息时需要进行注册，而注册时也希望被过滤器放行。 综上，我们需要在判断session中是否包含用户信息之前，应该加上对登陆及注册相关资源放行的逻辑处理 //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } 1.6.3.5 过滤器完整代码 @WebFilter(\"/*\") public class LoginFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { HttpServletRequest req = (HttpServletRequest) request; //判断访问资源路径是否和登录注册相关 //1,在数组中存储登陆和注册相关的资源路径 String[] urls = {\"/login.jsp\",\"/imgs/\",\"/css/\",\"/loginServlet\",\"/register.jsp\",\"/registerServlet\",\"/checkCodeServlet\"}; //2,获取当前访问的资源路径 String url = req.getRequestURL().toString(); //3,遍历数组，获取到每一个需要放行的资源路径 for (String u : urls) { //4,判断当前访问的资源路径字符串是否包含要放行的的资源路径字符串 /* 比如当前访问的资源路径是 /brand-demo/login.jsp 而字符串 /brand-demo/login.jsp 包含了 字符串 /login.jsp ，所以这个字符串就需要放行 */ if(url.contains(u)){ //找到了，放行 chain.doFilter(request, response); //break; return; } } //1. 判断session中是否有user HttpSession session = req.getSession(); Object user = session.getAttribute(\"user\"); //2. 判断user是否为null if(user != null){ // 登录过了 //放行 chain.doFilter(request, response); }else { // 没有登陆，存储提示信息，跳转到登录页面 req.setAttribute(\"login_msg\",\"您尚未登陆！\"); req.getRequestDispatcher(\"/login.jsp\").forward(req,response); } } public void init(FilterConfig config) throws ServletException { } public void destroy() { } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:2:6","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#1635--过滤器完整代码"},{"categories":["Web"],"content":" 2，Listener","date":"2023-12-31","objectID":"/filter-listener-ajax/:3:0","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#2listener"},{"categories":["Web"],"content":" 2.1 概述 Listener 表示监听器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。 监听器可以监听就是在 application，session，request 三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。 request 和 session 我们学习过。而 application 是 ServletContext 类型的对象。 ServletContext 代表整个web应用，在服务器启动的时候，tomcat会自动创建该对象。在服务器关闭时会自动销毁该对象。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:3:1","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#21--概述"},{"categories":["Web"],"content":" 2.2 分类JavaWeb 提供了8个监听器： 这里面只有 ServletContextListener 这个监听器后期我们会接触到，ServletContextListener 是用来监听 ServletContext 对象的创建和销毁。 ServletContextListener 接口中有以下两个方法 void contextInitialized(ServletContextEvent sce)：ServletContext 对象被创建了会自动执行的方法 void contextDestroyed(ServletContextEvent sce)：ServletContext 对象被销毁时会自动执行的方法 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:3:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#22--分类"},{"categories":["Web"],"content":" 2.3 代码演示我们只演示一下 ServletContextListener 监听器 定义一个类，实现ServletContextListener 接口 重写所有的抽象方法 使用 @WebListener 进行配置 代码如下： @WebListener public class ContextLoaderListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { //加载资源 System.out.println(\"ContextLoaderListener...\"); } @Override public void contextDestroyed(ServletContextEvent sce) { //释放资源 } } 启动服务器，就可以在启动的日志信息中看到 contextInitialized() 方法输出的内容，同时也说明了 ServletContext 对象在服务器启动的时候被创建了。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:3:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#23--代码演示"},{"categories":["Web"],"content":" 3，Ajax","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:0","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#3ajax"},{"categories":["Web"],"content":" 3.1 概述==AJAX (Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。== 我们先来说概念中的 JavaScript 和 XML，JavaScript 表明该技术和前端相关；XML 是指以此进行数据交换。而这两个我们之前都学习过。 3.1.1 作用AJAX 作用有以下两方面： 与服务器进行数据交换：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。如下图 我们先来看之前做功能的流程，如下图： 如上图，Servlet 调用完业务逻辑层后将数据存储到域对象中，然后跳转到指定的 jsp 页面，在页面上使用 EL表达式 和 JSTL 标签库进行数据的展示。 而我们学习了AJAX 后，就可以==使用AJAX和服务器进行通信，以达到使用 HTML+AJAX来替换JSP页面==了。如下图，浏览器发送请求servlet，servlet 调用完业务逻辑层后将数据直接响应回给浏览器页面，页面使用 HTML 来进行数据展示。 异步交互：可以在==不重新加载整个页面==的情况下，与服务器交换数据并==更新部分网页==的技术，如：搜索联想、用户名是否可用校验，等等… 上图所示的效果我们经常见到，在我们输入一些关键字（例如 奥运）后就会在下面联想出相关的内容，而联想出来的这部分数据肯定是存储在百度的服务器上，而我们并没有看出页面重新刷新，这就是 ==更新局部页面== 的效果。再如下图： 我们在用户名的输入框输入用户名，当输入框一失去焦点，如果用户名已经被占用就会在下方展示提示的信息；在这整个过程中也没有页面的刷新，只是在局部展示出了提示信息，这就是 ==更新局部页面== 的效果。 3.1.2 同步和异步知道了局部刷新后，接下来我们再聊聊同步和异步: 同步发送请求过程如下 ​ 浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。 异步发送请求过程如下 浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:1","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#31--概述"},{"categories":["Web"],"content":" 3.1 概述==AJAX (Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。== 我们先来说概念中的 JavaScript 和 XML，JavaScript 表明该技术和前端相关；XML 是指以此进行数据交换。而这两个我们之前都学习过。 3.1.1 作用AJAX 作用有以下两方面： 与服务器进行数据交换：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。如下图 我们先来看之前做功能的流程，如下图： 如上图，Servlet 调用完业务逻辑层后将数据存储到域对象中，然后跳转到指定的 jsp 页面，在页面上使用 EL表达式 和 JSTL 标签库进行数据的展示。 而我们学习了AJAX 后，就可以==使用AJAX和服务器进行通信，以达到使用 HTML+AJAX来替换JSP页面==了。如下图，浏览器发送请求servlet，servlet 调用完业务逻辑层后将数据直接响应回给浏览器页面，页面使用 HTML 来进行数据展示。 异步交互：可以在==不重新加载整个页面==的情况下，与服务器交换数据并==更新部分网页==的技术，如：搜索联想、用户名是否可用校验，等等… 上图所示的效果我们经常见到，在我们输入一些关键字（例如 奥运）后就会在下面联想出相关的内容，而联想出来的这部分数据肯定是存储在百度的服务器上，而我们并没有看出页面重新刷新，这就是 ==更新局部页面== 的效果。再如下图： 我们在用户名的输入框输入用户名，当输入框一失去焦点，如果用户名已经被占用就会在下方展示提示的信息；在这整个过程中也没有页面的刷新，只是在局部展示出了提示信息，这就是 ==更新局部页面== 的效果。 3.1.2 同步和异步知道了局部刷新后，接下来我们再聊聊同步和异步: 同步发送请求过程如下 ​ 浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。 异步发送请求过程如下 浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:1","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#311--作用"},{"categories":["Web"],"content":" 3.1 概述==AJAX (Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。== 我们先来说概念中的 JavaScript 和 XML，JavaScript 表明该技术和前端相关；XML 是指以此进行数据交换。而这两个我们之前都学习过。 3.1.1 作用AJAX 作用有以下两方面： 与服务器进行数据交换：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。如下图 我们先来看之前做功能的流程，如下图： 如上图，Servlet 调用完业务逻辑层后将数据存储到域对象中，然后跳转到指定的 jsp 页面，在页面上使用 EL表达式 和 JSTL 标签库进行数据的展示。 而我们学习了AJAX 后，就可以==使用AJAX和服务器进行通信，以达到使用 HTML+AJAX来替换JSP页面==了。如下图，浏览器发送请求servlet，servlet 调用完业务逻辑层后将数据直接响应回给浏览器页面，页面使用 HTML 来进行数据展示。 异步交互：可以在==不重新加载整个页面==的情况下，与服务器交换数据并==更新部分网页==的技术，如：搜索联想、用户名是否可用校验，等等… 上图所示的效果我们经常见到，在我们输入一些关键字（例如 奥运）后就会在下面联想出相关的内容，而联想出来的这部分数据肯定是存储在百度的服务器上，而我们并没有看出页面重新刷新，这就是 ==更新局部页面== 的效果。再如下图： 我们在用户名的输入框输入用户名，当输入框一失去焦点，如果用户名已经被占用就会在下方展示提示的信息；在这整个过程中也没有页面的刷新，只是在局部展示出了提示信息，这就是 ==更新局部页面== 的效果。 3.1.2 同步和异步知道了局部刷新后，接下来我们再聊聊同步和异步: 同步发送请求过程如下 ​ 浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。 异步发送请求过程如下 浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:1","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#312--同步和异步"},{"categories":["Web"],"content":" 3.2 快速入门 3.2.1 服务端实现在项目的创建 com.itheima.web.servlet ，并在该包下创建名为 AjaxServlet 的servlet @WebServlet(\"/ajaxServlet\") public class AjaxServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 响应数据 response.getWriter().write(\"hello ajax~\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 3.2.2 客户端实现在 webapp 下创建名为 01-ajax-demo1.html 的页面，在该页面书写 ajax 代码 创建核心对象，不同的浏览器创建的对象是不同的 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } 发送请求 //建立连接 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/ajaxServlet\"); //发送请求 xhttp.send(); 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { // 通过 this.responseText 可以获取到服务端响应的数据 alert(this.responseText); } }; 完整代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript\u003e //1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2. 发送请求 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/ajaxServlet\"); xhttp.send(); //3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { alert(this.responseText); } }; \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 3.2.3 测试在浏览器地址栏输入 http://localhost:8080/ajax-demo/01-ajax-demo1.html ，在 01-ajax-demo1.html加载的时候就会发送 ajax 请求，效果如下 我们可以通过 开发者模式 查看发送的 AJAX 请求。在浏览器上按 F12 快捷键 这个是查看所有的请求，如果我们只是想看 异步请求的话，点击上图中 All 旁边的 XHR，会发现只展示 Type 是 xhr 的请求。如下图： ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#32--快速入门"},{"categories":["Web"],"content":" 3.2 快速入门 3.2.1 服务端实现在项目的创建 com.itheima.web.servlet ，并在该包下创建名为 AjaxServlet 的servlet @WebServlet(\"/ajaxServlet\") public class AjaxServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 响应数据 response.getWriter().write(\"hello ajax~\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 3.2.2 客户端实现在 webapp 下创建名为 01-ajax-demo1.html 的页面，在该页面书写 ajax 代码 创建核心对象，不同的浏览器创建的对象是不同的 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } 发送请求 //建立连接 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/ajaxServlet\"); //发送请求 xhttp.send(); 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { // 通过 this.responseText 可以获取到服务端响应的数据 alert(this.responseText); } }; 完整代码如下： \u003c!DOCTYPE html\u003e Title 3.2.3 测试在浏览器地址栏输入 http://localhost:8080/ajax-demo/01-ajax-demo1.html ，在 01-ajax-demo1.html加载的时候就会发送 ajax 请求，效果如下 我们可以通过 开发者模式 查看发送的 AJAX 请求。在浏览器上按 F12 快捷键 这个是查看所有的请求，如果我们只是想看 异步请求的话，点击上图中 All 旁边的 XHR，会发现只展示 Type 是 xhr 的请求。如下图： ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#321-服务端实现"},{"categories":["Web"],"content":" 3.2 快速入门 3.2.1 服务端实现在项目的创建 com.itheima.web.servlet ，并在该包下创建名为 AjaxServlet 的servlet @WebServlet(\"/ajaxServlet\") public class AjaxServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 响应数据 response.getWriter().write(\"hello ajax~\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 3.2.2 客户端实现在 webapp 下创建名为 01-ajax-demo1.html 的页面，在该页面书写 ajax 代码 创建核心对象，不同的浏览器创建的对象是不同的 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } 发送请求 //建立连接 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/ajaxServlet\"); //发送请求 xhttp.send(); 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { // 通过 this.responseText 可以获取到服务端响应的数据 alert(this.responseText); } }; 完整代码如下： \u003c!DOCTYPE html\u003e Title 3.2.3 测试在浏览器地址栏输入 http://localhost:8080/ajax-demo/01-ajax-demo1.html ，在 01-ajax-demo1.html加载的时候就会发送 ajax 请求，效果如下 我们可以通过 开发者模式 查看发送的 AJAX 请求。在浏览器上按 F12 快捷键 这个是查看所有的请求，如果我们只是想看 异步请求的话，点击上图中 All 旁边的 XHR，会发现只展示 Type 是 xhr 的请求。如下图： ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#322--客户端实现"},{"categories":["Web"],"content":" 3.2 快速入门 3.2.1 服务端实现在项目的创建 com.itheima.web.servlet ，并在该包下创建名为 AjaxServlet 的servlet @WebServlet(\"/ajaxServlet\") public class AjaxServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 响应数据 response.getWriter().write(\"hello ajax~\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 3.2.2 客户端实现在 webapp 下创建名为 01-ajax-demo1.html 的页面，在该页面书写 ajax 代码 创建核心对象，不同的浏览器创建的对象是不同的 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } 发送请求 //建立连接 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/ajaxServlet\"); //发送请求 xhttp.send(); 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { // 通过 this.responseText 可以获取到服务端响应的数据 alert(this.responseText); } }; 完整代码如下： \u003c!DOCTYPE html\u003e Title 3.2.3 测试在浏览器地址栏输入 http://localhost:8080/ajax-demo/01-ajax-demo1.html ，在 01-ajax-demo1.html加载的时候就会发送 ajax 请求，效果如下 我们可以通过 开发者模式 查看发送的 AJAX 请求。在浏览器上按 F12 快捷键 这个是查看所有的请求，如果我们只是想看 异步请求的话，点击上图中 All 旁边的 XHR，会发现只展示 Type 是 xhr 的请求。如下图： ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#323--测试"},{"categories":["Web"],"content":" 3.3 案例需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在 3.3.1 分析 前端完成的逻辑 给用户名输入框绑定光标失去焦点事件 onblur 发送 ajax请求，携带username参数 处理响应：是否显示提示信息 后端完成的逻辑 接收用户名 调用service查询User。此案例是为了演示前后端异步交互，所以此处我们不做业务逻辑处理 返回标记 整体流程如下： 3.3.2 后端实现在 com.ithiema.web.servlet 包中定义名为 SelectUserServlet 的servlet。代码如下： @WebServlet(\"/selectUserServlet\") public class SelectUserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户名 String username = request.getParameter(\"username\"); //2. 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用 boolean flag = true; //3. 响应标记 response.getWriter().write(\"\" + flag); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 3.3.3 前端实现将 04-资料\\1. 验证用户名案例\\1. 静态页面 下的文件整体拷贝到项目下 webapp 下。并在 register.html 页面的 body 结束标签前编写 script 标签，在该标签中实现如下逻辑 第一步：给用户名输入框绑定光标失去焦点事件 onblur //1. 给用户名输入框绑定 失去焦点事件 document.getElementById(\"username\").onblur = function () { } 第二步：发送 ajax请求，携带username参数 在 第一步 绑定的匿名函数中书写发送 ajax 请求的代码 //2. 发送ajax请求 //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2.2. 发送请求 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { //处理响应的结果 } }; 由于我们发送的是 GET 请求，所以需要在 URL 后拼接从输入框获取的用户名数据。而我们在 第一步 绑定的匿名函数中通过以下代码可以获取用户名数据 // 获取用户名的值 var username = this.value; //this ： 给谁绑定的事件，this就代表谁 而携带数据需要将 URL 修改为： xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet?username=\"+username); 第三步：处理响应：是否显示提示信息 当 this.readyState == 4 \u0026\u0026 this.status == 200 条件满足时，说明已经成功响应数据了。 此时需要判断响应的数据是否是 “true” 字符串，如果是说明用户名已经占用给出错误提示；如果不是说明用户名未被占用清除错误提示。代码如下 //判断 if(this.responseText == \"true\"){ //用户名存在，显示提示信息 document.getElementById(\"username_err\").style.display = ''; }else { //用户名不存在 ，清楚提示信息 document.getElementById(\"username_err\").style.display = 'none'; } 综上所述，前端完成代码如下： //1. 给用户名输入框绑定 失去焦点事件 document.getElementById(\"username\").onblur = function () { //2. 发送ajax请求 // 获取用户名的值 var username = this.value; //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2.2. 发送请求 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet?username=\"+username); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { //alert(this.responseText); //判断 if(this.responseText == \"true\"){ //用户名存在，显示提示信息 document.getElementById(\"username_err\").style.display = ''; }else { //用户名不存在 ，清楚提示信息 document.getElementById(\"username_err\").style.display = 'none'; } } }; } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#33-案例"},{"categories":["Web"],"content":" 3.3 案例需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在 3.3.1 分析 前端完成的逻辑 给用户名输入框绑定光标失去焦点事件 onblur 发送 ajax请求，携带username参数 处理响应：是否显示提示信息 后端完成的逻辑 接收用户名 调用service查询User。此案例是为了演示前后端异步交互，所以此处我们不做业务逻辑处理 返回标记 整体流程如下： 3.3.2 后端实现在 com.ithiema.web.servlet 包中定义名为 SelectUserServlet 的servlet。代码如下： @WebServlet(\"/selectUserServlet\") public class SelectUserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户名 String username = request.getParameter(\"username\"); //2. 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用 boolean flag = true; //3. 响应标记 response.getWriter().write(\"\" + flag); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 3.3.3 前端实现将 04-资料\\1. 验证用户名案例\\1. 静态页面 下的文件整体拷贝到项目下 webapp 下。并在 register.html 页面的 body 结束标签前编写 script 标签，在该标签中实现如下逻辑 第一步：给用户名输入框绑定光标失去焦点事件 onblur //1. 给用户名输入框绑定 失去焦点事件 document.getElementById(\"username\").onblur = function () { } 第二步：发送 ajax请求，携带username参数 在 第一步 绑定的匿名函数中书写发送 ajax 请求的代码 //2. 发送ajax请求 //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2.2. 发送请求 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { //处理响应的结果 } }; 由于我们发送的是 GET 请求，所以需要在 URL 后拼接从输入框获取的用户名数据。而我们在 第一步 绑定的匿名函数中通过以下代码可以获取用户名数据 // 获取用户名的值 var username = this.value; //this ： 给谁绑定的事件，this就代表谁 而携带数据需要将 URL 修改为： xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet?username=\"+username); 第三步：处理响应：是否显示提示信息 当 this.readyState == 4 \u0026\u0026 this.status == 200 条件满足时，说明已经成功响应数据了。 此时需要判断响应的数据是否是 “true” 字符串，如果是说明用户名已经占用给出错误提示；如果不是说明用户名未被占用清除错误提示。代码如下 //判断 if(this.responseText == \"true\"){ //用户名存在，显示提示信息 document.getElementById(\"username_err\").style.display = ''; }else { //用户名不存在 ，清楚提示信息 document.getElementById(\"username_err\").style.display = 'none'; } 综上所述，前端完成代码如下： //1. 给用户名输入框绑定 失去焦点事件 document.getElementById(\"username\").onblur = function () { //2. 发送ajax请求 // 获取用户名的值 var username = this.value; //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2.2. 发送请求 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet?username=\"+username); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { //alert(this.responseText); //判断 if(this.responseText == \"true\"){ //用户名存在，显示提示信息 document.getElementById(\"username_err\").style.display = ''; }else { //用户名不存在 ，清楚提示信息 document.getElementById(\"username_err\").style.display = 'none'; } } }; } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#331--分析"},{"categories":["Web"],"content":" 3.3 案例需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在 3.3.1 分析 前端完成的逻辑 给用户名输入框绑定光标失去焦点事件 onblur 发送 ajax请求，携带username参数 处理响应：是否显示提示信息 后端完成的逻辑 接收用户名 调用service查询User。此案例是为了演示前后端异步交互，所以此处我们不做业务逻辑处理 返回标记 整体流程如下： 3.3.2 后端实现在 com.ithiema.web.servlet 包中定义名为 SelectUserServlet 的servlet。代码如下： @WebServlet(\"/selectUserServlet\") public class SelectUserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户名 String username = request.getParameter(\"username\"); //2. 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用 boolean flag = true; //3. 响应标记 response.getWriter().write(\"\" + flag); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 3.3.3 前端实现将 04-资料\\1. 验证用户名案例\\1. 静态页面 下的文件整体拷贝到项目下 webapp 下。并在 register.html 页面的 body 结束标签前编写 script 标签，在该标签中实现如下逻辑 第一步：给用户名输入框绑定光标失去焦点事件 onblur //1. 给用户名输入框绑定 失去焦点事件 document.getElementById(\"username\").onblur = function () { } 第二步：发送 ajax请求，携带username参数 在 第一步 绑定的匿名函数中书写发送 ajax 请求的代码 //2. 发送ajax请求 //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2.2. 发送请求 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { //处理响应的结果 } }; 由于我们发送的是 GET 请求，所以需要在 URL 后拼接从输入框获取的用户名数据。而我们在 第一步 绑定的匿名函数中通过以下代码可以获取用户名数据 // 获取用户名的值 var username = this.value; //this ： 给谁绑定的事件，this就代表谁 而携带数据需要将 URL 修改为： xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet?username=\"+username); 第三步：处理响应：是否显示提示信息 当 this.readyState == 4 \u0026\u0026 this.status == 200 条件满足时，说明已经成功响应数据了。 此时需要判断响应的数据是否是 “true” 字符串，如果是说明用户名已经占用给出错误提示；如果不是说明用户名未被占用清除错误提示。代码如下 //判断 if(this.responseText == \"true\"){ //用户名存在，显示提示信息 document.getElementById(\"username_err\").style.display = ''; }else { //用户名不存在 ，清楚提示信息 document.getElementById(\"username_err\").style.display = 'none'; } 综上所述，前端完成代码如下： //1. 给用户名输入框绑定 失去焦点事件 document.getElementById(\"username\").onblur = function () { //2. 发送ajax请求 // 获取用户名的值 var username = this.value; //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2.2. 发送请求 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet?username=\"+username); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { //alert(this.responseText); //判断 if(this.responseText == \"true\"){ //用户名存在，显示提示信息 document.getElementById(\"username_err\").style.display = ''; }else { //用户名不存在 ，清楚提示信息 document.getElementById(\"username_err\").style.display = 'none'; } } }; } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#332--后端实现"},{"categories":["Web"],"content":" 3.3 案例需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在 3.3.1 分析 前端完成的逻辑 给用户名输入框绑定光标失去焦点事件 onblur 发送 ajax请求，携带username参数 处理响应：是否显示提示信息 后端完成的逻辑 接收用户名 调用service查询User。此案例是为了演示前后端异步交互，所以此处我们不做业务逻辑处理 返回标记 整体流程如下： 3.3.2 后端实现在 com.ithiema.web.servlet 包中定义名为 SelectUserServlet 的servlet。代码如下： @WebServlet(\"/selectUserServlet\") public class SelectUserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户名 String username = request.getParameter(\"username\"); //2. 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用 boolean flag = true; //3. 响应标记 response.getWriter().write(\"\" + flag); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 3.3.3 前端实现将 04-资料\\1. 验证用户名案例\\1. 静态页面 下的文件整体拷贝到项目下 webapp 下。并在 register.html 页面的 body 结束标签前编写 script 标签，在该标签中实现如下逻辑 第一步：给用户名输入框绑定光标失去焦点事件 onblur //1. 给用户名输入框绑定 失去焦点事件 document.getElementById(\"username\").onblur = function () { } 第二步：发送 ajax请求，携带username参数 在 第一步 绑定的匿名函数中书写发送 ajax 请求的代码 //2. 发送ajax请求 //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2.2. 发送请求 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { //处理响应的结果 } }; 由于我们发送的是 GET 请求，所以需要在 URL 后拼接从输入框获取的用户名数据。而我们在 第一步 绑定的匿名函数中通过以下代码可以获取用户名数据 // 获取用户名的值 var username = this.value; //this ： 给谁绑定的事件，this就代表谁 而携带数据需要将 URL 修改为： xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet?username=\"+username); 第三步：处理响应：是否显示提示信息 当 this.readyState == 4 \u0026\u0026 this.status == 200 条件满足时，说明已经成功响应数据了。 此时需要判断响应的数据是否是 “true” 字符串，如果是说明用户名已经占用给出错误提示；如果不是说明用户名未被占用清除错误提示。代码如下 //判断 if(this.responseText == \"true\"){ //用户名存在，显示提示信息 document.getElementById(\"username_err\").style.display = ''; }else { //用户名不存在 ，清楚提示信息 document.getElementById(\"username_err\").style.display = 'none'; } 综上所述，前端完成代码如下： //1. 给用户名输入框绑定 失去焦点事件 document.getElementById(\"username\").onblur = function () { //2. 发送ajax请求 // 获取用户名的值 var username = this.value; //2.1. 创建核心对象 var xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2.2. 发送请求 xhttp.open(\"GET\", \"http://localhost:8080/ajax-demo/selectUserServlet?username=\"+username); xhttp.send(); //2.3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 \u0026\u0026 this.status == 200) { //alert(this.responseText); //判断 if(this.responseText == \"true\"){ //用户名存在，显示提示信息 document.getElementById(\"username_err\").style.display = ''; }else { //用户名不存在 ，清楚提示信息 document.getElementById(\"username_err\").style.display = 'none'; } } }; } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:4:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#333--前端实现"},{"categories":["Web"],"content":" 4，axiosAxios 对原生的AJAX进行封装，简化书写。 Axios官网是：https://www.axios-http.cn ","date":"2023-12-31","objectID":"/filter-listener-ajax/:5:0","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#4axios"},{"categories":["Web"],"content":" 4.1 基本使用axios 使用是比较简单的，分为以下两步： 引入 axios 的 js 文件 \u003cscript src=\"js/axios-0.18.0.js\"\u003e\u003c/script\u003e 使用axios 发送请求，并获取响应结果 发送 get 请求 axios({ method:\"get\", url:\"http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan\" }).then(function (resp){ alert(resp.data); }) 发送 post 请求 axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo1/aJAXDemo1\", data:\"username=zhangsan\" }).then(function (resp){ alert(resp.data); }); axios() 是用来发送异步请求的，小括号中使用 js 对象传递请求相关的参数： method 属性：用来设置请求方式的。取值为 get 或者 post。 url 属性：用来书写请求的资源路径。如果是 get 请求，需要将请求参数拼接到路径的后面，格式为： url?参数名=参数值\u0026参数名2=参数值2。 data 属性：作为请求体被发送的数据。也就是说如果是 post 请求的话，数据需要作为 data 属性的值。 then() 需要传递一个匿名函数。我们将 then() 中传递的匿名函数称为 ==回调函数==，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。而该回调函数中的 resp 参数是对响应的数据进行封装的对象，通过 resp.data 可以获取到响应的数据。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:5:1","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#41--基本使用"},{"categories":["Web"],"content":" 4.2 快速入门 4.2.1 后端实现定义一个用于接收请求的servlet，代码如下： @WebServlet(\"/axiosServlet\") public class AxiosServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"get...\"); //1. 接收请求参数 String username = request.getParameter(\"username\"); System.out.println(username); //2. 响应数据 response.getWriter().write(\"hello Axios~\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"post...\"); this.doGet(request, response); } } 4.2.2 前端实现 引入 js 文件 \u003cscript src=\"js/axios-0.18.0.js\"\u003e\u003c/script\u003e 发送 ajax 请求 get 请求 axios({ method:\"get\", url:\"http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan\" }).then(function (resp) { alert(resp.data); }) post 请求 axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:\"username=zhangsan\" }).then(function (resp) { alert(resp.data); }) 整体页面代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript src=\"js/axios-0.18.0.js\"\u003e\u003c/script\u003e \u003cscript\u003e //1. get /* axios({ method:\"get\", url:\"http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan\" }).then(function (resp) { alert(resp.data); })*/ //2. post 在js中{} 表示一个js对象，而这个js对象中有三个属性 axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:\"username=zhangsan\" }).then(function (resp) { alert(resp.data); }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2023-12-31","objectID":"/filter-listener-ajax/:5:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#42--快速入门"},{"categories":["Web"],"content":" 4.2 快速入门 4.2.1 后端实现定义一个用于接收请求的servlet，代码如下： @WebServlet(\"/axiosServlet\") public class AxiosServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"get...\"); //1. 接收请求参数 String username = request.getParameter(\"username\"); System.out.println(username); //2. 响应数据 response.getWriter().write(\"hello Axios~\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"post...\"); this.doGet(request, response); } } 4.2.2 前端实现 引入 js 文件 发送 ajax 请求 get 请求 axios({ method:\"get\", url:\"http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan\" }).then(function (resp) { alert(resp.data); }) post 请求 axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:\"username=zhangsan\" }).then(function (resp) { alert(resp.data); }) 整体页面代码如下： \u003c!DOCTYPE html\u003e Title ","date":"2023-12-31","objectID":"/filter-listener-ajax/:5:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#421--后端实现"},{"categories":["Web"],"content":" 4.2 快速入门 4.2.1 后端实现定义一个用于接收请求的servlet，代码如下： @WebServlet(\"/axiosServlet\") public class AxiosServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"get...\"); //1. 接收请求参数 String username = request.getParameter(\"username\"); System.out.println(username); //2. 响应数据 response.getWriter().write(\"hello Axios~\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"post...\"); this.doGet(request, response); } } 4.2.2 前端实现 引入 js 文件 发送 ajax 请求 get 请求 axios({ method:\"get\", url:\"http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan\" }).then(function (resp) { alert(resp.data); }) post 请求 axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:\"username=zhangsan\" }).then(function (resp) { alert(resp.data); }) 整体页面代码如下： \u003c!DOCTYPE html\u003e Title ","date":"2023-12-31","objectID":"/filter-listener-ajax/:5:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#422--前端实现"},{"categories":["Web"],"content":" 4.3 请求方法别名为了方便起见， Axios 已经为所有支持的请求方法提供了别名。如下： get 请求 ： axios.get(url[,config]) delete 请求 ： axios.delete(url[,config]) head 请求 ： axios.head(url[,config]) options 请求 ： axios.option(url[,config]) post 请求：axios.post(url[,data[,config]) put 请求：axios.put(url[,data[,config]) patch 请求：axios.patch(url[,data[,config]) 而我们只关注 get 请求和 post 请求。 入门案例中的 get 请求代码可以改为如下： axios.get(\"http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan\").then(function (resp) { alert(resp.data); }); 入门案例中的 post 请求代码可以改为如下： axios.post(\"http://localhost:8080/ajax-demo/axiosServlet\",\"username=zhangsan\").then(function (resp) { alert(resp.data); }) ","date":"2023-12-31","objectID":"/filter-listener-ajax/:5:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#43--请求方法别名"},{"categories":["Web"],"content":" 5，JSON","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:0","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#5json"},{"categories":["Web"],"content":" 5.1 概述==概念：JavaScript Object Notation。JavaScript 对象表示法.== 如下是 JavaScript 对象的定义格式： { name:\"zhangsan\", age:23, city:\"北京\" } 接下来我们再看看 JSON 的格式： { \"name\":\"zhangsan\", \"age\":23, \"city\":\"北京\" } 通过上面 js 对象格式和 json 格式进行对比，发现两个格式特别像。只不过 js 对象中的属性名可以使用引号（可以是单引号，也可以是双引号）；而 json 格式中的键要求必须使用双引号括起来，这是 json 格式的规定。json 格式的数据有什么作用呢？ 作用：由于其语法格式简单，层次结构鲜明，现多用于作为==数据载体==，在网络中进行数据传输。如下图所示就是服务端给浏览器响应的数据，这个数据比较简单，如果现需要将 JAVA 对象中封装的数据响应回给浏览器的话，应该以何种数据传输呢？ 大家还记得 ajax 的概念吗？ 是 ==异步的 JavaScript 和 xml==。这里的 xml就是以前进行数据传递的方式，如下： \u003cstudent\u003e \u003cname\u003e张三\u003c/name\u003e \u003cage\u003e23\u003c/age\u003e \u003ccity\u003e北京\u003c/city\u003e \u003c/student\u003e 再看 json 描述以上数据的写法： { \"name\":\"张三\", \"age\":23, \"city\":\"北京\" } 上面两种格式进行对比后就会发现 json 格式数据的简单，以及所占的字节数少等优点。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:1","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#51--概述"},{"categories":["Web"],"content":" 5.2 JSON 基础语法 5.2.1 定义格式JSON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的。 定义格式如下： var 变量名 = '{\"key\":value,\"key\":value,...}'; JSON 串的键要求必须使用双引号括起来，而值根据要表示的类型确定。value 的数据类型分为如下 数字（整数或浮点数） 字符串（使用双引号括起来） 逻辑值（true或者false） 数组（在方括号中） 对象（在花括号中） null 示例： var jsonStr = '{\"name\":\"zhangsan\",\"age\":23,\"addr\":[\"北京\",\"上海\",\"西安\"]}' 5.2.2 代码演示创建一个页面，在该页面的 \u003cscript\u003e 标签中定义json字符串 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript\u003e //1. 定义JSON字符串 var jsonStr = '{\"name\":\"zhangsan\",\"age\":23,\"addr\":[\"北京\",\"上海\",\"西安\"]}' alert(jsonStr); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 通过浏览器打开，页面效果如下图所示 现在我们需要获取到该 JSON 串中的 name 属性值，应该怎么处理呢？ 如果它是一个 js 对象，我们就可以通过 js对象.属性名 的方式来获取数据。JS 提供了一个对象 JSON ，该对象有如下两个方法： parse(str) ：将 JSON串转换为 js 对象。使用方式是： ==var jsObject = JSON.parse(jsonStr);== stringify(obj) ：将 js 对象转换为 JSON 串。使用方式是：==var jsonStr = JSON.stringify(jsObject)== 代码演示： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript\u003e //1. 定义JSON字符串 var jsonStr = '{\"name\":\"zhangsan\",\"age\":23,\"addr\":[\"北京\",\"上海\",\"西安\"]}' alert(jsonStr); //2. 将 JSON 字符串转为 JS 对象 let jsObject = JSON.parse(jsonStr); alert(jsObject) alert(jsObject.name) //3. 将 JS 对象转换为 JSON 字符串 let jsonStr2 = JSON.stringify(jsObject); alert(jsonStr2) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 5.2.3 发送异步请求携带参数后面我们使用 axios 发送请求时，如果要携带复杂的数据时都会以 JSON 格式进行传递，如下 axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:\"username=zhangsan\" }).then(function (resp) { alert(resp.data); }) 请求参数不可能由我们自己拼接字符串吧？肯定不用，可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 JSON.stringify(js对象) 转换为 JSON 串，再将该 JSON 串作为 axios 的 data 属性值进行请求参数的提交。如下： var jsObject = {name:\"张三\"}; axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data: JSON.stringify(jsObject) }).then(function (resp) { alert(resp.data); }) 而 axios 是一个很强大的工具。我们只需要将需要提交的参数封装成 js 对象，并将该 js 对象作为 axios 的 data 属性值进行，它会自动将 js 对象转换为 JSON 串进行提交。如下： var jsObject = {name:\"张三\"}; axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:jsObject //这里 axios 会将该js对象转换为 json 串的 }).then(function (resp) { alert(resp.data); }) ==注意：== js 提供的 JSON 对象我们只需要了解一下即可。因为 axios 会自动对 js 对象和 JSON 串进行想换转换。 发送异步请求时，如果请求参数是 JSON 格式，那请求方式必须是 POST。因为 JSON 串需要放在请求体中。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#52--json-基础语法"},{"categories":["Web"],"content":" 5.2 JSON 基础语法 5.2.1 定义格式JSON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的。 定义格式如下： var 变量名 = '{\"key\":value,\"key\":value,...}'; JSON 串的键要求必须使用双引号括起来，而值根据要表示的类型确定。value 的数据类型分为如下 数字（整数或浮点数） 字符串（使用双引号括起来） 逻辑值（true或者false） 数组（在方括号中） 对象（在花括号中） null 示例： var jsonStr = '{\"name\":\"zhangsan\",\"age\":23,\"addr\":[\"北京\",\"上海\",\"西安\"]}' 5.2.2 代码演示创建一个页面，在该页面的 通过浏览器打开，页面效果如下图所示 现在我们需要获取到该 JSON 串中的 name 属性值，应该怎么处理呢？ 如果它是一个 js 对象，我们就可以通过 js对象.属性名 的方式来获取数据。JS 提供了一个对象 JSON ，该对象有如下两个方法： parse(str) ：将 JSON串转换为 js 对象。使用方式是： ==var jsObject = JSON.parse(jsonStr);== stringify(obj) ：将 js 对象转换为 JSON 串。使用方式是：==var jsonStr = JSON.stringify(jsObject)== 代码演示： \u003c!DOCTYPE html\u003e Title 5.2.3 发送异步请求携带参数后面我们使用 axios 发送请求时，如果要携带复杂的数据时都会以 JSON 格式进行传递，如下 axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:\"username=zhangsan\" }).then(function (resp) { alert(resp.data); }) 请求参数不可能由我们自己拼接字符串吧？肯定不用，可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 JSON.stringify(js对象) 转换为 JSON 串，再将该 JSON 串作为 axios 的 data 属性值进行请求参数的提交。如下： var jsObject = {name:\"张三\"}; axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data: JSON.stringify(jsObject) }).then(function (resp) { alert(resp.data); }) 而 axios 是一个很强大的工具。我们只需要将需要提交的参数封装成 js 对象，并将该 js 对象作为 axios 的 data 属性值进行，它会自动将 js 对象转换为 JSON 串进行提交。如下： var jsObject = {name:\"张三\"}; axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:jsObject //这里 axios 会将该js对象转换为 json 串的 }).then(function (resp) { alert(resp.data); }) ==注意：== js 提供的 JSON 对象我们只需要了解一下即可。因为 axios 会自动对 js 对象和 JSON 串进行想换转换。 发送异步请求时，如果请求参数是 JSON 格式，那请求方式必须是 POST。因为 JSON 串需要放在请求体中。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#521--定义格式"},{"categories":["Web"],"content":" 5.2 JSON 基础语法 5.2.1 定义格式JSON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的。 定义格式如下： var 变量名 = '{\"key\":value,\"key\":value,...}'; JSON 串的键要求必须使用双引号括起来，而值根据要表示的类型确定。value 的数据类型分为如下 数字（整数或浮点数） 字符串（使用双引号括起来） 逻辑值（true或者false） 数组（在方括号中） 对象（在花括号中） null 示例： var jsonStr = '{\"name\":\"zhangsan\",\"age\":23,\"addr\":[\"北京\",\"上海\",\"西安\"]}' 5.2.2 代码演示创建一个页面，在该页面的 通过浏览器打开，页面效果如下图所示 现在我们需要获取到该 JSON 串中的 name 属性值，应该怎么处理呢？ 如果它是一个 js 对象，我们就可以通过 js对象.属性名 的方式来获取数据。JS 提供了一个对象 JSON ，该对象有如下两个方法： parse(str) ：将 JSON串转换为 js 对象。使用方式是： ==var jsObject = JSON.parse(jsonStr);== stringify(obj) ：将 js 对象转换为 JSON 串。使用方式是：==var jsonStr = JSON.stringify(jsObject)== 代码演示： \u003c!DOCTYPE html\u003e Title 5.2.3 发送异步请求携带参数后面我们使用 axios 发送请求时，如果要携带复杂的数据时都会以 JSON 格式进行传递，如下 axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:\"username=zhangsan\" }).then(function (resp) { alert(resp.data); }) 请求参数不可能由我们自己拼接字符串吧？肯定不用，可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 JSON.stringify(js对象) 转换为 JSON 串，再将该 JSON 串作为 axios 的 data 属性值进行请求参数的提交。如下： var jsObject = {name:\"张三\"}; axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data: JSON.stringify(jsObject) }).then(function (resp) { alert(resp.data); }) 而 axios 是一个很强大的工具。我们只需要将需要提交的参数封装成 js 对象，并将该 js 对象作为 axios 的 data 属性值进行，它会自动将 js 对象转换为 JSON 串进行提交。如下： var jsObject = {name:\"张三\"}; axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:jsObject //这里 axios 会将该js对象转换为 json 串的 }).then(function (resp) { alert(resp.data); }) ==注意：== js 提供的 JSON 对象我们只需要了解一下即可。因为 axios 会自动对 js 对象和 JSON 串进行想换转换。 发送异步请求时，如果请求参数是 JSON 格式，那请求方式必须是 POST。因为 JSON 串需要放在请求体中。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#522--代码演示"},{"categories":["Web"],"content":" 5.2 JSON 基础语法 5.2.1 定义格式JSON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的。 定义格式如下： var 变量名 = '{\"key\":value,\"key\":value,...}'; JSON 串的键要求必须使用双引号括起来，而值根据要表示的类型确定。value 的数据类型分为如下 数字（整数或浮点数） 字符串（使用双引号括起来） 逻辑值（true或者false） 数组（在方括号中） 对象（在花括号中） null 示例： var jsonStr = '{\"name\":\"zhangsan\",\"age\":23,\"addr\":[\"北京\",\"上海\",\"西安\"]}' 5.2.2 代码演示创建一个页面，在该页面的 通过浏览器打开，页面效果如下图所示 现在我们需要获取到该 JSON 串中的 name 属性值，应该怎么处理呢？ 如果它是一个 js 对象，我们就可以通过 js对象.属性名 的方式来获取数据。JS 提供了一个对象 JSON ，该对象有如下两个方法： parse(str) ：将 JSON串转换为 js 对象。使用方式是： ==var jsObject = JSON.parse(jsonStr);== stringify(obj) ：将 js 对象转换为 JSON 串。使用方式是：==var jsonStr = JSON.stringify(jsObject)== 代码演示： \u003c!DOCTYPE html\u003e Title 5.2.3 发送异步请求携带参数后面我们使用 axios 发送请求时，如果要携带复杂的数据时都会以 JSON 格式进行传递，如下 axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:\"username=zhangsan\" }).then(function (resp) { alert(resp.data); }) 请求参数不可能由我们自己拼接字符串吧？肯定不用，可以提前定义一个 js 对象，用来封装需要提交的参数，然后使用 JSON.stringify(js对象) 转换为 JSON 串，再将该 JSON 串作为 axios 的 data 属性值进行请求参数的提交。如下： var jsObject = {name:\"张三\"}; axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data: JSON.stringify(jsObject) }).then(function (resp) { alert(resp.data); }) 而 axios 是一个很强大的工具。我们只需要将需要提交的参数封装成 js 对象，并将该 js 对象作为 axios 的 data 属性值进行，它会自动将 js 对象转换为 JSON 串进行提交。如下： var jsObject = {name:\"张三\"}; axios({ method:\"post\", url:\"http://localhost:8080/ajax-demo/axiosServlet\", data:jsObject //这里 axios 会将该js对象转换为 json 串的 }).then(function (resp) { alert(resp.data); }) ==注意：== js 提供的 JSON 对象我们只需要了解一下即可。因为 axios 会自动对 js 对象和 JSON 串进行想换转换。 发送异步请求时，如果请求参数是 JSON 格式，那请求方式必须是 POST。因为 JSON 串需要放在请求体中。 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#523--发送异步请求携带参数"},{"categories":["Web"],"content":" 5.3 JSON串和Java对象的相互转换学习完 json 后，接下来聊聊 json 的作用。以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器。 在后端我们就需要重点学习以下两部分操作： 请求数据：JSON字符串转为Java对象 响应数据：Java对象转为JSON字符串 接下来给大家介绍一套 API，可以实现上面两部分操作。这套 API 就是 Fastjson 5.3.1 Fastjson 概述Fastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。 5.3.2 Fastjson 使用Fastjson 使用也是比较简单的，分为以下三步完成 导入坐标 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.62\u003c/version\u003e \u003c/dependency\u003e Java对象转JSON String jsonStr = JSON.toJSONString(obj); 将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。 JSON字符串转Java对象 User user = JSON.parseObject(jsonStr, User.class); 将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。 5.3.3 代码演示 引入坐标 创建一个类，专门用来测试 Java 对象和 JSON 串的相互转换，代码如下： public class FastJsonDemo { public static void main(String[] args) { //1. 将Java对象转为JSON字符串 User user = new User(); user.setId(1); user.setUsername(\"zhangsan\"); user.setPassword(\"123\"); String jsonString = JSON.toJSONString(user); System.out.println(jsonString);//{\"id\":1,\"password\":\"123\",\"username\":\"zhangsan\"} //2. 将JSON字符串转为Java对象 User u = JSON.parseObject(\"{\\\"id\\\":1,\\\"password\\\":\\\"123\\\",\\\"username\\\":\\\"zhangsan\\\"}\", User.class); System.out.println(u); } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#53--json串和java对象的相互转换"},{"categories":["Web"],"content":" 5.3 JSON串和Java对象的相互转换学习完 json 后，接下来聊聊 json 的作用。以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器。 在后端我们就需要重点学习以下两部分操作： 请求数据：JSON字符串转为Java对象 响应数据：Java对象转为JSON字符串 接下来给大家介绍一套 API，可以实现上面两部分操作。这套 API 就是 Fastjson 5.3.1 Fastjson 概述Fastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。 5.3.2 Fastjson 使用Fastjson 使用也是比较简单的，分为以下三步完成 导入坐标 com.alibaba fastjson 1.2.62 Java对象转JSON String jsonStr = JSON.toJSONString(obj); 将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。 JSON字符串转Java对象 User user = JSON.parseObject(jsonStr, User.class); 将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。 5.3.3 代码演示 引入坐标 创建一个类，专门用来测试 Java 对象和 JSON 串的相互转换，代码如下： public class FastJsonDemo { public static void main(String[] args) { //1. 将Java对象转为JSON字符串 User user = new User(); user.setId(1); user.setUsername(\"zhangsan\"); user.setPassword(\"123\"); String jsonString = JSON.toJSONString(user); System.out.println(jsonString);//{\"id\":1,\"password\":\"123\",\"username\":\"zhangsan\"} //2. 将JSON字符串转为Java对象 User u = JSON.parseObject(\"{\\\"id\\\":1,\\\"password\\\":\\\"123\\\",\\\"username\\\":\\\"zhangsan\\\"}\", User.class); System.out.println(u); } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#531--fastjson-概述"},{"categories":["Web"],"content":" 5.3 JSON串和Java对象的相互转换学习完 json 后，接下来聊聊 json 的作用。以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器。 在后端我们就需要重点学习以下两部分操作： 请求数据：JSON字符串转为Java对象 响应数据：Java对象转为JSON字符串 接下来给大家介绍一套 API，可以实现上面两部分操作。这套 API 就是 Fastjson 5.3.1 Fastjson 概述Fastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。 5.3.2 Fastjson 使用Fastjson 使用也是比较简单的，分为以下三步完成 导入坐标 com.alibaba fastjson 1.2.62 Java对象转JSON String jsonStr = JSON.toJSONString(obj); 将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。 JSON字符串转Java对象 User user = JSON.parseObject(jsonStr, User.class); 将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。 5.3.3 代码演示 引入坐标 创建一个类，专门用来测试 Java 对象和 JSON 串的相互转换，代码如下： public class FastJsonDemo { public static void main(String[] args) { //1. 将Java对象转为JSON字符串 User user = new User(); user.setId(1); user.setUsername(\"zhangsan\"); user.setPassword(\"123\"); String jsonString = JSON.toJSONString(user); System.out.println(jsonString);//{\"id\":1,\"password\":\"123\",\"username\":\"zhangsan\"} //2. 将JSON字符串转为Java对象 User u = JSON.parseObject(\"{\\\"id\\\":1,\\\"password\\\":\\\"123\\\",\\\"username\\\":\\\"zhangsan\\\"}\", User.class); System.out.println(u); } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#532--fastjson-使用"},{"categories":["Web"],"content":" 5.3 JSON串和Java对象的相互转换学习完 json 后，接下来聊聊 json 的作用。以后我们会以 json 格式的数据进行前后端交互。前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器。 在后端我们就需要重点学习以下两部分操作： 请求数据：JSON字符串转为Java对象 响应数据：Java对象转为JSON字符串 接下来给大家介绍一套 API，可以实现上面两部分操作。这套 API 就是 Fastjson 5.3.1 Fastjson 概述Fastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。 5.3.2 Fastjson 使用Fastjson 使用也是比较简单的，分为以下三步完成 导入坐标 com.alibaba fastjson 1.2.62 Java对象转JSON String jsonStr = JSON.toJSONString(obj); 将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。 JSON字符串转Java对象 User user = JSON.parseObject(jsonStr, User.class); 将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。 5.3.3 代码演示 引入坐标 创建一个类，专门用来测试 Java 对象和 JSON 串的相互转换，代码如下： public class FastJsonDemo { public static void main(String[] args) { //1. 将Java对象转为JSON字符串 User user = new User(); user.setId(1); user.setUsername(\"zhangsan\"); user.setPassword(\"123\"); String jsonString = JSON.toJSONString(user); System.out.println(jsonString);//{\"id\":1,\"password\":\"123\",\"username\":\"zhangsan\"} //2. 将JSON字符串转为Java对象 User u = JSON.parseObject(\"{\\\"id\\\":1,\\\"password\\\":\\\"123\\\",\\\"username\\\":\\\"zhangsan\\\"}\", User.class); System.out.println(u); } } ","date":"2023-12-31","objectID":"/filter-listener-ajax/:6:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#533--代码演示"},{"categories":["Web"],"content":" 6，案例","date":"2023-12-31","objectID":"/filter-listener-ajax/:7:0","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#6案例"},{"categories":["Web"],"content":" 6.1 需求使用Axios + JSON 完成品牌列表数据查询和添加。页面效果还是下图所示： ","date":"2023-12-31","objectID":"/filter-listener-ajax/:7:1","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#61--需求"},{"categories":["Web"],"content":" 6.2 查询所有功能 如上图所示就该功能的整体流程。前后端需以 JSON 格式进行数据的传递；由于此功能是查询所有的功能，前端发送 ajax 请求不需要携带参数，而后端响应数据需以如下格式的 json 数据 6.2.1 环境准备将 02-AJAX\\04-资料\\3. 品牌列表案例\\初始工程 下的 brand-demo 工程拷贝到我们自己 工作空间 ，然后再将项目导入到我们自己的 Idea 中。工程目录结构如下： ==注意：== 在给定的原始工程中已经给定一些代码。而在此案例中我们只关注前后端交互代码实现 要根据自己的数据库环境去修改连接数据库的信息，在 mybatis-config.xml 核心配置文件中修改 6.2.2 后端实现在 com.itheima.web 包下创建名为 SelectAllServlet 的 servlet，具体的逻辑如下： 调用 service 的 selectAll() 方法进行查询所有的逻辑处理 将查询到的集合数据转换为 json 数据。我们将此过程称为 ==序列化==；如果是将 json 数据转换为 Java 对象，我们称之为 ==反序列化== 将 json 数据响应回给浏览器。这里一定要设置响应数据的类型及字符集 response.setContentType(\"text/json;charset=utf-8\"); SelectAllServlet 代码如下： @WebServlet(\"/selectAllServlet\") public class SelectAllServlet extends HttpServlet { private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 调用Service查询 List\u003cBrand\u003e brands = brandService.selectAll(); //2. 将集合转换为JSON数据 序列化 String jsonString = JSON.toJSONString(brands); //3. 响应数据 application/json text/json response.setContentType(\"text/json;charset=utf-8\"); response.getWriter().write(jsonString); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 6.2.3 前端实现 引入 js 文件 在 brand.html 页面引入 axios 的 js 文件 \u003cscript src=\"js/axios-0.18.0.js\"\u003e\u003c/script\u003e 绑定 页面加载完毕 事件 在 brand.html 页面绑定加载完毕事件，该事件是在页面加载完毕后被触发，代码如下 window.onload = function() { } 发送异步请求 在页面加载完毕事件绑定的匿名函数中发送异步请求，代码如下： //2. 发送ajax请求 axios({ method:\"get\", url:\"http://localhost:8080/brand-demo/selectAllServlet\" }).then(function (resp) { }); 处理响应数据 在 then 中的回调函数中通过 resp.data 可以获取响应回来的数据，而数据格式如下 现在我们需要拼接字符串，将下面表格中的所有的 tr 拼接到一个字符串中，然后使用 document.getElementById(\"brandTable\").innerHTML = 拼接好的字符串 就可以动态的展示出用户想看到的数据 而表头行是固定的，所以先定义初始值是表头行数据的字符串，如下 //获取数据 let brands = resp.data; let tableData = \" \u003ctr\u003e\\n\" + \" \u003cth\u003e序号\u003c/th\u003e\\n\" + \" \u003cth\u003e品牌名称\u003c/th\u003e\\n\" + \" \u003cth\u003e企业名称\u003c/th\u003e\\n\" + \" \u003cth\u003e排序\u003c/th\u003e\\n\" + \" \u003cth\u003e品牌介绍\u003c/th\u003e\\n\" + \" \u003cth\u003e状态\u003c/th\u003e\\n\" + \" \u003cth\u003e操作\u003c/th\u003e\\n\" + \" \u003c/tr\u003e\"; 接下来遍历响应回来的数据 brands ，拿到每一条品牌数据 for (let i = 0; i \u003c brands.length ; i++) { let brand = brands[i]; } 紧接着就是从 brand 对象中获取数据并且拼接 数据行，累加到 tableData 字符串变量中 tableData += \"\\n\" + \" \u003ctr align=\\\"center\\\"\u003e\\n\" + \" \u003ctd\u003e\"+(i+1)+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.brandName+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.companyName+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.ordered+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.description+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.status+\"\u003c/td\u003e\\n\" + \"\\n\" + \" \u003ctd\u003e\u003ca href=\\\"#\\\"\u003e修改\u003c/a\u003e \u003ca href=\\\"#\\\"\u003e删除\u003c/a\u003e\u003c/td\u003e\\n\" + \" \u003c/tr\u003e\"; 最后再将拼接好的字符串写到表格中 // 设置表格数据 document.getElementById(\"brandTable\").innerHTML = tableData; 整体页面代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ca href=\"addBrand.html\"\u003e\u003cinput type=\"button\" value=\"新增\"\u003e\u003c/a\u003e\u003cbr\u003e \u003chr\u003e \u003ctable id=\"brandTable\" border=\"1\" cellspacing=\"0\" width=\"100%\"\u003e \u003c/table\u003e \u003cscript src=\"js/axios-0.18.0.js\"\u003e\u003c/script\u003e \u003cscript\u003e //1. 当页面加载完成后，发送ajax请求 window.onload = function () { //2. 发送ajax请求 axios({ method:\"get\", url:\"http://localhost:8080/brand-demo/selectAllServlet\" }).then(function (resp) { //获取数据 let brands = resp.data; let tableData = \" \u003ctr\u003e\\n\" + \" \u003cth\u003e序号\u003c/th\u003e\\n\" + \" \u003cth\u003e品牌名称\u003c/th\u003e\\n\" + \" \u003cth\u003e企业名称\u003c/th\u003e\\n\" + \" \u003cth\u003e排序\u003c/th\u003e\\n\" + \" \u003cth\u003e品牌介绍\u003c/th\u003e\\n\" + \" \u003cth\u003e状态\u003c/th\u003e\\n\" + \" \u003cth\u003e操作\u003c/th\u003e\\n\" + \" \u003c/tr\u003e\"; for (let i = 0; i \u003c brands.length ; i++) { let brand = brands[i]; tableData += \"\\n\" + \" \u003ctr align=\\\"center\\\"\u003e\\n\" + \" \u003ctd\u003e\"+(i+1)+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.brandName+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.companyName+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.ordered+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.description+\"\u003c/td\u003e\\n\" + \" \u003ctd\u003e\"+brand.status+\"\u003c/td\u003e\\n\" + \"\\n\" + \" \u003ctd\u003e\u003ca href=\\\"#\\\"\u003e修改\u003c/a\u003e \u003ca href=\\\"#\\\"\u003e删除\u003c/a\u003e\u003c/td\u003e\\n\" + \" \u003c/tr\u003e\"; } // 设置表格数据 document.getElementById(\"brandTable\").innerHTML = tableData; }) } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2023-12-31","objectID":"/filter-listener-ajax/:7:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#62--查询所有功能"},{"categories":["Web"],"content":" 6.2 查询所有功能 如上图所示就该功能的整体流程。前后端需以 JSON 格式进行数据的传递；由于此功能是查询所有的功能，前端发送 ajax 请求不需要携带参数，而后端响应数据需以如下格式的 json 数据 6.2.1 环境准备将 02-AJAX\\04-资料\\3. 品牌列表案例\\初始工程 下的 brand-demo 工程拷贝到我们自己 工作空间 ，然后再将项目导入到我们自己的 Idea 中。工程目录结构如下： ==注意：== 在给定的原始工程中已经给定一些代码。而在此案例中我们只关注前后端交互代码实现 要根据自己的数据库环境去修改连接数据库的信息，在 mybatis-config.xml 核心配置文件中修改 6.2.2 后端实现在 com.itheima.web 包下创建名为 SelectAllServlet 的 servlet，具体的逻辑如下： 调用 service 的 selectAll() 方法进行查询所有的逻辑处理 将查询到的集合数据转换为 json 数据。我们将此过程称为 ==序列化==；如果是将 json 数据转换为 Java 对象，我们称之为 ==反序列化== 将 json 数据响应回给浏览器。这里一定要设置响应数据的类型及字符集 response.setContentType(\"text/json;charset=utf-8\"); SelectAllServlet 代码如下： @WebServlet(\"/selectAllServlet\") public class SelectAllServlet extends HttpServlet { private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 调用Service查询 List brands = brandService.selectAll(); //2. 将集合转换为JSON数据 序列化 String jsonString = JSON.toJSONString(brands); //3. 响应数据 application/json text/json response.setContentType(\"text/json;charset=utf-8\"); response.getWriter().write(jsonString); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 6.2.3 前端实现 引入 js 文件 在 brand.html 页面引入 axios 的 js 文件 绑定 页面加载完毕 事件 在 brand.html 页面绑定加载完毕事件，该事件是在页面加载完毕后被触发，代码如下 window.onload = function() { } 发送异步请求 在页面加载完毕事件绑定的匿名函数中发送异步请求，代码如下： //2. 发送ajax请求 axios({ method:\"get\", url:\"http://localhost:8080/brand-demo/selectAllServlet\" }).then(function (resp) { }); 处理响应数据 在 then 中的回调函数中通过 resp.data 可以获取响应回来的数据，而数据格式如下 现在我们需要拼接字符串，将下面表格中的所有的 tr 拼接到一个字符串中，然后使用 document.getElementById(\"brandTable\").innerHTML = 拼接好的字符串 就可以动态的展示出用户想看到的数据 而表头行是固定的，所以先定义初始值是表头行数据的字符串，如下 //获取数据 let brands = resp.data; let tableData = \" \\n\" + \" 序号\\n\" + \" 品牌名称\\n\" + \" 企业名称\\n\" + \" 排序\\n\" + \" 品牌介绍\\n\" + \" 状态\\n\" + \" 操作\\n\" + \" \"; 接下来遍历响应回来的数据 brands ，拿到每一条品牌数据 for (let i = 0; i \u003c brands.length ; i++) { let brand = brands[i]; } 紧接着就是从 brand 对象中获取数据并且拼接 数据行，累加到 tableData 字符串变量中 tableData += \"\\n\" + \" \\n\" + \" \"+(i+1)+\"\\n\" + \" \"+brand.brandName+\"\\n\" + \" \"+brand.companyName+\"\\n\" + \" \"+brand.ordered+\"\\n\" + \" \"+brand.description+\"\\n\" + \" \"+brand.status+\"\\n\" + \"\\n\" + \" 修改 删除\\n\" + \" \"; 最后再将拼接好的字符串写到表格中 // 设置表格数据 document.getElementById(\"brandTable\").innerHTML = tableData; 整体页面代码如下： \u003c!DOCTYPE html\u003e Title ","date":"2023-12-31","objectID":"/filter-listener-ajax/:7:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#621--环境准备"},{"categories":["Web"],"content":" 6.2 查询所有功能 如上图所示就该功能的整体流程。前后端需以 JSON 格式进行数据的传递；由于此功能是查询所有的功能，前端发送 ajax 请求不需要携带参数，而后端响应数据需以如下格式的 json 数据 6.2.1 环境准备将 02-AJAX\\04-资料\\3. 品牌列表案例\\初始工程 下的 brand-demo 工程拷贝到我们自己 工作空间 ，然后再将项目导入到我们自己的 Idea 中。工程目录结构如下： ==注意：== 在给定的原始工程中已经给定一些代码。而在此案例中我们只关注前后端交互代码实现 要根据自己的数据库环境去修改连接数据库的信息，在 mybatis-config.xml 核心配置文件中修改 6.2.2 后端实现在 com.itheima.web 包下创建名为 SelectAllServlet 的 servlet，具体的逻辑如下： 调用 service 的 selectAll() 方法进行查询所有的逻辑处理 将查询到的集合数据转换为 json 数据。我们将此过程称为 ==序列化==；如果是将 json 数据转换为 Java 对象，我们称之为 ==反序列化== 将 json 数据响应回给浏览器。这里一定要设置响应数据的类型及字符集 response.setContentType(\"text/json;charset=utf-8\"); SelectAllServlet 代码如下： @WebServlet(\"/selectAllServlet\") public class SelectAllServlet extends HttpServlet { private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 调用Service查询 List brands = brandService.selectAll(); //2. 将集合转换为JSON数据 序列化 String jsonString = JSON.toJSONString(brands); //3. 响应数据 application/json text/json response.setContentType(\"text/json;charset=utf-8\"); response.getWriter().write(jsonString); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 6.2.3 前端实现 引入 js 文件 在 brand.html 页面引入 axios 的 js 文件 绑定 页面加载完毕 事件 在 brand.html 页面绑定加载完毕事件，该事件是在页面加载完毕后被触发，代码如下 window.onload = function() { } 发送异步请求 在页面加载完毕事件绑定的匿名函数中发送异步请求，代码如下： //2. 发送ajax请求 axios({ method:\"get\", url:\"http://localhost:8080/brand-demo/selectAllServlet\" }).then(function (resp) { }); 处理响应数据 在 then 中的回调函数中通过 resp.data 可以获取响应回来的数据，而数据格式如下 现在我们需要拼接字符串，将下面表格中的所有的 tr 拼接到一个字符串中，然后使用 document.getElementById(\"brandTable\").innerHTML = 拼接好的字符串 就可以动态的展示出用户想看到的数据 而表头行是固定的，所以先定义初始值是表头行数据的字符串，如下 //获取数据 let brands = resp.data; let tableData = \" \\n\" + \" 序号\\n\" + \" 品牌名称\\n\" + \" 企业名称\\n\" + \" 排序\\n\" + \" 品牌介绍\\n\" + \" 状态\\n\" + \" 操作\\n\" + \" \"; 接下来遍历响应回来的数据 brands ，拿到每一条品牌数据 for (let i = 0; i \u003c brands.length ; i++) { let brand = brands[i]; } 紧接着就是从 brand 对象中获取数据并且拼接 数据行，累加到 tableData 字符串变量中 tableData += \"\\n\" + \" \\n\" + \" \"+(i+1)+\"\\n\" + \" \"+brand.brandName+\"\\n\" + \" \"+brand.companyName+\"\\n\" + \" \"+brand.ordered+\"\\n\" + \" \"+brand.description+\"\\n\" + \" \"+brand.status+\"\\n\" + \"\\n\" + \" 修改 删除\\n\" + \" \"; 最后再将拼接好的字符串写到表格中 // 设置表格数据 document.getElementById(\"brandTable\").innerHTML = tableData; 整体页面代码如下： \u003c!DOCTYPE html\u003e Title ","date":"2023-12-31","objectID":"/filter-listener-ajax/:7:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#622--后端实现"},{"categories":["Web"],"content":" 6.2 查询所有功能 如上图所示就该功能的整体流程。前后端需以 JSON 格式进行数据的传递；由于此功能是查询所有的功能，前端发送 ajax 请求不需要携带参数，而后端响应数据需以如下格式的 json 数据 6.2.1 环境准备将 02-AJAX\\04-资料\\3. 品牌列表案例\\初始工程 下的 brand-demo 工程拷贝到我们自己 工作空间 ，然后再将项目导入到我们自己的 Idea 中。工程目录结构如下： ==注意：== 在给定的原始工程中已经给定一些代码。而在此案例中我们只关注前后端交互代码实现 要根据自己的数据库环境去修改连接数据库的信息，在 mybatis-config.xml 核心配置文件中修改 6.2.2 后端实现在 com.itheima.web 包下创建名为 SelectAllServlet 的 servlet，具体的逻辑如下： 调用 service 的 selectAll() 方法进行查询所有的逻辑处理 将查询到的集合数据转换为 json 数据。我们将此过程称为 ==序列化==；如果是将 json 数据转换为 Java 对象，我们称之为 ==反序列化== 将 json 数据响应回给浏览器。这里一定要设置响应数据的类型及字符集 response.setContentType(\"text/json;charset=utf-8\"); SelectAllServlet 代码如下： @WebServlet(\"/selectAllServlet\") public class SelectAllServlet extends HttpServlet { private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 调用Service查询 List brands = brandService.selectAll(); //2. 将集合转换为JSON数据 序列化 String jsonString = JSON.toJSONString(brands); //3. 响应数据 application/json text/json response.setContentType(\"text/json;charset=utf-8\"); response.getWriter().write(jsonString); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 6.2.3 前端实现 引入 js 文件 在 brand.html 页面引入 axios 的 js 文件 绑定 页面加载完毕 事件 在 brand.html 页面绑定加载完毕事件，该事件是在页面加载完毕后被触发，代码如下 window.onload = function() { } 发送异步请求 在页面加载完毕事件绑定的匿名函数中发送异步请求，代码如下： //2. 发送ajax请求 axios({ method:\"get\", url:\"http://localhost:8080/brand-demo/selectAllServlet\" }).then(function (resp) { }); 处理响应数据 在 then 中的回调函数中通过 resp.data 可以获取响应回来的数据，而数据格式如下 现在我们需要拼接字符串，将下面表格中的所有的 tr 拼接到一个字符串中，然后使用 document.getElementById(\"brandTable\").innerHTML = 拼接好的字符串 就可以动态的展示出用户想看到的数据 而表头行是固定的，所以先定义初始值是表头行数据的字符串，如下 //获取数据 let brands = resp.data; let tableData = \" \\n\" + \" 序号\\n\" + \" 品牌名称\\n\" + \" 企业名称\\n\" + \" 排序\\n\" + \" 品牌介绍\\n\" + \" 状态\\n\" + \" 操作\\n\" + \" \"; 接下来遍历响应回来的数据 brands ，拿到每一条品牌数据 for (let i = 0; i \u003c brands.length ; i++) { let brand = brands[i]; } 紧接着就是从 brand 对象中获取数据并且拼接 数据行，累加到 tableData 字符串变量中 tableData += \"\\n\" + \" \\n\" + \" \"+(i+1)+\"\\n\" + \" \"+brand.brandName+\"\\n\" + \" \"+brand.companyName+\"\\n\" + \" \"+brand.ordered+\"\\n\" + \" \"+brand.description+\"\\n\" + \" \"+brand.status+\"\\n\" + \"\\n\" + \" 修改 删除\\n\" + \" \"; 最后再将拼接好的字符串写到表格中 // 设置表格数据 document.getElementById(\"brandTable\").innerHTML = tableData; 整体页面代码如下： \u003c!DOCTYPE html\u003e Title ","date":"2023-12-31","objectID":"/filter-listener-ajax/:7:2","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#623--前端实现"},{"categories":["Web"],"content":" 6.3 添加品牌功能 如上所示，当我们点击 新增 按钮，会跳转到 addBrand.html 页面。在 addBrand.html 页面输入数据后点击 提交 按钮，就会将数据提交到后端，而后端将数据保存到数据库中。 具体的前后端交互的流程如下： ==说明：== 前端需要将用户输入的数据提交到后端，这部分数据需要以 json 格式进行提交，数据格式如下： 6.3.1 后端实现在 com.itheima.web 包下创建名为 AddServlet 的 servlet，具体的逻辑如下： 获取请求参数 由于前端提交的是 json 格式的数据，所以我们不能使用 request.getParameter() 方法获取请求参数 如果提交的数据格式是 username=zhangsan\u0026age=23 ，后端就可以使用 request.getParameter() 方法获取 如果提交的数据格式是 json，后端就需要通过 request 对象获取输入流，再通过输入流读取数据 将获取到的请求参数（json格式的数据）转换为 Brand 对象 调用 service 的 add() 方法进行添加数据的逻辑处理 将 json 数据响应回给浏览器。 AddServlet 代码如下： @WebServlet(\"/addServlet\") public class AddServlet extends HttpServlet { private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收数据,request.getParameter 不能接收json的数据 /* String brandName = request.getParameter(\"brandName\"); System.out.println(brandName);*/ // 获取请求体数据 BufferedReader br = request.getReader(); String params = br.readLine(); // 将JSON字符串转为Java对象 Brand brand = JSON.parseObject(params, Brand.class); //2. 调用service 添加 brandService.add(brand); //3. 响应成功标识 response.getWriter().write(\"success\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 6.3.2 前端实现在 addBrand.html 页面给 提交 按钮绑定点击事件，并在绑定的匿名函数中发送异步请求，代码如下： //1. 给按钮绑定单击事件 document.getElementById(\"btn\").onclick = function () { //2. 发送ajax请求 axios({ method:\"post\", url:\"http://localhost:8080/brand-demo/addServlet\", data:??? }).then(function (resp) { // 判断响应数据是否为 success if(resp.data == \"success\"){ location.href = \"http://localhost:8080/brand-demo/brand.html\"; } }) } 现在我们只需要考虑如何获取页面上用户输入的数据即可。 首先我们先定义如下的一个 js 对象，该对象是用来封装页面上输入的数据，并将该对象作为上面发送异步请求时 data 属性的值。 // 将表单数据转为json var formData = { brandName:\"\", companyName:\"\", ordered:\"\", description:\"\", status:\"\", }; 接下来获取输入框输入的数据，并将获取到的数据赋值给 formData 对象指定的属性。比如获取用户名的输入框数据，并把该数据赋值给 formData 对象的 brandName 属性 // 获取表单数据 let brandName = document.getElementById(\"brandName\").value; // 设置数据 formData.brandName = brandName; ==说明：其他的输入框都用同样的方式获取并赋值。==但是有一个比较特殊，就是状态数据，如下图是页面内容 我们需要判断哪儿个被选中，再将选中的单选框数据赋值给 formData 对象的 status 属性，代码实现如下： let status = document.getElementsByName(\"status\"); for (let i = 0; i \u003c status.length; i++) { if(status[i].checked){ // formData.status = status[i].value ; } } 整体页面代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e添加品牌\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch3\u003e添加品牌\u003c/h3\u003e \u003cform action=\"\" method=\"post\"\u003e 品牌名称：\u003cinput id=\"brandName\" name=\"brandName\"\u003e\u003cbr\u003e 企业名称：\u003cinput id=\"companyName\" name=\"companyName\"\u003e\u003cbr\u003e 排序：\u003cinput id=\"ordered\" name=\"ordered\"\u003e\u003cbr\u003e 描述信息：\u003ctextarea rows=\"5\" cols=\"20\" id=\"description\" name=\"description\"\u003e\u003c/textarea\u003e\u003cbr\u003e 状态： \u003cinput type=\"radio\" name=\"status\" value=\"0\"\u003e禁用 \u003cinput type=\"radio\" name=\"status\" value=\"1\"\u003e启用\u003cbr\u003e \u003cinput type=\"button\" id=\"btn\" value=\"提交\"\u003e \u003c/form\u003e \u003cscript src=\"js/axios-0.18.0.js\"\u003e\u003c/script\u003e \u003cscript\u003e //1. 给按钮绑定单击事件 document.getElementById(\"btn\").onclick = function () { // 将表单数据转为json var formData = { brandName:\"\", companyName:\"\", ordered:\"\", description:\"\", status:\"\", }; // 获取表单数据 let brandName = document.getElementById(\"brandName\").value; // 设置数据 formData.brandName = brandName; // 获取表单数据 let companyName = document.getElementById(\"companyName\").value; // 设置数据 formData.companyName = companyName; // 获取表单数据 let ordered = document.getElementById(\"ordered\").value; // 设置数据 formData.ordered = ordered; // 获取表单数据 let description = document.getElementById(\"description\").value; // 设置数据 formData.description = description; let status = document.getElementsByName(\"status\"); for (let i = 0; i \u003c status.length; i++) { if(status[i].checked){ // formData.status = status[i].value ; } } //console.log(formData); //2. 发送ajax请求 axios({ method:\"post\", url:\"http://localhost:8080/brand-demo/addServlet\", data:formData }).then(function (resp) { // 判断响应数据是否为 success if(resp.data == \"success\"){ location.href = \"http://localhost:8080/bran","date":"2023-12-31","objectID":"/filter-listener-ajax/:7:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#63--添加品牌功能"},{"categories":["Web"],"content":" 6.3 添加品牌功能 如上所示，当我们点击 新增 按钮，会跳转到 addBrand.html 页面。在 addBrand.html 页面输入数据后点击 提交 按钮，就会将数据提交到后端，而后端将数据保存到数据库中。 具体的前后端交互的流程如下： ==说明：== 前端需要将用户输入的数据提交到后端，这部分数据需要以 json 格式进行提交，数据格式如下： 6.3.1 后端实现在 com.itheima.web 包下创建名为 AddServlet 的 servlet，具体的逻辑如下： 获取请求参数 由于前端提交的是 json 格式的数据，所以我们不能使用 request.getParameter() 方法获取请求参数 如果提交的数据格式是 username=zhangsan\u0026age=23 ，后端就可以使用 request.getParameter() 方法获取 如果提交的数据格式是 json，后端就需要通过 request 对象获取输入流，再通过输入流读取数据 将获取到的请求参数（json格式的数据）转换为 Brand 对象 调用 service 的 add() 方法进行添加数据的逻辑处理 将 json 数据响应回给浏览器。 AddServlet 代码如下： @WebServlet(\"/addServlet\") public class AddServlet extends HttpServlet { private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收数据,request.getParameter 不能接收json的数据 /* String brandName = request.getParameter(\"brandName\"); System.out.println(brandName);*/ // 获取请求体数据 BufferedReader br = request.getReader(); String params = br.readLine(); // 将JSON字符串转为Java对象 Brand brand = JSON.parseObject(params, Brand.class); //2. 调用service 添加 brandService.add(brand); //3. 响应成功标识 response.getWriter().write(\"success\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 6.3.2 前端实现在 addBrand.html 页面给 提交 按钮绑定点击事件，并在绑定的匿名函数中发送异步请求，代码如下： //1. 给按钮绑定单击事件 document.getElementById(\"btn\").onclick = function () { //2. 发送ajax请求 axios({ method:\"post\", url:\"http://localhost:8080/brand-demo/addServlet\", data:??? }).then(function (resp) { // 判断响应数据是否为 success if(resp.data == \"success\"){ location.href = \"http://localhost:8080/brand-demo/brand.html\"; } }) } 现在我们只需要考虑如何获取页面上用户输入的数据即可。 首先我们先定义如下的一个 js 对象，该对象是用来封装页面上输入的数据，并将该对象作为上面发送异步请求时 data 属性的值。 // 将表单数据转为json var formData = { brandName:\"\", companyName:\"\", ordered:\"\", description:\"\", status:\"\", }; 接下来获取输入框输入的数据，并将获取到的数据赋值给 formData 对象指定的属性。比如获取用户名的输入框数据，并把该数据赋值给 formData 对象的 brandName 属性 // 获取表单数据 let brandName = document.getElementById(\"brandName\").value; // 设置数据 formData.brandName = brandName; ==说明：其他的输入框都用同样的方式获取并赋值。==但是有一个比较特殊，就是状态数据，如下图是页面内容 我们需要判断哪儿个被选中，再将选中的单选框数据赋值给 formData 对象的 status 属性，代码实现如下： let status = document.getElementsByName(\"status\"); for (let i = 0; i \u003c status.length; i++) { if(status[i].checked){ // formData.status = status[i].value ; } } 整体页面代码如下： \u003c!DOCTYPE html\u003e 添加品牌 添加品牌 品牌名称： 企业名称： 排序： 描述信息： 状态： 禁用 启用 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:7:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#631--后端实现"},{"categories":["Web"],"content":" 6.3 添加品牌功能 如上所示，当我们点击 新增 按钮，会跳转到 addBrand.html 页面。在 addBrand.html 页面输入数据后点击 提交 按钮，就会将数据提交到后端，而后端将数据保存到数据库中。 具体的前后端交互的流程如下： ==说明：== 前端需要将用户输入的数据提交到后端，这部分数据需要以 json 格式进行提交，数据格式如下： 6.3.1 后端实现在 com.itheima.web 包下创建名为 AddServlet 的 servlet，具体的逻辑如下： 获取请求参数 由于前端提交的是 json 格式的数据，所以我们不能使用 request.getParameter() 方法获取请求参数 如果提交的数据格式是 username=zhangsan\u0026age=23 ，后端就可以使用 request.getParameter() 方法获取 如果提交的数据格式是 json，后端就需要通过 request 对象获取输入流，再通过输入流读取数据 将获取到的请求参数（json格式的数据）转换为 Brand 对象 调用 service 的 add() 方法进行添加数据的逻辑处理 将 json 数据响应回给浏览器。 AddServlet 代码如下： @WebServlet(\"/addServlet\") public class AddServlet extends HttpServlet { private BrandService brandService = new BrandService(); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收数据,request.getParameter 不能接收json的数据 /* String brandName = request.getParameter(\"brandName\"); System.out.println(brandName);*/ // 获取请求体数据 BufferedReader br = request.getReader(); String params = br.readLine(); // 将JSON字符串转为Java对象 Brand brand = JSON.parseObject(params, Brand.class); //2. 调用service 添加 brandService.add(brand); //3. 响应成功标识 response.getWriter().write(\"success\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 6.3.2 前端实现在 addBrand.html 页面给 提交 按钮绑定点击事件，并在绑定的匿名函数中发送异步请求，代码如下： //1. 给按钮绑定单击事件 document.getElementById(\"btn\").onclick = function () { //2. 发送ajax请求 axios({ method:\"post\", url:\"http://localhost:8080/brand-demo/addServlet\", data:??? }).then(function (resp) { // 判断响应数据是否为 success if(resp.data == \"success\"){ location.href = \"http://localhost:8080/brand-demo/brand.html\"; } }) } 现在我们只需要考虑如何获取页面上用户输入的数据即可。 首先我们先定义如下的一个 js 对象，该对象是用来封装页面上输入的数据，并将该对象作为上面发送异步请求时 data 属性的值。 // 将表单数据转为json var formData = { brandName:\"\", companyName:\"\", ordered:\"\", description:\"\", status:\"\", }; 接下来获取输入框输入的数据，并将获取到的数据赋值给 formData 对象指定的属性。比如获取用户名的输入框数据，并把该数据赋值给 formData 对象的 brandName 属性 // 获取表单数据 let brandName = document.getElementById(\"brandName\").value; // 设置数据 formData.brandName = brandName; ==说明：其他的输入框都用同样的方式获取并赋值。==但是有一个比较特殊，就是状态数据，如下图是页面内容 我们需要判断哪儿个被选中，再将选中的单选框数据赋值给 formData 对象的 status 属性，代码实现如下： let status = document.getElementsByName(\"status\"); for (let i = 0; i \u003c status.length; i++) { if(status[i].checked){ // formData.status = status[i].value ; } } 整体页面代码如下： \u003c!DOCTYPE html\u003e 添加品牌 添加品牌 品牌名称： 企业名称： 排序： 描述信息： 状态： 禁用 启用 ","date":"2023-12-31","objectID":"/filter-listener-ajax/:7:3","series":null,"tags":["Web"],"title":"Filter Listener Ajax","uri":"/filter-listener-ajax/#632--前端实现"},{"categories":["Web"],"content":" 1，Web概述","date":"2023-12-31","objectID":"/servlet-tomcat/:1:0","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#1web概述"},{"categories":["Web"],"content":" 1.1 Web和JavaWeb的概念==Web是全球广域网，也称为万维网(www)，能够通过浏览器访问的网站。== 在我们日常的生活中，经常会使用浏览器去访问百度、京东、传智官网等这些网站，这些网站统称为Web网站。如下就是通过浏览器访问传智官网的界面: 我们知道了什么是Web，那么JavaWeb又是什么呢？顾名思义==JavaWeb就是用Java技术来解决相关web互联网领域的技术栈。== 等学习完JavaWeb之后，同学们就可以使用Java语言开发我们上述所说的网站。而国内很多大型网站公司也是首选Java语言来解决web互联网相关的问题。那都有哪些公司的系统是使用Java语言的呢? 使用Java语言开发互联网系统是有很多技术栈需要大家了解，具体都有哪些呢? ","date":"2023-12-31","objectID":"/servlet-tomcat/:1:1","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#11-web和javaweb的概念"},{"categories":["Web"],"content":" 1.2 JavaWeb技术栈了解JavaWeb技术栈之前，有一个很重要的概念要介绍。 1.2.1 B/S架构什么是B/S架构? B/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程: 打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容 思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的 日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容 所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。 了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢? 1.2.2 静态资源 静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。 我们之前已经学过前端网页制作三剑客(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。 在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果: 张三登录以后在网页的右上角看到的是 张三，而李四登录以后看到的则是李四。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。 1.2.3 动态资源 动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。 动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。 动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入用户名和密码,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢? 1.2.4 数据库 数据库主要负责存储数据。 整个Web的访问过程就如下图所示: (1)浏览器发送一个请求到服务端，去请求所需要的相关资源; (2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容; (3)在Java代码可以进行业务处理也可以从数据库中读取数据; (4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好; (5)服务端将静态资源响应给浏览器; (6)浏览器将这些资源进行解析; (7)解析后将效果展示在浏览器，用户就可以看到最终的结果。 在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢? 1.2.5 HTTP协议 HTTP协议:主要定义通信规则 浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。 1.2.6 Web服务器 Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据 浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器 Web服务器软件有很多，我们课程中将学习的是目前最为常用的==Tomcat==服务器 到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:1:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#12-javaweb技术栈"},{"categories":["Web"],"content":" 1.2 JavaWeb技术栈了解JavaWeb技术栈之前，有一个很重要的概念要介绍。 1.2.1 B/S架构什么是B/S架构? B/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程: 打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容 思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的 日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容 所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。 了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢? 1.2.2 静态资源 静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。 我们之前已经学过前端网页制作三剑客(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。 在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果: 张三登录以后在网页的右上角看到的是 张三，而李四登录以后看到的则是李四。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。 1.2.3 动态资源 动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。 动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。 动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入用户名和密码,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢? 1.2.4 数据库 数据库主要负责存储数据。 整个Web的访问过程就如下图所示: (1)浏览器发送一个请求到服务端，去请求所需要的相关资源; (2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容; (3)在Java代码可以进行业务处理也可以从数据库中读取数据; (4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好; (5)服务端将静态资源响应给浏览器; (6)浏览器将这些资源进行解析; (7)解析后将效果展示在浏览器，用户就可以看到最终的结果。 在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢? 1.2.5 HTTP协议 HTTP协议:主要定义通信规则 浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。 1.2.6 Web服务器 Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据 浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器 Web服务器软件有很多，我们课程中将学习的是目前最为常用的==Tomcat==服务器 到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:1:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#121-bs架构"},{"categories":["Web"],"content":" 1.2 JavaWeb技术栈了解JavaWeb技术栈之前，有一个很重要的概念要介绍。 1.2.1 B/S架构什么是B/S架构? B/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程: 打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容 思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的 日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容 所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。 了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢? 1.2.2 静态资源 静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。 我们之前已经学过前端网页制作三剑客(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。 在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果: 张三登录以后在网页的右上角看到的是 张三，而李四登录以后看到的则是李四。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。 1.2.3 动态资源 动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。 动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。 动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入用户名和密码,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢? 1.2.4 数据库 数据库主要负责存储数据。 整个Web的访问过程就如下图所示: (1)浏览器发送一个请求到服务端，去请求所需要的相关资源; (2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容; (3)在Java代码可以进行业务处理也可以从数据库中读取数据; (4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好; (5)服务端将静态资源响应给浏览器; (6)浏览器将这些资源进行解析; (7)解析后将效果展示在浏览器，用户就可以看到最终的结果。 在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢? 1.2.5 HTTP协议 HTTP协议:主要定义通信规则 浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。 1.2.6 Web服务器 Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据 浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器 Web服务器软件有很多，我们课程中将学习的是目前最为常用的==Tomcat==服务器 到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:1:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#122-静态资源"},{"categories":["Web"],"content":" 1.2 JavaWeb技术栈了解JavaWeb技术栈之前，有一个很重要的概念要介绍。 1.2.1 B/S架构什么是B/S架构? B/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程: 打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容 思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的 日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容 所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。 了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢? 1.2.2 静态资源 静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。 我们之前已经学过前端网页制作三剑客(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。 在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果: 张三登录以后在网页的右上角看到的是 张三，而李四登录以后看到的则是李四。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。 1.2.3 动态资源 动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。 动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。 动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入用户名和密码,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢? 1.2.4 数据库 数据库主要负责存储数据。 整个Web的访问过程就如下图所示: (1)浏览器发送一个请求到服务端，去请求所需要的相关资源; (2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容; (3)在Java代码可以进行业务处理也可以从数据库中读取数据; (4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好; (5)服务端将静态资源响应给浏览器; (6)浏览器将这些资源进行解析; (7)解析后将效果展示在浏览器，用户就可以看到最终的结果。 在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢? 1.2.5 HTTP协议 HTTP协议:主要定义通信规则 浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。 1.2.6 Web服务器 Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据 浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器 Web服务器软件有很多，我们课程中将学习的是目前最为常用的==Tomcat==服务器 到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:1:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#123-动态资源"},{"categories":["Web"],"content":" 1.2 JavaWeb技术栈了解JavaWeb技术栈之前，有一个很重要的概念要介绍。 1.2.1 B/S架构什么是B/S架构? B/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程: 打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容 思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的 日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容 所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。 了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢? 1.2.2 静态资源 静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。 我们之前已经学过前端网页制作三剑客(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。 在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果: 张三登录以后在网页的右上角看到的是 张三，而李四登录以后看到的则是李四。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。 1.2.3 动态资源 动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。 动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。 动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入用户名和密码,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢? 1.2.4 数据库 数据库主要负责存储数据。 整个Web的访问过程就如下图所示: (1)浏览器发送一个请求到服务端，去请求所需要的相关资源; (2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容; (3)在Java代码可以进行业务处理也可以从数据库中读取数据; (4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好; (5)服务端将静态资源响应给浏览器; (6)浏览器将这些资源进行解析; (7)解析后将效果展示在浏览器，用户就可以看到最终的结果。 在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢? 1.2.5 HTTP协议 HTTP协议:主要定义通信规则 浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。 1.2.6 Web服务器 Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据 浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器 Web服务器软件有很多，我们课程中将学习的是目前最为常用的==Tomcat==服务器 到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:1:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#124-数据库"},{"categories":["Web"],"content":" 1.2 JavaWeb技术栈了解JavaWeb技术栈之前，有一个很重要的概念要介绍。 1.2.1 B/S架构什么是B/S架构? B/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程: 打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容 思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的 日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容 所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。 了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢? 1.2.2 静态资源 静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。 我们之前已经学过前端网页制作三剑客(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。 在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果: 张三登录以后在网页的右上角看到的是 张三，而李四登录以后看到的则是李四。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。 1.2.3 动态资源 动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。 动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。 动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入用户名和密码,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢? 1.2.4 数据库 数据库主要负责存储数据。 整个Web的访问过程就如下图所示: (1)浏览器发送一个请求到服务端，去请求所需要的相关资源; (2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容; (3)在Java代码可以进行业务处理也可以从数据库中读取数据; (4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好; (5)服务端将静态资源响应给浏览器; (6)浏览器将这些资源进行解析; (7)解析后将效果展示在浏览器，用户就可以看到最终的结果。 在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢? 1.2.5 HTTP协议 HTTP协议:主要定义通信规则 浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。 1.2.6 Web服务器 Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据 浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器 Web服务器软件有很多，我们课程中将学习的是目前最为常用的==Tomcat==服务器 到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:1:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#125-http协议"},{"categories":["Web"],"content":" 1.2 JavaWeb技术栈了解JavaWeb技术栈之前，有一个很重要的概念要介绍。 1.2.1 B/S架构什么是B/S架构? B/S 架构：Browser/Server，浏览器/服务器 架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。大家可以通过下面这张图来回想下我们平常的上网过程: 打开浏览器访问百度首页，输入要搜索的内容，点击回车或百度一下，就可以获取和搜索相关的内容 思考下搜索的内容并不在我们自己的点上，那么这些内容从何而来？答案很明显是从百度服务器返回给我们的 日常百度的小细节，逢年过节百度的logo会更换不同的图片，服务端发生变化，客户端不需做任务事情就能获取最新内容 所以说B/S架构的好处:易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本。 了解了什么是B/S架构后，作为后台开发工程师的我们将来主要关注的是服务端的开发和维护工作。在服务端将来会放很多资源,都有哪些资源呢? 1.2.2 静态资源 静态资源主要包含HTML、CSS、JavaScript、图片等，主要负责页面的展示。 我们之前已经学过前端网页制作三剑客(HTML+CSS+JavaScript),使用这些技术我们就可以制作出效果比较丰富的网页，将来展现给用户。但是由于做出来的这些内容都是静态的，这就会导致所有的人看到的内容将是一模一样。 在日常上网的过程中，我们除了看到这些好看的页面以外，还会碰到很多动态内容，比如我们常见的百度登录效果: 张三登录以后在网页的右上角看到的是 张三，而李四登录以后看到的则是李四。所以不同的用户访问相同的资源看到的内容大多数是不一样的，要想实现这样的效果，光靠静态资源是无法实现的。 1.2.3 动态资源 动态资源主要包含Servlet、JSP等，主要用来负责逻辑处理。 动态资源处理完逻辑后会把得到的结果交给静态资源来进行展示，动态资源和静态资源要结合一起使用。 动态资源虽然可以处理逻辑，但是当用户来登录百度的时候，就需要输入用户名和密码,这个时候我们就又需要解决的一个问题是，用户在注册的时候填入的用户名和密码、以及我们经常会访问到一些数据列表的内容展示(如下图所示)，这些数据都存储在哪里?我们需要的时候又是从哪里来取呢? 1.2.4 数据库 数据库主要负责存储数据。 整个Web的访问过程就如下图所示: (1)浏览器发送一个请求到服务端，去请求所需要的相关资源; (2)资源分为动态资源和静态资源,动态资源可以是使用Java代码按照Servlet和JSP的规范编写的内容; (3)在Java代码可以进行业务处理也可以从数据库中读取数据; (4)拿到数据后，把数据交给HTML页面进行展示,再结合CSS和JavaScript使展示效果更好; (5)服务端将静态资源响应给浏览器; (6)浏览器将这些资源进行解析; (7)解析后将效果展示在浏览器，用户就可以看到最终的结果。 在整个Web的访问过程中，会设计到很多技术，这些技术有已经学习过的，也有还未涉及到的内容，都有哪些还没有涉及到呢? 1.2.5 HTTP协议 HTTP协议:主要定义通信规则 浏览器发送请求给服务器，服务器响应数据给浏览器，这整个过程都需要遵守一定的规则，之前大家学习过TCP、UDP，这些都属于规则，这里我们需要使用的是HTTP协议，这也是一种规则。 1.2.6 Web服务器 Web服务器:负责解析 HTTP 协议，解析请求数据，并发送响应数据 浏览器按照HTTP协议发送请求和数据，后台就需要一个Web服务器软件来根据HTTP协议解析请求和数据，然后把处理结果再按照HTTP协议发送给浏览器 Web服务器软件有很多，我们课程中将学习的是目前最为常用的==Tomcat==服务器 到这为止，关于JavaWeb中用到的技术栈我们就介绍完了，这里面就只有HTTP协议、Servlet、JSP以及Tomcat这些知识是没有学习过的，所以整个Web核心主要就是来学习这些技术。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:1:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#126-web服务器"},{"categories":["Web"],"content":" 1.3 Web核心课程安排 整个Web核心，我们总共有六天的学习内容，分别是: 第一天：HTTP、Tomcat、Servlet 第二天：Request(请求)、Response(响应) 第三天：JSP、会话技术(Cookie、Session) 第四天：Filter(过滤器)、Listener(监听器) 第五天：Ajax、Vue、ElementUI 第六天：综合案例 (1)Request是从客户端向服务端发出的请求对象， (2)Response是从服务端响应给客户端的结果对象， (3)JSP是动态网页技术, (4)会话技术是用来存储客户端和服务端交互所产生的数据， (5)过滤器是用来拦截客户端的请求, (6)监听器是用来监听特定事件, (7)Ajax、Vue、ElementUI都是属于前端技术 这些技术都该如何来使用，我们后面会一个个进行详细的讲解。接下来我们来学习下HTTP、Tomcat和Servlet。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:1:3","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#13-web核心课程安排"},{"categories":["Web"],"content":" 2, HTTP","date":"2023-12-31","objectID":"/servlet-tomcat/:2:0","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#2-http"},{"categories":["Web"],"content":" 2.1 简介HTTP概念 HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间==数据传输的规则==。 数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输。 如果想知道具体的格式，可以打开浏览器，点击F12打开开发者工具，点击Network来查看某一次请求的请求数据和响应数据具体的格式内容，如下图所示: 注意:在浏览器中如果看不到上述内容，需要清除浏览器的浏览数据。chrome浏览器可以使用ctrl+shift+Del进行清除。 ==所以学习HTTP主要就是学习请求和响应数据的具体格式内容。== HTTP协议特点 HTTP协议有它自己的一些特点，分别是: 基于TCP协议: 面向连接，安全 TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全。 基于请求-响应模型的:一次请求对应一次响应 请求和响应是一一对应关系 HTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的 无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。这种特性有优点也有缺点， 缺点:多次请求间不能共享数据 优点:速度快 请求之间无法共享数据会引发的问题，如: 京东购物，加入购物车和去购物车结算是两次请求， HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品 发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据 具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用会话技术(Cookie、Session)来解决这个问题。具体如何来做，我们后面会详细讲到。刚才提到HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢? ","date":"2023-12-31","objectID":"/servlet-tomcat/:2:1","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#21-简介"},{"categories":["Web"],"content":" 2.2 请求数据格式 2.2.1 格式介绍请求数据总共分为三部分内容，分别是==请求行==、==请求头==、==请求体== 请求行: HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] /[请求URL路径] HTTP/1.1[HTTP协议及版本] 请求方式有七种,最常用的是GET和POST 请求头: 第二行开始，格式为key: value形式 请求头中会包含若干个属性，常见的HTTP请求头有: Host: 表示请求的主机名 User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko； Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有； Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。 ==这些数据有什么用处?== 举例说明:服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如: 不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果 服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果 这就是我们常说的浏览器兼容问题 请求体: POST请求的最后一部分，存储请求参数 如上图红线框的内容就是请求体的内容，请求体和请求头之间是有一个空行隔开。此时浏览器发送的是POST请求，为什么不能使用GET呢?这时就需要回顾GET和POST两个请求之间的区别了: GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中 GET请求请求参数大小有限制，POST没有 2.2.2 实例演示把 代码\\http 拷贝到IDEA的工作目录中，比如D:\\workspace\\web目录， 使用IDEA打开 打开后，可以点击项目中的html\\19-表单验证.html，使用浏览器打开，通过修改页面中form表单的method属性来测试GET请求和POST请求的参数携带方式。 小结: 请求数据中包含三部分内容，分别是请求行、请求头和请求体 POST请求数据在请求体中，GET请求数据在请求行上 ","date":"2023-12-31","objectID":"/servlet-tomcat/:2:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#22-请求数据格式"},{"categories":["Web"],"content":" 2.2 请求数据格式 2.2.1 格式介绍请求数据总共分为三部分内容，分别是==请求行==、==请求头==、==请求体== 请求行: HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] /[请求URL路径] HTTP/1.1[HTTP协议及版本] 请求方式有七种,最常用的是GET和POST 请求头: 第二行开始，格式为key: value形式 请求头中会包含若干个属性，常见的HTTP请求头有: Host: 表示请求的主机名 User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko； Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有； Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。 ==这些数据有什么用处?== 举例说明:服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如: 不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果 服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果 这就是我们常说的浏览器兼容问题 请求体: POST请求的最后一部分，存储请求参数 如上图红线框的内容就是请求体的内容，请求体和请求头之间是有一个空行隔开。此时浏览器发送的是POST请求，为什么不能使用GET呢?这时就需要回顾GET和POST两个请求之间的区别了: GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中 GET请求请求参数大小有限制，POST没有 2.2.2 实例演示把 代码\\http 拷贝到IDEA的工作目录中，比如D:\\workspace\\web目录， 使用IDEA打开 打开后，可以点击项目中的html\\19-表单验证.html，使用浏览器打开，通过修改页面中form表单的method属性来测试GET请求和POST请求的参数携带方式。 小结: 请求数据中包含三部分内容，分别是请求行、请求头和请求体 POST请求数据在请求体中，GET请求数据在请求行上 ","date":"2023-12-31","objectID":"/servlet-tomcat/:2:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#221-格式介绍"},{"categories":["Web"],"content":" 2.2 请求数据格式 2.2.1 格式介绍请求数据总共分为三部分内容，分别是==请求行==、==请求头==、==请求体== 请求行: HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] /[请求URL路径] HTTP/1.1[HTTP协议及版本] 请求方式有七种,最常用的是GET和POST 请求头: 第二行开始，格式为key: value形式 请求头中会包含若干个属性，常见的HTTP请求头有: Host: 表示请求的主机名 User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko； Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有； Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。 ==这些数据有什么用处?== 举例说明:服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求，比如: 不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果 服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果 这就是我们常说的浏览器兼容问题 请求体: POST请求的最后一部分，存储请求参数 如上图红线框的内容就是请求体的内容，请求体和请求头之间是有一个空行隔开。此时浏览器发送的是POST请求，为什么不能使用GET呢?这时就需要回顾GET和POST两个请求之间的区别了: GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中 GET请求请求参数大小有限制，POST没有 2.2.2 实例演示把 代码\\http 拷贝到IDEA的工作目录中，比如D:\\workspace\\web目录， 使用IDEA打开 打开后，可以点击项目中的html\\19-表单验证.html，使用浏览器打开，通过修改页面中form表单的method属性来测试GET请求和POST请求的参数携带方式。 小结: 请求数据中包含三部分内容，分别是请求行、请求头和请求体 POST请求数据在请求体中，GET请求数据在请求行上 ","date":"2023-12-31","objectID":"/servlet-tomcat/:2:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#222-实例演示"},{"categories":["Web"],"content":" 2.3 响应数据格式 2.3.1 格式介绍响应数据总共分为三部分内容，分别是==响应行==、==响应头==、==响应体== 响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述] 响应头：第二行开始，格式为key：value形式 响应头中会包含若干个属性，常见的HTTP响应头有: Content-Type：表示该响应内容的类型，例如text/html，image/jpeg； Content-Length：表示该响应内容的长度（字节数）； Content-Encoding：表示该响应压缩算法，例如gzip； Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 响应体： 最后一部分。存放响应数据 上图中…这部分内容就是响应体，它和响应头之间有一个空行隔开。 2.3.2 响应状态码参考: 资料/1.HTTP/《响应状态码.md》 关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握: 200 ok 客户端请求成功 404 Not Found 请求资源不存在 500 Internal Server Error 服务端发生不可预期的错误 2.3.3 自定义服务器在前面我们导入到IDEA中的http项目中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是ServerSocket和Socket package com.itheima; import sun.misc.IOUtils; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.nio.charset.StandardCharsets; import java.nio.file.Files; /* 自定义服务器 */ public class Server { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8080); // 监听指定端口 System.out.println(\"server is running...\"); while (true){ Socket sock = ss.accept(); System.out.println(\"connected from \" + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); } } } class Handler extends Thread { Socket sock; public Handler(Socket sock) { this.sock = sock; } public void run() { try (InputStream input = this.sock.getInputStream()) { try (OutputStream output = this.sock.getOutputStream()) { handle(input, output); } } catch (Exception e) { try { this.sock.close(); } catch (IOException ioe) { } System.out.println(\"client disconnected.\"); } } private void handle(InputStream input, OutputStream output) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); // 读取HTTP请求: boolean requestOk = false; String first = reader.readLine(); if (first.startsWith(\"GET / HTTP/1.\")) { requestOk = true; } for (;;) { String header = reader.readLine(); if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕 break; } System.out.println(header); } System.out.println(requestOk ? \"Response OK\" : \"Response Error\"); if (!requestOk) { // 发送错误响应: writer.write(\"HTTP/1.0 404 Not Found\\r\\n\"); writer.write(\"Content-Length: 0\\r\\n\"); writer.write(\"\\r\\n\"); writer.flush(); } else { // 发送成功响应: //读取html文件，转换为字符串 BufferedReader br = new BufferedReader(new FileReader(\"http/html/a.html\")); StringBuilder data = new StringBuilder(); String line = null; while ((line = br.readLine()) != null){ data.append(line); } br.close(); int length = data.toString().getBytes(StandardCharsets.UTF_8).length; writer.write(\"HTTP/1.1 200 OK\\r\\n\"); writer.write(\"Connection: keep-alive\\r\\n\"); writer.write(\"Content-Type: text/html\\r\\n\"); writer.write(\"Content-Length: \" + length + \"\\r\\n\"); writer.write(\"\\r\\n\"); // 空行标识Header和Body的分隔 writer.write(data.toString()); writer.flush(); } } } 上面代码，大家不需要自己写，主要通过上述代码，只需要大家了解到服务器可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，真正用到的Web服务器，我们不会自己写，都是使用目前比较流行的web服务器，比如==Tomcat== 小结 响应数据中包含三部分内容，分别是响应行、响应头和响应体 掌握200，404，500这三个响应状态码所代表含义，分布是成功、所访问资源不存在和服务的错误 ","date":"2023-12-31","objectID":"/servlet-tomcat/:2:3","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#23-响应数据格式"},{"categories":["Web"],"content":" 2.3 响应数据格式 2.3.1 格式介绍响应数据总共分为三部分内容，分别是==响应行==、==响应头==、==响应体== 响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述] 响应头：第二行开始，格式为key：value形式 响应头中会包含若干个属性，常见的HTTP响应头有: Content-Type：表示该响应内容的类型，例如text/html，image/jpeg； Content-Length：表示该响应内容的长度（字节数）； Content-Encoding：表示该响应压缩算法，例如gzip； Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 响应体： 最后一部分。存放响应数据 上图中…这部分内容就是响应体，它和响应头之间有一个空行隔开。 2.3.2 响应状态码参考: 资料/1.HTTP/《响应状态码.md》 关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握: 200 ok 客户端请求成功 404 Not Found 请求资源不存在 500 Internal Server Error 服务端发生不可预期的错误 2.3.3 自定义服务器在前面我们导入到IDEA中的http项目中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是ServerSocket和Socket package com.itheima; import sun.misc.IOUtils; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.nio.charset.StandardCharsets; import java.nio.file.Files; /* 自定义服务器 */ public class Server { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8080); // 监听指定端口 System.out.println(\"server is running...\"); while (true){ Socket sock = ss.accept(); System.out.println(\"connected from \" + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); } } } class Handler extends Thread { Socket sock; public Handler(Socket sock) { this.sock = sock; } public void run() { try (InputStream input = this.sock.getInputStream()) { try (OutputStream output = this.sock.getOutputStream()) { handle(input, output); } } catch (Exception e) { try { this.sock.close(); } catch (IOException ioe) { } System.out.println(\"client disconnected.\"); } } private void handle(InputStream input, OutputStream output) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); // 读取HTTP请求: boolean requestOk = false; String first = reader.readLine(); if (first.startsWith(\"GET / HTTP/1.\")) { requestOk = true; } for (;;) { String header = reader.readLine(); if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕 break; } System.out.println(header); } System.out.println(requestOk ? \"Response OK\" : \"Response Error\"); if (!requestOk) { // 发送错误响应: writer.write(\"HTTP/1.0 404 Not Found\\r\\n\"); writer.write(\"Content-Length: 0\\r\\n\"); writer.write(\"\\r\\n\"); writer.flush(); } else { // 发送成功响应: //读取html文件，转换为字符串 BufferedReader br = new BufferedReader(new FileReader(\"http/html/a.html\")); StringBuilder data = new StringBuilder(); String line = null; while ((line = br.readLine()) != null){ data.append(line); } br.close(); int length = data.toString().getBytes(StandardCharsets.UTF_8).length; writer.write(\"HTTP/1.1 200 OK\\r\\n\"); writer.write(\"Connection: keep-alive\\r\\n\"); writer.write(\"Content-Type: text/html\\r\\n\"); writer.write(\"Content-Length: \" + length + \"\\r\\n\"); writer.write(\"\\r\\n\"); // 空行标识Header和Body的分隔 writer.write(data.toString()); writer.flush(); } } } 上面代码，大家不需要自己写，主要通过上述代码，只需要大家了解到服务器可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，真正用到的Web服务器，我们不会自己写，都是使用目前比较流行的web服务器，比如==Tomcat== 小结 响应数据中包含三部分内容，分别是响应行、响应头和响应体 掌握200，404，500这三个响应状态码所代表含义，分布是成功、所访问资源不存在和服务的错误 ","date":"2023-12-31","objectID":"/servlet-tomcat/:2:3","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#231-格式介绍"},{"categories":["Web"],"content":" 2.3 响应数据格式 2.3.1 格式介绍响应数据总共分为三部分内容，分别是==响应行==、==响应头==、==响应体== 响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述] 响应头：第二行开始，格式为key：value形式 响应头中会包含若干个属性，常见的HTTP响应头有: Content-Type：表示该响应内容的类型，例如text/html，image/jpeg； Content-Length：表示该响应内容的长度（字节数）； Content-Encoding：表示该响应压缩算法，例如gzip； Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 响应体： 最后一部分。存放响应数据 上图中…这部分内容就是响应体，它和响应头之间有一个空行隔开。 2.3.2 响应状态码参考: 资料/1.HTTP/《响应状态码.md》 关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握: 200 ok 客户端请求成功 404 Not Found 请求资源不存在 500 Internal Server Error 服务端发生不可预期的错误 2.3.3 自定义服务器在前面我们导入到IDEA中的http项目中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是ServerSocket和Socket package com.itheima; import sun.misc.IOUtils; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.nio.charset.StandardCharsets; import java.nio.file.Files; /* 自定义服务器 */ public class Server { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8080); // 监听指定端口 System.out.println(\"server is running...\"); while (true){ Socket sock = ss.accept(); System.out.println(\"connected from \" + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); } } } class Handler extends Thread { Socket sock; public Handler(Socket sock) { this.sock = sock; } public void run() { try (InputStream input = this.sock.getInputStream()) { try (OutputStream output = this.sock.getOutputStream()) { handle(input, output); } } catch (Exception e) { try { this.sock.close(); } catch (IOException ioe) { } System.out.println(\"client disconnected.\"); } } private void handle(InputStream input, OutputStream output) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); // 读取HTTP请求: boolean requestOk = false; String first = reader.readLine(); if (first.startsWith(\"GET / HTTP/1.\")) { requestOk = true; } for (;;) { String header = reader.readLine(); if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕 break; } System.out.println(header); } System.out.println(requestOk ? \"Response OK\" : \"Response Error\"); if (!requestOk) { // 发送错误响应: writer.write(\"HTTP/1.0 404 Not Found\\r\\n\"); writer.write(\"Content-Length: 0\\r\\n\"); writer.write(\"\\r\\n\"); writer.flush(); } else { // 发送成功响应: //读取html文件，转换为字符串 BufferedReader br = new BufferedReader(new FileReader(\"http/html/a.html\")); StringBuilder data = new StringBuilder(); String line = null; while ((line = br.readLine()) != null){ data.append(line); } br.close(); int length = data.toString().getBytes(StandardCharsets.UTF_8).length; writer.write(\"HTTP/1.1 200 OK\\r\\n\"); writer.write(\"Connection: keep-alive\\r\\n\"); writer.write(\"Content-Type: text/html\\r\\n\"); writer.write(\"Content-Length: \" + length + \"\\r\\n\"); writer.write(\"\\r\\n\"); // 空行标识Header和Body的分隔 writer.write(data.toString()); writer.flush(); } } } 上面代码，大家不需要自己写，主要通过上述代码，只需要大家了解到服务器可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，真正用到的Web服务器，我们不会自己写，都是使用目前比较流行的web服务器，比如==Tomcat== 小结 响应数据中包含三部分内容，分别是响应行、响应头和响应体 掌握200，404，500这三个响应状态码所代表含义，分布是成功、所访问资源不存在和服务的错误 ","date":"2023-12-31","objectID":"/servlet-tomcat/:2:3","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#232-响应状态码"},{"categories":["Web"],"content":" 2.3 响应数据格式 2.3.1 格式介绍响应数据总共分为三部分内容，分别是==响应行==、==响应头==、==响应体== 响应行：响应数据的第一行,响应行包含三块内容，分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述] 响应头：第二行开始，格式为key：value形式 响应头中会包含若干个属性，常见的HTTP响应头有: Content-Type：表示该响应内容的类型，例如text/html，image/jpeg； Content-Length：表示该响应内容的长度（字节数）； Content-Encoding：表示该响应压缩算法，例如gzip； Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 响应体： 最后一部分。存放响应数据 上图中…这部分内容就是响应体，它和响应头之间有一个空行隔开。 2.3.2 响应状态码参考: 资料/1.HTTP/《响应状态码.md》 关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握: 200 ok 客户端请求成功 404 Not Found 请求资源不存在 500 Internal Server Error 服务端发生不可预期的错误 2.3.3 自定义服务器在前面我们导入到IDEA中的http项目中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是ServerSocket和Socket package com.itheima; import sun.misc.IOUtils; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.nio.charset.StandardCharsets; import java.nio.file.Files; /* 自定义服务器 */ public class Server { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8080); // 监听指定端口 System.out.println(\"server is running...\"); while (true){ Socket sock = ss.accept(); System.out.println(\"connected from \" + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); } } } class Handler extends Thread { Socket sock; public Handler(Socket sock) { this.sock = sock; } public void run() { try (InputStream input = this.sock.getInputStream()) { try (OutputStream output = this.sock.getOutputStream()) { handle(input, output); } } catch (Exception e) { try { this.sock.close(); } catch (IOException ioe) { } System.out.println(\"client disconnected.\"); } } private void handle(InputStream input, OutputStream output) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); // 读取HTTP请求: boolean requestOk = false; String first = reader.readLine(); if (first.startsWith(\"GET / HTTP/1.\")) { requestOk = true; } for (;;) { String header = reader.readLine(); if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕 break; } System.out.println(header); } System.out.println(requestOk ? \"Response OK\" : \"Response Error\"); if (!requestOk) { // 发送错误响应: writer.write(\"HTTP/1.0 404 Not Found\\r\\n\"); writer.write(\"Content-Length: 0\\r\\n\"); writer.write(\"\\r\\n\"); writer.flush(); } else { // 发送成功响应: //读取html文件，转换为字符串 BufferedReader br = new BufferedReader(new FileReader(\"http/html/a.html\")); StringBuilder data = new StringBuilder(); String line = null; while ((line = br.readLine()) != null){ data.append(line); } br.close(); int length = data.toString().getBytes(StandardCharsets.UTF_8).length; writer.write(\"HTTP/1.1 200 OK\\r\\n\"); writer.write(\"Connection: keep-alive\\r\\n\"); writer.write(\"Content-Type: text/html\\r\\n\"); writer.write(\"Content-Length: \" + length + \"\\r\\n\"); writer.write(\"\\r\\n\"); // 空行标识Header和Body的分隔 writer.write(data.toString()); writer.flush(); } } } 上面代码，大家不需要自己写，主要通过上述代码，只需要大家了解到服务器可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，真正用到的Web服务器，我们不会自己写，都是使用目前比较流行的web服务器，比如==Tomcat== 小结 响应数据中包含三部分内容，分别是响应行、响应头和响应体 掌握200，404，500这三个响应状态码所代表含义，分布是成功、所访问资源不存在和服务的错误 ","date":"2023-12-31","objectID":"/servlet-tomcat/:2:3","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#233-自定义服务器"},{"categories":["Web"],"content":" 3, Tomcat","date":"2023-12-31","objectID":"/servlet-tomcat/:3:0","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#3-tomcat"},{"categories":["Web"],"content":" 3.1 简介 3.1.1 什么是Web服务器Web服务器是一个应该程序（==软件==），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是\"提供网上信息浏览服务\"。 Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。 Web服务器软件使用步骤 准备静态资源 下载安装Web服务器软件 将静态资源部署到Web服务器上 启动Web服务器使用浏览器访问对应的资源 上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器，比如: Tomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习: 简介: 初步认识下Tomcat 基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作 IDEA中如何创建Maven Web项目 IDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式 首选我们来认识下Tomcat。 Tomcat Tomcat的相关概念: Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。 概念中提到了JavaEE规范，那什么又是JavaEE规范呢? JavaEE: Java Enterprise Edition,Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF。 因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。 Tomcat的官网: https://tomcat.apache.org/ 从官网上可以下载对应的版本进行使用。 Tomcat的LOGO 小结 通过这一节的学习，我们需要掌握以下内容: Web服务器的作用 封装HTTP协议操作，简化开发 可以将Web项目部署到服务器中，对外提供网上浏览服务 Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:1","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#31-简介"},{"categories":["Web"],"content":" 3.1 简介 3.1.1 什么是Web服务器Web服务器是一个应该程序（==软件==），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是\"提供网上信息浏览服务\"。 Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。 Web服务器软件使用步骤 准备静态资源 下载安装Web服务器软件 将静态资源部署到Web服务器上 启动Web服务器使用浏览器访问对应的资源 上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器，比如: Tomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习: 简介: 初步认识下Tomcat 基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作 IDEA中如何创建Maven Web项目 IDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式 首选我们来认识下Tomcat。 Tomcat Tomcat的相关概念: Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。 概念中提到了JavaEE规范，那什么又是JavaEE规范呢? JavaEE: Java Enterprise Edition,Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF。 因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。 Tomcat的官网: https://tomcat.apache.org/ 从官网上可以下载对应的版本进行使用。 Tomcat的LOGO 小结 通过这一节的学习，我们需要掌握以下内容: Web服务器的作用 封装HTTP协议操作，简化开发 可以将Web项目部署到服务器中，对外提供网上浏览服务 Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:1","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#311-什么是web服务器"},{"categories":["Web"],"content":" 3.2 基本使用Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。 3.2.1 下载直接从官网下载 大家可以自行下载，也可以直接使用资料中已经下载好的资源， Tomcat的软件程序 资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip Tomcat的源码 资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip 3.2.2 安装Tomcat是绿色版,直接解压即可 在D盘的software目录下，将apache-tomcat-8.5.68-windows-x64.zip进行解压缩，会得到一个apache-tomcat-8.5.68的目录，Tomcat就已经安装成功。 ==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。 打开apache-tomcat-8.5.68目录就能看到如下目录结构，每个目录中包含的内容需要认识下, bin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。 webapps:就是以后项目部署的目录 到此，Tomcat的安装就已经完成。 3.2.3 卸载卸载比较简单，可以直接删除目录即可 3.2.4 启动双击: bin\\startup.bat 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 ==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties 3.2.5 关闭关闭有三种方式 直接x掉运行窗口:强制关闭[不建议] bin\\shutdown.bat：正常关闭 ctrl+c： 正常关闭 3.2.6 配置修改端口 Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的错误 Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误 Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置 3.2.7 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 将 资料/2. Tomcat/hello 目录拷贝到Tomcat的webapps目录下 通过浏览器访问http://localhost/hello/a.html，能看到下面的内容就说明项目已经部署成功。 但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢? 一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件 将 资料/2. Tomcat/haha.war目录拷贝到Tomcat的webapps目录下 Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录 通过浏览器访问http://localhost/haha/a.html，能看到下面的内容就说明项目已经部署成功。 至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#32-基本使用"},{"categories":["Web"],"content":" 3.2 基本使用Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。 3.2.1 下载直接从官网下载 大家可以自行下载，也可以直接使用资料中已经下载好的资源， Tomcat的软件程序 资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip Tomcat的源码 资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip 3.2.2 安装Tomcat是绿色版,直接解压即可 在D盘的software目录下，将apache-tomcat-8.5.68-windows-x64.zip进行解压缩，会得到一个apache-tomcat-8.5.68的目录，Tomcat就已经安装成功。 ==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。 打开apache-tomcat-8.5.68目录就能看到如下目录结构，每个目录中包含的内容需要认识下, bin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。 webapps:就是以后项目部署的目录 到此，Tomcat的安装就已经完成。 3.2.3 卸载卸载比较简单，可以直接删除目录即可 3.2.4 启动双击: bin\\startup.bat 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 ==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties 3.2.5 关闭关闭有三种方式 直接x掉运行窗口:强制关闭[不建议] bin\\shutdown.bat：正常关闭 ctrl+c： 正常关闭 3.2.6 配置修改端口 Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的错误 Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误 Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置 3.2.7 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 将 资料/2. Tomcat/hello 目录拷贝到Tomcat的webapps目录下 通过浏览器访问http://localhost/hello/a.html，能看到下面的内容就说明项目已经部署成功。 但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢? 一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件 将 资料/2. Tomcat/haha.war目录拷贝到Tomcat的webapps目录下 Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录 通过浏览器访问http://localhost/haha/a.html，能看到下面的内容就说明项目已经部署成功。 至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#321-下载"},{"categories":["Web"],"content":" 3.2 基本使用Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。 3.2.1 下载直接从官网下载 大家可以自行下载，也可以直接使用资料中已经下载好的资源， Tomcat的软件程序 资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip Tomcat的源码 资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip 3.2.2 安装Tomcat是绿色版,直接解压即可 在D盘的software目录下，将apache-tomcat-8.5.68-windows-x64.zip进行解压缩，会得到一个apache-tomcat-8.5.68的目录，Tomcat就已经安装成功。 ==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。 打开apache-tomcat-8.5.68目录就能看到如下目录结构，每个目录中包含的内容需要认识下, bin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。 webapps:就是以后项目部署的目录 到此，Tomcat的安装就已经完成。 3.2.3 卸载卸载比较简单，可以直接删除目录即可 3.2.4 启动双击: bin\\startup.bat 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 ==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties 3.2.5 关闭关闭有三种方式 直接x掉运行窗口:强制关闭[不建议] bin\\shutdown.bat：正常关闭 ctrl+c： 正常关闭 3.2.6 配置修改端口 Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的错误 Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误 Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置 3.2.7 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 将 资料/2. Tomcat/hello 目录拷贝到Tomcat的webapps目录下 通过浏览器访问http://localhost/hello/a.html，能看到下面的内容就说明项目已经部署成功。 但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢? 一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件 将 资料/2. Tomcat/haha.war目录拷贝到Tomcat的webapps目录下 Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录 通过浏览器访问http://localhost/haha/a.html，能看到下面的内容就说明项目已经部署成功。 至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#322-安装"},{"categories":["Web"],"content":" 3.2 基本使用Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。 3.2.1 下载直接从官网下载 大家可以自行下载，也可以直接使用资料中已经下载好的资源， Tomcat的软件程序 资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip Tomcat的源码 资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip 3.2.2 安装Tomcat是绿色版,直接解压即可 在D盘的software目录下，将apache-tomcat-8.5.68-windows-x64.zip进行解压缩，会得到一个apache-tomcat-8.5.68的目录，Tomcat就已经安装成功。 ==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。 打开apache-tomcat-8.5.68目录就能看到如下目录结构，每个目录中包含的内容需要认识下, bin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。 webapps:就是以后项目部署的目录 到此，Tomcat的安装就已经完成。 3.2.3 卸载卸载比较简单，可以直接删除目录即可 3.2.4 启动双击: bin\\startup.bat 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 ==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties 3.2.5 关闭关闭有三种方式 直接x掉运行窗口:强制关闭[不建议] bin\\shutdown.bat：正常关闭 ctrl+c： 正常关闭 3.2.6 配置修改端口 Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的错误 Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误 Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置 3.2.7 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 将 资料/2. Tomcat/hello 目录拷贝到Tomcat的webapps目录下 通过浏览器访问http://localhost/hello/a.html，能看到下面的内容就说明项目已经部署成功。 但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢? 一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件 将 资料/2. Tomcat/haha.war目录拷贝到Tomcat的webapps目录下 Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录 通过浏览器访问http://localhost/haha/a.html，能看到下面的内容就说明项目已经部署成功。 至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#323-卸载"},{"categories":["Web"],"content":" 3.2 基本使用Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。 3.2.1 下载直接从官网下载 大家可以自行下载，也可以直接使用资料中已经下载好的资源， Tomcat的软件程序 资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip Tomcat的源码 资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip 3.2.2 安装Tomcat是绿色版,直接解压即可 在D盘的software目录下，将apache-tomcat-8.5.68-windows-x64.zip进行解压缩，会得到一个apache-tomcat-8.5.68的目录，Tomcat就已经安装成功。 ==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。 打开apache-tomcat-8.5.68目录就能看到如下目录结构，每个目录中包含的内容需要认识下, bin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。 webapps:就是以后项目部署的目录 到此，Tomcat的安装就已经完成。 3.2.3 卸载卸载比较简单，可以直接删除目录即可 3.2.4 启动双击: bin\\startup.bat 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 ==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties 3.2.5 关闭关闭有三种方式 直接x掉运行窗口:强制关闭[不建议] bin\\shutdown.bat：正常关闭 ctrl+c： 正常关闭 3.2.6 配置修改端口 Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的错误 Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误 Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置 3.2.7 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 将 资料/2. Tomcat/hello 目录拷贝到Tomcat的webapps目录下 通过浏览器访问http://localhost/hello/a.html，能看到下面的内容就说明项目已经部署成功。 但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢? 一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件 将 资料/2. Tomcat/haha.war目录拷贝到Tomcat的webapps目录下 Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录 通过浏览器访问http://localhost/haha/a.html，能看到下面的内容就说明项目已经部署成功。 至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#324-启动"},{"categories":["Web"],"content":" 3.2 基本使用Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。 3.2.1 下载直接从官网下载 大家可以自行下载，也可以直接使用资料中已经下载好的资源， Tomcat的软件程序 资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip Tomcat的源码 资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip 3.2.2 安装Tomcat是绿色版,直接解压即可 在D盘的software目录下，将apache-tomcat-8.5.68-windows-x64.zip进行解压缩，会得到一个apache-tomcat-8.5.68的目录，Tomcat就已经安装成功。 ==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。 打开apache-tomcat-8.5.68目录就能看到如下目录结构，每个目录中包含的内容需要认识下, bin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。 webapps:就是以后项目部署的目录 到此，Tomcat的安装就已经完成。 3.2.3 卸载卸载比较简单，可以直接删除目录即可 3.2.4 启动双击: bin\\startup.bat 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 ==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties 3.2.5 关闭关闭有三种方式 直接x掉运行窗口:强制关闭[不建议] bin\\shutdown.bat：正常关闭 ctrl+c： 正常关闭 3.2.6 配置修改端口 Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的错误 Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误 Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置 3.2.7 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 将 资料/2. Tomcat/hello 目录拷贝到Tomcat的webapps目录下 通过浏览器访问http://localhost/hello/a.html，能看到下面的内容就说明项目已经部署成功。 但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢? 一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件 将 资料/2. Tomcat/haha.war目录拷贝到Tomcat的webapps目录下 Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录 通过浏览器访问http://localhost/haha/a.html，能看到下面的内容就说明项目已经部署成功。 至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#325-关闭"},{"categories":["Web"],"content":" 3.2 基本使用Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。 3.2.1 下载直接从官网下载 大家可以自行下载，也可以直接使用资料中已经下载好的资源， Tomcat的软件程序 资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip Tomcat的源码 资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip 3.2.2 安装Tomcat是绿色版,直接解压即可 在D盘的software目录下，将apache-tomcat-8.5.68-windows-x64.zip进行解压缩，会得到一个apache-tomcat-8.5.68的目录，Tomcat就已经安装成功。 ==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。 打开apache-tomcat-8.5.68目录就能看到如下目录结构，每个目录中包含的内容需要认识下, bin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。 webapps:就是以后项目部署的目录 到此，Tomcat的安装就已经完成。 3.2.3 卸载卸载比较简单，可以直接删除目录即可 3.2.4 启动双击: bin\\startup.bat 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 ==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties 3.2.5 关闭关闭有三种方式 直接x掉运行窗口:强制关闭[不建议] bin\\shutdown.bat：正常关闭 ctrl+c： 正常关闭 3.2.6 配置修改端口 Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的错误 Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误 Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置 3.2.7 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 将 资料/2. Tomcat/hello 目录拷贝到Tomcat的webapps目录下 通过浏览器访问http://localhost/hello/a.html，能看到下面的内容就说明项目已经部署成功。 但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢? 一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件 将 资料/2. Tomcat/haha.war目录拷贝到Tomcat的webapps目录下 Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录 通过浏览器访问http://localhost/haha/a.html，能看到下面的内容就说明项目已经部署成功。 至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#326-配置"},{"categories":["Web"],"content":" 3.2 基本使用Tomcat总共分两部分学习，先来学习Tomcat的基本使用，包括Tomcat的==下载、安装、卸载、启动和关闭==。 3.2.1 下载直接从官网下载 大家可以自行下载，也可以直接使用资料中已经下载好的资源， Tomcat的软件程序 资料/2. Tomcat/apache-tomcat-8.5.68-windows-x64.zip Tomcat的源码 资料/2. Tomcat/tomcat源码/apache-tomcat-8.5.68-src.zip 3.2.2 安装Tomcat是绿色版,直接解压即可 在D盘的software目录下，将apache-tomcat-8.5.68-windows-x64.zip进行解压缩，会得到一个apache-tomcat-8.5.68的目录，Tomcat就已经安装成功。 ==注意==，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。 打开apache-tomcat-8.5.68目录就能看到如下目录结构，每个目录中包含的内容需要认识下, bin:目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。 webapps:就是以后项目部署的目录 到此，Tomcat的安装就已经完成。 3.2.3 卸载卸载比较简单，可以直接删除目录即可 3.2.4 启动双击: bin\\startup.bat 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 ==注意==: 启动的过程中，控制台有中文乱码，需要修改conf/logging.prooperties 3.2.5 关闭关闭有三种方式 直接x掉运行窗口:强制关闭[不建议] bin\\shutdown.bat：正常关闭 ctrl+c： 正常关闭 3.2.6 配置修改端口 Tomcat默认的端口是8080，要想修改Tomcat启动的端口号，需要修改 conf/server.xml 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。 启动时可能出现的错误 Tomcat的端口号取值范围是0-65535之间任意未被占用的端口，如果设置的端口号被占用，启动的时候就会包如下的错误 Tomcat启动的时候，启动窗口一闪而过: 需要检查JAVA_HOME环境变量是否正确配置 3.2.7 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 将 资料/2. Tomcat/hello 目录拷贝到Tomcat的webapps目录下 通过浏览器访问http://localhost/hello/a.html，能看到下面的内容就说明项目已经部署成功。 但是呢随着项目的增大，项目中的资源也会越来越多，项目在拷贝的过程中也会越来越费时间，该如何解决呢? 一般JavaWeb项目会被打包称==war==包，然后将war包放到Webapps目录下，Tomcat会自动解压缩war文件 将 资料/2. Tomcat/haha.war目录拷贝到Tomcat的webapps目录下 Tomcat检测到war包后会自动完成解压缩，在webapps目录下就会多一个haha目录 通过浏览器访问http://localhost/haha/a.html，能看到下面的内容就说明项目已经部署成功。 至此，Tomcat的部署就已经完成了，至于如何获得项目对应的war包，后期我们会借助于IDEA工具来生成。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#327-部署"},{"categories":["Web"],"content":" 3.3 Maven创建Web项目介绍完Tomcat的基本使用后，我们来学习在IDEA中如何创建Maven Web项目，学习这种方式的原因是以后Tomcat中运行的绝大多数都是Web项目，而使用Maven工具能更加简单快捷的把Web项目给创建出来，所以Maven的Web项目具体如何来构建呢? 在真正创建Maven Web项目之前，我们先要知道Web项目长什么样子，具体的结构是什么? 3.3.1 Web项目结构Web项目的结构分为:开发中的项目和开发完可以部署的Web项目,这两种项目的结构是不一样的，我们一个个来介绍下: Maven Web项目结构: 开发中的项目 开发完成部署的Web项目 开发项目通过执行Maven打包命令==package==,可以获取到部署的Web项目目录 编译后的Java字节码文件和resources的资源文件，会被放到WEB-INF下的classes目录下 pom.xml中依赖坐标对应的jar包，会被放入WEB-INF下的lib目录下 3.3.2 创建Maven Web项目介绍完Maven Web的项目结构后，接下来使用Maven来创建Web项目，创建方式有两种:使用骨架和不使用骨架 使用骨架 具体的步骤包含: 1.创建Maven项目 2.选择使用Web项目骨架 3.输入Maven项目坐标创建项目 4.确认Maven相关的配置信息后，完成项目创建 5.删除pom.xml中多余内容 6.补齐Maven Web项目缺失的目录结构 创建Maven项目 选择使用Web项目骨架 输入Maven项目坐标创建项目 确认Maven相关的配置信息后，完成项目创建 删除pom.xml中多余内容，只留下面的这些内容，注意打包方式 jar和war的区别 补齐Maven Web项目缺失的目录结构，默认没有java和resources目录，需要手动完成创建补齐，最终的目录结果如下 不使用骨架 具体的步骤包含: 1.创建Maven项目 2.选择不使用Web项目骨架 3.输入Maven项目坐标创建项目 4.在pom.xml设置打包方式为war 5.补齐Maven Web项目缺失webapp的目录结构 6.补齐Maven Web项目缺失WEB-INF/web.xml的目录结构 创建Maven项目 选择不使用Web项目骨架 输入Maven项目坐标创建项目 在pom.xml设置打包方式为war,默认是不写代表打包方式为jar 补齐Maven Web项目缺失webapp的目录结构 补齐Maven Web项目缺失WEB-INF/web.xml的目录结构 补充完后，最终的项目结构如下: 上述两种方式，创建的web项目，都不是很全，需要手动补充内容，至于最终采用哪种方式来创建Maven Web项目，都是可以的，根据各自的喜好来选择使用即可。 小结 1.掌握Maven Web项目的目录结构 2.掌握使用骨架的方式创建Maven Web项目 3.掌握不使用骨架的方式创建Maven Web项目 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:3","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#33-maven创建web项目"},{"categories":["Web"],"content":" 3.3 Maven创建Web项目介绍完Tomcat的基本使用后，我们来学习在IDEA中如何创建Maven Web项目，学习这种方式的原因是以后Tomcat中运行的绝大多数都是Web项目，而使用Maven工具能更加简单快捷的把Web项目给创建出来，所以Maven的Web项目具体如何来构建呢? 在真正创建Maven Web项目之前，我们先要知道Web项目长什么样子，具体的结构是什么? 3.3.1 Web项目结构Web项目的结构分为:开发中的项目和开发完可以部署的Web项目,这两种项目的结构是不一样的，我们一个个来介绍下: Maven Web项目结构: 开发中的项目 开发完成部署的Web项目 开发项目通过执行Maven打包命令==package==,可以获取到部署的Web项目目录 编译后的Java字节码文件和resources的资源文件，会被放到WEB-INF下的classes目录下 pom.xml中依赖坐标对应的jar包，会被放入WEB-INF下的lib目录下 3.3.2 创建Maven Web项目介绍完Maven Web的项目结构后，接下来使用Maven来创建Web项目，创建方式有两种:使用骨架和不使用骨架 使用骨架 具体的步骤包含: 1.创建Maven项目 2.选择使用Web项目骨架 3.输入Maven项目坐标创建项目 4.确认Maven相关的配置信息后，完成项目创建 5.删除pom.xml中多余内容 6.补齐Maven Web项目缺失的目录结构 创建Maven项目 选择使用Web项目骨架 输入Maven项目坐标创建项目 确认Maven相关的配置信息后，完成项目创建 删除pom.xml中多余内容，只留下面的这些内容，注意打包方式 jar和war的区别 补齐Maven Web项目缺失的目录结构，默认没有java和resources目录，需要手动完成创建补齐，最终的目录结果如下 不使用骨架 具体的步骤包含: 1.创建Maven项目 2.选择不使用Web项目骨架 3.输入Maven项目坐标创建项目 4.在pom.xml设置打包方式为war 5.补齐Maven Web项目缺失webapp的目录结构 6.补齐Maven Web项目缺失WEB-INF/web.xml的目录结构 创建Maven项目 选择不使用Web项目骨架 输入Maven项目坐标创建项目 在pom.xml设置打包方式为war,默认是不写代表打包方式为jar 补齐Maven Web项目缺失webapp的目录结构 补齐Maven Web项目缺失WEB-INF/web.xml的目录结构 补充完后，最终的项目结构如下: 上述两种方式，创建的web项目，都不是很全，需要手动补充内容，至于最终采用哪种方式来创建Maven Web项目，都是可以的，根据各自的喜好来选择使用即可。 小结 1.掌握Maven Web项目的目录结构 2.掌握使用骨架的方式创建Maven Web项目 3.掌握不使用骨架的方式创建Maven Web项目 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:3","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#331-web项目结构"},{"categories":["Web"],"content":" 3.3 Maven创建Web项目介绍完Tomcat的基本使用后，我们来学习在IDEA中如何创建Maven Web项目，学习这种方式的原因是以后Tomcat中运行的绝大多数都是Web项目，而使用Maven工具能更加简单快捷的把Web项目给创建出来，所以Maven的Web项目具体如何来构建呢? 在真正创建Maven Web项目之前，我们先要知道Web项目长什么样子，具体的结构是什么? 3.3.1 Web项目结构Web项目的结构分为:开发中的项目和开发完可以部署的Web项目,这两种项目的结构是不一样的，我们一个个来介绍下: Maven Web项目结构: 开发中的项目 开发完成部署的Web项目 开发项目通过执行Maven打包命令==package==,可以获取到部署的Web项目目录 编译后的Java字节码文件和resources的资源文件，会被放到WEB-INF下的classes目录下 pom.xml中依赖坐标对应的jar包，会被放入WEB-INF下的lib目录下 3.3.2 创建Maven Web项目介绍完Maven Web的项目结构后，接下来使用Maven来创建Web项目，创建方式有两种:使用骨架和不使用骨架 使用骨架 具体的步骤包含: 1.创建Maven项目 2.选择使用Web项目骨架 3.输入Maven项目坐标创建项目 4.确认Maven相关的配置信息后，完成项目创建 5.删除pom.xml中多余内容 6.补齐Maven Web项目缺失的目录结构 创建Maven项目 选择使用Web项目骨架 输入Maven项目坐标创建项目 确认Maven相关的配置信息后，完成项目创建 删除pom.xml中多余内容，只留下面的这些内容，注意打包方式 jar和war的区别 补齐Maven Web项目缺失的目录结构，默认没有java和resources目录，需要手动完成创建补齐，最终的目录结果如下 不使用骨架 具体的步骤包含: 1.创建Maven项目 2.选择不使用Web项目骨架 3.输入Maven项目坐标创建项目 4.在pom.xml设置打包方式为war 5.补齐Maven Web项目缺失webapp的目录结构 6.补齐Maven Web项目缺失WEB-INF/web.xml的目录结构 创建Maven项目 选择不使用Web项目骨架 输入Maven项目坐标创建项目 在pom.xml设置打包方式为war,默认是不写代表打包方式为jar 补齐Maven Web项目缺失webapp的目录结构 补齐Maven Web项目缺失WEB-INF/web.xml的目录结构 补充完后，最终的项目结构如下: 上述两种方式，创建的web项目，都不是很全，需要手动补充内容，至于最终采用哪种方式来创建Maven Web项目，都是可以的，根据各自的喜好来选择使用即可。 小结 1.掌握Maven Web项目的目录结构 2.掌握使用骨架的方式创建Maven Web项目 3.掌握不使用骨架的方式创建Maven Web项目 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:3","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#332-创建maven-web项目"},{"categories":["Web"],"content":" 3.4 IDEA使用Tomcat Maven Web项目创建成功后，通过Maven的package命令可以将项目打包成war包，将war文件拷贝到Tomcat的webapps目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可。 然而我们在开发的过程中，项目中的内容会经常发生变化，如果按照上面这种方式来部署测试，是非常不方便的 如何在IDEA中能快速使用Tomcat呢? 在IDEA中集成使用Tomcat有两种方式，分别是==集成本地Tomcat==和==Tomcat Maven插件== 3.4.1 集成本地Tomcat目标: 将刚才本地安装好的Tomcat8集成到IDEA中，完成项目部署，具体的实现步骤 打开添加本地Tomcat的面板 指定本地Tomcat的具体路径 修改Tomcat的名称，此步骤可以不改，只是让名字看起来更有意义，HTTP port中的端口也可以进行修改，比如把8080改成80 将开发项目部署项目到Tomcat中 扩展内容： xxx.war和 xxx.war exploded这两种部署项目模式的区别? war模式是将WEB工程打成war包，把war包发布到Tomcat服务器上 war exploded模式是将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上 war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容 war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署 建议大家都选war模式进行部署，更符合项目部署的实际情况 部署成功后，就可以启动项目，为了能更好的看到启动的效果，可以在webapp目录下添加a.html页面 启动成功后，可以通过浏览器进行访问测试 最终的注意事项 至此，IDEA中集成本地Tomcat进行项目部署的内容我们就介绍完了，整体步骤如下，大家需要按照流程进行部署操作练习。 3.4.2 Tomcat Maven插件在IDEA中使用本地Tomcat进行项目部署，相对来说步骤比较繁琐，所以我们需要一种更简便的方式来替换它，那就是直接使用Maven中的Tomcat插件来部署项目，具体的实现步骤，只需要两步，分别是: 在pom.xml中添加Tomcat插件 \u003cbuild\u003e \u003cplugins\u003e \u003c!--Tomcat插件 --\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.tomcat.maven\u003c/groupId\u003e \u003cartifactId\u003etomcat7-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.2\u003c/version\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 使用Maven Helper插件快速启动项目，选中项目，右键–\u003eRun Maven –\u003e tomcat7:run ==注意:== 如果选中项目并右键点击后，看不到Run Maven和Debug Maven，这个时候就需要在IDEA中下载Maven Helper插件，具体的操作方式为: File –\u003e Settings –\u003e Plugins –\u003e Maven Helper —\u003e Install,安装完后按照提示重启IDEA，就可以看到了。 Maven Tomcat插件目前只有Tomcat7版本，没有更高的版本可以使用 使用Maven Tomcat插件，要想修改Tomcat的端口和访问路径，可以直接修改pom.xml \u003cbuild\u003e \u003cplugins\u003e \u003c!--Tomcat插件 --\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.tomcat.maven\u003c/groupId\u003e \u003cartifactId\u003etomcat7-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.2\u003c/version\u003e \u003cconfiguration\u003e \u003cport\u003e80\u003c/port\u003e\u003c!--访问端口号 --\u003e \u003c!--项目访问路径 未配置访问路径: http://localhost:80/tomcat-demo2/a.html 配置/后访问路径: http://localhost:80/a.html 如果配置成 /hello,访问路径会变成什么? 答案: http://localhost:80/hello/a.html --\u003e \u003cpath\u003e/\u003c/path\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 小结 通过这一节的学习，大家要掌握在IDEA中使用Tomcat的两种方式，集成本地Tomcat和使用Maven的Tomcat插件。后者更简单，推荐大家使用，但是如果对于Tomcat的版本有比较高的要求，要在Tomcat7以上，这个时候就只能用前者了。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:4","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#34-idea使用tomcat"},{"categories":["Web"],"content":" 3.4 IDEA使用Tomcat Maven Web项目创建成功后，通过Maven的package命令可以将项目打包成war包，将war文件拷贝到Tomcat的webapps目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可。 然而我们在开发的过程中，项目中的内容会经常发生变化，如果按照上面这种方式来部署测试，是非常不方便的 如何在IDEA中能快速使用Tomcat呢? 在IDEA中集成使用Tomcat有两种方式，分别是==集成本地Tomcat==和==Tomcat Maven插件== 3.4.1 集成本地Tomcat目标: 将刚才本地安装好的Tomcat8集成到IDEA中，完成项目部署，具体的实现步骤 打开添加本地Tomcat的面板 指定本地Tomcat的具体路径 修改Tomcat的名称，此步骤可以不改，只是让名字看起来更有意义，HTTP port中的端口也可以进行修改，比如把8080改成80 将开发项目部署项目到Tomcat中 扩展内容： xxx.war和 xxx.war exploded这两种部署项目模式的区别? war模式是将WEB工程打成war包，把war包发布到Tomcat服务器上 war exploded模式是将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上 war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容 war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署 建议大家都选war模式进行部署，更符合项目部署的实际情况 部署成功后，就可以启动项目，为了能更好的看到启动的效果，可以在webapp目录下添加a.html页面 启动成功后，可以通过浏览器进行访问测试 最终的注意事项 至此，IDEA中集成本地Tomcat进行项目部署的内容我们就介绍完了，整体步骤如下，大家需要按照流程进行部署操作练习。 3.4.2 Tomcat Maven插件在IDEA中使用本地Tomcat进行项目部署，相对来说步骤比较繁琐，所以我们需要一种更简便的方式来替换它，那就是直接使用Maven中的Tomcat插件来部署项目，具体的实现步骤，只需要两步，分别是: 在pom.xml中添加Tomcat插件 org.apache.tomcat.maven tomcat7-maven-plugin 2.2 使用Maven Helper插件快速启动项目，选中项目，右键–\u003eRun Maven –\u003e tomcat7:run ==注意:== 如果选中项目并右键点击后，看不到Run Maven和Debug Maven，这个时候就需要在IDEA中下载Maven Helper插件，具体的操作方式为: File –\u003e Settings –\u003e Plugins –\u003e Maven Helper —\u003e Install,安装完后按照提示重启IDEA，就可以看到了。 Maven Tomcat插件目前只有Tomcat7版本，没有更高的版本可以使用 使用Maven Tomcat插件，要想修改Tomcat的端口和访问路径，可以直接修改pom.xml org.apache.tomcat.maven tomcat7-maven-plugin 2.2 80 / 小结 通过这一节的学习，大家要掌握在IDEA中使用Tomcat的两种方式，集成本地Tomcat和使用Maven的Tomcat插件。后者更简单，推荐大家使用，但是如果对于Tomcat的版本有比较高的要求，要在Tomcat7以上，这个时候就只能用前者了。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:4","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#341-集成本地tomcat"},{"categories":["Web"],"content":" 3.4 IDEA使用Tomcat Maven Web项目创建成功后，通过Maven的package命令可以将项目打包成war包，将war文件拷贝到Tomcat的webapps目录下，启动Tomcat就可以将项目部署成功，然后通过浏览器进行访问即可。 然而我们在开发的过程中，项目中的内容会经常发生变化，如果按照上面这种方式来部署测试，是非常不方便的 如何在IDEA中能快速使用Tomcat呢? 在IDEA中集成使用Tomcat有两种方式，分别是==集成本地Tomcat==和==Tomcat Maven插件== 3.4.1 集成本地Tomcat目标: 将刚才本地安装好的Tomcat8集成到IDEA中，完成项目部署，具体的实现步骤 打开添加本地Tomcat的面板 指定本地Tomcat的具体路径 修改Tomcat的名称，此步骤可以不改，只是让名字看起来更有意义，HTTP port中的端口也可以进行修改，比如把8080改成80 将开发项目部署项目到Tomcat中 扩展内容： xxx.war和 xxx.war exploded这两种部署项目模式的区别? war模式是将WEB工程打成war包，把war包发布到Tomcat服务器上 war exploded模式是将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上 war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容 war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署 建议大家都选war模式进行部署，更符合项目部署的实际情况 部署成功后，就可以启动项目，为了能更好的看到启动的效果，可以在webapp目录下添加a.html页面 启动成功后，可以通过浏览器进行访问测试 最终的注意事项 至此，IDEA中集成本地Tomcat进行项目部署的内容我们就介绍完了，整体步骤如下，大家需要按照流程进行部署操作练习。 3.4.2 Tomcat Maven插件在IDEA中使用本地Tomcat进行项目部署，相对来说步骤比较繁琐，所以我们需要一种更简便的方式来替换它，那就是直接使用Maven中的Tomcat插件来部署项目，具体的实现步骤，只需要两步，分别是: 在pom.xml中添加Tomcat插件 org.apache.tomcat.maven tomcat7-maven-plugin 2.2 使用Maven Helper插件快速启动项目，选中项目，右键–\u003eRun Maven –\u003e tomcat7:run ==注意:== 如果选中项目并右键点击后，看不到Run Maven和Debug Maven，这个时候就需要在IDEA中下载Maven Helper插件，具体的操作方式为: File –\u003e Settings –\u003e Plugins –\u003e Maven Helper —\u003e Install,安装完后按照提示重启IDEA，就可以看到了。 Maven Tomcat插件目前只有Tomcat7版本，没有更高的版本可以使用 使用Maven Tomcat插件，要想修改Tomcat的端口和访问路径，可以直接修改pom.xml org.apache.tomcat.maven tomcat7-maven-plugin 2.2 80 / 小结 通过这一节的学习，大家要掌握在IDEA中使用Tomcat的两种方式，集成本地Tomcat和使用Maven的Tomcat插件。后者更简单，推荐大家使用，但是如果对于Tomcat的版本有比较高的要求，要在Tomcat7以上，这个时候就只能用前者了。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:3:4","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#342-tomcat-maven插件"},{"categories":["Web"],"content":" 4， Servlet","date":"2023-12-31","objectID":"/servlet-tomcat/:4:0","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#4-servlet"},{"categories":["Web"],"content":" 4.1 简介 Servlet是JavaWeb最为核心的内容，它是Java提供的一门==动态==web资源开发技术。 使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容。 Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet 介绍完Servlet是什么以后，接下来我们就按照快速入门-\u003e执行流程-\u003e生命周期-\u003e体系结构-\u003eurlPattern配置-\u003eXML配置的学习步骤，一步步完成对Servlet的知识学习，首选我们来通过一个入门案例来快速把Servlet用起来。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:4:1","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#41-简介"},{"categories":["Web"],"content":" 4.2 快速入门==需求分析: 编写一个Servlet类，并使用IDEA中Tomcat插件进行部署，最终通过浏览器访问所编写的Servlet程序。== 具体的实现步骤为: 创建Web项目web-demo，导入Servlet依赖坐标 \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003ejavax.servlet-api\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c!-- 此处为什么需要添加该标签? provided指的是在编译和测试过程中有效,最后生成的war包时不会加入 因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错 --\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e 创建:定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话 package com.itheima.web; import javax.servlet.*; import java.io.IOException; public class ServletDemo1 implements Servlet { public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"servlet hello world~\"); } public void init(ServletConfig servletConfig) throws ServletException { } public ServletConfig getServletConfig() { return null; } public String getServletInfo() { return null; } public void destroy() { } } 配置:在类上使用@WebServlet注解，配置该Servlet的访问路径 @WebServlet(\"/demo1\") 访问:启动Tomcat,浏览器中输入URL地址访问该Servlet http://localhost:8080/web-demo/demo1 器访问后，在控制台会打印servlet hello world~ 说明servlet程序已经成功运行。 至此，Servlet的入门案例就已经完成，大家可以按照上面的步骤进行练习了。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:4:2","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#42-快速入门"},{"categories":["Web"],"content":" 4.3 执行流程Servlet程序已经能正常运行，但是我们需要思考个问题: 我们并没有创建ServletDemo1类的对象，也没有调用对象中的service方法，为什么在控制台就打印了servlet hello world~这句话呢? 要想回答上述问题，我们就需要对Servlet的执行流程进行一个学习。 浏览器发出http://localhost:8080/web-demo/demo1请求，从请求中可以解析出三部分内容，分别是localhost:8080、web-demo、demo1 根据localhost:8080可以找到要访问的Tomcat Web服务器 根据web-demo可以找到部署在Tomcat服务器上的web-demo项目 根据demo1可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配 找到ServletDemo1这个类后，Tomcat Web服务器就会为ServletDemo1这个类创建一个对象，然后调用对象中的service方法 ServletDemo1实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用 service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互 小结 介绍完Servlet的执行流程，需要大家掌握两个问题： Servlet由谁创建?Servlet方法由谁调用? Servlet由web服务器创建，Servlet方法由web服务器调用 服务器怎么知道Servlet中一定有service方法? 因为我们自定义的Servlet,必须实现Servlet接口并复写其方法，而Servlet接口中有service方法 ","date":"2023-12-31","objectID":"/servlet-tomcat/:4:3","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#43-执行流程"},{"categories":["Web"],"content":" 4.4 生命周期介绍完Servlet的执行流程后，我们知道Servlet是由Tomcat Web服务器帮我们创建的。 接下来咱们再来思考一个问题:==Tomcat什么时候创建的Servlet对象?== 要想回答上述问题，我们就需要对Servlet的生命周期进行一个学习。 生命周期: 对象的生命周期指一个对象从被创建到被销毁的整个过程。 Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段： ==加载和实例化==：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象 默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置? @WebServlet(urlPatterns = \"/demo1\",loadOnStartup = 1) loadOnstartup的取值有两类情况 （1）负整数:第一次访问时创建Servlet对象 （2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高 ==初始化==：在Servlet实例化之后，容器将调用Servlet的==init()==方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只==调用一次== ==请求处理==：==每次==请求Servlet时，Servlet容器都会调用Servlet的==service()==方法对请求进行处理 ==服务终止==：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的==destroy()==方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收 通过案例演示下上述的生命周期 package com.itheima.web; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; /** * Servlet生命周期方法 */ @WebServlet(urlPatterns = \"/demo2\",loadOnStartup = 1) public class ServletDemo2 implements Servlet { /** * 初始化方法 * 1.调用时机：默认情况下，Servlet被第一次访问时，调用 * * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用 * 2.调用次数: 1次 * @param config * @throws ServletException */ public void init(ServletConfig config) throws ServletException { System.out.println(\"init...\"); } /** * 提供服务 * 1.调用时机:每一次Servlet被访问时，调用 * 2.调用次数: 多次 * @param req * @param res * @throws ServletException * @throws IOException */ public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { System.out.println(\"servlet hello world~\"); } /** * 销毁方法 * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用 * 2.调用次数: 1次 */ public void destroy() { System.out.println(\"destroy...\"); } public ServletConfig getServletConfig() { return null; } public String getServletInfo() { return null; } } ==注意:如何才能让Servlet中的destroy方法被执行？== 在Terminal命令行中，先使用mvn tomcat7:run启动，然后再使用ctrl+c关闭tomcat 小结 这节中需要掌握的内容是: Servlet对象在什么时候被创建的? 默认是第一次访问的时候被创建，可以使用@WebServlet(urlPatterns = “/demo2”,loadOnStartup = 1)的loadOnStartup 修改成在服务器启动的时候创建。 Servlet生命周期中涉及到的三个方法，这三个方法是什么?什么时候被调用?调用几次? 涉及到三个方法，分别是 init()、service()、destroy() init方法在Servlet对象被创建的时候执行，只执行1次 service方法在Servlet被访问的时候调用，每访问1次就调用1次 destroy方法在Servlet对象被销毁的时候调用，只执行1次 ","date":"2023-12-31","objectID":"/servlet-tomcat/:4:4","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#44-生命周期"},{"categories":["Web"],"content":" 4.5 方法介绍Servlet中总共有5个方法，我们已经介绍过其中的三个，剩下的两个方法作用分别是什么？ 我们先来回顾下前面讲的三个方法，分别是: 初始化方法，在Servlet被创建时执行，只执行一次 void init(ServletConfig config) 提供服务方法， 每次Servlet被访问，都会调用该方法 void service(ServletRequest req, ServletResponse res) 销毁方法，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet void destroy() 剩下的两个方法是: 获取Servlet信息 String getServletInfo() //该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可 public String getServletInfo() { return \"\"; } 获取ServletConfig对象 ServletConfig getServletConfig() ServletConfig对象，在init方法的参数中有，而Tomcat Web服务器在创建Servlet对象的时候会调用init方法，必定会传入一个ServletConfig对象，我们只需要将服务器传过来的ServletConfig进行返回即可。具体如何操作? package com.itheima.web; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; /** * Servlet方法介绍 */ @WebServlet(urlPatterns = \"/demo3\",loadOnStartup = 1) public class ServletDemo3 implements Servlet { private ServletConfig servletConfig; /** * 初始化方法 * 1.调用时机：默认情况下，Servlet被第一次访问时，调用 * * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用 * 2.调用次数: 1次 * @param config * @throws ServletException */ public void init(ServletConfig config) throws ServletException { this.servletConfig = config; System.out.println(\"init...\"); } public ServletConfig getServletConfig() { return servletConfig; } /** * 提供服务 * 1.调用时机:每一次Servlet被访问时，调用 * 2.调用次数: 多次 * @param req * @param res * @throws ServletException * @throws IOException */ public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { System.out.println(\"servlet hello world~\"); } /** * 销毁方法 * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用 * 2.调用次数: 1次 */ public void destroy() { System.out.println(\"destroy...\"); } public String getServletInfo() { return \"\"; } } getServletInfo()和getServletConfig()这两个方法使用的不是很多，大家了解下。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:4:5","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#45-方法介绍"},{"categories":["Web"],"content":" 4.6 体系结构通过上面的学习，我们知道要想编写一个Servlet就必须要实现Servlet接口，重写接口中的5个方法，虽然已经能完成要求，但是编写起来还是比较麻烦的，因为我们更关注的其实只有service方法，那有没有更简单方式来创建Servlet呢? 要想解决上面的问题，我们需要先对Servlet的体系结构进行下了解: 因为我们将来开发B/S架构的web项目，都是针对HTTP协议，所以我们自定义Servlet,会通过继承==HttpServlet== 具体的编写格式如下: @WebServlet(\"/demo4\") public class ServletDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //TODO GET 请求方式处理逻辑 System.out.println(\"get...\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //TODO Post 请求方式处理逻辑 System.out.println(\"post...\"); } } 要想发送一个GET请求，请求该Servlet，只需要通过浏览器发送http://localhost:8080/web-demo/demo4,就能看到doGet方法被执行了 要想发送一个POST请求，请求该Servlet，单单通过浏览器是无法实现的，这个时候就需要编写一个form表单来发送请求，在webapp下创建一个a.html页面，内容如下: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"/web-demo/demo4\" method=\"post\"\u003e \u003cinput name=\"username\"/\u003e\u003cinput type=\"submit\"/\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 启动测试，即可看到doPost方法被执行了。 Servlet的简化编写就介绍完了，接着需要思考两个问题: HttpServlet中为什么要根据请求方式的不同，调用不同的方法? 如何调用? 针对问题一，我们需要回顾之前的知识点==前端发送GET和POST请求的时候，参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中==，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理，这样能实现，但是每个Servlet类中都将有相似的代码，针对这个问题，有什么可以优化的策略么? package com.itheima.web; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\"/demo5\") public class ServletDemo5 implements Servlet { public void init(ServletConfig config) throws ServletException { } public ServletConfig getServletConfig() { return null; } public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { //如何调用? //获取请求方式，根据不同的请求方式进行不同的业务处理 HttpServletRequest request = (HttpServletRequest)req; //1. 获取请求方式 String method = request.getMethod(); //2. 判断 if(\"GET\".equals(method)){ // get方式的处理逻辑 }else if(\"POST\".equals(method)){ // post方式的处理逻辑 } } public String getServletInfo() { return null; } public void destroy() { } } 要解决上述问题，我们可以对Servlet接口进行继承封装，来简化代码开发。 package com.itheima.web; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; public class MyHttpServlet implements Servlet { public void init(ServletConfig config) throws ServletException { } public ServletConfig getServletConfig() { return null; } public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { HttpServletRequest request = (HttpServletRequest)req; //1. 获取请求方式 String method = request.getMethod(); //2. 判断 if(\"GET\".equals(method)){ // get方式的处理逻辑 doGet(req,res); }else if(\"POST\".equals(method)){ // post方式的处理逻辑 doPost(req,res); } } protected void doPost(ServletRequest req, ServletResponse res) { } protected void doGet(ServletRequest req, ServletResponse res) { } public String getServletInfo() { return null; } public void destroy() { } } 有了MyHttpServlet这个类，以后我们再编写Servlet类的时候，只需要继承MyHttpServlet，重写父类中的doGet和doPost方法，就可以用来处理GET和POST请求的业务逻辑。接下来，可以把ServletDemo5代码进行改造 @WebServlet(\"/demo5\") public class ServletDemo5 extends MyHttpServlet { @Override protected void doGet(ServletRequest req, ServletResponse res) { System.out.println(\"get...\"); } @Override protected void doPost(ServletRequest req, ServletResponse res) { System.out.println(\"post...\"); } } 将来页面发送的是GET请求，则会进入到doGet方法中进行执行，如果是POST请求，则进入到doPost方法。这样代码在编写的时候就相对来说更加简单快捷。 类似MyHttpServlet这样的类Servlet中已经为我们提供好了，就是HttpServlet,翻开源码，大家可以搜索service()方法，你会发现HttpServlet做的事更多，不仅可以处理GET和POST还可以处理其他五种请求方式。 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getMethod(); if (method.equals(METHOD_GET)) { long lastModified = getLastModified(req); if (lastModified == -1) { // servlet doesn't support if-modified-since, no reason // to go through further expen","date":"2023-12-31","objectID":"/servlet-tomcat/:4:6","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#46-体系结构"},{"categories":["Web"],"content":" 4.7 urlPattern配置Servlet类编写好后，要想被访问到，就需要配置其访问路径（==urlPattern==） 一个Servlet,可以配置多个urlPattern package com.itheima.web; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; /** * urlPattern: 一个Servlet可以配置多个访问路径 */ @WebServlet(urlPatterns = {\"/demo7\",\"/demo8\"}) public class ServletDemo7 extends MyHttpServlet { @Override protected void doGet(ServletRequest req, ServletResponse res) { System.out.println(\"demo7 get...\"); } @Override protected void doPost(ServletRequest req, ServletResponse res) { } } 在浏览器上输入http://localhost:8080/web-demo/demo7,http://localhost:8080/web-demo/demo8这两个地址都能访问到ServletDemo7的doGet方法。 ==urlPattern配置规则== 精确匹配 /** * UrlPattern: * * 精确匹配 */ @WebServlet(urlPatterns = \"/user/select\") public class ServletDemo8 extends MyHttpServlet { @Override protected void doGet(ServletRequest req, ServletResponse res) { System.out.println(\"demo8 get...\"); } @Override protected void doPost(ServletRequest req, ServletResponse res) { } } 访问路径http://localhost:8080/web-demo/user/select 目录匹配 package com.itheima.web; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; /** * UrlPattern: * * 目录匹配: /user/* */ @WebServlet(urlPatterns = \"/user/*\") public class ServletDemo9 extends MyHttpServlet { @Override protected void doGet(ServletRequest req, ServletResponse res) { System.out.println(\"demo9 get...\"); } @Override protected void doPost(ServletRequest req, ServletResponse res) { } } 访问路径http://localhost:8080/web-demo/user/任意 ==思考:== 访问路径http://localhost:8080/web-demo/user是否能访问到demo9的doGet方法? 访问路径http://localhost:8080/web-demo/user/a/b是否能访问到demo9的doGet方法? 访问路径http://localhost:8080/web-demo/user/select是否能访问到demo9还是demo8的doGet方法? 答案是: 能、能、demo8，进而我们可以得到的结论是/user/*中的/*代表的是零或多个层级访问目录同时精确匹配优先级要高于目录匹配。 扩展名匹配 package com.itheima.web; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; /** * UrlPattern: * * 扩展名匹配: *.do */ @WebServlet(urlPatterns = \"*.do\") public class ServletDemo10 extends MyHttpServlet { @Override protected void doGet(ServletRequest req, ServletResponse res) { System.out.println(\"demo10 get...\"); } @Override protected void doPost(ServletRequest req, ServletResponse res) { } } 访问路径http://localhost:8080/web-demo/任意.do ==注意==: 如果路径配置的不是扩展名，那么在路径的前面就必须要加/否则会报错 如果路径配置的是*.do,那么在*.do的前面不能加/,否则会报错 任意匹配 package com.itheima.web; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; /** * UrlPattern: * * 任意匹配： / */ @WebServlet(urlPatterns = \"/\") public class ServletDemo11 extends MyHttpServlet { @Override protected void doGet(ServletRequest req, ServletResponse res) { System.out.println(\"demo11 get...\"); } @Override protected void doPost(ServletRequest req, ServletResponse res) { } } 访问路径http://localhost:8080/demo-web/任意 package com.itheima.web; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; /** * UrlPattern: * * 任意匹配： /* */ @WebServlet(urlPatterns = \"/*\") public class ServletDemo12 extends MyHttpServlet { @Override protected void doGet(ServletRequest req, ServletResponse res) { System.out.println(\"demo12 get...\"); } @Override protected void doPost(ServletRequest req, ServletResponse res) { } } 访问路径`http://localhost:8080/demo-web/任意 ==注意:==/和/*的区别? 当我们的项目中的Servlet配置了 “/\",会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet 当我们的项目中配置了”/*\",意味着匹配任意访问路径 DefaultServlet是用来处理静态资源，如果配置了\"/“会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的Servlet类，最终导致静态资源不能被访问 小结 urlPattern总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配 五种配置的优先级为 精确匹配 \u003e 目录匹配\u003e 扩展名匹配 \u003e /* \u003e / ,无需记，以最终运行结果为准。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:4:7","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#47-urlpattern配置"},{"categories":["Web"],"content":" 4.8 XML配置前面对应Servlet的配置，我们都使用的是@WebServlet,这个是Servlet从3.0版本后开始支持注解配置，3.0版本前只支持XML配置文件的配置方法。 对于XML的配置步骤有两步: 编写Servlet类 package com.itheima.web; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebServlet; public class ServletDemo13 extends MyHttpServlet { @Override protected void doGet(ServletRequest req, ServletResponse res) { System.out.println(\"demo13 get...\"); } @Override protected void doPost(ServletRequest req, ServletResponse res) { } } 在web.xml中配置该Servlet \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!-- Servlet 全类名 --\u003e \u003cservlet\u003e \u003c!-- servlet的名称，名字任意--\u003e \u003cservlet-name\u003edemo13\u003c/servlet-name\u003e \u003c!--servlet的类全名--\u003e \u003cservlet-class\u003ecom.itheima.web.ServletDemo13\u003c/servlet-class\u003e \u003c/servlet\u003e \u003c!-- Servlet 访问路径 --\u003e \u003cservlet-mapping\u003e \u003c!-- servlet的名称，要和上面的名称一致--\u003e \u003cservlet-name\u003edemo13\u003c/servlet-name\u003e \u003c!-- servlet的访问路径--\u003e \u003curl-pattern\u003e/demo13\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e 这种配置方式和注解比起来，确认麻烦很多，所以建议大家使用注解来开发。但是大家要认识上面这种配置方式，因为并不是所有的项目都是基于注解开发的。 ","date":"2023-12-31","objectID":"/servlet-tomcat/:4:8","series":null,"tags":["Web"],"title":"Servlet Tomcat","uri":"/servlet-tomcat/#48-xml配置"},{"categories":["Web"],"content":" 1，Request和Response的概述==Request是请求对象，Response是响应对象。==这两个对象在我们使用Servlet的时候有看到： 此时，我们就需要思考一个问题request和response这两个参数的作用是什么? request:==获取==请求数据 浏览器会发送HTTP请求到后台服务器[Tomcat] HTTP的请求中会包含很多请求数据[请求行+请求头+请求体] 后台服务器[Tomcat]会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中 所存入的对象即为request对象，所以我们可以从request对象中获取请求的相关参数 获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务 response:==设置==响应数据 业务处理完后，后台就需要给前端返回业务处理的结果即响应数据 把响应数据封装到response对象中 后台服务器[Tomcat]会解析response对象,按照[响应行+响应头+响应体]格式拼接结果 浏览器最终解析结果，把内容展示在浏览器给用户浏览 对于上述所讲的内容，我们通过一个案例来初步体验下request和response对象的使用。 @WebServlet(\"/demo3\") public class ServletDemo3 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //使用request对象 获取请求数据 String name = request.getParameter(\"name\");//url?name=zhangsan //使用response对象 设置响应数据 response.setHeader(\"content-type\",\"text/html;charset=utf-8\"); response.getWriter().write(\"\u003ch1\u003e\"+name+\",欢迎您！\u003c/h1\u003e\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"Post...\"); } } 启动成功后就可以通过浏览器来访问，并且根据传入参数的不同就可以在页面上展示不同的内容: 小结 在这节中，我们主要认识了下request对象和reponse对象: request对象是用来封装请求数据的对象 response对象是用来封装响应数据的对象 ","date":"2023-12-31","objectID":"/request-response/:1:0","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#1request和response的概述"},{"categories":["Web"],"content":" 2，Request对象","date":"2023-12-31","objectID":"/request-response/:2:0","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#2request对象"},{"categories":["Web"],"content":" 2.1 Request继承体系在学习这节内容之前，我们先思考一个问题，前面在介绍Request和Reponse对象的时候，比较细心的同学可能已经发现： 当我们的Servlet类实现的是Servlet接口的时候，service方法中的参数是ServletRequest和ServletResponse 当我们的Servlet类继承的是HttpServlet类的时候，doGet和doPost方法中的参数就变成HttpServletRequest和HttpServletReponse 那么， ServletRequest和HttpServletRequest的关系是什么? request对象是有谁来创建的? request提供了哪些API,这些API从哪里查? 这个时候，我们就需要用到Request继承体系中的RequestFacade: 该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口。 Servlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器[Tomcat]来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建 要想了解RequestFacade中都提供了哪些方法，我们可以直接查看JavaEE的API文档中关于ServletRequest和HttpServletRequest的接口文档，因为RequestFacade实现了其接口就需要重写接口中的方法 对于上述结论，要想验证，可以编写一个Servlet，在方法中把request对象打印下，就能看到最终的对象是不是RequestFacade,代码如下: @WebServlet(\"/demo2\") public class ServletDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(request); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 启动服务器，运行访问http://localhost:8080/request-demo/demo2,得到运行结果: 小结 Request的继承体系为ServletRequest–\u003eHttpServletRequest–\u003eRequestFacade Tomcat需要解析请求数据，封装为request对象,并且创建request对象传递到service方法 使用request对象，可以查阅JavaEE API文档的HttpServletRequest接口中方法说明 ","date":"2023-12-31","objectID":"/request-response/:2:1","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#21-request继承体系"},{"categories":["Web"],"content":" 2.2 Request获取请求数据HTTP请求数据总共分为三部分内容，分别是==请求行、请求头、请求体==，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取? 2.2.1 获取请求行数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本 对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下: 获取请求方式: GET String getMethod() 获取虚拟目录(项目访问路径): /request-demo String getContextPath() 获取URL(统一资源定位符): http://localhost:8080/request-demo/req1 StringBuffer getRequestURL() 获取URI(统一资源标识符): /request-demo/req1 String getRequestURI() 获取请求参数(GET方式): username=zhangsan\u0026password=123 String getQueryString() 介绍完上述方法后，咱们通过代码把上述方法都使用下: /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getMethod()：获取请求方式： GET String method = req.getMethod(); System.out.println(method);//GET // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo String contextPath = req.getContextPath(); System.out.println(contextPath); // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1 StringBuffer url = req.getRequestURL(); System.out.println(url.toString()); // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1 String uri = req.getRequestURI(); System.out.println(uri); // String getQueryString()：获取请求参数（GET方式）： username=zhangsan String queryString = req.getQueryString(); System.out.println(queryString); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 启动服务器，访问http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.2 获取请求头数据对于请求头的数据，格式为key: value如下: 所以根据请求头名称获取对应值的方法为: String getHeader(String name) 接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取请求头: user-agent: 浏览器的版本信息 String agent = req.getHeader(\"user-agent\"); System.out.println(agent); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 重新启动服务器后，http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.3 获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下: 对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是: 获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法 ServletInputStream getInputStream() 该方法可以获取字节 获取字符输入流，如果前端发送的是纯文本数据，则使用该方法 BufferedReader getReader() 接下来，大家需要思考，要想获取到请求体的内容该如何实现? 具体实现的步骤如下: 1.准备一个页面，在页面中添加form表单,用来发送post请求 2.在Servlet的doPost方法中获取请求体数据 3.在doPost方法中使用request的getReader()或者getInputStream()来获取 4.访问测试 在项目的webapp目录下添加一个html页面，名称为：req.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- action:form表单提交的请求地址 method:请求方式，指定为post --\u003e \u003cform action=\"/request-demo/req1\" method=\"post\"\u003e \u003cinput type=\"text\" name=\"username\"\u003e \u003cinput type=\"password\" name=\"password\"\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 在Servlet的doPost方法中获取数据 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //在此处获取请求体中的数据 } } 调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取post 请求体：请求参数 //1. 获取字符输入流 BufferedReader br = req.getReader(); //2. 读取数据 String line = br.readLine(); System.out.println(line); } } ==注意== BufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销","date":"2023-12-31","objectID":"/request-response/:2:2","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#22-request获取请求数据"},{"categories":["Web"],"content":" 2.2 Request获取请求数据HTTP请求数据总共分为三部分内容，分别是==请求行、请求头、请求体==，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取? 2.2.1 获取请求行数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本 对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下: 获取请求方式: GET String getMethod() 获取虚拟目录(项目访问路径): /request-demo String getContextPath() 获取URL(统一资源定位符): http://localhost:8080/request-demo/req1 StringBuffer getRequestURL() 获取URI(统一资源标识符): /request-demo/req1 String getRequestURI() 获取请求参数(GET方式): username=zhangsan\u0026password=123 String getQueryString() 介绍完上述方法后，咱们通过代码把上述方法都使用下: /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getMethod()：获取请求方式： GET String method = req.getMethod(); System.out.println(method);//GET // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo String contextPath = req.getContextPath(); System.out.println(contextPath); // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1 StringBuffer url = req.getRequestURL(); System.out.println(url.toString()); // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1 String uri = req.getRequestURI(); System.out.println(uri); // String getQueryString()：获取请求参数（GET方式）： username=zhangsan String queryString = req.getQueryString(); System.out.println(queryString); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 启动服务器，访问http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.2 获取请求头数据对于请求头的数据，格式为key: value如下: 所以根据请求头名称获取对应值的方法为: String getHeader(String name) 接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取请求头: user-agent: 浏览器的版本信息 String agent = req.getHeader(\"user-agent\"); System.out.println(agent); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 重新启动服务器后，http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.3 获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下: 对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是: 获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法 ServletInputStream getInputStream() 该方法可以获取字节 获取字符输入流，如果前端发送的是纯文本数据，则使用该方法 BufferedReader getReader() 接下来，大家需要思考，要想获取到请求体的内容该如何实现? 具体实现的步骤如下: 1.准备一个页面，在页面中添加form表单,用来发送post请求 2.在Servlet的doPost方法中获取请求体数据 3.在doPost方法中使用request的getReader()或者getInputStream()来获取 4.访问测试 在项目的webapp目录下添加一个html页面，名称为：req.html \u003c!DOCTYPE html\u003e Title 在Servlet的doPost方法中获取数据 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //在此处获取请求体中的数据 } } 调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取post 请求体：请求参数 //1. 获取字符输入流 BufferedReader br = req.getReader(); //2. 读取数据 String line = br.readLine(); System.out.println(line); } } ==注意== BufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销","date":"2023-12-31","objectID":"/request-response/:2:2","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#221-获取请求行数据"},{"categories":["Web"],"content":" 2.2 Request获取请求数据HTTP请求数据总共分为三部分内容，分别是==请求行、请求头、请求体==，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取? 2.2.1 获取请求行数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本 对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下: 获取请求方式: GET String getMethod() 获取虚拟目录(项目访问路径): /request-demo String getContextPath() 获取URL(统一资源定位符): http://localhost:8080/request-demo/req1 StringBuffer getRequestURL() 获取URI(统一资源标识符): /request-demo/req1 String getRequestURI() 获取请求参数(GET方式): username=zhangsan\u0026password=123 String getQueryString() 介绍完上述方法后，咱们通过代码把上述方法都使用下: /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getMethod()：获取请求方式： GET String method = req.getMethod(); System.out.println(method);//GET // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo String contextPath = req.getContextPath(); System.out.println(contextPath); // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1 StringBuffer url = req.getRequestURL(); System.out.println(url.toString()); // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1 String uri = req.getRequestURI(); System.out.println(uri); // String getQueryString()：获取请求参数（GET方式）： username=zhangsan String queryString = req.getQueryString(); System.out.println(queryString); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 启动服务器，访问http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.2 获取请求头数据对于请求头的数据，格式为key: value如下: 所以根据请求头名称获取对应值的方法为: String getHeader(String name) 接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取请求头: user-agent: 浏览器的版本信息 String agent = req.getHeader(\"user-agent\"); System.out.println(agent); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 重新启动服务器后，http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.3 获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下: 对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是: 获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法 ServletInputStream getInputStream() 该方法可以获取字节 获取字符输入流，如果前端发送的是纯文本数据，则使用该方法 BufferedReader getReader() 接下来，大家需要思考，要想获取到请求体的内容该如何实现? 具体实现的步骤如下: 1.准备一个页面，在页面中添加form表单,用来发送post请求 2.在Servlet的doPost方法中获取请求体数据 3.在doPost方法中使用request的getReader()或者getInputStream()来获取 4.访问测试 在项目的webapp目录下添加一个html页面，名称为：req.html \u003c!DOCTYPE html\u003e Title 在Servlet的doPost方法中获取数据 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //在此处获取请求体中的数据 } } 调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取post 请求体：请求参数 //1. 获取字符输入流 BufferedReader br = req.getReader(); //2. 读取数据 String line = br.readLine(); System.out.println(line); } } ==注意== BufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销","date":"2023-12-31","objectID":"/request-response/:2:2","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#222-获取请求头数据"},{"categories":["Web"],"content":" 2.2 Request获取请求数据HTTP请求数据总共分为三部分内容，分别是==请求行、请求头、请求体==，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取? 2.2.1 获取请求行数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本 对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下: 获取请求方式: GET String getMethod() 获取虚拟目录(项目访问路径): /request-demo String getContextPath() 获取URL(统一资源定位符): http://localhost:8080/request-demo/req1 StringBuffer getRequestURL() 获取URI(统一资源标识符): /request-demo/req1 String getRequestURI() 获取请求参数(GET方式): username=zhangsan\u0026password=123 String getQueryString() 介绍完上述方法后，咱们通过代码把上述方法都使用下: /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getMethod()：获取请求方式： GET String method = req.getMethod(); System.out.println(method);//GET // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo String contextPath = req.getContextPath(); System.out.println(contextPath); // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1 StringBuffer url = req.getRequestURL(); System.out.println(url.toString()); // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1 String uri = req.getRequestURI(); System.out.println(uri); // String getQueryString()：获取请求参数（GET方式）： username=zhangsan String queryString = req.getQueryString(); System.out.println(queryString); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 启动服务器，访问http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.2 获取请求头数据对于请求头的数据，格式为key: value如下: 所以根据请求头名称获取对应值的方法为: String getHeader(String name) 接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取请求头: user-agent: 浏览器的版本信息 String agent = req.getHeader(\"user-agent\"); System.out.println(agent); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 重新启动服务器后，http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.3 获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下: 对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是: 获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法 ServletInputStream getInputStream() 该方法可以获取字节 获取字符输入流，如果前端发送的是纯文本数据，则使用该方法 BufferedReader getReader() 接下来，大家需要思考，要想获取到请求体的内容该如何实现? 具体实现的步骤如下: 1.准备一个页面，在页面中添加form表单,用来发送post请求 2.在Servlet的doPost方法中获取请求体数据 3.在doPost方法中使用request的getReader()或者getInputStream()来获取 4.访问测试 在项目的webapp目录下添加一个html页面，名称为：req.html \u003c!DOCTYPE html\u003e Title 在Servlet的doPost方法中获取数据 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //在此处获取请求体中的数据 } } 调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取post 请求体：请求参数 //1. 获取字符输入流 BufferedReader br = req.getReader(); //2. 读取数据 String line = br.readLine(); System.out.println(line); } } ==注意== BufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销","date":"2023-12-31","objectID":"/request-response/:2:2","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#223-获取请求体数据"},{"categories":["Web"],"content":" 2.2 Request获取请求数据HTTP请求数据总共分为三部分内容，分别是==请求行、请求头、请求体==，对于这三部分内容的数据，分别该如何获取，首先我们先来学习请求行数据如何获取? 2.2.1 获取请求行数据请求行包含三块内容，分别是请求方式、请求资源路径、HTTP协议及版本 对于这三部分内容，request对象都提供了对应的API方法来获取，具体如下: 获取请求方式: GET String getMethod() 获取虚拟目录(项目访问路径): /request-demo String getContextPath() 获取URL(统一资源定位符): http://localhost:8080/request-demo/req1 StringBuffer getRequestURL() 获取URI(统一资源标识符): /request-demo/req1 String getRequestURI() 获取请求参数(GET方式): username=zhangsan\u0026password=123 String getQueryString() 介绍完上述方法后，咱们通过代码把上述方法都使用下: /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // String getMethod()：获取请求方式： GET String method = req.getMethod(); System.out.println(method);//GET // String getContextPath()：获取虚拟目录(项目访问路径)：/request-demo String contextPath = req.getContextPath(); System.out.println(contextPath); // StringBuffer getRequestURL(): 获取URL(统一资源定位符)：http://localhost:8080/request-demo/req1 StringBuffer url = req.getRequestURL(); System.out.println(url.toString()); // String getRequestURI()：获取URI(统一资源标识符)： /request-demo/req1 String uri = req.getRequestURI(); System.out.println(uri); // String getQueryString()：获取请求参数（GET方式）： username=zhangsan String queryString = req.getQueryString(); System.out.println(queryString); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 启动服务器，访问http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.2 获取请求头数据对于请求头的数据，格式为key: value如下: 所以根据请求头名称获取对应值的方法为: String getHeader(String name) 接下来，在代码中如果想要获取客户端浏览器的版本信息，则可以使用 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取请求头: user-agent: 浏览器的版本信息 String agent = req.getHeader(\"user-agent\"); System.out.println(agent); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } } 重新启动服务器后，http://localhost:8080/request-demo/req1?username=zhangsan\u0026passwrod=123，获取的结果如下: 2.2.3 获取请求体数据浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST，请求体中的数据格式如下: 对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是: 获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法 ServletInputStream getInputStream() 该方法可以获取字节 获取字符输入流，如果前端发送的是纯文本数据，则使用该方法 BufferedReader getReader() 接下来，大家需要思考，要想获取到请求体的内容该如何实现? 具体实现的步骤如下: 1.准备一个页面，在页面中添加form表单,用来发送post请求 2.在Servlet的doPost方法中获取请求体数据 3.在doPost方法中使用request的getReader()或者getInputStream()来获取 4.访问测试 在项目的webapp目录下添加一个html页面，名称为：req.html \u003c!DOCTYPE html\u003e Title 在Servlet的doPost方法中获取数据 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //在此处获取请求体中的数据 } } 调用getReader()或者getInputStream()方法，因为目前前端传递的是纯文本数据，所以我们采用getReader()方法来获取 /** * request 获取请求数据 */ @WebServlet(\"/req1\") public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取post 请求体：请求参数 //1. 获取字符输入流 BufferedReader br = req.getReader(); //2. 读取数据 String line = br.readLine(); System.out.println(line); } } ==注意== BufferedReader流是通过request对象来获取的，当请求完成后request对象就会被销毁，request对象被销","date":"2023-12-31","objectID":"/request-response/:2:2","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#224-获取请求参数的通用方式"},{"categories":["Web"],"content":" 2.3 IDEA快速创建Servlet使用通用方式获取请求参数后，屏蔽了GET和POST的请求方式代码的不同，则代码可以定义如下格式: 由于格式固定，所以我们可以使用IDEA提供的模板来制作一个Servlet的模板，这样我们后期在创建Servlet的时候就会更高效，具体如何实现: (1)按照自己的需求，修改Servlet创建的模板内容 (2)使用servlet模板创建Servlet类 ","date":"2023-12-31","objectID":"/request-response/:2:3","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#23-idea快速创建servlet"},{"categories":["Web"],"content":" 2.4 请求参数中文乱码问题问题展示: (1)将req.html页面的请求方式修改为get \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"/request-demo/req2\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"username\"\u003e\u003cbr\u003e \u003cinput type=\"password\" name=\"password\"\u003e\u003cbr\u003e \u003cinput type=\"checkbox\" name=\"hobby\" value=\"1\"\u003e 游泳 \u003cinput type=\"checkbox\" name=\"hobby\" value=\"2\"\u003e 爬山 \u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e (2)在Servlet方法中获取参数，并打印 /** * 中文乱码问题解决方案 */ @WebServlet(\"/req4\") public class RequestDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 获取username String username = request.getParameter(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } （3）启动服务器，页面上输入中文参数 （4）查看控制台打印内容 （5）把req.html页面的请求方式改成post,再次发送请求和中文参数 （6）查看控制台打印内容，依然为乱码 通过上面的案例，会发现，不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。具体该如何解决呢？ 2.4.1 POST请求解决方案 分析出现中文乱码的原因： POST的请求参数是通过request的getReader()来获取流中的数据 TOMCAT在获取流的时候采用的编码是ISO-8859-1 ISO-8859-1编码是不支持中文的，所以会出现乱码 解决方案： 页面设置的编码格式为UTF-8 把TOMCAT在获取流数据之前的编码设置为UTF-8 通过request.setCharacterEncoding(“UTF-8”)设置编码,UTF-8也可以写成小写 修改后的代码为: /** * 中文乱码问题解决方案 */ @WebServlet(\"/req4\") public class RequestDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 解决乱码: POST getReader() //设置字符输入流的编码，设置的字符集要和页面保持一致 request.setCharacterEncoding(\"UTF-8\"); //2. 获取username String username = request.getParameter(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 重新发送POST请求，就会在控制台看到正常展示的中文结果。 至此POST请求中文乱码的问题就已经解决，但是这种方案不适用于GET请求，这个原因是什么呢，咱们下面再分析。 2.4.2 GET请求解决方案刚才提到一个问题是POST请求的中文乱码解决方案为什么不适用GET请求？ GET请求获取请求参数的方式是request.getQueryString() POST请求获取请求参数的方式是request.getReader() request.setCharacterEncoding(“utf-8”)是设置request处理流的编码 getQueryString方法并没有通过流的方式获取数据 所以GET请求不能用设置编码的方式来解决中文乱码问题，那问题又来了，如何解决GET请求的中文乱码呢? 首先我们需要先分析下GET请求出现乱码的原因: (1)浏览器通过HTTP协议发送请求和数据给后台服务器（Tomcat) (2)浏览器在发送HTTP的过程中会对中文数据进行URL==编码== (3)在进行URL编码的时候会采用页面\u003cmeta\u003e标签指定的UTF-8的方式进行编码，张三编码后的结果为%E5%BC%A0%E4%B8%89 (4)后台服务器(Tomcat)接收到%E5%BC%A0%E4%B8%89后会默认按照ISO-8859-1进行URL==解码== (5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。 思考: 如果把req.html页面的\u003cmeta\u003e标签的charset属性改成ISO-8859-1,后台不做操作，能解决中文乱码问题么? 答案是否定的，因为ISO-8859-1本身是不支持中文展示的，所以改了标签的charset属性后，会导致页面上的中文内容都无法正常展示。 分析完上面的问题后，我们会发现，其中有两个我们不熟悉的内容就是==URL编码==和==URL解码==，什么是URL编码，什么又是URL解码呢? URL编码 这块知识我们只需要了解下即可,具体编码过程分两步，分别是: (1)将字符串按照编码方式转为二进制 (2)每个字节转为2个16进制数并在前边加上% 张三按照UTF-8的方式转换成二进制的结果为: 1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001 这个结果是如何计算的? 使用http://www.mytju.com/classcode/tools/encode_utf8.asp，输入张三 就可以获取张和三分别对应的10进制，然后在使用计算器，选择程序员模式，计算出对应的二进制数据结果: 在计算的十六进制结果中，每两位前面加一个%,就可以获取到%E5%BC%A0%E4%B8%89。 当然你从上面所提供的网站中就已经能看到编码16进制的结果了: 但是对于上面的计算过程，如果没有工具，纯手工计算的话，相对来说还是比较复杂的，我们也不需要进行手动计算，在Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码: 编码: java.net.URLEncoder.encode(\"需要被编码的内容\",\"字符集(UTF-8)\") 解码: java.net.URLDecoder.decode(\"需要被解码的内容\",\"字符集(UTF-8)\") 接下来咱们对张三来进行编码和解码 public class URLDemo { public static void main(String[] args) throws UnsupportedEncodingException { String username = \"张三\"; //1. URL编码 String encode = URLEncoder.encode(username, \"utf-8\"); System.out.println(encode); //打印:%E5%BC%A0%E4%B8%89 //2. URL解码 //String decode = URLDecoder.decode(encode, \"utf-8\");//打印:张三 String decode = URLDecoder.decode(encode, \"ISO-8859-1\");//打印:`å¼ ä¸ ` System.out.println(decode); } } 到这，我们就可以分析出GET请求中文参数出现乱码的原因了， 浏览器把中文参数按照UTF-8进行URL编码 Tomcat对获取到的内容进行了ISO-8859-1的URL解码 在控制台就会出现类上å¼ ä¸的乱码，最后一位是个空格 清楚了出现乱码的原因，接下来我们就需要想办法进行解决 从上图可以看住， 在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的%E5%BC%A0%E4%B8%89是一致的 那他们对应的二进制值也是一样的，为: 1110 0101 1011 1100 1010 0000 1110","date":"2023-12-31","objectID":"/request-response/:2:4","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#24-请求参数中文乱码问题"},{"categories":["Web"],"content":" 2.4 请求参数中文乱码问题问题展示: (1)将req.html页面的请求方式修改为get \u003c!DOCTYPE html\u003e Title 游泳 爬山 (2)在Servlet方法中获取参数，并打印 /** * 中文乱码问题解决方案 */ @WebServlet(\"/req4\") public class RequestDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 获取username String username = request.getParameter(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } （3）启动服务器，页面上输入中文参数 （4）查看控制台打印内容 （5）把req.html页面的请求方式改成post,再次发送请求和中文参数 （6）查看控制台打印内容，依然为乱码 通过上面的案例，会发现，不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。具体该如何解决呢？ 2.4.1 POST请求解决方案 分析出现中文乱码的原因： POST的请求参数是通过request的getReader()来获取流中的数据 TOMCAT在获取流的时候采用的编码是ISO-8859-1 ISO-8859-1编码是不支持中文的，所以会出现乱码 解决方案： 页面设置的编码格式为UTF-8 把TOMCAT在获取流数据之前的编码设置为UTF-8 通过request.setCharacterEncoding(“UTF-8”)设置编码,UTF-8也可以写成小写 修改后的代码为: /** * 中文乱码问题解决方案 */ @WebServlet(\"/req4\") public class RequestDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 解决乱码: POST getReader() //设置字符输入流的编码，设置的字符集要和页面保持一致 request.setCharacterEncoding(\"UTF-8\"); //2. 获取username String username = request.getParameter(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 重新发送POST请求，就会在控制台看到正常展示的中文结果。 至此POST请求中文乱码的问题就已经解决，但是这种方案不适用于GET请求，这个原因是什么呢，咱们下面再分析。 2.4.2 GET请求解决方案刚才提到一个问题是POST请求的中文乱码解决方案为什么不适用GET请求？ GET请求获取请求参数的方式是request.getQueryString() POST请求获取请求参数的方式是request.getReader() request.setCharacterEncoding(“utf-8”)是设置request处理流的编码 getQueryString方法并没有通过流的方式获取数据 所以GET请求不能用设置编码的方式来解决中文乱码问题，那问题又来了，如何解决GET请求的中文乱码呢? 首先我们需要先分析下GET请求出现乱码的原因: (1)浏览器通过HTTP协议发送请求和数据给后台服务器（Tomcat) (2)浏览器在发送HTTP的过程中会对中文数据进行URL==编码== (3)在进行URL编码的时候会采用页面标签指定的UTF-8的方式进行编码，张三编码后的结果为%E5%BC%A0%E4%B8%89 (4)后台服务器(Tomcat)接收到%E5%BC%A0%E4%B8%89后会默认按照ISO-8859-1进行URL==解码== (5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。 思考: 如果把req.html页面的标签的charset属性改成ISO-8859-1,后台不做操作，能解决中文乱码问题么? 答案是否定的，因为ISO-8859-1本身是不支持中文展示的，所以改了标签的charset属性后，会导致页面上的中文内容都无法正常展示。 分析完上面的问题后，我们会发现，其中有两个我们不熟悉的内容就是==URL编码==和==URL解码==，什么是URL编码，什么又是URL解码呢? URL编码 这块知识我们只需要了解下即可,具体编码过程分两步，分别是: (1)将字符串按照编码方式转为二进制 (2)每个字节转为2个16进制数并在前边加上% 张三按照UTF-8的方式转换成二进制的结果为: 1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001 这个结果是如何计算的? 使用http://www.mytju.com/classcode/tools/encode_utf8.asp，输入张三 就可以获取张和三分别对应的10进制，然后在使用计算器，选择程序员模式，计算出对应的二进制数据结果: 在计算的十六进制结果中，每两位前面加一个%,就可以获取到%E5%BC%A0%E4%B8%89。 当然你从上面所提供的网站中就已经能看到编码16进制的结果了: 但是对于上面的计算过程，如果没有工具，纯手工计算的话，相对来说还是比较复杂的，我们也不需要进行手动计算，在Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码: 编码: java.net.URLEncoder.encode(\"需要被编码的内容\",\"字符集(UTF-8)\") 解码: java.net.URLDecoder.decode(\"需要被解码的内容\",\"字符集(UTF-8)\") 接下来咱们对张三来进行编码和解码 public class URLDemo { public static void main(String[] args) throws UnsupportedEncodingException { String username = \"张三\"; //1. URL编码 String encode = URLEncoder.encode(username, \"utf-8\"); System.out.println(encode); //打印:%E5%BC%A0%E4%B8%89 //2. URL解码 //String decode = URLDecoder.decode(encode, \"utf-8\");//打印:张三 String decode = URLDecoder.decode(encode, \"ISO-8859-1\");//打印:`å¼ ä¸ ` System.out.println(decode); } } 到这，我们就可以分析出GET请求中文参数出现乱码的原因了， 浏览器把中文参数按照UTF-8进行URL编码 Tomcat对获取到的内容进行了ISO-8859-1的URL解码 在控制台就会出现类上å¼ ä¸的乱码，最后一位是个空格 清楚了出现乱码的原因，接下来我们就需要想办法进行解决 从上图可以看住， 在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的%E5%BC%A0%E4%B8%89是一致的 那他们对应的二进制值也是一样的，为: 1110 0101 1011 1100 1010 0000 1110","date":"2023-12-31","objectID":"/request-response/:2:4","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#241-post请求解决方案"},{"categories":["Web"],"content":" 2.4 请求参数中文乱码问题问题展示: (1)将req.html页面的请求方式修改为get \u003c!DOCTYPE html\u003e Title 游泳 爬山 (2)在Servlet方法中获取参数，并打印 /** * 中文乱码问题解决方案 */ @WebServlet(\"/req4\") public class RequestDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 获取username String username = request.getParameter(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } （3）启动服务器，页面上输入中文参数 （4）查看控制台打印内容 （5）把req.html页面的请求方式改成post,再次发送请求和中文参数 （6）查看控制台打印内容，依然为乱码 通过上面的案例，会发现，不管是GET还是POST请求，在发送的请求参数中如果有中文，在后台接收的时候，都会出现中文乱码的问题。具体该如何解决呢？ 2.4.1 POST请求解决方案 分析出现中文乱码的原因： POST的请求参数是通过request的getReader()来获取流中的数据 TOMCAT在获取流的时候采用的编码是ISO-8859-1 ISO-8859-1编码是不支持中文的，所以会出现乱码 解决方案： 页面设置的编码格式为UTF-8 把TOMCAT在获取流数据之前的编码设置为UTF-8 通过request.setCharacterEncoding(“UTF-8”)设置编码,UTF-8也可以写成小写 修改后的代码为: /** * 中文乱码问题解决方案 */ @WebServlet(\"/req4\") public class RequestDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 解决乱码: POST getReader() //设置字符输入流的编码，设置的字符集要和页面保持一致 request.setCharacterEncoding(\"UTF-8\"); //2. 获取username String username = request.getParameter(\"username\"); System.out.println(username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 重新发送POST请求，就会在控制台看到正常展示的中文结果。 至此POST请求中文乱码的问题就已经解决，但是这种方案不适用于GET请求，这个原因是什么呢，咱们下面再分析。 2.4.2 GET请求解决方案刚才提到一个问题是POST请求的中文乱码解决方案为什么不适用GET请求？ GET请求获取请求参数的方式是request.getQueryString() POST请求获取请求参数的方式是request.getReader() request.setCharacterEncoding(“utf-8”)是设置request处理流的编码 getQueryString方法并没有通过流的方式获取数据 所以GET请求不能用设置编码的方式来解决中文乱码问题，那问题又来了，如何解决GET请求的中文乱码呢? 首先我们需要先分析下GET请求出现乱码的原因: (1)浏览器通过HTTP协议发送请求和数据给后台服务器（Tomcat) (2)浏览器在发送HTTP的过程中会对中文数据进行URL==编码== (3)在进行URL编码的时候会采用页面标签指定的UTF-8的方式进行编码，张三编码后的结果为%E5%BC%A0%E4%B8%89 (4)后台服务器(Tomcat)接收到%E5%BC%A0%E4%B8%89后会默认按照ISO-8859-1进行URL==解码== (5)由于前后编码与解码采用的格式不一样，就会导致后台获取到的数据为乱码。 思考: 如果把req.html页面的标签的charset属性改成ISO-8859-1,后台不做操作，能解决中文乱码问题么? 答案是否定的，因为ISO-8859-1本身是不支持中文展示的，所以改了标签的charset属性后，会导致页面上的中文内容都无法正常展示。 分析完上面的问题后，我们会发现，其中有两个我们不熟悉的内容就是==URL编码==和==URL解码==，什么是URL编码，什么又是URL解码呢? URL编码 这块知识我们只需要了解下即可,具体编码过程分两步，分别是: (1)将字符串按照编码方式转为二进制 (2)每个字节转为2个16进制数并在前边加上% 张三按照UTF-8的方式转换成二进制的结果为: 1110 0101 1011 1100 1010 0000 1110 0100 1011 1000 1000 1001 这个结果是如何计算的? 使用http://www.mytju.com/classcode/tools/encode_utf8.asp，输入张三 就可以获取张和三分别对应的10进制，然后在使用计算器，选择程序员模式，计算出对应的二进制数据结果: 在计算的十六进制结果中，每两位前面加一个%,就可以获取到%E5%BC%A0%E4%B8%89。 当然你从上面所提供的网站中就已经能看到编码16进制的结果了: 但是对于上面的计算过程，如果没有工具，纯手工计算的话，相对来说还是比较复杂的，我们也不需要进行手动计算，在Java中已经为我们提供了编码和解码的API工具类可以让我们更快速的进行编码和解码: 编码: java.net.URLEncoder.encode(\"需要被编码的内容\",\"字符集(UTF-8)\") 解码: java.net.URLDecoder.decode(\"需要被解码的内容\",\"字符集(UTF-8)\") 接下来咱们对张三来进行编码和解码 public class URLDemo { public static void main(String[] args) throws UnsupportedEncodingException { String username = \"张三\"; //1. URL编码 String encode = URLEncoder.encode(username, \"utf-8\"); System.out.println(encode); //打印:%E5%BC%A0%E4%B8%89 //2. URL解码 //String decode = URLDecoder.decode(encode, \"utf-8\");//打印:张三 String decode = URLDecoder.decode(encode, \"ISO-8859-1\");//打印:`å¼ ä¸ ` System.out.println(decode); } } 到这，我们就可以分析出GET请求中文参数出现乱码的原因了， 浏览器把中文参数按照UTF-8进行URL编码 Tomcat对获取到的内容进行了ISO-8859-1的URL解码 在控制台就会出现类上å¼ ä¸的乱码，最后一位是个空格 清楚了出现乱码的原因，接下来我们就需要想办法进行解决 从上图可以看住， 在进行编码和解码的时候，不管使用的是哪个字符集，他们对应的%E5%BC%A0%E4%B8%89是一致的 那他们对应的二进制值也是一样的，为: 1110 0101 1011 1100 1010 0000 1110","date":"2023-12-31","objectID":"/request-response/:2:4","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#242-get请求解决方案"},{"categories":["Web"],"content":" 2.5 Request请求转发 ==请求转发(forward):一种在服务器内部的资源跳转方式。== (1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求 (2)资源A处理完请求后将请求发给资源B (3)资源B处理完后将结果响应给浏览器 (4)请求从资源A到资源B的过程就叫==请求转发== 请求转发的实现方式: req.getRequestDispatcher(\"资源B路径\").forward(req,resp); 具体如何来使用，我们先来看下需求: 针对上述需求，具体的实现步骤为: 1.创建一个RequestDemo5类，接收/req5的请求，在doGet方法中打印demo5 2.创建一个RequestDemo6类，接收/req6的请求，在doGet方法中打印demo6 3.在RequestDemo5的方法中使用 ​ req.getRequestDispatcher(\"/req6\").forward(req,resp)进行请求转发 4.启动测试 (1)创建RequestDemo5类 /** * 请求转发 */ @WebServlet(\"/req5\") public class RequestDemo5 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo5...\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (2)创建RequestDemo6类 /** * 请求转发 */ @WebServlet(\"/req6\") public class RequestDemo6 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo6...\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (3)在RequestDemo5的doGet方法中进行请求转发 /** * 请求转发 */ @WebServlet(\"/req5\") public class RequestDemo5 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo5...\"); //请求转发 request.getRequestDispatcher(\"/req6\").forward(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (4)启动测试 访问http://localhost:8080/request-demo/req5,就可以在控制台看到如下内容: 说明请求已经转发到了/req6 请求转发资源间共享数据:使用Request对象 此处主要解决的问题是把请求从/req5转发到/req6的时候，如何传递数据给/req6。 需要使用request对象提供的三个方法: 存储数据到request域[范围,数据是存储在request对象]中 void setAttribute(String name,Object o); 根据key获取值 Object getAttribute(String name); 根据key删除该键值对 void removeAttribute(String name); 接着上个需求来: 1.在RequestDemo5的doGet方法中转发请求之前，将数据存入request域对象中 2.在RequestDemo6的doGet方法从request域对象中获取数据，并将数据打印到控制台 3.启动访问测试 (1)修改RequestDemo5中的方法 @WebServlet(\"/req5\") public class RequestDemo5 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo5...\"); //存储数据 request.setAttribute(\"msg\",\"hello\"); //请求转发 request.getRequestDispatcher(\"/req6\").forward(request,response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (2)修改RequestDemo6中的方法 /** * 请求转发 */ @WebServlet(\"/req6\") public class RequestDemo6 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"demo6...\"); //获取数据 Object msg = request.getAttribute(\"msg\"); System.out.println(msg); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (3)启动测试 访问http://localhost:8080/request-demo/req5,就可以在控制台看到如下内容: 此时就可以实现在转发多个资源之间共享数据。 请求转发的特点 浏览器地址栏路径不发生变化 虽然后台从/req5转发到/req6,但是浏览器的地址一直是/req5,未发生变化 只能转发到当前服务器的内部资源 不能从一个服务器通过转发访问另一台服务器 一次请求，可以在转发资源间使用request共享数据 虽然后台从/req5转发到/req6，但是这个==只有一次请求== ","date":"2023-12-31","objectID":"/request-response/:2:5","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#25-request请求转发"},{"categories":["Web"],"content":" 3，Response对象前面讲解完Request对象，接下来我们回到刚开始的那张图: Request:使用request对象来==获取==请求数据 Response:使用response对象来==设置==响应数据 Reponse的继承体系和Request的继承体系也非常相似: 介绍完Response的相关体系结构后，接下来对于Response我们需要学习如下内容: Response设置响应数据的功能介绍 Response完成重定向 Response响应字符数据 Response响应字节数据 ","date":"2023-12-31","objectID":"/request-response/:3:0","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#3response对象"},{"categories":["Web"],"content":" 3.1 Response设置响应数据功能介绍HTTP响应数据总共分为三部分内容，分别是==响应行、响应头、响应体==，对于这三部分内容的数据，respone对象都提供了哪些方法来进行设置? 响应行 对于响应头，比较常用的就是设置响应状态码: void setStatus(int sc); 响应头 设置响应头键值对： void setHeader(String name,String value); 响应体 对于响应体，是通过字符、字节输出流的方式往浏览器写， 获取字符输出流: PrintWriter getWriter(); 获取字节输出流 ServletOutputStream getOutputStream(); 介绍完这些方法后，后面我们会通过案例把这些方法都用一用，首先先来完成下重定向的功能开发。 ","date":"2023-12-31","objectID":"/request-response/:3:1","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#31-response设置响应数据功能介绍"},{"categories":["Web"],"content":" 3.2 Respones请求重定向 ==Response重定向(redirect):一种资源跳转方式。== (1)浏览器发送请求给服务器，服务器中对应的资源A接收到请求 (2)资源A现在无法处理该请求，就会给浏览器响应一个302的状态码+location的一个访问资源B的路径 (3)浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B (4)资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫==重定向== 重定向的实现方式: resp.setStatus(302); resp.setHeader(\"location\",\"资源B的访问路径\"); 具体如何来使用，我们先来看下需求: 针对上述需求，具体的实现步骤为: 1.创建一个ResponseDemo1类，接收/resp1的请求，在doGet方法中打印resp1.... 2.创建一个ResponseDemo2类，接收/resp2的请求，在doGet方法中打印resp2.... 3.在ResponseDemo1的方法中使用 ​ response.setStatus(302); ​ response.setHeader(“Location”,\"/request-demo/resp2\") 来给前端响应结果数据 4.启动测试 (1)创建ResponseDemo1类 @WebServlet(\"/resp1\") public class ResponseDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"resp1....\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (2)创建ResponseDemo2类 @WebServlet(\"/resp2\") public class ResponseDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"resp2....\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (3)在ResponseDemo1的doGet方法中给前端响应数据 @WebServlet(\"/resp1\") public class ResponseDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"resp1....\"); //重定向 //1.设置响应状态码 302 response.setStatus(302); //2. 设置响应头 Location response.setHeader(\"Location\",\"/request-demo/resp2\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } (4)启动测试 访问http://localhost:8080/request-demo/resp1,就可以在控制台看到如下内容: 说明/resp1和/resp2都被访问到了。到这重定向就已经完成了。 虽然功能已经实现，但是从设置重定向的两行代码来看，会发现除了重定向的地址不一样，其他的内容都是一模一样，所以request对象给我们提供了简化的编写方式为: resposne.sendRedirect(\"/request-demo/resp2\") 所以第3步中的代码就可以简化为： @WebServlet(\"/resp1\") public class ResponseDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"resp1....\"); //重定向 resposne.sendRedirect(\"/request-demo/resp2\")； } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 重定向的特点 浏览器地址栏路径发送变化 当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化 可以重定向到任何位置的资源(服务内容、外部均可) 因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。 两次请求，不能在多个资源使用request共享数据 因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据 介绍完==请求重定向==和==请求转发==以后，接下来需要把这两个放在一块对比下: 以后到底用哪个，还是需要根据具体的业务来决定。 ","date":"2023-12-31","objectID":"/request-response/:3:2","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#32-respones请求重定向"},{"categories":["Web"],"content":" 3.3 路径问题 问题1：转发的时候路径上没有加/request-demo而重定向加了，那么到底什么时候需要加，什么时候不需要加呢? 其实判断的依据很简单，只需要记住下面的规则即可: 浏览器使用:需要加虚拟目录(项目访问路径) 服务端使用:不需要加虚拟目录 对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录 对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。 掌握了这个规则，接下来就通过一些练习来强化下知识的学习: \u003ca href='路劲'\u003e \u003cform action='路径'\u003e req.getRequestDispatcher(“路径”) resp.sendRedirect(“路径”) 答案: 1.超链接，从浏览器发送，需要加 2.表单，从浏览器发送，需要加 3.转发，是从服务器内部跳转，不需要加 4.重定向，是由浏览器进行跳转，需要加。 问题2：在重定向的代码中，/request-demo是固定编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，该如何优化? 答案也比较简单，我们可以在代码中动态去获取项目访问的虚拟目录，具体如何获取，我们可以借助前面咱们所学习的request对象中的getContextPath()方法，修改后的代码如下: @WebServlet(\"/resp1\") public class ResponseDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"resp1....\"); //简化方式完成重定向 //动态获取虚拟目录 String contextPath = request.getContextPath(); response.sendRedirect(contextPath+\"/resp2\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 重新启动访问测试，功能依然能够实现，此时就可以动态获取项目访问的虚拟路径，从而降低代码的耦合度。 ","date":"2023-12-31","objectID":"/request-response/:3:3","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#33-路径问题"},{"categories":["Web"],"content":" 3.4 Response响应字符数据要想将字符数据写回到浏览器，我们需要两个步骤: 通过Response对象获取字符输出流： PrintWriter writer = resp.getWriter(); 通过字符输出流写数据: writer.write(“aaa”); 接下来，我们实现通过些案例把响应字符数据给实际应用下: 返回一个简单的字符串aaa /** * 响应字符数据：设置字符数据的响应体 */ @WebServlet(\"/resp3\") public class ResponseDemo3 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html;charset=utf-8\"); //1. 获取字符输出流 PrintWriter writer = response.getWriter(); writer.write(\"aaa\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 返回一串html字符串，并且能被浏览器解析 PrintWriter writer = response.getWriter(); //content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签 response.setHeader(\"content-type\",\"text/html\"); writer.write(\"\u003ch1\u003eaaa\u003c/h1\u003e\"); ==注意:==一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。 返回一个中文的字符串你好，需要注意设置响应数据的编码为utf-8 //设置响应的数据格式及数据的编码 response.setContentType(\"text/html;charset=utf-8\"); writer.write(\"你好\"); ","date":"2023-12-31","objectID":"/request-response/:3:4","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#34-response响应字符数据"},{"categories":["Web"],"content":" 3.3 Response响应字节数据要想将字节数据写回到浏览器，我们需要两个步骤: 通过Response对象获取字节输出流：ServletOutputStream outputStream = resp.getOutputStream(); 通过字节输出流写数据: outputStream.write(字节数据); 接下来，我们实现通过些案例把响应字符数据给实际应用下: 返回一个图片文件到浏览器 /** * 响应字节数据：设置字节数据的响应体 */ @WebServlet(\"/resp4\") public class ResponseDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 读取文件 FileInputStream fis = new FileInputStream(\"d://a.jpg\"); //2. 获取response字节输出流 ServletOutputStream os = response.getOutputStream(); //3. 完成流的copy byte[] buff = new byte[1024]; int len = 0; while ((len = fis.read(buff))!= -1){ os.write(buff,0,len); } fis.close(); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 上述代码中，对于流的copy的代码还是比较复杂的，所以我们可以使用别人提供好的方法来简化代码的开发，具体的步骤是: (1)pom.xml添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecommons-io\u003c/groupId\u003e \u003cartifactId\u003ecommons-io\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e (2)调用工具类方法 //fis:输入流 //os:输出流 IOUtils.copy(fis,os); 优化后的代码: /** * 响应字节数据：设置字节数据的响应体 */ @WebServlet(\"/resp4\") public class ResponseDemo4 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 读取文件 FileInputStream fis = new FileInputStream(\"d://a.jpg\"); //2. 获取response字节输出流 ServletOutputStream os = response.getOutputStream(); //3. 完成流的copy IOUtils.copy(fis,os); fis.close(); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } ","date":"2023-12-31","objectID":"/request-response/:3:5","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#33-response响应字节数据"},{"categories":["Web"],"content":" 4，用户注册登录案例接下来我们通过两个比较常见的案例，一个是==注册==，一个是==登录==来对今天学习的内容进行一个实战演练，首先来实现用户登录。 ","date":"2023-12-31","objectID":"/request-response/:4:0","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#4用户注册登录案例"},{"categories":["Web"],"content":" 4.1 用户登录 4.1.1 需求分析 用户在登录页面输入用户名和密码，提交请求给LoginServlet 在LoginServlet中接收请求和数据[用户名和密码] 在LoginServlt中通过Mybatis实现调用UserMapper来根据用户名和密码查询数据库表 将查询的结果封装到User对象中进行返回 在LoginServlet中判断返回的User对象是否为null 如果为nul，说明根据用户名和密码没有查询到用户，则登录失败，返回\"登录失败\"数据给前端 如果不为null,则说明用户存在并且密码正确，则登录成功，返回\"登录成功\"数据给前端 4.1.2 环境准备 复制资料中的静态页面到项目的webapp目录下 参考资料\\1. 登陆注册案例\\1. 静态页面,拷贝完效果如下: 创建db1数据库，创建tb_user表，创建User实体类 2.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\tb_user.sql中的sql语句执行下: 2.2 将资料\\1. 登陆注册案例\\2. MyBatis环境\\User.java拷贝到com.itheima.pojo 在项目的pom.xml导入Mybatis和Mysql驱动坐标 \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.34\u003c/version\u003e \u003c/dependency\u003e 创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件,UserMapper接口 4.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\mybatis-config.xml拷贝到resources目录下 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!--起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.itheima.pojo\"/\u003e \u003c/typeAliases\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003c!-- useSSL:关闭SSL安全连接 性能更高 useServerPrepStmts:开启预编译功能 \u0026amp; 等同于 \u0026 ,xml配置文件中不能直接写 \u0026符号 --\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql:///db1?useSSL=false\u0026amp;useServerPrepStmts=true\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"1234\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003c!--扫描mapper--\u003e \u003cpackage name=\"com.itheima.mapper\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 4.2 在com.itheima.mapper包下创建UserMapper接口 public interface UserMapper { } 4.3 将资料\\1. 登陆注册案例\\2. MyBatis环境\\UserMapper.xml拷贝到resources目录下 ==注意：在resources下创建UserMapper.xml的目录时，要使用/分割== 至此我们所需要的环境就都已经准备好了，具体该如何实现? 4.1.3 代码实现 在UserMapper接口中提供一个根据用户名和密码查询用户对象的方法 /** * 根据用户名和密码查询用户对象 * @param username * @param password * @return */ @Select(\"select * from tb_user where username = #{username} and password = #{password}\") User select(@Param(\"username\") String username,@Param(\"password\") String password); 说明 @Param注解的作用:用于传递参数,是方法的参数可以与SQL中的字段名相对应。 修改loign.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elogin\u003c/title\u003e \u003clink href=\"css/login.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"loginDiv\"\u003e \u003cform action=\"/request-demo/loginServlet\" method=\"post\" id=\"form\"\u003e \u003ch1 id=\"loginMsg\"\u003eLOGIN IN\u003c/h1\u003e \u003cp\u003eUsername:\u003cinput id=\"username\" name=\"username\" type=\"text\"\u003e\u003c/p\u003e \u003cp\u003ePassword:\u003cinput id=\"password\" name=\"password\" type=\"password\"\u003e\u003c/p\u003e \u003cdiv id=\"subDiv\"\u003e \u003cinput type=\"submit\" class=\"button\" value=\"login up\"\u003e \u003cinput type=\"reset\" class=\"button\" value=\"reset\"\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp; \u003ca href=\"register.html\"\u003e没有账号？点击注册\u003c/a\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 编写LoginServlet @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户名和密码 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); //2. 调用MyBatis完成查询 //2.1 获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.2 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //2.3 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //2.4 调用方法 User user = userMapper.select(username, password); //2.5 释放资源 sqlSession.close(); //获取字符输出流，并设置content type response.setContentType(\"text/html;charset=utf-8\"); PrintWriter writer = response.getWriter(); //3. 判断user释放为null if(user != null){ // 登陆成功 writer.write(\"登陆成功\"); }else { // 登陆失败 writer.write(\"登陆失败\"); } } @Override protected void doPost(HttpServletRequest reques","date":"2023-12-31","objectID":"/request-response/:4:1","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#41-用户登录"},{"categories":["Web"],"content":" 4.1 用户登录 4.1.1 需求分析 用户在登录页面输入用户名和密码，提交请求给LoginServlet 在LoginServlet中接收请求和数据[用户名和密码] 在LoginServlt中通过Mybatis实现调用UserMapper来根据用户名和密码查询数据库表 将查询的结果封装到User对象中进行返回 在LoginServlet中判断返回的User对象是否为null 如果为nul，说明根据用户名和密码没有查询到用户，则登录失败，返回\"登录失败\"数据给前端 如果不为null,则说明用户存在并且密码正确，则登录成功，返回\"登录成功\"数据给前端 4.1.2 环境准备 复制资料中的静态页面到项目的webapp目录下 参考资料\\1. 登陆注册案例\\1. 静态页面,拷贝完效果如下: 创建db1数据库，创建tb_user表，创建User实体类 2.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\tb_user.sql中的sql语句执行下: 2.2 将资料\\1. 登陆注册案例\\2. MyBatis环境\\User.java拷贝到com.itheima.pojo 在项目的pom.xml导入Mybatis和Mysql驱动坐标 org.mybatis mybatis 3.5.5 mysql mysql-connector-java 5.1.34 创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件,UserMapper接口 4.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\mybatis-config.xml拷贝到resources目录下 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e 4.2 在com.itheima.mapper包下创建UserMapper接口 public interface UserMapper { } 4.3 将资料\\1. 登陆注册案例\\2. MyBatis环境\\UserMapper.xml拷贝到resources目录下 ==注意：在resources下创建UserMapper.xml的目录时，要使用/分割== 至此我们所需要的环境就都已经准备好了，具体该如何实现? 4.1.3 代码实现 在UserMapper接口中提供一个根据用户名和密码查询用户对象的方法 /** * 根据用户名和密码查询用户对象 * @param username * @param password * @return */ @Select(\"select * from tb_user where username = #{username} and password = #{password}\") User select(@Param(\"username\") String username,@Param(\"password\") String password); 说明 @Param注解的作用:用于传递参数,是方法的参数可以与SQL中的字段名相对应。 修改loign.html \u003c!DOCTYPE html\u003e login LOGIN IN Username: Password:     没有账号？点击注册 编写LoginServlet @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户名和密码 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); //2. 调用MyBatis完成查询 //2.1 获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.2 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //2.3 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //2.4 调用方法 User user = userMapper.select(username, password); //2.5 释放资源 sqlSession.close(); //获取字符输出流，并设置content type response.setContentType(\"text/html;charset=utf-8\"); PrintWriter writer = response.getWriter(); //3. 判断user释放为null if(user != null){ // 登陆成功 writer.write(\"登陆成功\"); }else { // 登陆失败 writer.write(\"登陆失败\"); } } @Override protected void doPost(HttpServletRequest reques","date":"2023-12-31","objectID":"/request-response/:4:1","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#411-需求分析"},{"categories":["Web"],"content":" 4.1 用户登录 4.1.1 需求分析 用户在登录页面输入用户名和密码，提交请求给LoginServlet 在LoginServlet中接收请求和数据[用户名和密码] 在LoginServlt中通过Mybatis实现调用UserMapper来根据用户名和密码查询数据库表 将查询的结果封装到User对象中进行返回 在LoginServlet中判断返回的User对象是否为null 如果为nul，说明根据用户名和密码没有查询到用户，则登录失败，返回\"登录失败\"数据给前端 如果不为null,则说明用户存在并且密码正确，则登录成功，返回\"登录成功\"数据给前端 4.1.2 环境准备 复制资料中的静态页面到项目的webapp目录下 参考资料\\1. 登陆注册案例\\1. 静态页面,拷贝完效果如下: 创建db1数据库，创建tb_user表，创建User实体类 2.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\tb_user.sql中的sql语句执行下: 2.2 将资料\\1. 登陆注册案例\\2. MyBatis环境\\User.java拷贝到com.itheima.pojo 在项目的pom.xml导入Mybatis和Mysql驱动坐标 org.mybatis mybatis 3.5.5 mysql mysql-connector-java 5.1.34 创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件,UserMapper接口 4.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\mybatis-config.xml拷贝到resources目录下 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e 4.2 在com.itheima.mapper包下创建UserMapper接口 public interface UserMapper { } 4.3 将资料\\1. 登陆注册案例\\2. MyBatis环境\\UserMapper.xml拷贝到resources目录下 ==注意：在resources下创建UserMapper.xml的目录时，要使用/分割== 至此我们所需要的环境就都已经准备好了，具体该如何实现? 4.1.3 代码实现 在UserMapper接口中提供一个根据用户名和密码查询用户对象的方法 /** * 根据用户名和密码查询用户对象 * @param username * @param password * @return */ @Select(\"select * from tb_user where username = #{username} and password = #{password}\") User select(@Param(\"username\") String username,@Param(\"password\") String password); 说明 @Param注解的作用:用于传递参数,是方法的参数可以与SQL中的字段名相对应。 修改loign.html \u003c!DOCTYPE html\u003e login LOGIN IN Username: Password: 没有账号？点击注册 编写LoginServlet @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户名和密码 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); //2. 调用MyBatis完成查询 //2.1 获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.2 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //2.3 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //2.4 调用方法 User user = userMapper.select(username, password); //2.5 释放资源 sqlSession.close(); //获取字符输出流，并设置content type response.setContentType(\"text/html;charset=utf-8\"); PrintWriter writer = response.getWriter(); //3. 判断user释放为null if(user != null){ // 登陆成功 writer.write(\"登陆成功\"); }else { // 登陆失败 writer.write(\"登陆失败\"); } } @Override protected void doPost(HttpServletRequest reques","date":"2023-12-31","objectID":"/request-response/:4:1","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#412-环境准备"},{"categories":["Web"],"content":" 4.1 用户登录 4.1.1 需求分析 用户在登录页面输入用户名和密码，提交请求给LoginServlet 在LoginServlet中接收请求和数据[用户名和密码] 在LoginServlt中通过Mybatis实现调用UserMapper来根据用户名和密码查询数据库表 将查询的结果封装到User对象中进行返回 在LoginServlet中判断返回的User对象是否为null 如果为nul，说明根据用户名和密码没有查询到用户，则登录失败，返回\"登录失败\"数据给前端 如果不为null,则说明用户存在并且密码正确，则登录成功，返回\"登录成功\"数据给前端 4.1.2 环境准备 复制资料中的静态页面到项目的webapp目录下 参考资料\\1. 登陆注册案例\\1. 静态页面,拷贝完效果如下: 创建db1数据库，创建tb_user表，创建User实体类 2.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\tb_user.sql中的sql语句执行下: 2.2 将资料\\1. 登陆注册案例\\2. MyBatis环境\\User.java拷贝到com.itheima.pojo 在项目的pom.xml导入Mybatis和Mysql驱动坐标 org.mybatis mybatis 3.5.5 mysql mysql-connector-java 5.1.34 创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件,UserMapper接口 4.1 将资料\\1. 登陆注册案例\\2. MyBatis环境\\mybatis-config.xml拷贝到resources目录下 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e 4.2 在com.itheima.mapper包下创建UserMapper接口 public interface UserMapper { } 4.3 将资料\\1. 登陆注册案例\\2. MyBatis环境\\UserMapper.xml拷贝到resources目录下 ==注意：在resources下创建UserMapper.xml的目录时，要使用/分割== 至此我们所需要的环境就都已经准备好了，具体该如何实现? 4.1.3 代码实现 在UserMapper接口中提供一个根据用户名和密码查询用户对象的方法 /** * 根据用户名和密码查询用户对象 * @param username * @param password * @return */ @Select(\"select * from tb_user where username = #{username} and password = #{password}\") User select(@Param(\"username\") String username,@Param(\"password\") String password); 说明 @Param注解的作用:用于传递参数,是方法的参数可以与SQL中的字段名相对应。 修改loign.html \u003c!DOCTYPE html\u003e login LOGIN IN Username: Password: 没有账号？点击注册 编写LoginServlet @WebServlet(\"/loginServlet\") public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户名和密码 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); //2. 调用MyBatis完成查询 //2.1 获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.2 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //2.3 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //2.4 调用方法 User user = userMapper.select(username, password); //2.5 释放资源 sqlSession.close(); //获取字符输出流，并设置content type response.setContentType(\"text/html;charset=utf-8\"); PrintWriter writer = response.getWriter(); //3. 判断user释放为null if(user != null){ // 登陆成功 writer.write(\"登陆成功\"); }else { // 登陆失败 writer.write(\"登陆失败\"); } } @Override protected void doPost(HttpServletRequest reques","date":"2023-12-31","objectID":"/request-response/:4:1","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#413-代码实现"},{"categories":["Web"],"content":" 4.2 用户注册 4.2.1 需求分析 用户在注册页面输入用户名和密码，提交请求给RegisterServlet 在RegisterServlet中接收请求和数据[用户名和密码] 在RegisterServlet中通过Mybatis实现调用UserMapper来根据用户名查询数据库表 将查询的结果封装到User对象中进行返回 在RegisterServlet中判断返回的User对象是否为null 如果为nul，说明根据用户名可用，则调用UserMapper来实现添加用户 如果不为null,则说明用户不可以，返回\"用户名已存在\"数据给前端 4.2.2 代码编写 编写UserMapper提供根据用户名查询用户数据方法和添加用户方法 /** * 根据用户名查询用户对象 * @param username * @return */ @Select(\"select * from tb_user where username = #{username}\") User selectByUsername(String username); /** * 添加用户 * @param user */ @Insert(\"insert into tb_user values(null,#{username},#{password})\") void add(User user); 修改register.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e欢迎注册\u003c/title\u003e \u003clink href=\"css/register.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"form-div\"\u003e \u003cdiv class=\"reg-content\"\u003e \u003ch1\u003e欢迎注册\u003c/h1\u003e \u003cspan\u003e已有帐号？\u003c/span\u003e \u003ca href=\"login.html\"\u003e登录\u003c/a\u003e \u003c/div\u003e \u003cform id=\"reg-form\" action=\"/request-demo/registerServlet\" method=\"post\"\u003e \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e用户名\u003c/td\u003e \u003ctd class=\"inputs\"\u003e \u003cinput name=\"username\" type=\"text\" id=\"username\"\u003e \u003cbr\u003e \u003cspan id=\"username_err\" class=\"err_msg\" style=\"display: none\"\u003e用户名不太受欢迎\u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e密码\u003c/td\u003e \u003ctd class=\"inputs\"\u003e \u003cinput name=\"password\" type=\"password\" id=\"password\"\u003e \u003cbr\u003e \u003cspan id=\"password_err\" class=\"err_msg\" style=\"display: none\"\u003e密码格式有误\u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003cdiv class=\"buttons\"\u003e \u003cinput value=\"注 册\" type=\"submit\" id=\"reg_btn\"\u003e \u003c/div\u003e \u003cbr class=\"clear\"\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 创建RegisterServlet类 @WebServlet(\"/registerServlet\") public class RegisterServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户数据 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); //封装用户对象 User user = new User(); user.setUsername(username); user.setPassword(password); //2. 调用mapper 根据用户名查询用户对象 //2.1 获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.2 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //2.3 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //2.4 调用方法 User u = userMapper.selectByUsername(username); //3. 判断用户对象释放为null if( u == null){ // 用户名不存在，添加用户 userMapper.add(user); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); }else { // 用户名存在，给出提示信息 response.setContentType(\"text/html;charset=utf-8\"); response.getWriter().write(\"用户名已存在\"); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动服务器进行测试 4.1 如果测试成功，则在数据库中就能查看到新注册的数据 4.2 如果用户已经存在，则在页面上展示 用户名已存在 的提示信息 ","date":"2023-12-31","objectID":"/request-response/:4:2","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#42-用户注册"},{"categories":["Web"],"content":" 4.2 用户注册 4.2.1 需求分析 用户在注册页面输入用户名和密码，提交请求给RegisterServlet 在RegisterServlet中接收请求和数据[用户名和密码] 在RegisterServlet中通过Mybatis实现调用UserMapper来根据用户名查询数据库表 将查询的结果封装到User对象中进行返回 在RegisterServlet中判断返回的User对象是否为null 如果为nul，说明根据用户名可用，则调用UserMapper来实现添加用户 如果不为null,则说明用户不可以，返回\"用户名已存在\"数据给前端 4.2.2 代码编写 编写UserMapper提供根据用户名查询用户数据方法和添加用户方法 /** * 根据用户名查询用户对象 * @param username * @return */ @Select(\"select * from tb_user where username = #{username}\") User selectByUsername(String username); /** * 添加用户 * @param user */ @Insert(\"insert into tb_user values(null,#{username},#{password})\") void add(User user); 修改register.html \u003c!DOCTYPE html\u003e 欢迎注册 欢迎注册 已有帐号？ 登录 用户名 用户名不太受欢迎 密码 密码格式有误 创建RegisterServlet类 @WebServlet(\"/registerServlet\") public class RegisterServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户数据 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); //封装用户对象 User user = new User(); user.setUsername(username); user.setPassword(password); //2. 调用mapper 根据用户名查询用户对象 //2.1 获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.2 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //2.3 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //2.4 调用方法 User u = userMapper.selectByUsername(username); //3. 判断用户对象释放为null if( u == null){ // 用户名不存在，添加用户 userMapper.add(user); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); }else { // 用户名存在，给出提示信息 response.setContentType(\"text/html;charset=utf-8\"); response.getWriter().write(\"用户名已存在\"); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动服务器进行测试 4.1 如果测试成功，则在数据库中就能查看到新注册的数据 4.2 如果用户已经存在，则在页面上展示 用户名已存在 的提示信息 ","date":"2023-12-31","objectID":"/request-response/:4:2","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#421-需求分析"},{"categories":["Web"],"content":" 4.2 用户注册 4.2.1 需求分析 用户在注册页面输入用户名和密码，提交请求给RegisterServlet 在RegisterServlet中接收请求和数据[用户名和密码] 在RegisterServlet中通过Mybatis实现调用UserMapper来根据用户名查询数据库表 将查询的结果封装到User对象中进行返回 在RegisterServlet中判断返回的User对象是否为null 如果为nul，说明根据用户名可用，则调用UserMapper来实现添加用户 如果不为null,则说明用户不可以，返回\"用户名已存在\"数据给前端 4.2.2 代码编写 编写UserMapper提供根据用户名查询用户数据方法和添加用户方法 /** * 根据用户名查询用户对象 * @param username * @return */ @Select(\"select * from tb_user where username = #{username}\") User selectByUsername(String username); /** * 添加用户 * @param user */ @Insert(\"insert into tb_user values(null,#{username},#{password})\") void add(User user); 修改register.html \u003c!DOCTYPE html\u003e 欢迎注册 欢迎注册 已有帐号？ 登录 用户名 用户名不太受欢迎 密码 密码格式有误 创建RegisterServlet类 @WebServlet(\"/registerServlet\") public class RegisterServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1. 接收用户数据 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); //封装用户对象 User user = new User(); user.setUsername(username); user.setPassword(password); //2. 调用mapper 根据用户名查询用户对象 //2.1 获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.2 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //2.3 获取Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //2.4 调用方法 User u = userMapper.selectByUsername(username); //3. 判断用户对象释放为null if( u == null){ // 用户名不存在，添加用户 userMapper.add(user); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); }else { // 用户名存在，给出提示信息 response.setContentType(\"text/html;charset=utf-8\"); response.getWriter().write(\"用户名已存在\"); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 启动服务器进行测试 4.1 如果测试成功，则在数据库中就能查看到新注册的数据 4.2 如果用户已经存在，则在页面上展示 用户名已存在 的提示信息 ","date":"2023-12-31","objectID":"/request-response/:4:2","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#422-代码编写"},{"categories":["Web"],"content":" 4.3 SqlSessionFactory工具类抽取上面两个功能已经实现，但是在写Servlet的时候，因为需要使用Mybatis来完成数据库的操作，所以对于Mybatis的基础操作就出现了些重复代码，如下 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 有了这些重复代码就会造成一些问题: 重复代码不利于后期的维护 SqlSessionFactory工厂类进行重复创建 就相当于每次买手机都需要重新创建一个手机生产工厂来给你制造一个手机一样，资源消耗非常大但性能却非常低。所以这么做是不允许的。 那如何来优化呢？ 代码重复可以抽取工具类 对指定代码只需要执行一次可以使用静态代码块 有了这两个方向后，代码具体该如何编写? public class SqlSessionFactoryUtils { private static SqlSessionFactory sqlSessionFactory; static { //静态代码块会随着类的加载而自动执行，且只执行一次 try { String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } public static SqlSessionFactory getSqlSessionFactory(){ return sqlSessionFactory; } } 工具类抽取以后，以后在对Mybatis的SqlSession进行操作的时候，就可以直接使用 SqlSessionFactory sqlSessionFactory =SqlSessionFactoryUtils.getSqlSessionFactory(); 这样就可以很好的解决上面所说的代码重复和重复创建工厂导致性能低的问题了。 ","date":"2023-12-31","objectID":"/request-response/:4:3","series":null,"tags":["Web"],"title":"Request Response","uri":"/request-response/#43-sqlsessionfactory工具类抽取"},{"categories":["SQL"],"content":"这里边没啥好玩的，就不自己写了，直接用黑马的作业 ","date":"2023-12-31","objectID":"/mysql/:0:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#"},{"categories":["SQL"],"content":" MySQL基础今日目标： 完成MySQL的安装及登陆基本操作 能通过SQL对数据库进行CRUD 能通过SQL对表进行CRUD 能通过SQL对数据进行CRUD ","date":"2023-12-31","objectID":"/mysql/:1:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#mysql基础"},{"categories":["SQL"],"content":" 1，数据库相关概念以前我们做系统，数据持久化的存储采用的是文件存储。存储到文件中可以达到系统关闭数据不会丢失的效果，当然文件存储也有它的弊端。 假设在文件中存储以下的数据： 姓名 年龄 性别 住址 张三 23 男 北京西三旗 李四 24 女 北京西二旗 王五 25 男 西安软件新城 现要修改李四这条数据的性别数据改为男，我们现学习的IO技术可以通过将所有的数据读取到内存中，然后进行修改再存到该文件中。通过这种方式操作存在很大问题，现在只有三条数据，如果文件中存储1T的数据，那么就会发现内存根本就存储不了。 现需要既能持久化存储数据，也要能避免上述问题的技术使用在我们的系统中。数据库就是这样的一门技术。 ","date":"2023-12-31","objectID":"/mysql/:2:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#1数据库相关概念"},{"categories":["SQL"],"content":" 1.1 数据库 ==存储和管理数据的仓库，数据是有组织的进行存储。== 数据库英文名是 DataBase，简称DB。 数据库就是将数据存储在硬盘上，可以达到持久化存储的效果。那又是如何解决上述问题的？使用数据库管理系统。 ","date":"2023-12-31","objectID":"/mysql/:2:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#11--数据库"},{"categories":["SQL"],"content":" 1.2 数据库管理系统 ==管理数据库的大型软件== 英文：DataBase Management System，简称 DBMS 在电脑上安装了数据库管理系统后，就可以通过数据库管理系统创建数据库来存储数据，也可以通过该系统对数据库中的数据进行数据的增删改查相关的操作。我们平时说的MySQL数据库其实是MySQL数据库管理系统。 通过上面的描述，大家应该已经知道了 数据库管理系统 和 数据库 的关系。那么有有哪些常见的数据库管理系统呢？ ","date":"2023-12-31","objectID":"/mysql/:2:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#12--数据库管理系统"},{"categories":["SQL"],"content":" 1.3 常见的数据库管理系统 接下来对上面列举的数据库管理系统进行简单的介绍： Oracle：收费的大型数据库，Oracle 公司的产品 ==MySQL==： 开源免费的中小型数据库。后来 Sun公司收购了 MySQL，而 Sun 公司又被 Oracle 收购 SQL Server：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用 PostgreSQL：开源免费中小型的数据库 DB2：IBM 公司的大型收费数据库产品 SQLite：嵌入式的微型数据库。如：作为 Android 内置数据库 MariaDB：开源免费中小型的数据库 我们课程上学习的是MySQL数据库管理系统，PostgreSQL在一些公司也有使用，此时大家肯定会想以后在公司中如果使用我们没有学习过程的PostgreSQL数据库管理系统怎么办？这点大家大可不必担心，如下图所示： 我们可以通过数据库管理系统操作数据库，对数据库中的数据进行增删改查操作，而怎么样让用户跟数据库管理系统打交道呢？就可以通过一门编程语言（SQL）来实现。 ","date":"2023-12-31","objectID":"/mysql/:2:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#13--常见的数据库管理系统"},{"categories":["SQL"],"content":" 1.4 SQL 英文：Structured Query Language，简称 SQL，结构化查询语言 操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准，可以使用SQL操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的数据库管理系统，也同样的使用SQL来操作。 ","date":"2023-12-31","objectID":"/mysql/:2:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#14--sql"},{"categories":["SQL"],"content":" 2，MySQL","date":"2023-12-31","objectID":"/mysql/:3:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#2mysql"},{"categories":["SQL"],"content":" 2.1 MySQL安装 安装环境:Win10 64位 软件版本:MySQL 5.7.24 解压版 2.1.1 下载https://downloads.mysql.com/archives/community/ 点开上面的链接就能看到如下界面： 选择选择和自己系统位数相对应的版本点击右边的Download，此时会进到另一个页面，同样在接近页面底部的地方找到如下图所示的位置： 不用理会上面的登录和注册按钮，直接点击 No thanks, just start my download. 就可以下载。 2.1.2 安装(解压)下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到MySQL 5.7.24的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置。 ","date":"2023-12-31","objectID":"/mysql/:3:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#21--mysql安装"},{"categories":["SQL"],"content":" 2.1 MySQL安装 安装环境:Win10 64位 软件版本:MySQL 5.7.24 解压版 2.1.1 下载https://downloads.mysql.com/archives/community/ 点开上面的链接就能看到如下界面： 选择选择和自己系统位数相对应的版本点击右边的Download，此时会进到另一个页面，同样在接近页面底部的地方找到如下图所示的位置： 不用理会上面的登录和注册按钮，直接点击 No thanks, just start my download. 就可以下载。 2.1.2 安装(解压)下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到MySQL 5.7.24的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置。 ","date":"2023-12-31","objectID":"/mysql/:3:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#211--下载"},{"categories":["SQL"],"content":" 2.1 MySQL安装 安装环境:Win10 64位 软件版本:MySQL 5.7.24 解压版 2.1.1 下载https://downloads.mysql.com/archives/community/ 点开上面的链接就能看到如下界面： 选择选择和自己系统位数相对应的版本点击右边的Download，此时会进到另一个页面，同样在接近页面底部的地方找到如下图所示的位置： 不用理会上面的登录和注册按钮，直接点击 No thanks, just start my download. 就可以下载。 2.1.2 安装(解压)下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到MySQL 5.7.24的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置。 ","date":"2023-12-31","objectID":"/mysql/:3:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#212--安装解压"},{"categories":["SQL"],"content":" 2.2 MySQL卸载如果你想卸载MySQL，也很简单。 右键开始菜单，选择命令提示符(管理员)，打开黑框。 敲入net stop mysql，回车。 net stop mysql 再敲入mysqld -remove mysql，回车。 mysqld -remove mysql 最后删除MySQL目录及相关的环境变量。 至此，MySQL卸载完成！ ","date":"2023-12-31","objectID":"/mysql/:3:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#22--mysql卸载"},{"categories":["SQL"],"content":" 2.3 MySQL配置 2.3.1 添加环境变量 环境变量里面有很多选项，这里我们只用到Path这个参数。为什么在初始化的开始要添加环境变量呢？ 在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的Path所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。 右键此电脑→属性，点击高级系统设置 点击环境变量 在系统变量中新建MYSQL_HOME 在系统变量中找到并双击Path 点击新建 最后点击确定。 如何验证是否添加成功？ 右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。 如果提示Can't connect to MySQL server on 'localhost'则证明添加成功； 如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。 2.3.2 新建配置文件新建一个文本文件，内容如下： [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 default-storage-engine=INNODB sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为MySQL的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的MySQL目录位置修改)。 上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。 2.3.3 初始化MySQL在刚才的黑框中敲入mysqld --initialize-insecure，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。 mysqld --initialize-insecure tips：如果出现如下错误 是由于权限不足导致的，去C:\\Windows\\System32 下以管理员方式运行 cmd.exe 2.3.4 注册MySQL服务在黑框里敲入mysqld -install，回车。 mysqld -install 现在你的计算机上已经安装好了MySQL服务了。 MySQL服务器 2.3.5 启动MySQL服务在黑框里敲入net start mysql，回车。 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 2.3.6 修改默认账户密码在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。 mysqladmin -u root password 1234 至此，MySQL 5.7 解压版安装完毕！ ","date":"2023-12-31","objectID":"/mysql/:3:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#23--mysql配置"},{"categories":["SQL"],"content":" 2.3 MySQL配置 2.3.1 添加环境变量 环境变量里面有很多选项，这里我们只用到Path这个参数。为什么在初始化的开始要添加环境变量呢？ 在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的Path所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。 右键此电脑→属性，点击高级系统设置 点击环境变量 在系统变量中新建MYSQL_HOME 在系统变量中找到并双击Path 点击新建 最后点击确定。 如何验证是否添加成功？ 右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。 如果提示Can't connect to MySQL server on 'localhost'则证明添加成功； 如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。 2.3.2 新建配置文件新建一个文本文件，内容如下： [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 default-storage-engine=INNODB sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为MySQL的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的MySQL目录位置修改)。 上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。 2.3.3 初始化MySQL在刚才的黑框中敲入mysqld --initialize-insecure，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。 mysqld --initialize-insecure tips：如果出现如下错误 是由于权限不足导致的，去C:\\Windows\\System32 下以管理员方式运行 cmd.exe 2.3.4 注册MySQL服务在黑框里敲入mysqld -install，回车。 mysqld -install 现在你的计算机上已经安装好了MySQL服务了。 MySQL服务器 2.3.5 启动MySQL服务在黑框里敲入net start mysql，回车。 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 2.3.6 修改默认账户密码在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。 mysqladmin -u root password 1234 至此，MySQL 5.7 解压版安装完毕！ ","date":"2023-12-31","objectID":"/mysql/:3:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#231--添加环境变量"},{"categories":["SQL"],"content":" 2.3 MySQL配置 2.3.1 添加环境变量 环境变量里面有很多选项，这里我们只用到Path这个参数。为什么在初始化的开始要添加环境变量呢？ 在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的Path所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。 右键此电脑→属性，点击高级系统设置 点击环境变量 在系统变量中新建MYSQL_HOME 在系统变量中找到并双击Path 点击新建 最后点击确定。 如何验证是否添加成功？ 右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。 如果提示Can't connect to MySQL server on 'localhost'则证明添加成功； 如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。 2.3.2 新建配置文件新建一个文本文件，内容如下： [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 default-storage-engine=INNODB sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为MySQL的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的MySQL目录位置修改)。 上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。 2.3.3 初始化MySQL在刚才的黑框中敲入mysqld --initialize-insecure，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。 mysqld --initialize-insecure tips：如果出现如下错误 是由于权限不足导致的，去C:\\Windows\\System32 下以管理员方式运行 cmd.exe 2.3.4 注册MySQL服务在黑框里敲入mysqld -install，回车。 mysqld -install 现在你的计算机上已经安装好了MySQL服务了。 MySQL服务器 2.3.5 启动MySQL服务在黑框里敲入net start mysql，回车。 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 2.3.6 修改默认账户密码在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。 mysqladmin -u root password 1234 至此，MySQL 5.7 解压版安装完毕！ ","date":"2023-12-31","objectID":"/mysql/:3:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#232--新建配置文件"},{"categories":["SQL"],"content":" 2.3 MySQL配置 2.3.1 添加环境变量 环境变量里面有很多选项，这里我们只用到Path这个参数。为什么在初始化的开始要添加环境变量呢？ 在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的Path所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。 右键此电脑→属性，点击高级系统设置 点击环境变量 在系统变量中新建MYSQL_HOME 在系统变量中找到并双击Path 点击新建 最后点击确定。 如何验证是否添加成功？ 右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。 如果提示Can't connect to MySQL server on 'localhost'则证明添加成功； 如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。 2.3.2 新建配置文件新建一个文本文件，内容如下： [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 default-storage-engine=INNODB sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为MySQL的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的MySQL目录位置修改)。 上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。 2.3.3 初始化MySQL在刚才的黑框中敲入mysqld --initialize-insecure，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。 mysqld --initialize-insecure tips：如果出现如下错误 是由于权限不足导致的，去C:\\Windows\\System32 下以管理员方式运行 cmd.exe 2.3.4 注册MySQL服务在黑框里敲入mysqld -install，回车。 mysqld -install 现在你的计算机上已经安装好了MySQL服务了。 MySQL服务器 2.3.5 启动MySQL服务在黑框里敲入net start mysql，回车。 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 2.3.6 修改默认账户密码在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。 mysqladmin -u root password 1234 至此，MySQL 5.7 解压版安装完毕！ ","date":"2023-12-31","objectID":"/mysql/:3:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#233--初始化mysql"},{"categories":["SQL"],"content":" 2.3 MySQL配置 2.3.1 添加环境变量 环境变量里面有很多选项，这里我们只用到Path这个参数。为什么在初始化的开始要添加环境变量呢？ 在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的Path所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。 右键此电脑→属性，点击高级系统设置 点击环境变量 在系统变量中新建MYSQL_HOME 在系统变量中找到并双击Path 点击新建 最后点击确定。 如何验证是否添加成功？ 右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。 如果提示Can't connect to MySQL server on 'localhost'则证明添加成功； 如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。 2.3.2 新建配置文件新建一个文本文件，内容如下： [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 default-storage-engine=INNODB sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为MySQL的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的MySQL目录位置修改)。 上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。 2.3.3 初始化MySQL在刚才的黑框中敲入mysqld --initialize-insecure，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。 mysqld --initialize-insecure tips：如果出现如下错误 是由于权限不足导致的，去C:\\Windows\\System32 下以管理员方式运行 cmd.exe 2.3.4 注册MySQL服务在黑框里敲入mysqld -install，回车。 mysqld -install 现在你的计算机上已经安装好了MySQL服务了。 MySQL服务器 2.3.5 启动MySQL服务在黑框里敲入net start mysql，回车。 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 2.3.6 修改默认账户密码在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。 mysqladmin -u root password 1234 至此，MySQL 5.7 解压版安装完毕！ ","date":"2023-12-31","objectID":"/mysql/:3:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#234--注册mysql服务"},{"categories":["SQL"],"content":" 2.3 MySQL配置 2.3.1 添加环境变量 环境变量里面有很多选项，这里我们只用到Path这个参数。为什么在初始化的开始要添加环境变量呢？ 在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的Path所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。 右键此电脑→属性，点击高级系统设置 点击环境变量 在系统变量中新建MYSQL_HOME 在系统变量中找到并双击Path 点击新建 最后点击确定。 如何验证是否添加成功？ 右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。 如果提示Can't connect to MySQL server on 'localhost'则证明添加成功； 如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。 2.3.2 新建配置文件新建一个文本文件，内容如下： [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 default-storage-engine=INNODB sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为MySQL的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的MySQL目录位置修改)。 上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。 2.3.3 初始化MySQL在刚才的黑框中敲入mysqld --initialize-insecure，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。 mysqld --initialize-insecure tips：如果出现如下错误 是由于权限不足导致的，去C:\\Windows\\System32 下以管理员方式运行 cmd.exe 2.3.4 注册MySQL服务在黑框里敲入mysqld -install，回车。 mysqld -install 现在你的计算机上已经安装好了MySQL服务了。 MySQL服务器 2.3.5 启动MySQL服务在黑框里敲入net start mysql，回车。 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 2.3.6 修改默认账户密码在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。 mysqladmin -u root password 1234 至此，MySQL 5.7 解压版安装完毕！ ","date":"2023-12-31","objectID":"/mysql/:3:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#235--启动mysql服务"},{"categories":["SQL"],"content":" 2.3 MySQL配置 2.3.1 添加环境变量 环境变量里面有很多选项，这里我们只用到Path这个参数。为什么在初始化的开始要添加环境变量呢？ 在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的Path所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。 右键此电脑→属性，点击高级系统设置 点击环境变量 在系统变量中新建MYSQL_HOME 在系统变量中找到并双击Path 点击新建 最后点击确定。 如何验证是否添加成功？ 右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。 如果提示Can't connect to MySQL server on 'localhost'则证明添加成功； 如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。 2.3.2 新建配置文件新建一个文本文件，内容如下： [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 default-storage-engine=INNODB sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为MySQL的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的MySQL目录位置修改)。 上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。 2.3.3 初始化MySQL在刚才的黑框中敲入mysqld --initialize-insecure，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。 mysqld --initialize-insecure tips：如果出现如下错误 是由于权限不足导致的，去C:\\Windows\\System32 下以管理员方式运行 cmd.exe 2.3.4 注册MySQL服务在黑框里敲入mysqld -install，回车。 mysqld -install 现在你的计算机上已经安装好了MySQL服务了。 MySQL服务器 2.3.5 启动MySQL服务在黑框里敲入net start mysql，回车。 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 2.3.6 修改默认账户密码在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。 mysqladmin -u root password 1234 至此，MySQL 5.7 解压版安装完毕！ ","date":"2023-12-31","objectID":"/mysql/:3:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#236--修改默认账户密码"},{"categories":["SQL"],"content":" 2.4 MySQL登陆和退出 2.4.1 登陆右键开始菜单，选择命令提示符，打开黑框。 在黑框中输入，mysql -uroot -p1234，回车，出现下图且左下角为mysql\u003e，则登录成功。 mysql -uroot -p1234 到这里你就可以开始你的MySQL之旅了！ 登陆参数： mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306) 2.4.2 退出退出mysql： exit quit ","date":"2023-12-31","objectID":"/mysql/:3:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#24--mysql登陆和退出"},{"categories":["SQL"],"content":" 2.4 MySQL登陆和退出 2.4.1 登陆右键开始菜单，选择命令提示符，打开黑框。 在黑框中输入，mysql -uroot -p1234，回车，出现下图且左下角为mysql\u003e，则登录成功。 mysql -uroot -p1234 到这里你就可以开始你的MySQL之旅了！ 登陆参数： mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306) 2.4.2 退出退出mysql： exit quit ","date":"2023-12-31","objectID":"/mysql/:3:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#241--登陆"},{"categories":["SQL"],"content":" 2.4 MySQL登陆和退出 2.4.1 登陆右键开始菜单，选择命令提示符，打开黑框。 在黑框中输入，mysql -uroot -p1234，回车，出现下图且左下角为mysql\u003e，则登录成功。 mysql -uroot -p1234 到这里你就可以开始你的MySQL之旅了！ 登陆参数： mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306) 2.4.2 退出退出mysql： exit quit ","date":"2023-12-31","objectID":"/mysql/:3:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#242--退出"},{"categories":["SQL"],"content":" 2.5 MySQL数据模型关系型数据库： 关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的 二维表 组成的数据库 如下图，订单信息表 和 客户信息表 都是有行有列二维表我们将这样的称为关系型数据库。 接下来看关系型数据库的优点： 都是使用表结构，格式一致，易于维护。 使用通用的 SQL 语言操作，使用方便，可用于复杂查询。 关系型数据库都可以通过SQL进行操作，所以使用方便。 复杂查询。现在需要查询001号订单数据，我们可以看到该订单是1号客户的订单，而1号订单是李聪这个客户。以后也可以在一张表中进行统计分析等操作。 数据存储在磁盘中，安全。 数据模型： 如上图，我们通过客户端可以通过数据库管理系统创建数据库，在数据库中创建表，在表中添加数据。创建的每一个数据库对应到磁盘上都是一个文件夹。比如可以通过SQL语句创建一个数据库（数据库名称为db1），语句如下。该语句咱们后面会学习。 我们可以在数据库安装目录下的data目录下看到多了一个 db1 的文件夹。所以，在MySQL中一个数据库对应到磁盘上的一个文件夹。 而一个数据库下可以创建多张表，我们到MySQL中自带的mysql数据库的文件夹目录下： 而上图中右边的 db.frm 是表文件，db.MYD 是数据文件，通过这两个文件就可以查询到数据展示成二维表的效果。 小结： MySQL中可以创建多个数据库，每个数据库对应到磁盘上的一个文件夹 在每个数据库中可以创建多个表，每张都对应到磁盘上一个 frm 文件 每张表可以存储多条数据，数据会被存储到磁盘中 MYD 文件中 ","date":"2023-12-31","objectID":"/mysql/:3:5","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#25--mysql数据模型"},{"categories":["SQL"],"content":" 3，SQL概述了解了数据模型后，接下来我们就学习SQL语句，通过SQL语句对数据库、表、数据进行增删改查操作。 ","date":"2023-12-31","objectID":"/mysql/:4:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#3sql概述"},{"categories":["SQL"],"content":" 3.1 SQL简介 英文：Structured Query Language，简称 SQL 结构化查询语言，一门操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准 对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言” ","date":"2023-12-31","objectID":"/mysql/:4:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#31--sql简介"},{"categories":["SQL"],"content":" 3.2 通用语法 SQL 语句可以单行或多行书写，以分号结尾。 如上，以分号结尾才是一个完整的sql语句。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 同样的一条sql语句写成下图的样子，一样可以运行处结果。 注释 单行注释: – 注释内容 或 #注释内容(MySQL 特有) 注意：使用– 添加单行注释时，–后面一定要加空格，而#没有要求。 多行注释: /* 注释 */ ","date":"2023-12-31","objectID":"/mysql/:4:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#32--通用语法"},{"categories":["SQL"],"content":" 3.3 SQL分类 DDL(Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等 DDL简单理解就是用来操作数据库，表等 DML(Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改 DML简单理解就对表中数据进行增删改 DQL(Data Query Language) 数据查询语言，用来查询数据库中表的记录(数据) DQL简单理解就是对数据进行查询操作。从数据库表中查询到我们想要的数据。 DCL(Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户 DML简单理解就是对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。 注意： 以后我们最常操作的是 DML 和 DQL ，因为我们开发中最常操作的就是数据。 ","date":"2023-12-31","objectID":"/mysql/:4:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#33--sql分类"},{"categories":["SQL"],"content":" 4，DDL:操作数据库我们先来学习DDL来操作数据库。而操作数据库主要就是对数据库的增删查操作。 ","date":"2023-12-31","objectID":"/mysql/:5:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#4ddl操作数据库"},{"categories":["SQL"],"content":" 4.1 查询查询所有的数据库 SHOW DATABASES; 运行上面语句效果如下： 上述查询到的是的这些数据库是mysql安装好自带的数据库，我们以后不要操作这些数据库。 ","date":"2023-12-31","objectID":"/mysql/:5:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#41--查询"},{"categories":["SQL"],"content":" 4.2 创建数据库 创建数据库： CREATE DATABASE 数据库名称; 运行语句效果如下： 而在创建数据库的时候，我并不知道db1数据库有没有创建，直接再次创建名为db1的数据库就会出现错误。 为了避免上面的错误，在创建数据库的时候先做判断，如果不存在再创建。 创建数据库(判断，如果不存在则创建) CREATE DATABASE IF NOT EXISTS 数据库名称; 运行语句效果如下： 从上面的效果可以看到虽然db1数据库已经存在，再创建db1也没有报错，而创建db2数据库则创建成功。 ","date":"2023-12-31","objectID":"/mysql/:5:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#42--创建数据库"},{"categories":["SQL"],"content":" 4.3 删除数据库 删除数据库 DROP DATABASE 数据库名称; 删除数据库(判断，如果存在则删除) DROP DATABASE IF EXISTS 数据库名称; 运行语句效果如下： ","date":"2023-12-31","objectID":"/mysql/:5:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#43--删除数据库"},{"categories":["SQL"],"content":" 4.4 使用数据库数据库创建好了，要在数据库中创建表，得先明确在哪儿个数据库中操作，此时就需要使用数据库。 使用数据库 USE 数据库名称; 查看当前使用的数据库 SELECT DATABASE(); 运行语句效果如下： ","date":"2023-12-31","objectID":"/mysql/:5:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#44--使用数据库"},{"categories":["SQL"],"content":" 5，DDL:操作表操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。 ","date":"2023-12-31","objectID":"/mysql/:6:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#5ddl操作表"},{"categories":["SQL"],"content":" 5.1 查询表 查询当前数据库下所有表名称 SHOW TABLES; 我们创建的数据库中没有任何表，因此我们进入mysql自带的mysql数据库，执行上述语句查看 查询表结构 DESC 表名称; 查看mysql数据库中func表的结构，运行语句如下： ","date":"2023-12-31","objectID":"/mysql/:6:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#51--查询表"},{"categories":["SQL"],"content":" 5.2 创建表 创建表 CREATE TABLE 表名 ( 字段名1 数据类型1, 字段名2 数据类型2, … 字段名n 数据类型n ); 注意：最后一行末尾，不能加逗号 知道了创建表的语句，那么我们创建创建如下结构的表 create table tb_user ( id int, username varchar(20), password varchar(32) ); 运行语句如下： ","date":"2023-12-31","objectID":"/mysql/:6:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#52--创建表"},{"categories":["SQL"],"content":" 5.3 数据类型MySQL 支持多种类型，可以分为三类： 数值 tinyint : 小整数型，占一个字节 int ： 大整数类型，占四个字节 eg ： age int double ： 浮点类型 使用格式： 字段名 double(总长度,小数点后保留的位数) eg ： score double(5,2) 日期 date ： 日期值。只包含年月日 eg ：birthday date ： datetime ： 混合日期和时间值。包含年月日时分秒 字符串 char ： 定长字符串。 优点：存储性能高 缺点：浪费空间 eg ： name char(10) 如果存储的数据字符个数不足10个，也会占10个的空间 varchar ： 变长字符串。 优点：节约空间 缺点：存储性能底 eg ： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间 注意：其他类型参考资料中的《MySQL数据类型].xlsx》 案例： 需求：设计一张学生表，请注重数据类型、长度的合理性 1. 编号 2. 姓名，姓名最长不超过10个汉字 3. 性别，因为取值只有两种可能，因此最多一个汉字 4. 生日，取值为年月日 5. 入学成绩，小数点后保留两位 6. 邮件地址，最大长度不超过 64 7. 家庭联系电话，不一定是手机号码，可能会出现 - 等字符 8. 学生状态（用数字表示，正常、休学、毕业...） 语句设计如下： create table student ( id int, name varchar(10), gender char(1), birthday date, score double(5,2), email varchar(15), tel varchar(15), status tinyint ); ","date":"2023-12-31","objectID":"/mysql/:6:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#53--数据类型"},{"categories":["SQL"],"content":" 5.4 删除表 删除表 DROP TABLE 表名; 删除表时判断表是否存在 DROP TABLE IF EXISTS 表名; 运行语句效果如下： ","date":"2023-12-31","objectID":"/mysql/:6:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#54--删除表"},{"categories":["SQL"],"content":" 5.5 修改表 修改表名 ALTER TABLE 表名 RENAME TO 新的表名; -- 将表名student修改为stu alter table student rename to stu; 添加一列 ALTER TABLE 表名 ADD 列名 数据类型; -- 给stu表添加一列address，该字段类型是varchar(50) alter table stu add address varchar(50); 修改数据类型 ALTER TABLE 表名 MODIFY 列名 新数据类型; -- 将stu表中的address字段的类型改为 char(50) alter table stu modify address char(50); 修改列名和数据类型 ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型; -- 将stu表中的address字段名改为 addr，类型改为varchar(50) alter table stu change address addr varchar(50); 删除列 ALTER TABLE 表名 DROP 列名; -- 将stu表中的addr字段 删除 alter table stu drop addr; ","date":"2023-12-31","objectID":"/mysql/:6:5","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#55--修改表"},{"categories":["SQL"],"content":" 6，navicat使用通过上面的学习，我们发现在命令行中写sql语句特别不方便，尤其是编写创建表的语句，我们只能在记事本上写好后直接复制到命令行进行执行。那么有没有刚好的工具提供给我们进行使用呢？ 有。 ","date":"2023-12-31","objectID":"/mysql/:7:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#6navicat使用"},{"categories":["SQL"],"content":" 6.1 navicat概述 Navicat for MySQL 是管理和开发 MySQL 或 MariaDB 的理想解决方案。 这套全面的前端工具为数据库管理、开发和维护提供了一款直观而强大的图形界面。 官网： http://www.navicat.com.cn ","date":"2023-12-31","objectID":"/mysql/:7:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#61--navicat概述"},{"categories":["SQL"],"content":" 6.2 navicat安装参考 : 资料\\navicat安装包\\navicat_mysql_x86\\navicat安装步骤.md ","date":"2023-12-31","objectID":"/mysql/:7:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#62--navicat安装"},{"categories":["SQL"],"content":" 6.3 navicat使用 6.3.1 建立和mysql服务的连接第一步： 点击连接，选择MySQL 第二步：填写连接数据库必要的信息 以上操作没有问题就会出现如下图所示界面： 6.3.2 操作连接成功后就能看到如下图界面： 修改表结构 通过下图操作修改表结构： 点击了设计表后即出现如下图所示界面，在图中红框中直接修改字段名，类型等信息： 编写SQL语句并执行 按照如下图所示进行操作即可书写SQL语句并执行sql语句。 ","date":"2023-12-31","objectID":"/mysql/:7:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#63--navicat使用"},{"categories":["SQL"],"content":" 6.3 navicat使用 6.3.1 建立和mysql服务的连接第一步： 点击连接，选择MySQL 第二步：填写连接数据库必要的信息 以上操作没有问题就会出现如下图所示界面： 6.3.2 操作连接成功后就能看到如下图界面： 修改表结构 通过下图操作修改表结构： 点击了设计表后即出现如下图所示界面，在图中红框中直接修改字段名，类型等信息： 编写SQL语句并执行 按照如下图所示进行操作即可书写SQL语句并执行sql语句。 ","date":"2023-12-31","objectID":"/mysql/:7:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#631--建立和mysql服务的连接"},{"categories":["SQL"],"content":" 6.3 navicat使用 6.3.1 建立和mysql服务的连接第一步： 点击连接，选择MySQL 第二步：填写连接数据库必要的信息 以上操作没有问题就会出现如下图所示界面： 6.3.2 操作连接成功后就能看到如下图界面： 修改表结构 通过下图操作修改表结构： 点击了设计表后即出现如下图所示界面，在图中红框中直接修改字段名，类型等信息： 编写SQL语句并执行 按照如下图所示进行操作即可书写SQL语句并执行sql语句。 ","date":"2023-12-31","objectID":"/mysql/:7:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#632--操作"},{"categories":["SQL"],"content":" 7，DMLDML主要是对数据进行增（insert）删（delete）改（update）操作。 ","date":"2023-12-31","objectID":"/mysql/:8:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#7dml"},{"categories":["SQL"],"content":" 7.1 添加数据 给指定列添加数据 INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…); 给全部列添加数据 INSERT INTO 表名 VALUES(值1,值2,…); 批量添加数据 INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…; INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…; 练习 为了演示以下的增删改操作是否操作成功，故先将查询所有数据的语句介绍给大家： select * from stu; -- 给指定列添加数据 INSERT INTO stu (id, NAME) VALUES (1, '张三'); -- 给所有列添加数据，列名的列表可以省略的 INSERT INTO stu (id,NAME,sex,birthday,score,email,tel,STATUS) VALUES (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1); INSERT INTO stu VALUES (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1); -- 批量添加数据 INSERT INTO stu VALUES (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1), (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1), (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1); ","date":"2023-12-31","objectID":"/mysql/:8:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#71--添加数据"},{"categories":["SQL"],"content":" 7.2 修改数据 修改表数据 UPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ; 注意： 修改语句中如果不加条件，则将所有数据都修改！ 像上面的语句中的中括号，表示在写sql语句中可以省略这部分 练习 将张三的性别改为女 update stu set sex = '女' where name = '张三'; 将张三的生日改为 1999-12-12 分数改为99.99 update stu set birthday = '1999-12-12', score = 99.99 where name = '张三'; 注意：如果update语句没有加where条件，则会将表中所有数据全部修改！ update stu set sex = '女'; 上面语句的执行完后查询到的结果是： ","date":"2023-12-31","objectID":"/mysql/:8:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#72--修改数据"},{"categories":["SQL"],"content":" 7.3 删除数据 删除数据 DELETE FROM 表名 [WHERE 条件] ; 练习 -- 删除张三记录 delete from stu where name = '张三'; -- 删除stu表中所有的数据 delete from stu; ","date":"2023-12-31","objectID":"/mysql/:8:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#73--删除数据"},{"categories":["SQL"],"content":" 8，DQL下面是黑马程序员展示试题库数据的页面 页面上展示的数据肯定是在数据库中的试题库表中进行存储，而我们需要将数据库中的数据查询出来并展示在页面给用户看。上图中的是最基本的查询效果，那么数据库其实是很多的，不可能在将所有的数据在一页进行全部展示，而页面上会有分页展示的效果，如下： 当然上图中的难度字段当我们点击也可以实现排序查询操作。从这个例子我们就可以看出，对于数据库的查询时灵活多变的，需要根据具体的需求来实现，而数据库查询操作也是最重要的操作，所以此部分需要大家重点掌握。 接下来我们先介绍查询的完整语法： SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段 HAVING 分组后条件 ORDER BY 排序字段 LIMIT 分页限定 为了给大家演示查询的语句，我们需要先准备表及一些数据： -- 删除stu表 drop table if exists stu; -- 创建stu表 CREATE TABLE stu ( id int, -- 编号 name varchar(20), -- 姓名 age int, -- 年龄 sex varchar(5), -- 性别 address varchar(100), -- 地址 math double(5,2), -- 数学成绩 english double(5,2), -- 英语成绩 hire_date date -- 入学时间 ); -- 添加数据 INSERT INTO stu(id,NAME,age,sex,address,math,english,hire_date) VALUES (1,'马运',55,'男','杭州',66,78,'1995-09-01'), (2,'马花疼',45,'女','深圳',98,87,'1998-09-01'), (3,'马斯克',55,'男','香港',56,77,'1999-09-02'), (4,'柳白',20,'女','湖南',76,65,'1997-09-05'), (5,'柳青',20,'男','湖南',86,NULL,'1998-09-01'), (6,'刘德花',57,'男','香港',99,99,'1998-09-01'), (7,'张学右',22,'女','香港',99,99,'1998-09-01'), (8,'德玛西亚',18,'男','南京',56,65,'1994-09-02'); 接下来咱们从最基本的查询语句开始学起。 ","date":"2023-12-31","objectID":"/mysql/:9:0","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#8dql"},{"categories":["SQL"],"content":" 8.1 基础查询 8.1.1 语法 查询多个字段 SELECT 字段列表 FROM 表名; SELECT * FROM 表名; -- 查询所有数据 去除重复记录 SELECT DISTINCT 字段列表 FROM 表名; 起别名 AS: AS 也可以省略 8.1.2 练习 查询name、age两列 select name,age from stu; 查询所有列的数据，列名的列表可以使用*替代 select * from stu; 上面语句中的*不建议大家使用，因为在这写*不方便我们阅读sql语句。我们写字段列表的话，可以添加注释对每一个字段进行说明 而在上课期间为了简约课程的时间，老师很多地方都会写*。 查询地址信息 select address from stu; 执行上面语句结果如下： 从上面的结果我们可以看到有重复的数据，我们也可以使用 distinct 关键字去重重复数据。 去除重复记录 select distinct address from stu; 查询姓名、数学成绩、英语成绩。并通过as给math和english起别名（as关键字可以省略） select name,math as 数学成绩,english as 英文成绩 from stu; select name,math 数学成绩,english 英文成绩 from stu; ","date":"2023-12-31","objectID":"/mysql/:9:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#81--基础查询"},{"categories":["SQL"],"content":" 8.1 基础查询 8.1.1 语法 查询多个字段 SELECT 字段列表 FROM 表名; SELECT * FROM 表名; -- 查询所有数据 去除重复记录 SELECT DISTINCT 字段列表 FROM 表名; 起别名 AS: AS 也可以省略 8.1.2 练习 查询name、age两列 select name,age from stu; 查询所有列的数据，列名的列表可以使用*替代 select * from stu; 上面语句中的*不建议大家使用，因为在这写*不方便我们阅读sql语句。我们写字段列表的话，可以添加注释对每一个字段进行说明 而在上课期间为了简约课程的时间，老师很多地方都会写*。 查询地址信息 select address from stu; 执行上面语句结果如下： 从上面的结果我们可以看到有重复的数据，我们也可以使用 distinct 关键字去重重复数据。 去除重复记录 select distinct address from stu; 查询姓名、数学成绩、英语成绩。并通过as给math和english起别名（as关键字可以省略） select name,math as 数学成绩,english as 英文成绩 from stu; select name,math 数学成绩,english 英文成绩 from stu; ","date":"2023-12-31","objectID":"/mysql/:9:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#811--语法"},{"categories":["SQL"],"content":" 8.1 基础查询 8.1.1 语法 查询多个字段 SELECT 字段列表 FROM 表名; SELECT * FROM 表名; -- 查询所有数据 去除重复记录 SELECT DISTINCT 字段列表 FROM 表名; 起别名 AS: AS 也可以省略 8.1.2 练习 查询name、age两列 select name,age from stu; 查询所有列的数据，列名的列表可以使用*替代 select * from stu; 上面语句中的*不建议大家使用，因为在这写*不方便我们阅读sql语句。我们写字段列表的话，可以添加注释对每一个字段进行说明 而在上课期间为了简约课程的时间，老师很多地方都会写*。 查询地址信息 select address from stu; 执行上面语句结果如下： 从上面的结果我们可以看到有重复的数据，我们也可以使用 distinct 关键字去重重复数据。 去除重复记录 select distinct address from stu; 查询姓名、数学成绩、英语成绩。并通过as给math和english起别名（as关键字可以省略） select name,math as 数学成绩,english as 英文成绩 from stu; select name,math 数学成绩,english 英文成绩 from stu; ","date":"2023-12-31","objectID":"/mysql/:9:1","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#812--练习"},{"categories":["SQL"],"content":" 8.2 条件查询 8.2.1 语法 SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件 条件列表可以使用以下运算符 8.2.2 条件查询练习 查询年龄大于20岁的学员信息 select * from stu where age \u003e 20; 查询年龄大于等于20岁的学员信息 select * from stu where age \u003e= 20; 查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学员信息 select * from stu where age \u003e= 20 \u0026\u0026 age \u003c= 30; select * from stu where age \u003e= 20 and age \u003c= 30; 上面语句中 \u0026\u0026 和 and 都表示并且的意思。建议使用 and 。 也可以使用 between … and 来实现上面需求 select * from stu where age BETWEEN 20 and 30; 查询入学日期在'1998-09-01’ 到 ‘1999-09-01’ 之间的学员信息 select * from stu where hire_date BETWEEN '1998-09-01' and '1999-09-01'; 查询年龄等于18岁的学员信息 select * from stu where age = 18; 查询年龄不等于18岁的学员信息 select * from stu where age != 18; select * from stu where age \u003c\u003e 18; 查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息 select * from stu where age = 18 or age = 20 or age = 22; select * from stu where age in (18,20 ,22); 查询英语成绩为 null的学员信息 null值的比较不能使用 = 或者 != 。需要使用 is 或者 is not select * from stu where english = null; -- 这个语句是不行的 select * from stu where english is null; select * from stu where english is not null; 8.2.3 模糊查询练习 模糊查询使用like关键字，可以使用通配符进行占位: （1）_ : 代表单个任意字符 （2）% : 代表任意个数字符 查询姓’马’的学员信息 select * from stu where name like '马%'; 查询第二个字是’花’的学员信息 select * from stu where name like '_花%'; 查询名字中包含 ‘德’ 的学员信息 select * from stu where name like '%德%'; ","date":"2023-12-31","objectID":"/mysql/:9:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#82--条件查询"},{"categories":["SQL"],"content":" 8.2 条件查询 8.2.1 语法 SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件 条件列表可以使用以下运算符 8.2.2 条件查询练习 查询年龄大于20岁的学员信息 select * from stu where age \u003e 20; 查询年龄大于等于20岁的学员信息 select * from stu where age \u003e= 20; 查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学员信息 select * from stu where age \u003e= 20 \u0026\u0026 age \u003c= 30; select * from stu where age \u003e= 20 and age \u003c= 30; 上面语句中 \u0026\u0026 和 and 都表示并且的意思。建议使用 and 。 也可以使用 between … and 来实现上面需求 select * from stu where age BETWEEN 20 and 30; 查询入学日期在'1998-09-01’ 到 ‘1999-09-01’ 之间的学员信息 select * from stu where hire_date BETWEEN '1998-09-01' and '1999-09-01'; 查询年龄等于18岁的学员信息 select * from stu where age = 18; 查询年龄不等于18岁的学员信息 select * from stu where age != 18; select * from stu where age \u003c\u003e 18; 查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息 select * from stu where age = 18 or age = 20 or age = 22; select * from stu where age in (18,20 ,22); 查询英语成绩为 null的学员信息 null值的比较不能使用 = 或者 != 。需要使用 is 或者 is not select * from stu where english = null; -- 这个语句是不行的 select * from stu where english is null; select * from stu where english is not null; 8.2.3 模糊查询练习 模糊查询使用like关键字，可以使用通配符进行占位: （1）_ : 代表单个任意字符 （2）% : 代表任意个数字符 查询姓’马’的学员信息 select * from stu where name like '马%'; 查询第二个字是’花’的学员信息 select * from stu where name like '_花%'; 查询名字中包含 ‘德’ 的学员信息 select * from stu where name like '%德%'; ","date":"2023-12-31","objectID":"/mysql/:9:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#821--语法"},{"categories":["SQL"],"content":" 8.2 条件查询 8.2.1 语法 SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件 条件列表可以使用以下运算符 8.2.2 条件查询练习 查询年龄大于20岁的学员信息 select * from stu where age \u003e 20; 查询年龄大于等于20岁的学员信息 select * from stu where age \u003e= 20; 查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学员信息 select * from stu where age \u003e= 20 \u0026\u0026 age \u003c= 30; select * from stu where age \u003e= 20 and age \u003c= 30; 上面语句中 \u0026\u0026 和 and 都表示并且的意思。建议使用 and 。 也可以使用 between … and 来实现上面需求 select * from stu where age BETWEEN 20 and 30; 查询入学日期在'1998-09-01’ 到 ‘1999-09-01’ 之间的学员信息 select * from stu where hire_date BETWEEN '1998-09-01' and '1999-09-01'; 查询年龄等于18岁的学员信息 select * from stu where age = 18; 查询年龄不等于18岁的学员信息 select * from stu where age != 18; select * from stu where age \u003c\u003e 18; 查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息 select * from stu where age = 18 or age = 20 or age = 22; select * from stu where age in (18,20 ,22); 查询英语成绩为 null的学员信息 null值的比较不能使用 = 或者 != 。需要使用 is 或者 is not select * from stu where english = null; -- 这个语句是不行的 select * from stu where english is null; select * from stu where english is not null; 8.2.3 模糊查询练习 模糊查询使用like关键字，可以使用通配符进行占位: （1）_ : 代表单个任意字符 （2）% : 代表任意个数字符 查询姓’马’的学员信息 select * from stu where name like '马%'; 查询第二个字是’花’的学员信息 select * from stu where name like '_花%'; 查询名字中包含 ‘德’ 的学员信息 select * from stu where name like '%德%'; ","date":"2023-12-31","objectID":"/mysql/:9:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#822--条件查询练习"},{"categories":["SQL"],"content":" 8.2 条件查询 8.2.1 语法 SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件 条件列表可以使用以下运算符 8.2.2 条件查询练习 查询年龄大于20岁的学员信息 select * from stu where age \u003e 20; 查询年龄大于等于20岁的学员信息 select * from stu where age \u003e= 20; 查询年龄大于等于20岁 并且 年龄 小于等于 30岁 的学员信息 select * from stu where age \u003e= 20 \u0026\u0026 age \u003c= 30; select * from stu where age \u003e= 20 and age \u003c= 30; 上面语句中 \u0026\u0026 和 and 都表示并且的意思。建议使用 and 。 也可以使用 between … and 来实现上面需求 select * from stu where age BETWEEN 20 and 30; 查询入学日期在'1998-09-01’ 到 ‘1999-09-01’ 之间的学员信息 select * from stu where hire_date BETWEEN '1998-09-01' and '1999-09-01'; 查询年龄等于18岁的学员信息 select * from stu where age = 18; 查询年龄不等于18岁的学员信息 select * from stu where age != 18; select * from stu where age \u003c\u003e 18; 查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息 select * from stu where age = 18 or age = 20 or age = 22; select * from stu where age in (18,20 ,22); 查询英语成绩为 null的学员信息 null值的比较不能使用 = 或者 != 。需要使用 is 或者 is not select * from stu where english = null; -- 这个语句是不行的 select * from stu where english is null; select * from stu where english is not null; 8.2.3 模糊查询练习 模糊查询使用like关键字，可以使用通配符进行占位: （1）_ : 代表单个任意字符 （2）% : 代表任意个数字符 查询姓’马’的学员信息 select * from stu where name like '马%'; 查询第二个字是’花’的学员信息 select * from stu where name like '_花%'; 查询名字中包含 ‘德’ 的学员信息 select * from stu where name like '%德%'; ","date":"2023-12-31","objectID":"/mysql/:9:2","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#823--模糊查询练习"},{"categories":["SQL"],"content":" 8.3 排序查询 8.3.1 语法 SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …; 上述语句中的排序方式有两种，分别是： ASC ： 升序排列 （默认值） DESC ： 降序排列 注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序 8.3.2 练习 查询学生信息，按照年龄升序排列 select * from stu order by age ; 查询学生信息，按照数学成绩降序排列 select * from stu order by math desc ; 查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列 select * from stu order by math desc , english asc ; ","date":"2023-12-31","objectID":"/mysql/:9:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#83--排序查询"},{"categories":["SQL"],"content":" 8.3 排序查询 8.3.1 语法 SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …; 上述语句中的排序方式有两种，分别是： ASC ： 升序排列 （默认值） DESC ： 降序排列 注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序 8.3.2 练习 查询学生信息，按照年龄升序排列 select * from stu order by age ; 查询学生信息，按照数学成绩降序排列 select * from stu order by math desc ; 查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列 select * from stu order by math desc , english asc ; ","date":"2023-12-31","objectID":"/mysql/:9:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#831--语法"},{"categories":["SQL"],"content":" 8.3 排序查询 8.3.1 语法 SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …; 上述语句中的排序方式有两种，分别是： ASC ： 升序排列 （默认值） DESC ： 降序排列 注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序 8.3.2 练习 查询学生信息，按照年龄升序排列 select * from stu order by age ; 查询学生信息，按照数学成绩降序排列 select * from stu order by math desc ; 查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列 select * from stu order by math desc , english asc ; ","date":"2023-12-31","objectID":"/mysql/:9:3","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#832--练习"},{"categories":["SQL"],"content":" 8.4 聚合函数 8.4.1 概念==将一列数据作为一个整体，进行纵向计算。== 如何理解呢？假设有如下表 现有一需求让我们求表中所有数据的数学成绩的总和。这就是对math字段进行纵向求和。 8.4.2 聚合函数分类 函数名 功能 count(列名) 统计数量（一般选用不为null的列） max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 8.4.3 聚合函数语法 SELECT 聚合函数名(列名) FROM 表; 注意：null 值不参与所有聚合函数运算 8.4.4 练习 统计班级一共有多少个学生 select count(id) from stu; select count(english) from stu; 上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*) select count(*) from stu; 查询数学成绩的最高分 select max(math) from stu; 查询数学成绩的最低分 select min(math) from stu; 查询数学成绩的总分 select sum(math) from stu; 查询数学成绩的平均分 select avg(math) from stu; 查询英语成绩的最低分 select min(english) from stu; ","date":"2023-12-31","objectID":"/mysql/:9:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#84--聚合函数"},{"categories":["SQL"],"content":" 8.4 聚合函数 8.4.1 概念==将一列数据作为一个整体，进行纵向计算。== 如何理解呢？假设有如下表 现有一需求让我们求表中所有数据的数学成绩的总和。这就是对math字段进行纵向求和。 8.4.2 聚合函数分类 函数名 功能 count(列名) 统计数量（一般选用不为null的列） max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 8.4.3 聚合函数语法 SELECT 聚合函数名(列名) FROM 表; 注意：null 值不参与所有聚合函数运算 8.4.4 练习 统计班级一共有多少个学生 select count(id) from stu; select count(english) from stu; 上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*) select count(*) from stu; 查询数学成绩的最高分 select max(math) from stu; 查询数学成绩的最低分 select min(math) from stu; 查询数学成绩的总分 select sum(math) from stu; 查询数学成绩的平均分 select avg(math) from stu; 查询英语成绩的最低分 select min(english) from stu; ","date":"2023-12-31","objectID":"/mysql/:9:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#841--概念"},{"categories":["SQL"],"content":" 8.4 聚合函数 8.4.1 概念==将一列数据作为一个整体，进行纵向计算。== 如何理解呢？假设有如下表 现有一需求让我们求表中所有数据的数学成绩的总和。这就是对math字段进行纵向求和。 8.4.2 聚合函数分类 函数名 功能 count(列名) 统计数量（一般选用不为null的列） max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 8.4.3 聚合函数语法 SELECT 聚合函数名(列名) FROM 表; 注意：null 值不参与所有聚合函数运算 8.4.4 练习 统计班级一共有多少个学生 select count(id) from stu; select count(english) from stu; 上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*) select count(*) from stu; 查询数学成绩的最高分 select max(math) from stu; 查询数学成绩的最低分 select min(math) from stu; 查询数学成绩的总分 select sum(math) from stu; 查询数学成绩的平均分 select avg(math) from stu; 查询英语成绩的最低分 select min(english) from stu; ","date":"2023-12-31","objectID":"/mysql/:9:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#842--聚合函数分类"},{"categories":["SQL"],"content":" 8.4 聚合函数 8.4.1 概念==将一列数据作为一个整体，进行纵向计算。== 如何理解呢？假设有如下表 现有一需求让我们求表中所有数据的数学成绩的总和。这就是对math字段进行纵向求和。 8.4.2 聚合函数分类 函数名 功能 count(列名) 统计数量（一般选用不为null的列） max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 8.4.3 聚合函数语法 SELECT 聚合函数名(列名) FROM 表; 注意：null 值不参与所有聚合函数运算 8.4.4 练习 统计班级一共有多少个学生 select count(id) from stu; select count(english) from stu; 上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*) select count(*) from stu; 查询数学成绩的最高分 select max(math) from stu; 查询数学成绩的最低分 select min(math) from stu; 查询数学成绩的总分 select sum(math) from stu; 查询数学成绩的平均分 select avg(math) from stu; 查询英语成绩的最低分 select min(english) from stu; ","date":"2023-12-31","objectID":"/mysql/:9:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#843--聚合函数语法"},{"categories":["SQL"],"content":" 8.4 聚合函数 8.4.1 概念==将一列数据作为一个整体，进行纵向计算。== 如何理解呢？假设有如下表 现有一需求让我们求表中所有数据的数学成绩的总和。这就是对math字段进行纵向求和。 8.4.2 聚合函数分类 函数名 功能 count(列名) 统计数量（一般选用不为null的列） max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 8.4.3 聚合函数语法 SELECT 聚合函数名(列名) FROM 表; 注意：null 值不参与所有聚合函数运算 8.4.4 练习 统计班级一共有多少个学生 select count(id) from stu; select count(english) from stu; 上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以在count(*) 来实现。* 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(*) select count(*) from stu; 查询数学成绩的最高分 select max(math) from stu; 查询数学成绩的最低分 select min(math) from stu; 查询数学成绩的总分 select sum(math) from stu; 查询数学成绩的平均分 select avg(math) from stu; 查询英语成绩的最低分 select min(english) from stu; ","date":"2023-12-31","objectID":"/mysql/:9:4","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#844--练习"},{"categories":["SQL"],"content":" 8.5 分组查询 8.5.1 语法 SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤]; 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 8.5.2 练习 查询男同学和女同学各自的数学平均分 select sex, avg(math) from stu group by sex; 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 select name, sex, avg(math) from stu group by sex; -- 这里查询name字段就没有任何意义 查询男同学和女同学各自的数学平均分，以及各自人数 select sex, avg(math),count(*) from stu group by sex; 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组 select sex, avg(math),count(*) from stu where math \u003e 70 group by sex; 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的 select sex, avg(math),count(*) from stu where math \u003e 70 group by sex having count(*) \u003e 2; where 和 having 区别： 执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。 可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。 ","date":"2023-12-31","objectID":"/mysql/:9:5","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#85--分组查询"},{"categories":["SQL"],"content":" 8.5 分组查询 8.5.1 语法 SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤]; 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 8.5.2 练习 查询男同学和女同学各自的数学平均分 select sex, avg(math) from stu group by sex; 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 select name, sex, avg(math) from stu group by sex; -- 这里查询name字段就没有任何意义 查询男同学和女同学各自的数学平均分，以及各自人数 select sex, avg(math),count(*) from stu group by sex; 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组 select sex, avg(math),count(*) from stu where math \u003e 70 group by sex; 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的 select sex, avg(math),count(*) from stu where math \u003e 70 group by sex having count(*) \u003e 2; where 和 having 区别： 执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。 可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。 ","date":"2023-12-31","objectID":"/mysql/:9:5","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#851--语法"},{"categories":["SQL"],"content":" 8.5 分组查询 8.5.1 语法 SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤]; 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 8.5.2 练习 查询男同学和女同学各自的数学平均分 select sex, avg(math) from stu group by sex; 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 select name, sex, avg(math) from stu group by sex; -- 这里查询name字段就没有任何意义 查询男同学和女同学各自的数学平均分，以及各自人数 select sex, avg(math),count(*) from stu group by sex; 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组 select sex, avg(math),count(*) from stu where math \u003e 70 group by sex; 查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的 select sex, avg(math),count(*) from stu where math \u003e 70 group by sex having count(*) \u003e 2; where 和 having 区别： 执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。 可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。 ","date":"2023-12-31","objectID":"/mysql/:9:5","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#852--练习"},{"categories":["SQL"],"content":" 8.6 分页查询如下图所示，大家在很多网站都见过类似的效果，如京东、百度、淘宝等。分页查询是将数据一页一页的展示给用户看，用户也可以通过点击查看下一页的数据。 接下来我们先说分页查询的语法。 8.6.1 语法 SELECT 字段列表 FROM 表名 LIMIT 起始索引 , 查询条目数; 注意： 上述语句中的起始索引是从0开始 8.6.2 练习 从0开始查询，查询3条数据 select * from stu limit 0 , 3; 每页显示3条数据，查询第1页数据 select * from stu limit 0 , 3; 每页显示3条数据，查询第2页数据 select * from stu limit 3 , 3; 每页显示3条数据，查询第3页数据 select * from stu limit 6 , 3; 从上面的练习推导出起始索引计算公式： 起始索引 = (当前页码 - 1) * 每页显示的条数 ","date":"2023-12-31","objectID":"/mysql/:9:6","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#86--分页查询"},{"categories":["SQL"],"content":" 8.6 分页查询如下图所示，大家在很多网站都见过类似的效果，如京东、百度、淘宝等。分页查询是将数据一页一页的展示给用户看，用户也可以通过点击查看下一页的数据。 接下来我们先说分页查询的语法。 8.6.1 语法 SELECT 字段列表 FROM 表名 LIMIT 起始索引 , 查询条目数; 注意： 上述语句中的起始索引是从0开始 8.6.2 练习 从0开始查询，查询3条数据 select * from stu limit 0 , 3; 每页显示3条数据，查询第1页数据 select * from stu limit 0 , 3; 每页显示3条数据，查询第2页数据 select * from stu limit 3 , 3; 每页显示3条数据，查询第3页数据 select * from stu limit 6 , 3; 从上面的练习推导出起始索引计算公式： 起始索引 = (当前页码 - 1) * 每页显示的条数 ","date":"2023-12-31","objectID":"/mysql/:9:6","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#861--语法"},{"categories":["SQL"],"content":" 8.6 分页查询如下图所示，大家在很多网站都见过类似的效果，如京东、百度、淘宝等。分页查询是将数据一页一页的展示给用户看，用户也可以通过点击查看下一页的数据。 接下来我们先说分页查询的语法。 8.6.1 语法 SELECT 字段列表 FROM 表名 LIMIT 起始索引 , 查询条目数; 注意： 上述语句中的起始索引是从0开始 8.6.2 练习 从0开始查询，查询3条数据 select * from stu limit 0 , 3; 每页显示3条数据，查询第1页数据 select * from stu limit 0 , 3; 每页显示3条数据，查询第2页数据 select * from stu limit 3 , 3; 每页显示3条数据，查询第3页数据 select * from stu limit 6 , 3; 从上面的练习推导出起始索引计算公式： 起始索引 = (当前页码 - 1) * 每页显示的条数 ","date":"2023-12-31","objectID":"/mysql/:9:6","series":null,"tags":["SQL"],"title":"MySql","uri":"/mysql/#862--练习"}]